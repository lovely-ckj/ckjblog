{"themeConfig":{"themeName":"gridea-theme-expert-next","postPageSize":10,"archivesPageSize":50,"siteName":"Exber's Blog","siteDescription":"Exber's Blog","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":true,"domain":"https://lovely-ckj.github.io/ckjblog","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，每次操作可以选择相邻三个元素 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i-1},a_i,a_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>，将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 都加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 然后删掉 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。操作完后序列会自动补位，即 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 会相邻。</p>\n<p>最后会剩下两个元素，最小化它们的和。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>18</mn></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 18</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">8</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长 nnn 的序列 aaa，每次操作可以选择相邻三个元素 ai−1,ai,ai+1a_{i-1},a_i,a_{i+1}ai−1​,ai​,ai+1​，将 ai−1a_{i-1}ai−1​ 和 ai+1a_{i+1}ai+1​ 都加上 aia_iai​ 然后删掉 aia_iai​。操作完后序列会自动补位，即 ai−1a_{i-1}ai−1​ 和 ai+1a_{i+1}ai+1​ 会相邻。 最后会剩下两个元素，最小化它们的和。 2≤n≤182\\le n\\le 182≤n≤18，1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109。 直接做不好做，考虑时光倒流。 不难发现每个元素最终都会以某个系数算入答案，考虑一次操作本质上是把 ai−1a_{i-1}ai−1​ 和 ai+1a_{i+1}ai+1​ 的系数都加到 aia_iai​ 的上，那么设 fl,r,x,yf_{l,r,x,y}fl,r,x,y​ 表示 ala_lal​ 的系数为 xxx，ara_rar​ 的系数为 yyy 时 a[l,r]a_{[l,r]}a[l,r]​ 的最小贡献，那么有转移： fl,r,x,y=min⁡l&lt;k&lt;r{fl,k,x,x+y+fk,r,x+y,y−ak×(x+y)}f_{l,r,x,y}=\\min\\limits_{l&lt; k&lt; r}\\{f_{l,k,x,x+y}+f_{k,r,x+y,y}-a_k\\times (x+y)\\} fl,r,x,y​=l&lt;k&lt;rmin​{fl,k,x,x+y​+fk,r,x+y,y​−ak​×(x+y)} 减掉是因为重复算了。 这样状态数最多是 O(n22n)O(n^22^n)O(n22n) 的，足以通过本题。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;map&gt; using namespace std; typedef long long ll; const int S=25; const ll inf=1e17; int n,a[S]; map&lt;tuple&lt;int,int,int,int&gt;,ll&gt; f; ll dfs(int l,int r,int fl,int fr) { if(l+1==r) return 1ll*a[l]*fl+1ll*a[r]*fr; tuple&lt;int,int,int,int&gt; u(l,r,fl,fr); if(f.count(u)) return f[u]; f[u]=inf; for(int k=l+1;k&lt;=r-1;k++) { ll lb=dfs(l,k,fl,fl+fr),rb=dfs(k,r,fl+fr,fr); f[u]=min(f[u],lb+rb-1ll*(fl+fr)*a[k]); } return f[u]; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); printf(&quot;%lld\\n&quot;,dfs(1,n,1,1)); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"AGC035D Add and Remove 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/agc035d-add-and-remove-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":162000,"words":513,"minutes":3},"date":"2024-01-16 21:50:42","dateFormat":"2024-01-16"},{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，每次操作可以选择一个区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l,r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 将其删去，代价为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi><mo>×</mo><mrow><mo fence=\"true\">(</mo><msub><mi>max</mi><mo>⁡</mo><mrow><mi>l</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>r</mi></mrow></msub><mo>{</mo><msub><mi>a</mi><mi>i</mi></msub><mo>}</mo><mo>−</mo><msub><mi>min</mi><mo>⁡</mo><mrow><mi>l</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>r</mi></mrow></msub><mo>{</mo><msub><mi>a</mi><mi>i</mi></msub><mo>}</mo><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">A+B\\times \\left(\\max\\limits_{l\\le i\\le r}\\{a_i\\}-\\min\\limits_{l\\le i\\le r}\\{a_i\\}\\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">(</span></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43055999999999994em;\"><span style=\"top:-2.047892em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-2.7em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span><span class=\"mop\">max</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8472869999999999em;\"><span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.66786em;\"><span style=\"top:-2.047892em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-2.7em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span><span class=\"mop\">min</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8472869999999999em;\"><span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">)</span></span></span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 是给定的常数。</p>\n<p>一个区间被删掉后两边的元素会自动补齐空位，求把序列删空的最小代价。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>A</mi><mo>≤</mo><mn>1500</mn></mrow><annotation encoding=\"application/x-tex\">1\\le A\\le 1500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">1\\le B \\le 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le w_i\\le 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长 nnn 的序列 aaa，每次操作可以选择一个区间 [l,r][l,r][l,r] 将其删去，代价为 A+B×(max⁡l≤i≤r{ai}−min⁡l≤i≤r{ai})A+B\\times \\left(\\max\\limits_{l\\le i\\le r}\\{a_i\\}-\\min\\limits_{l\\le i\\le r}\\{a_i\\}\\right)A+B×(l≤i≤rmax​{ai​}−l≤i≤rmin​{ai​})，其中 AAA 和 BBB 是给定的常数。 一个区间被删掉后两边的元素会自动补齐空位，求把序列删空的最小代价。 1≤n≤501\\le n\\le 501≤n≤50，1≤A≤15001\\le A\\le 15001≤A≤1500，1≤B≤101\\le B \\le 101≤B≤10，1≤wi≤10001\\le w_i\\le 10001≤wi​≤1000。 设 fl,rf_{l,r}fl,r​ 表示把 a[l,r]a_{[l,r]}a[l,r]​ 删掉的最小代价，但是发现转移不了，因为不知道最后一次删除时序列长什么样。 那么考虑设 gl,r,x,yg_{l,r,x,y}gl,r,x,y​ 表示把 a[l,r]a_{[l,r]}a[l,r]​ 删至所有剩下的数都在 [x,y][x,y][x,y] 中的最小代价，则有： fl,r=min⁡x≤y{gl,r,x,y+A+B(x−y)}f_{l,r}=\\min\\limits_{x\\le y}\\{g_{l,r,x,y}+A+B(x-y)\\} fl,r​=x≤ymin​{gl,r,x,y​+A+B(x−y)} 而 ggg 可以通过枚举剩下的数中最靠左/靠右的来转移： gl,r,x,y=min⁡(min⁡l≤k&lt;r{gl,k,x,y+fk+1,r},min⁡l&lt;k≤r{fl,k−1+gk,r,x,y})g_{l,r,x,y}=\\min\\left(\\min\\limits_{l\\le k&lt;r}\\{g_{l,k,x,y}+f_{k+1,r}\\},\\min\\limits_{l&lt;k\\le r}\\{f_{l,k-1}+g_{k,r,x,y}\\}\\right) gl,r,x,y​=min(l≤k&lt;rmin​{gl,k,x,y​+fk+1,r​},l&lt;k≤rmin​{fl,k−1​+gk,r,x,y​}) 特别的，若 a[l,r]∈[x,y]a_{[l,r]}\\in [x,y]a[l,r]​∈[x,y]，则 gl,r,x,y=0g_{l,r,x,y}=0gl,r,x,y​=0。 那么时间复杂度 O(n3V2)O(n^3V^2)O(n3V2)，可以通过本题。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"P5336 [THUSC2016] 成绩单 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p5336-thusc2016-cheng-ji-dan-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":149000,"words":477,"minutes":3},"date":"2024-01-10 21:57:46","dateFormat":"2024-01-10"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n,m,k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，考虑对某个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>（标号 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0\\sim n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>）做如下操作：</p>\n<ul>\n<li>从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 枚举 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mtext> mod </mtext><mi>n</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mi>A</mi><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mtext> mod </mtext><mi>n</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mi>A</mi><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo>)</mo><mtext> mod </mtext><mi>n</mi></mrow></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>A</mi><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mtext> mod </mtext><mi>n</mi></mrow></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[A_{i\\text{ mod }n},A_{(i+1)\\text{ mod }n},A_{(i+2)\\text{ mod }n},\\dots,A_{(i+m-1)\\text{ mod }n}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mord text mtight\"><span class=\"mord mtight\"> mod </span></span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord text mtight\"><span class=\"mord mtight\"> mod </span></span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span><span class=\"mclose mtight\">)</span><span class=\"mord text mtight\"><span class=\"mord mtight\"> mod </span></span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mathdefault mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord text mtight\"><span class=\"mord mtight\"> mod </span></span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> 拿出来升序排序再放回去；</li>\n</ul>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，求有多少个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 满足操作完后会变成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le n\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 n,m,kn,m,kn,m,k，考虑对某个 nnn 的排列 AAA（标号 0∼n−10\\sim n-10∼n−1）做如下操作： 从 000 到 k−1k-1k−1 枚举 iii，把 [Ai mod n,A(i+1) mod n,A(i+2) mod n,…,A(i+m−1) mod n][A_{i\\text{ mod }n},A_{(i+1)\\text{ mod }n},A_{(i+2)\\text{ mod }n},\\dots,A_{(i+m-1)\\text{ mod }n}][Ai mod n​,A(i+1) mod n​,A(i+2) mod n​,…,A(i+m−1) mod n​] 拿出来升序排序再放回去； 给定一个 nnn 的排列 BBB，求有多少个 AAA 满足操作完后会变成 BBB。 1≤m≤n≤3×1051\\le m\\le n\\le 3\\times 10^51≤m≤n≤3×105，1≤k≤1091\\le k\\le 10^91≤k≤109。 由于 kkk 很大，所以猜测操作很多次是没用的。 观察到若 k&gt;n−m+1k&gt;n-m+1k&gt;n−m+1 则后 k−(n−m+1)k-(n-m+1)k−(n−m+1) 次操作相当于拉着前 m−1m-1m−1 大值在转圈，所以这些操作是没用的，仅需把前 m−1m-1m−1 大值复位即可归约到 k=n−m+1k=n-m+1k=n−m+1 的情况。 不难发现 k&lt;n−m+1k&lt;n-m+1k&lt;n−m+1 的情况可以通过删掉操作没影响到的一段后缀来归约到 k=n−m+1k=n-m+1k=n−m+1 的情况，所以仅需讨论 k=n−m+1k=n-m+1k=n−m+1 情况下的做法。 不难发现，若 Bi−1&gt;BiB_{i-1}&gt;B_iBi−1​&gt;Bi​ 则 BiB_iBi​ 一定填入 Ai+m−1A_{i+m-1}Ai+m−1​，否则： 若 BiB_iBi​ 是前缀最大值，则其可以找 A[1,i+m−1]A_{[1,i+m-1]}A[1,i+m−1]​ 中随便一个未填数的位置填入，有 mmm 种方案； 若 BiB_iBi​ 不是前缀最大值，则 BiB_iBi​ 一定填入 Ai+m−1A_{i+m-1}Ai+m−1​，证明如下： 若 Bi−1&gt;BiB_{i-1}&gt;B_iBi−1​&gt;Bi​ 则证明完毕，否则找到 BiB_iBi​ 前面最靠后的 &gt;Bi&gt;B_i&gt;Bi​ 的 BjB_jBj​，则 BiB_iBi​ 一定不能填入 A[j,j+m−1]A_{[j,j+m-1]}A[j,j+m−1]​。 观察到 Bj&gt;B[j+1,i]B_j&gt;B_{[j+1,i]}Bj​&gt;B[j+1,i]​，所以 Bj+1B_{j+1}Bj+1​ 一定填入 Aj+mA_{j+m}Aj+m​，Bj+2B_{j+2}Bj+2​ 原本可以填入 A[j+m,j+m+1]A_{[j+m,j+m+1]}A[j+m,j+m+1]​，可 Aj+mA_{j+m}Aj+m​ 被占用，所以它只能填入 Aj+m+1A_{j+m+1}Aj+m+1​。这样一直循环进行，最终 A[j+m,i+m−2]A_{[j+m,i+m-2]}A[j+m,i+m−2]​ 均被占用，所以 BiB_iBi​ 仅能填入 Ai+m−1A_{i+m-1}Ai+m−1​。 Q.E.D. 那么设 B[0,k−1]B_{[0,k-1]}B[0,k−1]​ 有 cntcntcnt 个前缀最大值，答案即为 mcnt(m−1)!m^{cnt}(m-1)!mcnt(m−1)!，最后的阶乘是因为最后一段的尾巴可以乱放。 时间复杂度 O(n)O(n)O(n)，注意 000 的判断，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=300005,p=998244353; int n,m,k,a[S]; int b[S],c[S]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); if(k&gt;n-m+1) { int lft=k-(n-m+1); int beg=((n-m+1)+lft)%n; for(int i=0;i&lt;m-1;i++) b[i]=a[(beg+i)%n]; int siz=n-m+1; for(int i=0;i&lt;siz;i++) c[i]=a[(beg+m-1+i)%n]; for(int i=0;i&lt;siz;i++) a[i]=c[((i-lft)%siz+siz)%siz]; for(int i=0;i&lt;m-1;i++) a[siz+i]=b[i]; k=n-m+1; } for(int i=0;i&lt;n;i++) b[i]=a[i]; sort(b+k-1,b+k-1+m); for(int i=k-1;i&lt;=k-1+m-1;i++) { if(a[i]&lt;a[k-1]||a[i]!=b[i]) return puts(&quot;0&quot;),0; } int ans=1; for(int i=0;i&lt;k;i++) { if(i==0||a[i]&gt;a[i-1]) ans=1ll*ans*m%p; else a[i]=a[i-1]; } for(int i=1;i&lt;m;i++) ans=1ll*ans*i%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ARC149E Sliding Window Sort 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc149e-sliding-window-sort-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":314000,"words":995,"minutes":6},"date":"2023-12-29 12:37:57","dateFormat":"2023-12-29"},{"abstract":"<blockquote>\n<p>定义两个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数组相似，当且仅当对于每一个区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l,r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span>，两个数组在该区间中最大值的位置相同。</p>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 和一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 且缺了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个值的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，再给定一个大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问，每次给定一个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span>，求能否将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>∪</mo><mo>{</mo><mi>d</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">S\\cup\\{d\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">d</span><span class=\"mclose\">}</span></span></span></span> 以任意顺序填入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的空缺位置使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 相似。</p>\n<p>保证 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">a,S,d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span> 中元素两两不同。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,q\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>d</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i,S_i,d\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 定义两个长 nnn 的数组相似，当且仅当对于每一个区间 [l,r][l,r][l,r]，两个数组在该区间中最大值的位置相同。 给定 nnn 的排列 ppp 和一个长 nnn 且缺了 kkk 个值的数组 aaa，再给定一个大小为 k−1k-1k−1 的集合 SSS。 qqq 次询问，每次给定一个整数 ddd，求能否将 S∪{d}S\\cup\\{d\\}S∪{d} 以任意顺序填入 aaa 的空缺位置使得 aaa 和 ppp 相似。 保证 a,S,da,S,da,S,d 中元素两两不同。 1≤n,q≤3×1051\\le n,q\\le 3\\times 10^51≤n,q≤3×105，2≤k≤n2\\le k\\le n2≤k≤n，1≤ai,Si,d≤1061\\le a_i,S_i,d\\le 10^61≤ai​,Si​,d≤106。 首先观察到 aaa 和 ppp 相似当且仅当它们的笛卡尔树同构。 那么对于一个空缺的位置 uuu，它填入的数至少要 &gt;&gt;&gt; 它子树的最大值 mxumx_umxu​，并且至少要 &lt;&lt;&lt; 它父亲的值 vfuvf_uvfu​。 现在我们来证明，只要所有空缺位置填入的数都 &gt;mxu&gt; mx_u&gt;mxu​ 且 &lt;vfu&lt;vf_u&lt;vfu​ 那么 aaa 就和 ppp 相似。 仅需证明互为祖先后代关系的空缺位置不会相互影响。 考虑满足 xxx 为 yyy 祖先的两个空缺位置 x,yx,yx,y，显然有 mxx≥mxymx_x\\ge mx_ymxx​≥mxy​ 且 vfx≥vfyvf_x\\ge vf_yvfx​≥vfy​，设 xxx 填入的数为 vxv_xvx​，yyy 的为 vyv_yvy​，那么 vxv_xvx​ 和 vyv_yvy​ 冲突当且仅当 vx&lt;vyv_x&lt;v_yvx​&lt;vy​。此时必有 mxy≤mxx&lt;vx&lt;vy&lt;vfy≤vfxmx_y\\le mx_x&lt;v_x&lt;v_y&lt;vf_y\\le vf_xmxy​≤mxx​&lt;vx​&lt;vy​&lt;vfy​≤vfx​，也就是说，交换 vxv_xvx​ 和 vyv_yvy​ 也还是合法的。那么只要找到了一组满足填入的数 ∈[mxu+1,vfu−1]\\in[mx_u+1,vf_u-1]∈[mxu​+1,vfu​−1] 的填法，就一定可以通过交换来让它合法。 那么求出所有 [mxu+1,vfu−1][mx_u+1,vf_u-1][mxu​+1,vfu​−1]，问题变为： 给定 kkk 个区间 [l,r][l,r][l,r] 和一个大小为 k−1k-1k−1 的点的集合，qqq 次询问，每次给定一个点 ddd，求 S∪{d}S\\cup\\{d\\}S∪{d} 能否和区间一一匹配使得每个点都在对应区间内。 若 S∪{d}S\\cup\\{d\\}S∪{d} 固定，则这个问题有一个经典贪心： 把区间按照 lll 从小到大排序，把点也从小到大排序； 从小到大枚举位置 ppp： 加入 l=pl=pl=p 的区间； 若存在点 ppp，则把它和当前已经加入的 rrr 最小的区间匹配； 若每次都能找到可以匹配的区间则有解，否则无解。 考虑魔改一下这个贪心，直接在 SSS 上跑，若有点找不到与之匹配的区间则无解，否则一定有一个区间失配，设该区间为 [lb,rb][lb,rb][lb,rb]。注意到这个贪心本质上是尽量让剩下的区间 rrr 更大，所以 ddd 一定要 ≤rb\\le rb≤rb。 同理，反过来做一遍这个贪心即可得出一个 lblblb 表示 ddd 一定要 ≥lb\\ge lb≥lb。 现在我们得知 d∈[lb,rb]d\\in[lb,rb]d∈[lb,rb] 是必要条件，考虑证明它是充分的。 注意到这是一个完美匹配问题，考虑用 Hall 定理描述其有解性。这类问题有一个结论： 存在大小为 kkk 的匹配当且仅当： 把值域离散化到 [1,k][1,k][1,k] 后，对于所有区间 [l,r][l,r][l,r]，被 [l,r][l,r][l,r] 完全包含的区间个数 ≤r−l+1\\le r-l+1≤r−l+1； 那么设 f(l,r)f(l,r)f(l,r) 表示被 [l,r][l,r][l,r] 完全包含的区间个数，g(l,r)g(l,r)g(l,r) 表示 [l,r][l,r][l,r] 中点的个数，h(l,r)=f(l,r)−g(l,r)h(l,r)=f(l,r)-g(l,r)h(l,r)=f(l,r)−g(l,r)。 若存在 h(l,r)&gt;1h(l,r)&gt;1h(l,r)&gt;1 则就算加入点 ddd 也不合法，一定无解。 若 h(l,r)≤0h(l,r)\\le 0h(l,r)≤0 则不用管，设 [L,R]=∩h(l,r)=1[l,r][L,R]=\\cap_{h(l,r)=1}[l,r][L,R]=∩h(l,r)=1​[l,r]，则仅需证明 [L,R]=[lb,rb][L,R]=[lb,rb][L,R]=[lb,rb] 必要条件那里已经证明了 lb≤L,rb≥Rlb\\le L,rb\\ge Rlb≤L,rb≥R，现在仅需证明 lb≥L,rb≤Rlb\\ge L,rb\\le Rlb≥L,rb≤R。 先来证明 rb≤Rrb\\le Rrb≤R，lb≥Llb\\ge Llb≥L 同理。 对于一个 h(l,r)=1h(l,r)=1h(l,r)=1 的 [l,r][l,r][l,r]，必然有一个区间 iii 被它包含且无法被 [l,r][l,r][l,r] 内点匹配，那么贪心肯定能找到 rir_iri​，所以 rbrbrb 必然 ≤R\\le R≤R。 那么证完了，d∈[lb,rb]d\\in[lb,rb]d∈[lb,rb] 是充要条件。 直接模拟即可，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int S=300005,BS=25; const int inf=1e8; struct node { int l,r; }; int n,q,a[S],b[S]; int m,idx[S],c[S]; int mlog[S],mx[S][BS]; int cnt,pos[S],rpos[S],ls[S],rs[S]; int lb[S],rb[S]; node sg[S]; bool vis[S]; int L,R; inline int quemx(int l,int r) { int k=mlog[r-l+1]; int x=mx[l][k],y=mx[r-(1&lt;&lt;k)+1][k]; return a[x]&gt;a[y]?x:y; } inline void initmx() { mlog[0]=-1; for(int i=1;i&lt;=n;i++) mlog[i]=mlog[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;i++) mx[i][0]=i; for(int j=1;j&lt;=mlog[n];j++) { for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++) { int x=mx[i][j-1],y=mx[i+(1&lt;&lt;j-1)][j-1]; mx[i][j]=a[x]&gt;a[y]?x:y; } } } int built(int l,int r) { int u=++cnt; int rt=quemx(l,r); rpos[pos[u]=rt]=u; ls[u]=rt==l?0:built(l,rt-1); rs[u]=rt==r?0:built(rt+1,r); return u; } void dfs(int u,int x) { rb[u]=x,lb[u]=0; if(b[pos[u]]!=0) x=min(x,b[pos[u]]); if(ls[u]!=0) dfs(ls[u],x),lb[u]=max(lb[u],max(lb[ls[u]],b[pos[ls[u]]])); if(rs[u]!=0) dfs(rs[u],x),lb[u]=max(lb[u],max(lb[rs[u]],b[pos[rs[u]]])); // printf(&quot;%d(%d)[%d %d]: %d %d\\n&quot;,u,pos[u],lb[u],rb[u],ls[u],rs[u]); } inline void getLR() { for(int i=1;i&lt;=n;i++) { if(b[i]==0) continue; if(b[i]&lt;lb[rpos[i]]||b[i]&gt;rb[rpos[i]]) return L=inf,R=-inf,void(); } for(int i=1;i&lt;=m;i++) sg[i]=(node){lb[idx[i]],rb[idx[i]]}; // for(int i=1;i&lt;=m;i++) printf(&quot;[%d %d]\\n&quot;,sg[i].l,sg[i].r); // calc R for(int i=1;i&lt;=m;i++) vis[i]=false; sort(sg+1,sg+m+1,[&amp;](node x,node y){return x.l&lt;y.l;}); sort(c+1,c+m,[&amp;](int x,int y){return x&lt;y;}); priority_queue&lt;pair&lt;int,int&gt; &gt; q; for(int i=1,j=1;i&lt;=m-1;i++) { while(j&lt;=m&amp;&amp;sg[j].l&lt;=c[i]) q.push(make_pair(-sg[j].r,j)),j++; while(!q.empty()&amp;&amp;-q.top().first&lt;c[i]) q.pop(); if(q.empty()) return L=inf,R=-inf,void(); vis[q.top().second]=true; q.pop(); } for(int i=1;i&lt;=m;i++) if(!vis[i]) R=sg[i].r; // calc L for(int i=1;i&lt;=m;i++) vis[i]=false; sort(sg+1,sg+m+1,[&amp;](node x,node y){return x.r&gt;y.r;}); sort(c+1,c+m,[&amp;](int x,int y){return x&gt;y;}); while(!q.empty()) q.pop(); for(int i=1,j=1;i&lt;=m-1;i++) { while(j&lt;=m&amp;&amp;sg[j].r&gt;=c[i]) q.push(make_pair(sg[j].l,j)),j++; while(!q.empty()&amp;&amp;q.top().first&gt;c[i]) q.pop(); if(q.empty()) return L=inf,R=-inf,void(); vis[q.top().second]=true; q.pop(); } for(int i=1;i&lt;=m;i++) if(!vis[i]) L=sg[i].l; } inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); m=0; for(int i=1;i&lt;=n;i++) if(b[i]==0) idx[++m]=i; for(int i=1;i&lt;=m-1;i++) scanf(&quot;%d&quot;,&amp;c[i]); initmx(); cnt=0; built(1,n); for(int i=1;i&lt;=m;i++) idx[i]=rpos[idx[i]]/*,printf(&quot;&gt;&gt; %d\\n&quot;,idx[i])*/; dfs(1,inf); for(int i=1;i&lt;=cnt;i++) lb[i]++,rb[i]--; getLR(); // printf(&quot;%d %d\\n&quot;,L,R); while(q--&gt;0) { int x; scanf(&quot;%d&quot;,&amp;x); puts(L&lt;=x&amp;&amp;x&lt;=R?&quot;YES&quot;:&quot;NO&quot;); } } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } /* 1 4 2 4 1 3 2 0 5 3 0 2 4 6 */ ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1718D Permutation for Burenka 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1718d-permutation-for-burenka-zuo-ti-ji-lu/","stats":{"text":"11 min read","time":644000,"words":2076,"minutes":11},"date":"2023-12-28 22:27:38","dateFormat":"2023-12-28"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向图和一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，边有边权表示机器人经过这条边消耗的电量，点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1,2,3,\\dots,k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为充电中心。机器人可以在充电中心免费充满电。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 组询问，每次给定两个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">s,t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span>，保证 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1\\le s,t\\le k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。你需要求解以下问题：</p>\n<ul>\n<li>若有一个机器人从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 出发，它的电池容量至少为多少才能顺利到达 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span>？</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m,q\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定一张 nnn 个点 mmm 条边的无向图和一个正整数 kkk，边有边权表示机器人经过这条边消耗的电量，点 1,2,3,…,k1,2,3,\\dots,k1,2,3,…,k 为充电中心。机器人可以在充电中心免费充满电。 qqq 组询问，每次给定两个节点 s,ts,ts,t，保证 1≤s,t≤k1\\le s,t\\le k1≤s,t≤k。你需要求解以下问题： 若有一个机器人从 sss 出发，它的电池容量至少为多少才能顺利到达 ttt？ 1≤n,m,q≤3×1051\\le n,m,q\\le 3\\times 10^51≤n,m,q≤3×105 首先有一个敏锐的观察，发现 1≤s,t≤k1\\le s,t\\le k1≤s,t≤k 很有用，这意味着有一个策略是每到达一个新的点就去最近的充电中心充一次电是不劣的。 观察出这个结论后，直接求出 disudis_udisu​ 表示 uuu 到最近充电站的距离，那么对于一条路径 EEE，电池容量至少为 max⁡(u,v,w)∈E{disu+disv+w}\\max\\limits_{(u,v,w)\\in E}\\{dis_u+dis_v+w\\}(u,v,w)∈Emax​{disu​+disv​+w}。 那么做法就很显然了，求出 disudis_udisu​ 后把边 (u,v,w)(u,v,w)(u,v,w) 变成 (u,v,w+disu+disv)(u,v,w+dis_u+dis_v)(u,v,w+disu​+disv​)，跑一遍 Kruskal 重构树即可。 时间复杂度 O((n+m)log⁡n)O((n+m)\\log n)O((n+m)logn)。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1253F Cheap Robot 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1253f-cheap-robot-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":94000,"words":357,"minutes":2},"date":"2023-12-28 21:04:40","dateFormat":"2023-12-28"},{"abstract":"","content":"Part 1 Border，Period 理论 设有一长 nnn 的字符串 SSS。 1.1 定义 Border： 满足 1≤k&lt;n1\\le k&lt;n1≤k&lt;n 且 S[1,k]=S[n−k+1,n]S_{[1,k]}=S_{[n-k+1,n]}S[1,k]​=S[n−k+1,n]​ 的 kkk。 不妨把 SSS 的 Border 放入集合 B(S)B(S)B(S) 中。 记 Bl(S)B_l(S)Bl​(S) 为 max⁡{k∣k∈B(S)}\\max\\{k|k\\in B(S)\\}max{k∣k∈B(S)}。 Period（周期元）： 满足 1≤k&lt;n1\\le k&lt;n1≤k&lt;n 且 ∀1≤i≤n−k\\forall 1\\le i\\le n-k∀1≤i≤n−k 都有 Si=Si+kS_i=S_{i+k}Si​=Si+k​ 的 kkk。 不妨把 SSS 的 Period 放入集合 P(S)P(S)P(S) 中。 1.2 基本性质&amp;定理 1.2.1 对偶性 k∈B(S)⇔n−k∈P(S)k\\in B(S)\\Leftrightarrow n-k\\in P(S)k∈B(S)⇔n−k∈P(S) 证明考虑把已知的等价关系画出来。 1.2.2 弱周期定理 x,y∈P(S),x+y≤n⇒gcd⁡(x,y)∈P(S)x,y\\in P(S),x+y\\le n\\Rightarrow \\gcd(x,y)\\in P(S)x,y∈P(S),x+y≤n⇒gcd(x,y)∈P(S) 证明 不妨令 x&lt;yx&lt;yx&lt;y。 仅需证明 y−x∈P(S)y-x\\in P(S)y−x∈P(S)，辗转相除会出手。 对于 SiS_iSi​： i≤xi\\le xi≤x：i+y≤ni+y\\le ni+y≤n，Si=Si+y=Si+y−xS_i=S_{i+y}=S_{i+y-x}Si​=Si+y​=Si+y−x​； i&gt;xi&gt;xi&gt;x：Si=Si−x=Si+y−xS_i=S_{i-x}=S_{i+y-x}Si​=Si−x​=Si+y−x​； 1.2.3 Border 的传递性 y∈B(S[1,k]∣k∈B(S))⇒y∈B(S)y\\in B(S_{[1,k]}|k\\in B(S))\\Rightarrow y\\in B(S)y∈B(S[1,k]​∣k∈B(S))⇒y∈B(S) 即 Border 的 Border 还是 Border。 证明考虑画画。 1.2.4 Border 的区间包含单调性 Bl(S[l+1,r−1])≥Bl(S[l,r])+2B_l(S_{[l+1,r-1]})\\ge B_l(S_{[l,r]})+2Bl​(S[l+1,r−1]​)≥Bl​(S[l,r]​)+2 1.3 Border 的结构 1.3.1 Border 的树状结构 B(S)=B(S[1,Bl(S)])+{Bl(S)}B(S)=B(S_{[1,B_l(S)]})+\\{B_l(S)\\}B(S)=B(S[1,Bl​(S)]​)+{Bl​(S)} 证明 根据传递性，有 B(S[1,Bl(S)])⊂B(S)B(S_{[1,B_l(S)]}) \\subset B(S)B(S[1,Bl​(S)]​)⊂B(S)。 由于 Bl(S)B_l(S)Bl​(S) 是 SSS 最长的 Border，所以 B(S)−B(S[1,Bl(S)])={Bl(S)}B(S)-B(S_{[1,B_l(S)]})=\\{B_l(S)\\}B(S)−B(S[1,Bl​(S)]​)={Bl​(S)}。 这启发我们可以建出 nnn 个点的树，每个点代表 SSS 的一个前缀，iii 的父亲为 Bl(S[1,i])B_l(S_{[1,i]})Bl​(S[1,i]​)。 容易发现这棵树的根为 111，每个节点的 BBB 集合就是它到根路径上的节点集合。 实际上这就是 AC 自动机的 fail 树。 1.3.2 Border 的等差数列结构 1.3.2.1 引理 所有满足 2k≥n2k\\ge n2k≥n 的 Border kkk 构成一个等差数列 证明 考虑 P(S)P(S)P(S) 中 ≤⌊n2⌋\\le \\lfloor\\frac{n}{2}\\rfloor≤⌊2n​⌋ 的元素 xxx 构成的集合 Ps(S)P_s(S)Ps​(S)，根据弱周期定理，显然 r=min⁡{Ps(S)}r=\\min\\{P_s(S)\\}r=min{Ps​(S)} 是 Ps(S)P_s(S)Ps​(S) 中所有元素的因子。 且由于 rrr 是最小的 Period，Ps(S)P_s(S)Ps​(S) 一定为 {kr∣1≤k,kr≤⌊n2⌋}\\{kr|1\\le k,kr\\le \\lfloor\\frac{n}{2}\\rfloor\\}{kr∣1≤k,kr≤⌊2n​⌋} 即 rrr 的正整数倍构成的集合。 根据对偶定理，A={n−kr∣1≤k,kr≤⌊n2⌋}⊆B(S)A=\\{n-kr|1\\le k,kr\\le \\lfloor\\frac{n}{2}\\rfloor\\}\\subseteq B(S)A={n−kr∣1≤k,kr≤⌊2n​⌋}⊆B(S)，并且 AAA 包含所有 2k≥n2k\\ge n2k≥n 的 Border kkk。 也就是说，满足 2k≥n2k\\ge n2k≥n 的 Border kkk 构成了一个首项为 n−rn-rn−r，公差为 −r-r−r 的等差数列。 1.3.2.2 定理 - 等差数列结构 B(S)B(S)B(S) 构成 O(log⁡n)O(\\log n)O(logn) 个等差数列 证明 根据引理 1.3.2.1，所有满足 2k≥n2k\\ge n2k≥n 的 Border kkk 构成了一个等差数列。 设 l=max⁡{k∣k∈B(S),2k&lt;n}l=\\max\\{k|k\\in B(S),2k&lt;n\\}l=max{k∣k∈B(S),2k&lt;n}，类比 1.3.1（树状结构）的证明，易知去除该等差数列后剩下的 Border 集合为 B(S[1,l])+{l}B(S_{[1,l]})+\\{l\\}B(S[1,l]​)+{l}。 那么在 S[1,l]S_{[1,l]}S[1,l]​ 上调用一次引理 1.3.2.1，可以实现继续砍半。 由于每次砍半，所以总共会得到 O(log⁡n)O(\\log n)O(logn) 个等差数列。 等差数列的寻找方法 这里给出一种寻找等差数列的方法：（该方法把 nnn 也当作 SSS 的 Border） 找到 SSS 的极长 Border kkk，设 l=n−(n−k)⌈n−⌊n2⌋n−k⌉l=n-(n-k)\\lceil\\frac{n-\\lfloor\\frac{n}{2}\\rfloor}{n-k}\\rceill=n−(n−k)⌈n−kn−⌊2n​⌋​⌉； 加入新的首项为 n−(n−k)⌈n−⌊n2⌋n−k⌉n-(n-k)\\lceil\\frac{n-\\lfloor\\frac{n}{2}\\rfloor}{n-k}\\rceiln−(n−k)⌈n−kn−⌊2n​⌋​⌉，末项为 nnn，公差为 n−kn-kn−k 的等差数列； 找到 S[1,l]S_{[1,l]}S[1,l]​ 的最长 Border ppp，递归处理 S[1,p]S_{[1,p]}S[1,p]​； 1.4 例题 P5287 [HNOI2019] JOJO | 题解 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"一些字符串的定理","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/yi-xie-zi-fu-chuan-de-ding-li/","stats":{"text":"7 min read","time":392000,"words":1272,"minutes":7},"date":"2023-12-28 20:49:55","dateFormat":"2023-12-28"},{"abstract":"<blockquote>\n<p>你需要动态维护一个字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 次操作：</p>\n<ul>\n<li><code>1 x c</code>：在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 末尾加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 个字符 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span>，保证操作前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 末尾字符不为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span>；</li>\n<li><code>2 x</code>：撤销第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 次操作后的所有操作；</li>\n</ul>\n<p>输出每次操作结束 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 的每个前缀的最长真 Border 的长度的和。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le x\\le 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 你需要动态维护一个字符串 SSS，有 nnn 次操作： 1 x c：在 SSS 末尾加上 xxx 个字符 ccc，保证操作前 SSS 末尾字符不为 ccc； 2 x：撤销第 xxx 次操作后的所有操作； 输出每次操作结束 SSS 的每个前缀的最长真 Border 的长度的和。 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤x≤1041\\le x\\le 10^41≤x≤104。 首先可持久化可以通过在操作树上 dfs 干掉，那么我们需要一个非均摊的东西来维护答案。 由于相邻 111 操作的 ccc 不同，所以 SSS 可以被划分成若干段，每次操作就相当于在末尾加入一段。 考虑维护 SSS 的最长真 Border，不妨用二元组 (x,c)(x,c)(x,c) 表示一段。对于 SSS 的一个 Border，不难发现前缀的 (x,c)(x,c)(x,c) 和后缀的 (x,c)(x,c)(x,c) 除了开头结尾外都要完全一致，而： 若开头不一致，则之后插入时肯定不能继承这个 Border，所以这个 Border 没用； 若结尾不一致，一定是后缀的 xxx 大于前缀的 xxx，否则同样没用； 也就是说，有用的 Border 的前缀肯定包含完整的段。 那么不妨维护二元组序列，用 failufail_ufailu​ 表示前缀 uuu 的最长有用真 Border 包含的二元组的个数。 有了 failfailfail，一个暴力的想法是：直接跳 failfailfail，假设当前插入的第 ttt 个二元组为 (x,c)(x,c)(x,c)，则维护一个指针 curcurcur 表示已经算出了当前段 [1,cur][1,cur][1,cur] 的极长真 Border 的长度，跳到一个 Border iii 时假设第 i+1i+1i+1 个二元组是 (y,c’)(y,c’)(y,c’) 且 c=c′c=c&#x27;c=c′，则： 若 x=yx=yx=y 则答案加上一个等差数列，更新 failt=i+1fail_{t}=i+1failt​=i+1，停止跳 failfailfail； 否则若 y&gt;cury&gt;cury&gt;cur 则答案加上一个等差数列，更新 cur=min⁡{x,y}cur=\\min\\{x,y\\}cur=min{x,y}； 最后还要特判一下 failt=1fail_t=1failt​=1 且 (x,c)(x,c)(x,c) 不被真 Border 完全包含的情况。 这样暴力跳是均摊 O(n)O(n)O(n) 的，操作树来个菊花就卡死了。 继续利用相邻二元组 ccc 不同的性质，对于一个 &gt;⌊n2⌋&gt;\\lfloor\\frac{n}{2}\\rfloor&gt;⌊2n​⌋ 的 Border kkk，n−kn-kn−k 必然是一个 Period，并且这些 &gt;⌊n2⌋&gt;\\lfloor\\frac{n}{2}\\rfloor&gt;⌊2n​⌋ 的 Border 构成一个等差数列，所以对于每个 &gt;⌊n2⌋&gt;\\lfloor\\frac{n}{2}\\rfloor&gt;⌊2n​⌋ 的 Border kkk，第 k+1k+1k+1 个二元组必然相同。由于相邻二元组 ccc 不同，所以 &gt;⌊n2⌋&gt;\\lfloor\\frac{n}{2}\\rfloor&gt;⌊2n​⌋ 的 Border 都被它们中最长的那个支配，那么处理完最长那个后直接跳过剩下的即可。 根据经典结论，这样的等差数列只会有 O(log⁡n)O(\\log n)O(logn) 个，那么就做完了，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=100005,p=998244353; struct node { int x,c; }; int n,m,rt[S]; vector&lt;pair&lt;int,node&gt; &gt; g[S]; vector&lt;int&gt; idx[S]; int tot; node a[S]; int len[S],fail[S]; int ans[S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int ins(node x) { a[++tot]=x; len[tot]=(len[tot-1]+x.x)%p; if(tot==1) { fail[tot]=0; return 1ll*(x.x-1)*x.x/2%p; } int res=0; fail[tot]=0; int cur=0,n=tot-1,u=fail[tot-1]; while(1) { if(a[u+1].c==x.c) { if(a[u+1].x==x.x) { int lft=x.x-cur; add(res,1ll*(cur+1+x.x)*lft/2%p); add(res,1ll*len[u]*lft%p); fail[tot]=u+1; break; } else if(a[u+1].x&gt;cur) { int le=min(x.x,a[u+1].x),lft=le-cur; add(res,1ll*(cur+1+le)*lft/2%p); add(res,1ll*len[u]*lft%p); cur=le; } if(u==0&amp;&amp;a[1].x&lt;x.x) { int lft=x.x-cur; add(res,1ll*a[1].x*lft%p); fail[tot]=1; break; } } if(u==0) break; if(u&gt;n/2) { int len=n-u,lft=u-n/2; u=u-(lft/len+(lft%len!=0))*len+len; n=u,u=fail[u]; } else n=u,u=fail[u]; } return res; } void dfs(int u,int res) { for(int id:idx[u]) ans[id]=res; for(auto t:g[u]) { int v=t.first; node x=t.second; int tt=tot; dfs(v,(res+ins(x))%p); tot=tt; } } int main() { scanf(&quot;%d&quot;,&amp;n); rt[0]=m=1; for(int i=1;i&lt;=n;i++) { int op,x; scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op==1) { char c; scanf(&quot; %c&quot;,&amp;c); g[rt[i-1]].emplace_back(rt[i]=++m,(node){x,c-'a'+1}); } else rt[i]=rt[x]; idx[rt[i]].push_back(i); } dfs(rt[0],0); for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"P5287 [HNOI2019] JOJO 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p5287-hnoi2019-jojo-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":344000,"words":1175,"minutes":6},"date":"2023-12-28 20:38:00","dateFormat":"2023-12-28"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的边集为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 的无向图和一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span>，你要给每个点分配一个非负实数点权 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">\\sum s_i=K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mo>∑</mo><mrow><mo>(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>)</mo><mo>∈</mo><mi>E</mi></mrow></msub><msub><mi>s</mi><mi>u</mi></msub><mo>×</mo><msub><mi>s</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{(u,v)\\in E}s_u\\times s_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.9660100000000003em;vertical-align:-1.216005em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7500050000000001em;\"><span style=\"top:-2.058995em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">u</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose mtight\">)</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">E</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.216005em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 最大。输出该式子的最大值（保留 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span></span></span></span> 位小数）。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>40</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 40</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le K\\le 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一张 nnn 个点的边集为 EEE 的无向图和一个正整数 KKK，你要给每个点分配一个非负实数点权 sis_isi​，满足 ∑si=K\\sum s_i=K∑si​=K 且 ∑(u,v)∈Esu×sv\\sum\\limits_{(u,v)\\in E}s_u\\times s_v(u,v)∈E∑​su​×sv​ 最大。输出该式子的最大值（保留 666 位小数）。 1≤n≤401\\le n\\le 401≤n≤40，1≤K≤10001\\le K\\le 10001≤K≤1000。 首先若 si=0s_i\\not=0si​​=0 的点不组成完全图，则可以找到两个相互没有连边的点 x,yx,yx,y，不妨假设 ∑(x,v)∈Esv≥∑(y,v)∈Esv\\sum\\limits_{(x,v)\\in E} s_v\\ge \\sum\\limits_{(y,v)\\in E} s_v(x,v)∈E∑​sv​≥(y,v)∈E∑​sv​，那么把 sys_ysy​ 全部给 sxs_xsx​ 肯定不劣。 并且根据数学直觉，点权肯定尽量平均分。 那么这就变成了最大团问题，这是个 NP 问题，但是我们有经典随机化算法： 随机一个加点顺序，若加入当前点后还是团则加入，否则不加入。 这个算法很难卡。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; using namespace std; const int S=45,TS=1000000,RS=15; int n,k; int a[S][S]; int tot,b[S],c[S]; int main() { srand(time(NULL)); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); } for(int i=1;i&lt;=n;i++) b[i]=i; int ans=0; for(int tt=1;tt&lt;=TS;tt++) { for(int i=1;i&lt;=RS;i++) swap(b[rand()%n+1],b[rand()%n+1]); int tot=0; for(int i=1;i&lt;=n;i++) { bool f=true; for(int j=1;j&lt;=tot&amp;&amp;f;j++) f&amp;=a[b[i]][c[j]]; if(f) c[++tot]=b[i]; } ans=max(ans,tot); } long double res=k*k/(long double)(ans*ans)*(ans*(ans-1)/2); printf(&quot;%Lf\\n&quot;,res); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF839E Mother of Dragons 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf839e-mother-of-dragons-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":136000,"words":447,"minutes":3},"date":"2023-12-27 19:29:36","dateFormat":"2023-12-27"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 和一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>。重复进行如下操作 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 次：</p>\n<ul>\n<li>选定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le j\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，并将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i,P_{i+1},..,P_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 翻转。</li>\n</ul>\n<p>对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac><msup><mo>)</mo><mi>m</mi></msup></mrow><annotation encoding=\"application/x-tex\">(\\frac{n(n+1)}{2})^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span></span></span></span></span></span></span></span> 种方案，计算 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></msub><mo>[</mo><msub><mi>P</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>P</mi><mi>j</mi></msub><mo>]</mo><mo>(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{i&lt;j}[P_i&gt;P_j](j-i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.185818em;vertical-align:-0.43581800000000004em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span></span></span></span> 的值的和。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 n,mn,mn,m 和一个 nnn 的排列 PPP。重复进行如下操作 mmm 次： 选定 1≤i≤j≤n1\\le i\\le j\\le n1≤i≤j≤n，并将 Pi,Pi+1,..,PjP_i,P_{i+1},..,P_jPi​,Pi+1​,..,Pj​ 翻转。 对于所有 (n(n+1)2)m(\\frac{n(n+1)}{2})^m(2n(n+1)​)m 种方案，计算 ∑i&lt;j[Pi&gt;Pj](j−i)\\sum_{i&lt;j}[P_i&gt;P_j](j-i)∑i&lt;j​[Pi​&gt;Pj​](j−i) 的值的和。 1≤n,m≤2×1051\\le n,m\\le 2\\times 10^51≤n,m≤2×105。 考虑拆开 ∑i&lt;j[Pi&gt;Pj](j−i)\\sum_{i&lt;j}[P_i&gt;P_j](j-i)∑i&lt;j​[Pi​&gt;Pj​](j−i)： ∑i&lt;j[Pi&gt;Pj](j−i)=∑ii×(∑j&lt;i[Pi&lt;Pj]−∑j&gt;i[Pi&gt;Pj])=∑ii×(i−∑j&lt;i[Pi≥Pj]−∑j&gt;i[Pi&gt;Pj])=∑ii×(i−∑j[Pi≥Pj])=∑ii×(i−Pi)=∑ii2−∑iiPi\\begin{aligned} \\sum_{i&lt;j}[P_i&gt;P_j](j-i)&amp;=\\sum\\limits_{i}i\\times \\left(\\sum\\limits_{j&lt;i}[P_i&lt;P_j]-\\sum\\limits_{j&gt;i}[P_i&gt;P_j]\\right)\\\\ &amp;=\\sum\\limits_i i\\times \\left(i-\\sum\\limits_{j&lt;i}[P_i\\ge P_j]-\\sum\\limits_{j&gt;i}[P_i&gt;P_j]\\right)\\\\ &amp;=\\sum\\limits_i i\\times \\left(i-\\sum\\limits_{j}[P_i\\ge P_j]\\right)\\\\ &amp;=\\sum\\limits_i i\\times (i-P_i)\\\\ &amp;=\\sum\\limits_i i^2-\\sum\\limits_i iP_i \\end{aligned} i&lt;j∑​[Pi​&gt;Pj​](j−i)​=i∑​i×(j&lt;i∑​[Pi​&lt;Pj​]−j&gt;i∑​[Pi​&gt;Pj​])=i∑​i×(i−j&lt;i∑​[Pi​≥Pj​]−j&gt;i∑​[Pi​&gt;Pj​])=i∑​i×(i−j∑​[Pi​≥Pj​])=i∑​i×(i−Pi​)=i∑​i2−i∑​iPi​​ 那么只要求出 ∑iiPi\\sum\\limits_{i} iP_ii∑​iPi​ 的和即可。 注意到操作只和位置相关，PiP_iPi​ 的和不太好求，那么不妨转而求 QiQ_iQi​ 表示 PiP_iPi​ 最后去的位置（PPP 的逆排列），那么 ∑iiPi=∑iQiPi\\sum\\limits_{i} iP_i=\\sum\\limits_{i} Q_iP_ii∑​iPi​=i∑​Qi​Pi​。 发现 QiQ_iQi​ 还是不好求，这时候你突然灵光一闪就能想到，其实可以求 SiS_iSi​ 表示 QiQ_iQi​ 的期望，最后再乘上 (n(n+1)2)m(\\frac{n(n+1)}{2})^m(2n(n+1)​)m。 注意到 SiS_iSi​ 是好求的。具体的，PiP_iPi​ 一旦被某次操作覆盖到，那么它去往 jjj 和去往 n−j+1n-j+1n−j+1 的概率是一样的，因为你总能构建出双射。 那么答案即为 (n(n+1)2)m(∑ii2−∑iSiPi)(\\frac{n(n+1)}{2})^m\\left(\\sum\\limits_i i^2-\\sum\\limits_i S_iP_i\\right)(2n(n+1)​)m(i∑​i2−i∑​Si​Pi​)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005,p=998244353,inv2=(p+1)/2; int n,m,a[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int calc(int n) { return 1ll*(n+1)*n/2%p; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int sm=0; for(int i=1;i&lt;=n;i++) { add(sm,1ll*i*i%p); int nc1=1ll*(calc(i-1)+calc(n-i))*qpow(calc(n),p-2)%p; int ncov=qpow(nc1,m); int si=0; add(si,1ll*i*ncov%p); add(si,1ll*(n+1)*inv2%p*(p+1-ncov)%p); add(sm,p-1ll*si*a[i]%p); } sm=1ll*sm*qpow(calc(n),m)%p; printf(&quot;%d\\n&quot;,sm); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ARC154E Reverse and Inversion 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc154e-reverse-and-inversion-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":251000,"words":754,"minutes":5},"date":"2023-12-27 18:55:59","dateFormat":"2023-12-27"},{"abstract":"<blockquote>\n<p>给你两个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo separator=\"true\">,</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P,Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span>，你要构造一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 的括号序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>。定义一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 是合法的，当且仅当按照 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><msub><mi>C</mi><mn>1</mn></msub></msub><msub><mi>S</mi><msub><mi>C</mi><mn>2</mn></msub></msub><mo>⋯</mo><msub><mi>S</mi><msub><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></msub></mrow><annotation encoding=\"application/x-tex\">S_{C_1}S_{C_2}\\cdots S_{C_{2n}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> 是合法括号序列。你构造的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 要满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> 是字典序最小的合法排列，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span> 是最大的。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给你两个 2n2n2n 的排列 P,QP,QP,Q，你要构造一个长 2n2n2n 的括号序列 SSS。定义一个 2n2n2n 的排列 CCC 是合法的，当且仅当按照 SC1SC2⋯SC2nS_{C_1}S_{C_2}\\cdots S_{C_{2n}}SC1​​SC2​​⋯SC2n​​ 是合法括号序列。你构造的 SSS 要满足 PPP 是字典序最小的合法排列，QQQ 是最大的。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105。 首先不难发现，若 P1=1P_1\\not= 1P1​​=1，那么 S[1,P1−1]S_{[1,P_1-1]}S[1,P1​−1]​ 一定都是 )，并且 SP1S_{P_1}SP1​​ 是 (，并且 SPiS_{P_i}SPi​​ 接下来长 2(P1−1)2(P_1-1)2(P1​−1) 的一段一定是 ()()()() 这样的。 这个似乎没什么用，继续观察。 这种只有 +1+1+1 和 −1-1−1 的序列不妨考虑折线图。 不难发现，()()()() 等价于把在 y=0y=0y=0 下方的折线拉回来，而折线原本就在 y=0y=0y=0 上方的部分在 PPP 中不会被修改。 所以，根据 PPP 可以确认折线图 y=0y=0y=0 上方的部分，根据 QQQ 可以确认折线图 y=0y=0y=0 下方的部分，这符合我们初步观察的结论。 那么直接模拟即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int S=400005; int n; int a[S],b[S]; char s[S]; int c[S],d[S]; inline void calca() { set&lt;int&gt; st; for(int i=1;i&lt;=n;i++) st.insert(i); for(int i=1;i&lt;=n&amp;&amp;!st.empty();i++) { if(a[i]==*st.begin()) { int j=i; s[a[j]]='('; for(;j&lt;=n&amp;&amp;!st.empty()&amp;&amp;a[j]==*st.begin();j++) { st.erase(a[j]); } j--; s[a[j]]=')'; i=j; } else { int tot=0; while(!st.empty()&amp;&amp;*st.begin()&lt;a[i]) { s[*st.begin()]=')'; st.erase(st.begin()); tot++; } if(tot==0) return; for(int j=i;j&lt;=i+tot*2-1;j+=2) { s[a[j]]='('; st.erase(a[j]); } i=i+tot*2-1; } } } inline void calcb() { set&lt;int,greater&lt;int&gt; &gt; st; for(int i=1;i&lt;=n;i++) st.insert(i); for(int i=1;i&lt;=n&amp;&amp;!st.empty();i++) { if(b[i]==*st.begin()) { int j=i; s[b[j]]='('; for(;j&lt;=n&amp;&amp;!st.empty()&amp;&amp;b[j]==*st.begin();j++) { st.erase(b[j]); } j--; s[b[j]]=')'; i=j; } else { int tot=0; while(!st.empty()&amp;&amp;*st.begin()&gt;b[i]) { s[*st.begin()]=')'; st.erase(st.begin()); tot++; } if(tot==0) return; for(int j=i;j&lt;=i+tot*2-1;j+=2) { s[b[j]]='('; st.erase(b[j]); } i=i+tot*2-1; } } } int main() { scanf(&quot;%d&quot;,&amp;n); n*=2; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); calca(); // puts(&quot;fina&quot;); // for(int i=1;i&lt;=n;i++) printf(&quot;%c&quot;,s[i]==0?'.':s[i]); // printf(&quot;\\n&quot;); calcb(); // for(int i=1;i&lt;=n;i++) printf(&quot;%c&quot;,s[i]==0?'.':s[i]); // printf(&quot;\\n&quot;); // puts(&quot;fin&quot;); for(int i=1;i&lt;=n;i++) if(s[i]==0) return puts(&quot;-1&quot;),0; int c0=0; for(int i=1;i&lt;=n;i++) c0+=s[i]=='('; if(c0!=n/2) return puts(&quot;-1&quot;),0; queue&lt;int&gt; v0,v1; for(int i=1;i&lt;=n;i++) { if(s[i]=='(') v0.push(i); else v1.push(i); } for(int i=1,k=0;i&lt;=n;i++) { if(!v0.empty()&amp;&amp;(v1.empty()||v0.front()&lt;v1.front()||k==0)) { k++; c[i]=v0.front(); v0.pop(); } else k--,c[i]=v1.front(),v1.pop(); } for(int i=n;i&gt;=1;i--) { if(s[i]=='(') v0.push(i); else v1.push(i); } for(int i=1,k=0;i&lt;=n;i++) { if(!v0.empty()&amp;&amp;(v1.empty()||v0.front()&gt;v1.front()||k==0)) { k++; d[i]=v0.front(); v0.pop(); } else k--,d[i]=v1.front(),v1.pop(); } bool f=true; // for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,c[i]); // printf(&quot;\\n&quot;); // for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,d[i]); // printf(&quot;\\n&quot;); for(int i=1;i&lt;=n&amp;&amp;f;i++) f&amp;=a[i]==c[i]; for(int i=1;i&lt;=n&amp;&amp;f;i++) f&amp;=b[i]==d[i]; if(!f) puts(&quot;-1&quot;); else printf(&quot;%s\\n&quot;,s+1); return 0; } /* ( */ ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ARC141C Bracket and Permutation 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc141c-bracket-and-permutation-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":311000,"words":931,"minutes":6},"date":"2023-12-27 18:55:23","dateFormat":"2023-12-27"},{"abstract":"<blockquote>\n<p>黑板上有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，再给定一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，可进行操作如下：</p>\n<ul>\n<li>选择一个黑板上的正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 和两个满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">y+z=x+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">y,z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span></span></span></span>，删掉 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，在黑板上写上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span></span></span></span>；</li>\n</ul>\n<p>求最少进行多少次操作可以让黑板上的数相等，或报告无解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i,k\\le 10^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 黑板上有 nnn 个正整数 aia_iai​，再给定一个正整数 kkk，可进行操作如下： 选择一个黑板上的正整数 xxx 和两个满足 y+z=x+ky+z=x+ky+z=x+k 的正整数 y,zy,zy,z，删掉 xxx，在黑板上写上 yyy 和 zzz； 求最少进行多少次操作可以让黑板上的数相等，或报告无解。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤ai,k≤10121\\le a_i,k\\le 10^{12}1≤ai​,k≤1012。 等号两边都有两个量不方便，注意到只要给每个 aia_iai​ 都减去 kkk，那么操作的限制就变成 y+z=xy+z=xy+z=x，且 −k&lt;y,z-k&lt;y,z−k&lt;y,z。 那么无解当且仅当 aia_iai​ 不同号，即存在 1≤i,j≤n1\\le i,j\\le n1≤i,j≤n 满足 ai&lt;0,aj&gt;0a_i&lt;0,a_j&gt;0ai​&lt;0,aj​&gt;0 或 ai=0,aj=0a_i=0,a_j\\not=0ai​=0,aj​​=0。 显然最后的数选择 g=gcd⁡{ai}g=\\gcd\\{a_i\\}g=gcd{ai​} 最优，答案即为 ∑aig−1\\sum \\frac{a_i}{g}-1∑gai​​−1。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; typedef long long ll; const int S=200005; int n; ll k,a[S]; inline ll gcd(ll x,ll y) { if(x==0||y==0) return x+y; ll t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } inline void slove() { scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),a[i]-=k; bool f=true; for(int i=1;i&lt;=n&amp;&amp;f;i++) { if(a[1]==0) f&amp;=a[i]==0; else if(a[1]&gt;0) f&amp;=a[i]&gt;0; else f&amp;=a[i]&lt;0; } if(!f) return puts(&quot;-1&quot;),void(); if(a[1]==0) return puts(&quot;0&quot;),void(); if(a[1]&lt;0) for(int i=1;i&lt;=n;i++) a[i]=-a[i]; ll m=0; for(int i=1;i&lt;=n;i++) m=gcd(m,a[i]); ll ans=0; for(int i=1;i&lt;=n;i++) ans+=a[i]/m-1; printf(&quot;%lld\\n&quot;,ans); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1909D Split Plus K 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1909d-split-plus-k-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":160000,"words":496,"minutes":3},"date":"2023-12-24 17:29:09","dateFormat":"2023-12-24"},{"abstract":"","content":"这次集训相比武汉、成都集训感觉过得更快，可能是因为节奏比较快，新奇的东西也比较多。 讲课的日子有做不完的好题，打赛的日子又有苦思冥想都不会的妙题，每天晚上还有好题分享……总是感觉时间不够用。虽然 THUPC 差一点 8 题进决赛，最后也差个读题没拿到奖，但总的来说这次集训还不错。 这次集训不止学到了 OI 知识。之前去过两次北京，都没看到下雪，没想到这次不但看到了漫天飞舞的雪花，还打了雪仗，堆了雪人，去了非常冷的故宫。在学校也见识到了北方的独特菜品，京爷学校的神秘构造和高级的宿舍。 总体来说，这次集训带给我的收获比较大，回来后也还有好多东西需要慢慢消化。 ","tags":[{"name":2023,"slug":"duHpjt30p","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/duHpjt30p/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"}],"title":"2023 北京集训游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023-bei-jing-ji-xun-you-ji/","stats":{"text":"1 min read","time":48000,"words":242,"minutes":1},"date":"2023-12-24 14:26:11","dateFormat":"2023-12-24"},{"abstract":"","content":" 给定长 nnn 的字符串 SSS，对于每个 1≤i≤n1\\le i\\le n1≤i≤n，求出 ziz_izi​ 表示 lcp(S,S[i,n])\\text{lcp}(S,S_{[i,n]})lcp(S,S[i,n]​)。 时间复杂度 O(n)O(n)O(n)。 类似 manacher，若存在 jjj 满足 j&lt;ij&lt;ij&lt;i 且 j+zj−1≥ij+z_j-1\\ge ij+zj​−1≥i，则 ziz_izi​ 至少为 min⁡(zi−j+1,j+zj−i)\\min(z_{i-j+1},j+z_j-i)min(zi−j+1​,j+zj​−i)： 那么记录 p+zp−1p+z_p-1p+zp​−1 最大的 ppp，每次暴力拓展 ziz_izi​ 都会令 p+zp−1p+z_p-1p+zp​−1 增加 111，所以时间复杂度均摊 O(n)O(n)O(n)。 注意 z1z_1z1​ 要单独计算。 代码如下： z[1]=n; for(int i=2,rb=2;i&lt;=n;i++) { if(rb+z[rb]-1&gt;=i) z[i]=min(z[i-rb+1],rb+z[rb]-i); while(z[i]&lt;n-i+1&amp;&amp;a[z[i]+1]==a[i+z[i]]) z[i]++; if(i+z[i]&gt;rb+z[rb]) rb=i; } 练习题目： P5410 【模板】扩展 KMP/exKMP（Z 函数） ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Z 算法（EX KMP）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/z-suan-fa-ex-kmpxue-xi-bi-ji/","stats":{"text":"2 min read","time":77000,"words":245,"minutes":2},"date":"2023-12-21 16:28:37","dateFormat":"2023-12-21"},{"abstract":"","content":"决策单调性一般可用观察法/分析四边形不等式得出，这里主要介绍四边形不等式。 在这里我们只讨论代价为二元函数 w(l,r)w(l,r)w(l,r) 的 dp。 Part 1 定义 &amp; 性质 1.1 dp 维数定义 描述 dp 的时间复杂度时，往往会用 xD/yD 这样的说法，其中 xxx 为 状态数log⁡n\\text{状态数}\\log n状态数logn，yyy 为 单次转移复杂度log⁡n\\text{单次转移复杂度}\\log n单次转移复杂度logn。 例如 fl,r=∑k=l+1rfl,k−1+fk,rf_{l,r}=\\sum\\limits_{k=l+1}^rf_{l,k-1}+f_{k,r}fl,r​=k=l+1∑r​fl,k−1​+fk,r​ 是 2D/1D 的 dp。 1.2 决策单调性 设 dp 的状态集合为 SSS，状态 uuu 的最优决策点为 opt(u)\\text{opt}(u)opt(u)。 若 ∀i,j∈S,i&lt;j\\forall i,j\\in S,i&lt;j∀i,j∈S,i&lt;j 都有 opt(i)≤opt(j)\\text{opt}(i)\\le\\text{opt}(j)opt(i)≤opt(j)，则称该 dp 满足决策单调性。 1.3 区间包含单调性和四边形不等式 这两个东西都是定义在二元函数 f(l,r)f(l,r)f(l,r) 上的。 1.3.1 区间包含单调性 若 ∀l≤l′≤r′≤r\\forall l\\le l&#x27;\\le r&#x27;\\le r∀l≤l′≤r′≤r，都有 f(l′,r′)≤f(l,r)f(l&#x27;,r&#x27;)\\le f(l,r)f(l′,r′)≤f(l,r)，则称 fff 满足区间包含单调性。 1.3.2 四边形不等式 若 ∀l≤l′≤r′≤r\\forall l\\le l&#x27;\\le r&#x27;\\le r∀l≤l′≤r′≤r，都有 f(l,r′)+f(l′,r)≤f(l,r)+f(l′,r′)f(l,r&#x27;)+f(l&#x27;,r)\\le f(l,r)+f(l&#x27;,r&#x27;)f(l,r′)+f(l′,r)≤f(l,r)+f(l′,r′)，则称 fff 满足四边形不等式。 即相交小于包含。 1.3.3 一些帮助证明的性质 若 w(l+1,r)≤w(l,r)w(l+1,r)\\le w(l,r)w(l+1,r)≤w(l,r) 且 w(l,r−1)≤w(l,r)w(l,r-1)\\le w(l,r)w(l,r−1)≤w(l,r)，则可以归纳证明 w(l,r)w(l,r)w(l,r) 满足区间包含单调性； 若 w(l+1,r)+w(l,r−1)≤w(l,r)+w(l+1,r−1)w(l+1,r)+w(l,r-1)\\le w(l,r)+w(l+1,r-1)w(l+1,r)+w(l,r−1)≤w(l,r)+w(l+1,r−1)，则可以归纳证明 w(l,r)w(l,r)w(l,r) 满足四边形不等式； 线性性：若 f(l,r)f(l,r)f(l,r) 与 g(l,r)g(l,r)g(l,r) 均满足区间包含单调性 / 四边形不等式，则 ∀c1,c2≥0\\forall c1,c2\\ge 0∀c1,c2≥0，c1×f(l,r)+c2×g(l,r)c1\\times f(l,r)+c2\\times g(l,r)c1×f(l,r)+c2×g(l,r) 也满足区间包含单调性 / 四边形不等式； 若 w(l,r)=f(r)−g(l)w(l,r)=f(r)-g(l)w(l,r)=f(r)−g(l)： w(l,r)w(l,r)w(l,r) 满足四边形恒等式（≤\\le≤ 恒取 ===）； 若 f,gf,gf,g 均单调不增，则 w(l,r)w(l,r)w(l,r) 还满足区间包含单调性； 若 f(x)f(x)f(x) 为下凸函数（导数不降），w(l,r)w(l,r)w(l,r) 满足区间包含单调性和四边形不等式： f(w(l,r))f(w(l,r))f(w(l,r)) 满足四边形不等式； 若 f(x)f(x)f(x) 单调不降，则 f(w(l,r))f(w(l,r))f(w(l,r)) 还满足区间包含单调性； 证明 (2）： w(l+1,r)+w(l,r−1)≤w(l,r)+w(l+1,r−1)(1)w(l+1,r−1)+w(l,r−2)≤w(l,r−1)+w(l+1,r−2)(2)w(l+1,r)+w(l,r−1)+w(l+1,r−1)+w(l,r−2)≤w(l,r)+w(l+1,r−1)+w(l,r−1)+w(l+1,r−2)(1)+(2)w(l+1,r)+w(l,r−2)≤w(l,r)+w(l+1,r−2)\\begin{aligned} w(l+1,r)+w(l,r-1)\\le w(l,r)+w(l+1,r-1)\\qquad&amp;(1)\\\\ w(l+1,r-1)+w(l,r-2)\\le w(l,r-1)+w(l+1,r-2)\\qquad&amp;(2)\\\\ w(l+1,r)+w(l,r-1)+w(l+1,r-1)+w(l,r-2)\\\\ \\le\\\\w(l,r)+w(l+1,r-1)+ w(l,r-1)+w(l+1,r-2)\\\\ &amp;(1)+(2)\\\\ w(l+1,r)+w(l,r-2)\\le w(l,r)+w(l+1,r-2) \\end{aligned} w(l+1,r)+w(l,r−1)≤w(l,r)+w(l+1,r−1)w(l+1,r−1)+w(l,r−2)≤w(l,r−1)+w(l+1,r−2)w(l+1,r)+w(l,r−1)+w(l+1,r−1)+w(l,r−2)≤w(l,r)+w(l+1,r−1)+w(l,r−1)+w(l+1,r−2)w(l+1,r)+w(l,r−2)≤w(l,r)+w(l+1,r−2)​(1)(2)(1)+(2)​ (5).1：不会证，感性理解一下： 满足区间包含单调性：更长的区间 w(l,r)w(l,r)w(l,r) 更大； 下凸函数：更大的 w(l,r)w(l,r)w(l,r) 增长得更快； 原本就满足四边形不等式：相交总和更小； Part 2 应用 这里默认代价函数为二元函数 w(l,r)w(l,r)w(l,r)，且该函数计算时间复杂度为 O(1)O(1)O(1)。 2.1 优化 1D/1D dp 若 w(l,r)w(l,r)w(l,r) 满足四边形不等式，则如下 1D/1D dp 存在决策单调性： fi=min⁡j=0i−1{w(j+1,i)}朴素形fi=min⁡j=0i−1{fj+w(j+1,i)}区间划分形f_i=\\min\\limits_{j=0}^{i-1}\\{w(j+1,i)\\}\\qquad\\text{朴素形}\\\\ f_i=\\min\\limits_{j=0}^{i-1}\\{f_j+w(j+1,i)\\}\\qquad\\text{区间划分形} fi​=j=0mini−1​{w(j+1,i)}朴素形fi​=j=0mini−1​{fj​+w(j+1,i)}区间划分形 即 ∀i&lt;j\\forall i&lt;j∀i&lt;j，opt(i)≤opt(j)\\text{opt}(i)\\le \\text{opt}(j)opt(i)≤opt(j)。 证明 先证明第二个： 解释：若出现上面的情况，则可以交换变成下面的情况，fi+fjf_i+f_{j}fi​+fj​ 变小，与 fif_ifi​ 和 fjf_jfj​ 均为最小值相悖。 第一个只不过是把黑色部分去掉了。 那么就可以分治或者在队列上二分来快速转移，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 2.1.1 分治优化转移 该方法仅适用于转移不依赖之前状态的情况（朴素形），在这种情况下，仅需求出 opt(i)\\text{opt}(i)opt(i) 即可得出 fif_ifi​。 考虑分治，令 mid=⌊n2⌋mid=\\lfloor\\frac{n}{2}\\rfloormid=⌊2n​⌋，先求出 k=opt(mid)k=\\text{opt}(mid)k=opt(mid)，接下来： 对于 i∈[1,mid−1]i\\in[1,mid-1]i∈[1,mid−1]，opt(i)≤k\\text{opt}(i)\\le kopt(i)≤k； 对于 i∈[mid+1,n]i\\in [mid+1,n]i∈[mid+1,n]，opt(i)≥k\\text{opt}(i)\\ge kopt(i)≥k； 那么在分治的时候记录 opt(i)\\text{opt}(i)opt(i) 的上下界即可。这样分治树的高度为 O(log⁡n)O(\\log n)O(logn)，每一层每一个转移点只会被遍历到最多两次，总时间复杂度即为 O(nlog⁡n)O(n\\log n)O(nlogn)。 示例代码 void dfs(int opt[],int(*calw)(int,int),int l,int r,int kl,int kr) { if(l&gt;r) return; int mid=l+r&gt;&gt;1,k=kl; for(int i=kl;i&lt;=kr&amp;&amp;i&lt;=mid;i++) { if(calw(i,mid)&lt;calw(k,mid)) k=i; } opt[mid]=k; dfs(opt,calw,l,mid-1,kl,k); dfs(opt,calw,mid+1,r,k,kr); } 例题：P3515 [POI2011] Lightning Conductor 题解 考虑拆成两半求解，先求满足 [1,i][1,i][1,i] 的 ppp，再求满足 [i,n][i,n][i,n] 的 ppp，取 max⁡\\maxmax。 设 fif_ifi​ 为前一半的 ppp，有： fi=max⁡j&lt;i{aj+i−j−ai}=−min⁡j&lt;i{ai−aj−i−j}\\begin{aligned} f_i&amp;=\\max\\limits_{j&lt;i}\\{a_j+\\sqrt{i-j}-a_i\\}\\\\ &amp;=-\\min\\limits_{j&lt;i}\\{a_i-a_j-\\sqrt{i-j}\\} \\end{aligned} fi​​=j&lt;imax​{aj​+i−j​−ai​}=−j&lt;imin​{ai​−aj​−i−j​}​ 由于 w1(j,i)=−i−jw1(j,i)=-\\sqrt{i-j}w1(j,i)=−i−j​ 和 w2(j,i)=ai−ajw2(j,i)=a_i-a_jw2(j,i)=ai​−aj​ 都满足四边形不等式，所以 w(j,i)=w1(j,i)+w2(j,i)w(j,i)=w1(j,i)+w2(j,i)w(j,i)=w1(j,i)+w2(j,i) 也满足四边形不等式。 那么直接分治优化转移即可，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 记得寻找 opt(i)\\text{opt}(i)opt(i) 时代价不能上取整，要最后再上取整。 参考代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; typedef long double db; const int S=500005; int n,a[S]; int opt1[S],opt2[S]; int ans[S]; inline db calw(int l,int r) { return a[r]-a[l]-sqrt((db)(r-l)); } void dfs(int opt[],db(*calw)(int,int),int l,int r,int kl,int kr) { if(l&gt;r) return; int mid=l+r&gt;&gt;1,k=kl; for(int i=kl;i&lt;=kr&amp;&amp;i&lt;=mid;i++) { if(calw(i,mid)&lt;calw(k,mid)) k=i; } opt[mid]=k; dfs(opt,calw,l,mid-1,kl,k); dfs(opt,calw,mid+1,r,k,kr); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(opt1,calw,1,n,1,n); for(int i=1;i&lt;=n;i++) ans[i]=ceil(-calw(opt1[i],i)); for(int i=1;i&lt;=n/2;i++) swap(a[i],a[n-i+1]); dfs(opt2,calw,1,n,1,n); for(int i=1;i&lt;=n;i++) ans[n-i+1]=max(ans[n-i+1],(int)ceil(-calw(opt2[i],i))); for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } 2.1.2 二分队列优化转移 该方法适用于转移依赖之前状态的情况（区间划分形）。 观察到对于特定的 jjj，opt(i)=j\\text{opt}(i)=jopt(i)=j 的 iii 肯定形成一个区间。 那么不妨用单调队列维护 jjj 和其对应的区间 [lj,rj][l_j,r_j][lj​,rj​]，队头为 ljl_jlj​ 最小的，队尾为 ljl_jlj​ 最大的。 每次转移到新的 iii 时： 先把队头 rj&lt;ir_j&lt;irj​&lt;i 的决策点弹掉，得到 opt(i)\\text{opt}(i)opt(i)，从而得到 fif_ifi​，令队头 lj=i+1l_j=i+1lj​=i+1； 然后对于队尾决策点 jjj，若 fi+w(i+1,lj)&lt;fj+w(j+1,lj)f_i+w(i+1,l_j)&lt;f_j+w(j+1,l_j)fi​+w(i+1,lj​)&lt;fj​+w(j+1,lj​) 则弹掉队尾； 若队列为空，加入决策 iii，令 li=i+1l_i=i+1li​=i+1，ri=nr_i=nri​=n； 否则二分找到分界点再加入决策 iii； 这样每个决策点最多只会入队一次，所以总时间复杂度为均摊 O(nlog⁡n)O(n\\log n)O(nlogn)。 参考代码 lb[0]=1,rb[0]=n; hed=1,til=0; que[++til]=0; f[0]=0; for(int i=1;i&lt;=n;i++) { while(rb[que[hed]]&lt;i) hed++; int opti=que[hed]; f[i]=f[opti]+calw(opti+1,i); if(rb[opti]==i) hed++; else lb[opti]=i+1; while(hed&lt;=til&amp;&amp; f[i]+calw(i+1,lb[que[til]]) &lt; f[que[til]]+calw(que[til]+1,lb[que[til]]) ) til--; if(hed&gt;til) { if(i&lt;n) { lb[i]=i+1,rb[i]=n; que[++til]=i; } } else { int j=que[til]; int l=lb[j],r=rb[j],p=lb[j]; while(l&lt;=r) { int mid=l+r&gt;&gt;1; if(f[j]+calw(j+1,mid)&lt;f[i]+calw(i+1,mid)) p=mid,l=mid+1; else r=mid-1; } rb[j]=p; if(p&lt;n) { lb[i]=p+1,rb[i]=n; que[++til]=i; } } } 例题：P3195 [HNOI2008] 玩具装箱 题解 设 fif_ifi​ 表示 [1,i][1,i][1,i] 的代价，那么有转移： fi=min⁡0≤j&lt;i{fj+w(j+1,i)}f_i=\\min\\limits_{0\\le j&lt;i}\\{f_j+w(j+1,i)\\} fi​=0≤j&lt;imin​{fj​+w(j+1,i)} 其中 w(l,r)=(r−l+∑l≤k≤rCk−L)2w(l,r)=(r-l+\\sum\\limits_{l\\le k\\le r}C_k-L)^2w(l,r)=(r−l+l≤k≤r∑​Ck​−L)2。 设 Si=∑1≤j≤iCjS_i=\\sum\\limits_{1\\le j\\le i}C_jSi​=1≤j≤i∑​Cj​，那么 w(l,r)=(r−l+Sr−Sl−1−L)2w(l,r)=(r-l+S_r-S_{l-1}-L)^2w(l,r)=(r−l+Sr​−Sl−1​−L)2。 显然 r−l+Sr−Sl−1−Lr-l+S_r-S_{l-1}-Lr−l+Sr​−Sl−1​−L 满足区间包含单调性和四边形不等式，由于 f(x)=x2f(x)=x^2f(x)=x2 是下凸函数，所以 w(l,r)w(l,r)w(l,r) 满足四边形不等式。 那么直接二分队列优化转移即可，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 参考代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; typedef long long ll; const int S=50005; int n,L; ll a[S]; int lb[S],rb[S]; int hed,til,que[S]; ll f[S]; inline ll calw(int l,int r) { ll x=r-l+a[r]-a[l-1]; return (x-L)*(x-L); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;L); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; lb[0]=1,rb[0]=n; hed=1,til=0; que[++til]=0; f[0]=0; for(int i=1;i&lt;=n;i++) { while(rb[que[hed]]&lt;i) hed++; int opti=que[hed]; f[i]=f[opti]+calw(opti+1,i); if(rb[opti]==i) hed++; else lb[opti]=i+1; while(hed&lt;=til&amp;&amp; f[i]+calw(i+1,lb[que[til]]) &lt; f[que[til]]+calw(que[til]+1,lb[que[til]]) ) til--; if(hed&gt;til) { if(i&lt;n) { lb[i]=i+1,rb[i]=n; que[++til]=i; } } else { int j=que[til]; int l=lb[j],r=rb[j],p=lb[j]; while(l&lt;=r) { int mid=l+r&gt;&gt;1; if(f[j]+calw(j+1,mid)&lt;f[i]+calw(i+1,mid)) p=mid,l=mid+1; else r=mid-1; } rb[j]=p; if(p&lt;n) { lb[i]=p+1,rb[i]=n; que[++til]=i; } } } printf(&quot;%lld\\n&quot;,f[n]); return 0; } 2.2 优化 2D/1D dp 2.2.1 恰好 kkk 段的区间划分形 若 w(l,r)w(l,r)w(l,r) 满足四边形不等式，则如下 2D/1D dp 存在决策单调性： fi,k=min⁡0≤j&lt;i{fj,k−1+w(j+1,i)}f_{i,k}=\\min\\limits_{0\\le j&lt;i}\\{f_{j,k-1}+w(j+1,i)\\} fi,k​=0≤j&lt;imin​{fj,k−1​+w(j+1,i)} 即满足 opt(i,k−1)≤opt(i,k)≤opt(i+1,k)\\text{opt}(i,k-1)\\le\\text{opt}(i,k)\\le \\text{opt}(i+1,k)opt(i,k−1)≤opt(i,k)≤opt(i+1,k)。 证明 opt(i,k)≤opt(i+1,k)\\text{opt}(i,k)\\le \\text{opt}(i+1,k)opt(i,k)≤opt(i+1,k) 套用 1D/1D 的区间划分形 dp 的证明方法即可，仅需证明 opt(i,k−1)≤opt(i,k)\\text{opt}(i,k-1)\\le \\text{opt}(i,k)opt(i,k−1)≤opt(i,k)。 不会证，感性理解一下。 并且这类问题有个神奇的性质（同样不会证）： fi,kf_{i,k}fi,k​ 是关于 kkk 的下凸函数。 感性理解一下就是刚开始分的越多越好，超过一个临界点分多点反而不好了。 也就是说，这类问题都可以 wqs 二分。 2.2.2 区间合并形 若 w(l,r)w(l,r)w(l,r) 满足四边形不等式和区间包含单调性，则如下 2D/1D dp 存在决策单调性： fl,r=min⁡l≤k&lt;r{fl,k+fk+1,r}+w(l,r)f_{l,r}=\\min\\limits_{l\\le k&lt; r}\\{f_{l,k}+f_{k+1,r}\\}+w(l,r) fl,r​=l≤k&lt;rmin​{fl,k​+fk+1,r​}+w(l,r) 即满足 opt(l,r−1)≤opt(l,r)≤opt(l+1,r)\\text{opt}(l,r-1)\\le\\text{opt}(l,r)\\le \\text{opt}(l+1,r)opt(l,r−1)≤opt(l,r)≤opt(l+1,r)，且 fl,rf_{l,r}fl,r​ 也满足四边形不等式。 并且若 w(l,r)w(l,r)w(l,r) 和 fl,rf_{l,r}fl,r​ 均非负，fl,rf_{l,r}fl,r​ 也满足区间包含单调性。 证明 四边形不等式和区间包含单调性的证明： 四边形不等式： 考虑归纳，l≥r−2l\\ge r-2l≥r−2 时显然成立。 仅需证明 fl,r−1+fl+1,r≤fl,r+fl+1,r−1f_{l,r-1}+f_{l+1,r}\\le f_{l,r}+f_{l+1,r-1}fl,r−1​+fl+1,r​≤fl,r​+fl+1,r−1​。 不妨设 opt(l,r)=k\\text{opt}(l,r)=kopt(l,r)=k。 k=lk=lk=l 或 k=r−1k=r-1k=r−1： 这里假设 k=r−1k=r-1k=r−1，另一种情况同理。 有： fl,r+fl+1,r−1=fl,k+fk+1,r+w(l,r)+fl+1,r−1=fl,r−1+fr,r+w(l,r)+fl+1,r−1\\begin{aligned} f_{l,r}+f_{l+1,r-1}&amp;=f_{l,k}+f_{k+1,r}+w(l,r)+f_{l+1,r-1}\\\\ &amp;=f_{l,r-1}+f_{r,r}+w(l,r)+f_{l+1,r-1}\\\\ \\end{aligned} fl,r​+fl+1,r−1​​=fl,k​+fk+1,r​+w(l,r)+fl+1,r−1​=fl,r−1​+fr,r​+w(l,r)+fl+1,r−1​​ 由于 w(l,r)w(l,r)w(l,r) 满足区间包含单调性，所以 w(l,r−1)≤w(l,r)w(l,r-1)\\le w(l,r)w(l,r−1)≤w(l,r)，那么有： fl,r+fl+1,r−1≥fl,r−1+fr,r+w(l,r−1)+fl+1,r−1≥fl,r−1+fl+1,r\\begin{aligned} f_{l,r}+f_{l+1,r-1}&amp;\\ge f_{l,r-1}+f_{r,r}+w(l,r-1)+f_{l+1,r-1}\\\\ &amp;\\ge f_{l,r-1}+f_{l+1,r}\\\\ \\end{aligned} fl,r​+fl+1,r−1​​≥fl,r−1​+fr,r​+w(l,r−1)+fl+1,r−1​≥fl,r−1​+fl+1,r​​ 最后一步是根据 dp 转移式得到的。 l&lt;k&lt;r−1l&lt;k&lt;r-1l&lt;k&lt;r−1： 此时设 opt(l+1,r−1)=p\\text{opt}(l+1,r-1)=popt(l+1,r−1)=p，不妨假设 k≤pk\\le pk≤p，k&gt;pk&gt;pk&gt;p 同理： fl,r+fl+1,r−1=fl,k+fk+1,r+w(l,r)+fl+1,p+fp+1,r−1+w(l+1,r−1)≥fk+1,r−1+fp+1,r+fl,k+fl+1,p+w(l,r)+w(l+1,r−1)≥fk+1,r−1+fp+1,r+fl,k+fl+1,p+w(l,r−1)+w(l+1,r)≥fl,r−1+fl+1,r\\begin{aligned} f_{l,r}+f_{l+1,r-1}&amp;=f_{l,k}+f_{k+1,r}+w(l,r)+f_{l+1,p}+f_{p+1,r-1}+w(l+1,r-1)\\\\ &amp;\\ge f_{k+1,r-1}+f_{p+1,r}+f_{l,k}+f_{l+1,p}+w(l,r)+w(l+1,r-1)\\\\ &amp;\\ge f_{k+1,r-1}+f_{p+1,r}+f_{l,k}+f_{l+1,p}+w(l,r-1)+w(l+1,r)\\\\ &amp;\\ge f_{l,r-1}+f_{l+1,r} \\end{aligned} fl,r​+fl+1,r−1​​=fl,k​+fk+1,r​+w(l,r)+fl+1,p​+fp+1,r−1​+w(l+1,r−1)≥fk+1,r−1​+fp+1,r​+fl,k​+fl+1,p​+w(l,r)+w(l+1,r−1)≥fk+1,r−1​+fp+1,r​+fl,k​+fl+1,p​+w(l,r−1)+w(l+1,r)≥fl,r−1​+fl+1,r​​ 其中： 第二个不等式是因为根据归纳假设，有 fk+1,r−1+fp+1,r≤fk+1,r+fp+1,r−1f_{k+1,r-1}+f_{p+1,r}\\le f_{k+1,r}+f_{p+1,r-1}fk+1,r−1​+fp+1,r​≤fk+1,r​+fp+1,r−1​； 第三个不等式是因为 w(l,r)w(l,r)w(l,r) 满足四边形不等式； 第四个不等式是根据 dp 转移式得到的； 区间包含单调性： 证明起来比较简单，依旧考虑归纳，l=rl=rl=r 时显然成立。 仅需证明 fl,r−1≤fl,rf_{l,r-1}\\le f_{l,r}fl,r−1​≤fl,r​ 和 fl+1,r≤fl,rf_{l+1,r}\\le f_{l,r}fl+1,r​≤fl,r​。 这里证明 fl,r−1≤fl,rf_{l,r-1}\\le f_{l,r}fl,r−1​≤fl,r​，另一个的证明是一样的。 设 opt(l,r)=k\\text{opt}(l,r)=kopt(l,r)=k。 l≤k&lt;r−1l\\le k&lt;r-1l≤k&lt;r−1： 有： fl,r=fl,k+fk+1,r+w(l,r)≥fl,k+fk+1,r−1+w(l,r−1)≥fl,r−1\\begin{aligned} f_{l,r}&amp;=f_{l,k}+f_{k+1,r}+w(l,r)\\\\ &amp;\\ge f_{l,k}+f_{k+1,r-1}+w(l,r-1)\\\\ &amp;\\ge f_{l,r-1} \\end{aligned} fl,r​​=fl,k​+fk+1,r​+w(l,r)≥fl,k​+fk+1,r−1​+w(l,r−1)≥fl,r−1​​ 其中： 第二个不等式是因为 w(l,r)w(l,r)w(l,r) 满足区间包含单调性，并且根据归纳假设，有 fk+1,r−1≤fk,rf_{k+1,r-1}\\le f_{k,r}fk+1,r−1​≤fk,r​； 第三个不等式是根据 dp 转移式得到的； k=r−1k=r-1k=r−1： 设 opt(l,r−1)=p\\text{opt}(l,r-1)=popt(l,r−1)=p，有： fl,r=fl,r−1+fr,r+w(l,r)\\begin{aligned} f_{l,r}&amp;=f_{l,r-1}+f_{r,r}+w(l,r) \\end{aligned} fl,r​​=fl,r−1​+fr,r​+w(l,r)​ 由于 w(l,r)w(l,r)w(l,r) 非负，fr,rf_{r,r}fr,r​ 也非负，所以 fl,r≥fl,r−1f_{l,r}\\ge f_{l,r-1}fl,r​≥fl,r−1​。 决策单调性的证明： 根据决策单调性，我们在 dp 的时候就可以记录 opt(l,r)\\text{opt}(l,r)opt(l,r)，转移的时候先枚举区间长度，枚举 kkk 只在 opt(l,r−1)\\text{opt}(l,r-1)opt(l,r−1) 和 opt(l+1,r)\\text{opt}(l+1,r)opt(l+1,r) 之间枚举。这样长度相同的区间的枚举 kkk 的时间复杂度总和是 O(n)O(n)O(n) 的，那么整体时间复杂度也就是 O(n2)O(n^2)O(n2) 的了。 例题：石子合并（加强版） 有 n 堆石子排成一个环，第 iii 堆石子有 aia_iai​ 个。 可以把相邻的两堆石子合并为一堆，合并的代价为两堆石子的个数之和，求把所有石子合并成一堆的最小代价和最大代价。 1≤n≤25001\\le n\\le 25001≤n≤2500。 题解 先段环为链，设 si=∑j=1iajs_{i}=\\sum\\limits_{j=1}^i a_jsi​=j=1∑i​aj​，fl,rf_{l,r}fl,r​ 为把 a[l,r]a_{[l,r]}a[l,r]​ 合并为一堆的最小代价，那么有转移： fl,r=min⁡l≤k&lt;r{fl,k+fk+1,r}+sr−sl−1f_{l,r}=\\min\\limits_{l\\le k&lt;r}\\{f_{l,k}+f_{k+1,r}\\}+s_{r}-s_{l-1} fl,r​=l≤k&lt;rmin​{fl,k​+fk+1,r​}+sr​−sl−1​ 显然由于 aia_iai​ 非负，所以 w(l,r)=sr−sl−1w(l,r)=s_r-s_{l-1}w(l,r)=sr​−sl−1​ 满足区间包含单调性和四边形不等式，那么 fl,rf_{l,r}fl,r​ 满足决策单调性，所以可以直接优化到 O(n2)O(n^2)O(n2)。 2.3 更多练习 P4767 [IOI2000] 邮局 CF321E Ciel and Gondolas SP33372 LARMY P6932 [ICPC2017 WF] Money for Nothing ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"决策单调性优化 dp 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/jue-ce-dan-diao-xing-you-hua-dp-xue-xi-bi-ji/","stats":{"text":"29 min read","time":1692000,"words":5320,"minutes":29},"date":"2023-12-19 09:49:56","dateFormat":"2023-12-19"},{"abstract":"","content":"可并堆就是支持快速合并的堆。 某些时候用这个东西可能会少一个 logloglog。 阅读一般的二叉堆合并代码： int merge(int x,int y) { if(x==0||y==0) return x+y; if(tr[x].val&gt;tr[y].val) swap(x,y); if(...) tr[x].ls=merge(tr[x].ls,y); else tr[x].rs=merge(tr[x].rs,y); return x; } 注意到由于只需要维护堆的性质，所以 yyy 和 x.lsx.lsx.ls 或者 x.rsx.rsx.rs 中任意一个合并都是可行的。 不难发现，合并会停止当且仅当 xxx 和 yyy 其中一个为空节点。那么在每个节点处维护它到子树内最近的空节点（即最近的缺左/右儿子的左/右儿子）的距离 distdistdist，每次往 distdistdist 小的儿子递归。 由于 dist=xdist=xdist=x 的节点子树大小至少为 2x−12^{x-1}2x−1，所以 distdistdist 是 log⁡\\loglog 级别的。 那么单次合并的时间复杂度也就是一个 log⁡\\loglog 的了。 为了方便实现，不妨钦定左儿子 distdistdist 较小。 合并代码如下： inline void upda(int u) { int &amp;ls=tr[u].ls,&amp;rs=tr[u].rs; if(tr[ls].dist&gt;tr[rs].dist) swap(ls,rs); tr[u].dist=tr[ls].dist+1; } int merge(int x,int y) { if(x==0||y==0) return x+y; if(tr[x].val&gt;tr[y].val) swap(x,y); tr[x].ls=merge(tr[x].ls,y); upda(x); return x; } 有了合并操作，其它操作都是 Ordinary 的，时间复杂度都只有一个 log⁡\\loglog，常数也比较小。 封装板子： template&lt;typename T,int siz&gt; class LTree { private: struct node { T val; int dist,ls,rs; }tr[siz]; int tot; inline int nnde(T val) { tr[++tot]={val,1,0,0}; return tot; } inline void upda(int u) { int &amp;ls=tr[u].ls,&amp;rs=tr[u].rs; if(tr[ls].dist&gt;tr[rs].dist) swap(ls,rs); tr[u].dist=tr[ls].dist+1; } int merge(int x,int y) { if(x==0||y==0) return x+y; if(tr[x].val&gt;tr[y].val) swap(x,y); tr[x].ls=merge(tr[x].ls,y); upda(x); return x; } public: inline void clear() { tr[tot=0]=(node){T(),0,0,0}; } inline void ins(int &amp;rt,T x) { rt=merge(rt,nnde(x)); } inline T top(int rt) { return tr[rt].val; } inline void pop(int &amp;rt) { rt=merge(tr[rt].ls,tr[rt].rs); } inline void meg(int &amp;x,int y) { x=merge(x,y); } }; ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"可并堆学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ke-bing-dui-xue-xi-bi-ji/","stats":{"text":"3 min read","time":164000,"words":546,"minutes":3},"date":"2023-12-18 20:39:02","dateFormat":"2023-12-18"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个卡，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个卡每次抽到的概率都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><msub><mi>a</mi><mi>i</mi></msub><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{a_i}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.056492em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7114919999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4101em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n=\\sum\\limits_{i=1}^m a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.329066em;vertical-align:-0.9776689999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3513970000000004em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9776689999999999em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，求集齐所有卡期望需要多少次，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 有 mmm 个卡，第 iii 个卡每次抽到的概率都是 ain\\frac{a_i}{n}nai​​，其中 n=∑i=1main=\\sum\\limits_{i=1}^m a_in=i=1∑m​ai​，求集齐所有卡期望需要多少次，对 998244353998244353998244353 取模。 1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105，1≤ai≤n1\\le a_i\\le n1≤ai​≤n。 首先 min-max 容斥转化为背包。 然后相当于 ∑k=1nnk[xk]∏i=1m(1−xai)\\sum\\limits_{k=1}^{n}\\frac{n}{k}[x^k]\\prod\\limits_{i=1}^m (1-x^{a_i})k=1∑n​kn​[xk]i=1∏m​(1−xai​)。 把 ∏i=1m(1−xai)\\prod\\limits_{i=1}^m (1-x^{a_i})i=1∏m​(1−xai​) 转化为 exp⁡(∑i=1mln⁡(1−xai))\\exp\\left(\\sum\\limits_{i=1}^m\\ln(1-x^{a_i})\\right)exp(i=1∑m​ln(1−xai​))。 ln⁡(1−xv)′=−vxv−11−xv=−∑j=0∞vxv−1+vj=−∑j=1∞vxvj−1=−∑j=1∞vjxvj−1j\\begin{aligned} \\ln(1-x^v)&#x27;&amp;=\\frac{-vx^{v-1}}{1-x^v}\\\\ &amp;=-\\sum\\limits_{j=0}^{\\infin}vx^{v-1+vj}\\\\ &amp;=-\\sum\\limits_{j=1}^{\\infin}vx^{vj-1}\\\\ &amp;=-\\sum\\limits_{j=1}^{\\infin}\\frac{vjx^{vj-1}}{j}\\\\ \\end{aligned} ln(1−xv)′​=1−xv−vxv−1​=−j=0∑∞​vxv−1+vj=−j=1∑∞​vxvj−1=−j=1∑∞​jvjxvj−1​​ ∫ln⁡(1−xv)′dx=∫−∑j=1∞vjxvj−1jdx=−∑j=1∞∫vjxvj−1dxj=−∑j=1∞xvjj=−∑j=1∞xvjj\\begin{aligned} \\int \\ln(1-x^v)&#x27;dx&amp;=\\int -\\sum\\limits_{j=1}^{\\infin}\\frac{vjx^{vj-1}}{j}dx\\\\ &amp;=-\\sum\\limits_{j=1}^{\\infin}\\frac{\\int vjx^{vj-1}dx}{j}\\\\ &amp;=-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}\\\\ &amp;=-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}\\\\ \\end{aligned} ∫ln(1−xv)′dx​=∫−j=1∑∞​jvjxvj−1​dx=−j=1∑∞​j∫vjxvj−1dx​=−j=1∑∞​jxvj​=−j=1∑∞​jxvj​​ ln⁡(1−xv)=−∑j=1∞xvjj\\ln(1-x^v)=-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j} ln(1−xv)=−j=1∑∞​jxvj​ 注意到 −∑j=1∞xvjj-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}−j=1∑∞​jxvj​ 在 mod xn\\text{mod } x^nmod xn 意义下只有 ⌊nv⌋\\lfloor\\frac{n}{v}\\rfloor⌊vn​⌋ 项非零，枚举 vvv 即可 O(nln⁡n)O(n\\ln n)O(nlnn) 算出 ∑i=1mln⁡(1−xai)\\sum\\limits_{i=1}^m\\ln(1-x^{a_i})i=1∑m​ln(1−xai​)，然后 O(nlog⁡n)O(n\\log n)O(nlogn) 求 exp 即可。 时间复杂度 O(m+nlog⁡n)O(m+n\\log n)O(m+nlogn)。 ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ABC331G Collect Them All 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc331g-collect-them-all-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":168000,"words":486,"minutes":3},"date":"2023-12-05 21:41:09","dateFormat":"2023-12-05"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 种货币，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 种面值为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.824664em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>，求凑出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 元钱有多少种方案数，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p>Ex：求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 有多少种 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 位 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 进制表示（每一位的数字无上限）。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 30</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le n\\le 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">2\\le k\\le 16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span></span></span></span>。</p>\n</blockquote>\n","content":" 有 mmm 种货币，第 iii 种面值为 2i−12^{i-1}2i−1，求凑出 nnn 元钱有多少种方案数，对 998244353998244353998244353 取模。 Ex：求 nnn 有多少种 mmm 位 kkk 进制表示（每一位的数字无上限）。 1≤m≤301\\le m\\le 301≤m≤30，0≤n≤10180\\le n\\le 10^{18}0≤n≤1018，2≤k≤162\\le k\\le 162≤k≤16。 考虑把面值为 2i2^i2i 的货币拆成面值 2i2^{i}2i、2i+12^{i+1}2i+1、2i+22^{i+2}2i+2……的货币各一个，即把 2i2^i2i 的选择个数 aia_iai​“摊平”。这样就可以转化为 01 背包。 那么数位 dp，设 dpi,jdp_{i,j}dpi,j​ 表示考虑完 20∼2i2^0\\sim 2^i20∼2i，向后进了 jjj 的方案数。 转移考虑枚举有 kkk 种面值当前位都为 111，枚举上一位的进位 lll，则： dpi,⌊k+l2⌋=[k+l≡n2i (mod 2)](min⁡(m,i+1)k)dpi−1,ldp_{i,\\lfloor\\frac{k+l}{2}\\rfloor}=[k+l\\equiv n_{2^i}\\text{ (mod }2\\text{)}]\\binom{\\min(m,i+1)}{k}dp_{i-1,l} dpi,⌊2k+l​⌋​=[k+l≡n2i​ (mod 2)](kmin(m,i+1)​)dpi−1,l​ Ex 做法类似，不过拆出来的每种货币可以选 k−1k-1k−1 个。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023GGXS】货币 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023ggxs-huo-bi-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":82000,"words":286,"minutes":2},"date":"2023-12-04 22:32:02","dateFormat":"2023-12-04"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 和一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，求满足以下条件的长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的个数</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">1\\le b_i\\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 两两不同；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 可以被 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 整除；</li>\n</ul>\n<p>对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le m\\le 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 n,mn,mn,m 和一个长 nnn 的序列 aia_iai​，求满足以下条件的长 nnn 的序列 bbb 的个数 1≤bi≤m1\\le b_i\\le m1≤bi​≤m； bib_ibi​ 两两不同； bib_ibi​ 可以被 aia_iai​ 整除； 对 998244353998244353998244353 取模。 1≤n≤161\\le n\\le 161≤n≤16，1≤ai≤m≤10181\\le a_i\\le m\\le 10^{18}1≤ai​≤m≤1018。 若 bi=bjb_i=b_jbi​=bj​ 则连接无向边 (i,j)(i,j)(i,j)，则两两不同的限制相当于图中没有边。 考虑容斥，设 dpSdp_SdpS​ 为 i∈Si\\in Si∈S 的 bib_ibi​ 的方案数。钦定某些点在同一个连通块，不难发现相同大小的连通块的容斥系数是相同的。不妨设大小为 nnn 的连通块的容斥系数为 fnf_nfn​，则有转移： dpS=∑T⊆S,min⁡{T}=min⁡{S}f∣T∣⌊mlcm{ai∣i∈T}⌋dpS−Tdp_S=\\sum\\limits_{T\\subseteq S,\\min\\{T\\}=\\min\\{S\\}}f_{|T|}\\left\\lfloor\\frac{m}{\\text{lcm}\\{a_i|i\\in T\\}}\\right\\rfloor dp_{S-T} dpS​=T⊆S,min{T}=min{S}∑​f∣T∣​⌊lcm{ai​∣i∈T}m​⌋dpS−T​ 考虑 fnf_nfn​ 需要满足的条件，设 gng_ngn​ 表示所有 nnn 个点的无向图的容斥系数的总和，那么枚举图中边的个数，有： gn=∑i=0n(n−1)2(n(n−1)2i)(−1)i=∑i=0n(n−1)2(n(n−1)2i)(−1)i1n−i=[n=0]+[n=1]\\begin{aligned} g_n&amp;=\\sum\\limits_{i=0}^{\\frac{n(n-1)}{2}}\\binom{\\frac{n(n-1)}{2}}{i}(-1)^i\\\\ &amp;=\\sum\\limits_{i=0}^{\\frac{n(n-1)}{2}}\\binom{\\frac{n(n-1)}{2}}{i}(-1)^i1^{n-i}\\\\ &amp;=[n=0]+[n=1] \\end{aligned} gn​​=i=0∑2n(n−1)​​(i2n(n−1)​​)(−1)i=i=0∑2n(n−1)​​(i2n(n−1)​​)(−1)i1n−i=[n=0]+[n=1]​ 而枚举 nnn 所在的连通块大小，有： gn=∑i=1n(n−1i−1)fign−i=fn+(n−1)fn−1\\begin{aligned} g_n&amp;=\\sum\\limits_{i=1}^{n}\\binom{n-1}{i-1}f_{i}g_{n-i}\\\\ &amp;=f_n+(n-1)f_{n-1} \\end{aligned} gn​​=i=1∑n​(i−1n−1​)fi​gn−i​=fn​+(n−1)fn−1​​ 而 g1=f1=1g_1=f_1=1g1​=f1​=1。 所以有： fn={1n=1−(n−1)fn−1n&gt;1f_{n}=\\begin{cases} 1&amp;n=1\\\\ -(n-1)f_{n-1}&amp;n&gt;1 \\end{cases} fn​={1−(n−1)fn−1​​n=1n&gt;1​ 那么 fn=(−1)n−1(n−1)!f_n=(-1)^{n-1}(n-1)!fn​=(−1)n−1(n−1)!。 那么直接 dp 即可，时间复杂度 O(3n)O(3^n)O(3n)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; typedef long long ll; const int S=20,BS=1&lt;&lt;16,p=998244353; int n; ll m,a[S]; ll lcm[BS]; int f[S],dp[BS]; #define popc __builtin_popcount inline ll gcd(ll x,ll y) { if(x==0||y==0) return x+y; ll t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } inline ll getlcm(int st) { ll res=1; for(int i=1;i&lt;=n;i++) { if(st&gt;&gt;i-1&amp;1) { ll g=gcd(res,a[i]); res/=g; if(res&gt;m/a[i]) res=m+1; else res*=a[i]; } } return res; } int main() { scanf(&quot;%d%lld&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=0;i&lt;(1&lt;&lt;n);i++) lcm[i]=getlcm(i); f[1]=1; for(int i=2;i&lt;=n;i++) f[i]=p-1ll*(i-1)*f[i-1]%p; dp[0]=1; for(int i=1;i&lt;(1&lt;&lt;n);i++) { for(int j=i;j&gt;0;j=(j-1)&amp;i) { if((i&amp;-i)!=(j&amp;-j)) continue; dp[i]=(dp[i]+1ll*f[popc(j)]*((m/lcm[j])%p)%p*dp[i^j]%p)%p; } } printf(&quot;%d\\n&quot;,dp[(1&lt;&lt;n)-1]); return 0; } ","tags":[{"name":"容斥","slug":"1Ur0PWueZ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/1Ur0PWueZ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ABC236Ex Distinct Multiples 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc236ex-distinct-multiples-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":265000,"words":798,"minutes":5},"date":"2023-11-15 21:40:00","dateFormat":"2023-11-15"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点，给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条有顺序的无向边和一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问，每次询问给定一个区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l_i,r_i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>，问应用区间内的边后连通块个数是否 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\le k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n<p>询问相互独立，强制在线。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le q\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个点，给定 mmm 条有顺序的无向边和一个 kkk。 qqq 次询问，每次询问给定一个区间 [li,ri][l_i,r_i][li​,ri​]，问应用区间内的边后连通块个数是否 ≤k\\le k≤k。 询问相互独立，强制在线。 1≤n,m≤2×1051\\le n,m\\le 2\\times 10^51≤n,m≤2×105，1≤k≤n1\\le k\\le n1≤k≤n，1≤q≤5×1051\\le q\\le 5\\times 10^51≤q≤5×105。 考虑求出 frf_rfr​ 表示最大的使得 [fr,r][f_r,r][fr​,r] 合法的左端点。 一个朴素的做法是扫描线，用 LCT 维护。 但是我们不会 LCT。 注意到双指针过程中左端点 lll 扫过的边 (xp,yp)(x_p,y_p)(xp​,yp​) 会对 f[p,n]f_{[p,n]}f[p,n]​ 有贡献，而由于 f[r+1,n]f_{[r+1,n]}f[r+1,n]​ 都不需要这条边，所以只会对 f[p,r]f_{[p,r]}f[p,r]​ 有贡献。 这种一个操作对某个区间有贡献的情况，不妨考虑线段树分治。 不同于一般情况，在本题中线段树分治的同时会加入新的操作，所以本题的线段树分治是半在线的。 具体的，线段树分治时维护一个并查集： 先分治右边再分治左边； 若当前点是叶子，则先令 fl=fl+1f_l=f_{l+1}fl​=fl+1​，然后不断往左推 flf_lfl​ 直到合法； 在推的过程中，在并查集中加入新的边，并把新的边 (xp,yp)(x_p,y_p)(xp​,yp​) 加入区间 [p,l−1][p,l-1][p,l−1]； 在 return 之前清空并查集中在当前节点新加入的所有边； 代码如下： void slove(int u,int l,int r) { int tp=top; for(int x:idx[u]) meg(rx[x],ry[x]); if(l==r) { f[l]=f[l+1]; while(f[l]&gt;1&amp;&amp;cnt&gt;K) { f[l]--; meg(rx[f[l]],ry[f[l]]); add(1,1,m,f[l],l-1,f[l]); } if(cnt&gt;K&amp;&amp;f[l]&gt;=1) f[l]=0; } else { int mid=l+r&gt;&gt;1; slove(u&lt;&lt;1|1,mid+1,r); slove(u&lt;&lt;1,l,mid); } rolbak(tp); } 由于 l∈[p,l−1]l\\not\\in[p,l-1]l​∈[p,l−1]，所以从 lll 去到 l−1l-1l−1 的过程中一定会经过 [p,l−1][p,l-1][p,l−1] 拆分出的线段树上的节点，所以直接清空并查集中在当前节点新加入的所有边是没有问题的。 时间复杂度 O(mlog⁡mlog⁡n)O(m\\log m\\log n)O(mlogmlogn)（log⁡n\\log nlogn 来自并查集），完整代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=200005; int n,m,K,tp; int rx[S],ry[S]; int cnt,fa[S],hei[S]; int top,fap[S],fax[S],hip[S],hix[S],ctx[S]; vector&lt;int&gt; idx[S&lt;&lt;2]; int f[S]; int q; int fnd(int x) { return fa[x]==x?x:fnd(fa[x]); } inline void meg(int x,int y) { int rx=fnd(x),ry=fnd(y); if(hei[rx]&gt;hei[ry]) swap(rx,ry); if(rx!=ry) { top++; fap[top]=rx,fax[top]=rx; hip[top]=ry,hix[top]=hei[ry]; ctx[top]=cnt; fa[rx]=ry; hei[ry]=max(hei[ry],hei[rx]+1); cnt--; } } inline void rolbak(int tme) { while(top&gt;tme) { fa[fap[top]]=fax[top]; hei[hip[top]]=hix[top]; cnt=ctx[top]; top--; } } void add(int u,int l,int r,int L,int R,int x) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) return idx[u].push_back(x),void(); int mid=l+r&gt;&gt;1; if(L&lt;=mid) add(u&lt;&lt;1,l,mid,L,R,x); if(R&gt;=mid+1) add(u&lt;&lt;1|1,mid+1,r,L,R,x); } void slove(int u,int l,int r) { int tp=top; for(int x:idx[u]) meg(rx[x],ry[x]); if(l==r) { f[l]=f[l+1]; while(f[l]&gt;1&amp;&amp;cnt&gt;K) { f[l]--; meg(rx[f[l]],ry[f[l]]); add(1,1,m,f[l],l-1,f[l]); } if(cnt&gt;K&amp;&amp;f[l]&gt;=1) f[l]=0; } else { int mid=l+r&gt;&gt;1; slove(u&lt;&lt;1|1,mid+1,r); slove(u&lt;&lt;1,l,mid); } rolbak(tp); } int main() { freopen(&quot;darkduck.in&quot;,&quot;r&quot;,stdin); freopen(&quot;darkduck.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;K,&amp;tp); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;rx[i],&amp;ry[i]); cnt=n; for(int i=1;i&lt;=n;i++) fa[i]=i,hei[i]=1; f[m+1]=m+1; slove(1,1,m); scanf(&quot;%d&quot;,&amp;q); unsigned lans=0; for(int i=1;i&lt;=q;++i) { int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(tp==1) { l=(l+lans)%m+1; r=(r+lans)%m+1; if(l&gt;r) swap(l,r); } bool fl=l&lt;=f[r]; puts(fl?&quot;Yes&quot;:&quot;No&quot;); lans&lt;&lt;=1; if(fl) ++lans; } return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"}],"title":"【2022NOIP模拟赛20】小Z的作业 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022noip-mo-ni-sai-20-xiao-z-de-zuo-ye-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":351000,"words":1107,"minutes":6},"date":"2023-11-15 10:04:18","dateFormat":"2023-11-15"},{"abstract":"","content":"做法 最小割。 这是我第一次在赛场上做出有难度的网络流，写篇题解纪念一下。 赛后发现我的建模方法和官方题解并不相同，所以这篇题解也算是提供了一种新奇的建图思路吧。 首先观察到每个人有两种选择：愿意和不愿意。那么可以用源点表示愿意，汇点表示不愿意。具体就是对第 iii 个人建立节点 iii，然后从源点向 iii 连一条流量为 did_idi​ 的边，从 iii 向汇点连一条流量为 cic_ici​ 的边： 然后考虑同一组内的两个人 x,yx,yx,y 意见不同（xxx 选择了愿意）的情况，此时情况如下： 因为会产生 exe_xex​ 的不满，所以从 xxx 向 yyy 连一条流量为 exe_xex​ 的边来增加不满。 对于 yyy 选择了愿意但是 xxx 选择了不愿意的情况亦然。 加上这些边之后的图如下：（两个奇奇怪怪的点是用来防止边权重叠的） 接下来我们就需要解决最棘手的喜欢关系了。（赛场上想了 1h 左右/ll） 首先可以发现，只有一组里两个人都选择愿意才可以合作。所以可以给每一组引入一个点 xix_ixi​，从 xix_ixi​ 分别向两个成员连流量为 inf⁡\\infinf 的边： 这么连边的目的是，假设有一些流量送到了 xix_ixi​： 那么就可以保证每一组如果不合作的话给 xix_ixi​ 送流量的边都要被割断，如果合作的话就不隔断，并且如果一组中有一个或以上人选择了不愿意那么就必须不合作。换句话说，xix_ixi​ 没有流量代表这一组不合作，否则代表这一组合作。 现在我们可以表示合不合作了，接下来考虑喜欢关系的连边。 若第 jjj 组关系是 xjx_jxj​ 喜欢 yjy_jyj​，设 uuu 表示 xjx_jxj​ 那一组的 xix_ixi​，vvv 表示 yjy_jyj​ 那一组的 xix_ixi​，那么： 如果 xjx_jxj​ 没有和队友合作，并且 yjy_jyj​ 选择了愿意，在图上就是 yjy_jyj​ 有流量并且 uuu 不能有流量。此时会产生 aja_jaj​ 的不满，那么我们可以从有流量的 yjy_jyj​ 向不能有流量的 uuu 连一条流量为 aja_jaj​ 的边。 如果 xjx_jxj​ 选择了不愿意，并且 yjy_jyj​ 和队友合作了，在图上就是 xjx_jxj​ 连向汇点的边没有被割断并且 vvv 有流量。此时会产生 bjb_jbj​ 的不满，那么我们可以从有流量的 vvv 向可以到达汇点的 xjx_jxj​ 连一条流量为 bjb_jbj​ 的边。 加上这些边后的图：（假设有一条喜欢关系：222 喜欢 333） 这样我们就建完图了，跑最小割即可。 AC 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std; struct node { }; typedef long long ll; const ll S=5000005,MS=1000005; int n,m,s,t; int xid[MS]; int esum,to[S],nxt[S],h[MS]; ll c[S]; int dep[MS]; inline void init() { esum=1; memset(h,0,sizeof(h)); s=0; t=1000003; } inline void add(int x,int y,ll w) { c[++esum]=w; to[esum]=y; nxt[esum]=h[x]; h[x]=esum; } inline bool bfs() { memset(dep,0,sizeof(dep)); queue&lt;int&gt; q; q.push(s); dep[s]=1; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[v]==0) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]!=0; } ll dfs(int u,ll w) { if(u==t) { return w; } ll sum=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[v]==dep[u]+1) { ll re=dfs(v,min(w,c[i])); c[i]-=re; c[i^1]+=re; sum+=re; w-=re; if(w==0) { break; } } } if(sum==0) { dep[u]=0; } return sum; } inline ll dinic() { ll ans=0; while(bfs()) { ans+=dfs(s,1e17); } return ans; } inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); n*=2; init(); for(int i=1;i&lt;=n;i++) { ll C,D,E; scanf(&quot;%lld%lld%lld&quot;,&amp;C,&amp;D,&amp;E); add(s,i,D); add(i,s,0); add(i,t,C); add(t,i,0); int v=(i&amp;1)?i+1:i-1; add(i,v,E); add(v,i,0); } for(int i=1;i&lt;=n;i+=2) { int u=n+(i+1)/2; add(u,i,1e17); add(i,u,0); add(u,i+1,1e17); add(i+1,u,0); xid[i]=u; xid[i+1]=u; } for(int i=1;i&lt;=m;i++) { int x,y; ll a,b; scanf(&quot;%d%d%lld%lld&quot;,&amp;x,&amp;y,&amp;a,&amp;b); int u1=xid[y],v1=xid[x]; add(u1,x,b); add(x,u1,0); add(y,v1,a); add(v1,y,0); } printf(&quot;%lld\\n&quot;,dinic()); } int main() { int _=1; // scanf(&quot;%d&quot;,&amp;_); while(_--) { slove(); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"网络流","slug":"19EjLeSB_D","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/19EjLeSB_D/"}],"title":"P8215 [THUPC2022 初赛] 分组作业 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p8215-thupc2022-chu-sai-fen-zu-zuo-ye-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":317000,"words":1155,"minutes":6},"date":"2023-11-09 16:28:42","dateFormat":"2023-11-09"},{"abstract":"<blockquote>\n<p>求有多少个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的括号序列满足其最长的合法括号子序列长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n<p>你需要对于每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mo>⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>⌋</mo></mrow><annotation encoding=\"application/x-tex\">0\\le k\\le \\lfloor\\frac{n}{2}\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 求出答案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 求有多少个长度为 nnn 的括号序列满足其最长的合法括号子序列长度为 2k2k2k。 你需要对于每个 0≤k≤⌊n2⌋0\\le k\\le \\lfloor\\frac{n}{2}\\rfloor0≤k≤⌊2n​⌋ 的 kkk 求出答案。 1≤n≤1061\\le n\\le 10^61≤n≤106。 不妨设括号序列中有 xxx 个 (。 不难发现括号序列匹配之后一定是形如 )))))((( 的。那么设匹配完后 ) 的个数有 yyy 个，则答案就是 n−x−yn-x-yn−x−y。 不难发现若 x≤⌊n2⌋x\\le \\lfloor \\frac{n}{2}\\rfloorx≤⌊2n​⌋ 则 −y-y−y 等于把 ( 看作 111，) 看作 −1-1−1 时的最小前缀和。而若 x&gt;⌊n2⌋x&gt;\\lfloor\\frac{n}{2}\\rfloorx&gt;⌊2n​⌋ 则可以翻转再反转来变成 x≤⌊n2⌋x\\le \\lfloor \\frac{n}{2}\\rfloorx≤⌊2n​⌋ 的情况，所以下面默认 x≤⌊n2⌋x\\le \\lfloor \\frac{n}{2}\\rfloorx≤⌊2n​⌋。 套路地，把 =k=k=k 转变为 ≥k\\ge k≥k。那么枚举 xxx，方案数即为：从 (0,0)(0,0)(0,0) 开始，每次 (+1,+1)(+1,+1)(+1,+1) 或 (+1,−1)(+1,-1)(+1,−1)，和直线 y=k−n+x−1y=k-n+x-1y=k−n+x−1 没有交，走到 (n,2x−n)(n,2x-n)(n,2x−n) 的路径数。 容斥，计算和直线有交的路径数。套路地作出 (n,2x−n)(n,2x-n)(n,2x−n) 关于直线的对称点 (n,2k−n−2)(n,2k-n-2)(n,2k−n−2)，那么和直线有交的路径数就是从 (0,0)(0,0)(0,0) 走到 (n,2k−n−2)(n,2k-n-2)(n,2k−n−2) 的路径数，即 (nk−1)\\binom{n}{k-1}(k−1n​)。 所以方案数就是 (nx)−(nk−1)\\binom{n}{x}-\\binom{n}{k-1}(xn​)−(k−1n​)。 那么 ≥k\\ge k≥k 的答案即为 ∑i=kn−k(nx)−(nk−1)\\sum\\limits_{i=k}^{n-k}\\binom{n}{x}-\\binom{n}{k-1}i=k∑n−k​(xn​)−(k−1n​)。 维护 (nx)\\binom{n}{x}(xn​) 的前缀和后这个东西就可以 O(1)O(1)O(1) 计算，所以总的时间复杂度为 O(n)O(n)O(n)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005,p=998244353; int fra[S],inv[S]; int sum[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } inline int calc(int n,int k) { int res=0; for(int i=k;i&lt;=n-k;i++) res=(0ll+res+C(n,i)-C(n,k-1)+p)%p; return res; } inline int calco1(int n,int k) { if(n-k&lt;k) return 0; return ((sum[n-k]-sum[k-1]+p)%p-1ll*(n-k-k+1)*C(n,k-1)%p+p)%p; } int main() { freopen(&quot;merchant.in&quot;,&quot;r&quot;,stdin); freopen(&quot;merchant.out&quot;,&quot;w&quot;,stdout); fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; int tp; scanf(&quot;%d&quot;,&amp;tp); if(tp==1) { int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); printf(&quot;%d\\n&quot;,(calc(n,k)-calc(n,k+1)+p)%p); } else { int n; scanf(&quot;%d&quot;,&amp;n); sum[0]=1; for(int i=1;i&lt;=n;i++) sum[i]=(sum[i-1]+C(n,i))%p; int ans=0,mul=1; for(int i=0;i&lt;=n/2;i++) { int pre=(calco1(n,i)-calco1(n,i+1)+p)%p; ans=(ans+1ll*pre*mul%p)%p; mul=1ll*mul*233%p; } printf(&quot;%d\\n&quot;,ans); } return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛37】商人 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-37-shang-ren/","stats":{"text":"5 min read","time":265000,"words":827,"minutes":5},"date":"2023-10-26 20:17:37","dateFormat":"2023-10-26"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l_i,r_i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>，构造一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，最小化 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>max</mi><mo>⁡</mo><mo>(</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mi>r</mi><msub><mi>p</mi><mi>i</mi></msub></msub><mo>−</mo><msub><mi>l</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msub><mo>)</mo><mo>−</mo><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{i=1}^{n-1}\\max(0,r_{p_i}-l_{p_{i+1}})-l_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.478782em;vertical-align:-0.9776689999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5011130000000001em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9776689999999999em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.041765em;vertical-align:-0.291765em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32808571428571426em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20252142857142857em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.291765em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 个区间 [li,ri][l_i,r_i][li​,ri​]，构造一个 nnn 的排列 ppp，最小化 ∑i=1n−1max⁡(0,rpi−lpi+1)−l1\\sum\\limits_{i=1}^{n-1}\\max(0,r_{p_i}-l_{p_{i+1}})-l_1i=1∑n−1​max(0,rpi​​−lpi+1​​)−l1​，输出方案。 1≤n≤5×1051\\le n\\le 5\\times 10^51≤n≤5×105。 考虑拆掉 max⁡\\maxmax，再讨论加回来新增的贡献。 拆掉 max⁡\\maxmax 后，答案为 ∑i=1nri−∑i=1nli−rn\\sum\\limits_{i=1}^n r_i-\\sum\\limits_{i=1}^n l_i-r_ni=1∑n​ri​−i=1∑n​li​−rn​。 那么为了让新增的贡献尽可能少，则我们要让 max⁡(0,rpi−lpi+1)\\max(0,r_{p_i}-l_{p_{i+1}})max(0,rpi​​−lpi+1​​) 取 000 的位置尽可能少，并且要让 rnr_nrn​ 尽可能大。 若两个区间相交，那么在它们之间连一条边。考虑只有一个连通块的情况，显然可以把 lll 最小的和 rrr 最大的两个区间以及它们之间的 “链”拉出来，然后把剩下的区间按照 rrr 从大到小放到前面： 这样没有取 000 的位置且 rnr_nrn​ 最大，显然满足答案最小。 对于有多个连通块的情况，设从左到右第 iii 个连通块的左端点为 lbilb_ilbi​，右端点为 rbirb_irbi​，那么显然新增的贡献至少是 ∑lbi+1−rbi\\sum lb_{i+1}-rb_i∑lbi+1​−rbi​，那么显然按照只有一个连通块的方法构造还是最优的。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)（排序）。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;deque&gt; using namespace std; typedef long long ll; const int S=500005; struct node { int l,r,id; }a[S]; int n,m; deque&lt;int&gt; res; set&lt;int&gt; st; int ans[S]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r),a[i].id=i; sort(a+1,a+n+1,[&amp;](auto x,auto y){return x.l&lt;y.l;}); for(int i=1,mxr=0;i&lt;=n;i++) { if(a[i].r&gt;mxr) res.push_back(a[i].id),st.insert(a[i].id); mxr=max(mxr,a[i].r); } sort(a+1,a+n+1,[&amp;](auto x,auto y){return x.r&lt;y.r;}); for(int i=1;i&lt;=n;i++) if(!st.count(a[i].id)) res.push_front(a[i].id); sort(a+1,a+n+1,[&amp;](auto x,auto y){return x.id&lt;y.id;}); while(!res.empty()) ans[res.size()]=res.back(),res.pop_back(); ll sum=0; for(int i=1;i&lt;=n-1;i++) sum+=max(0,a[ans[i]].r-a[ans[i+1]].l); sum+=m-a[ans[1]].l; printf(&quot;%lld\\n&quot;,sum); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛36】A 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-36-a-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":197000,"words":641,"minutes":4},"date":"2023-10-25 21:20:34","dateFormat":"2023-10-25"},{"abstract":"","content":"Part 1 一些定义 当你在 (x,y)(x,y)(x,y)，你下一步只能走到 (x+1,y)(x+1,y)(x+1,y) 或者 (x,y+1)(x,y+1)(x,y+1)。 所有数字均为非负整数，保证能从起点走到终点。 f(x1,y1,x2,y2)f(x1,y1,x2,y2)f(x1,y1,x2,y2) 为从 (x1,y1)(x1,y1)(x1,y1) 走到 (x2,y2)(x2,y2)(x2,y2) 的方案数（x1≤x2,y1≤y2x1\\le x2,y1\\le y2x1≤x2,y1≤y2）； cf(x1,y1,x2,y2,k)cf(x1,y1,x2,y2,k)cf(x1,y1,x2,y2,k) 为从 (x1,y1)(x1,y1)(x1,y1) 走到 (x2,y2)(x2,y2)(x2,y2)，并且和直线 y=x+ky=x+ky=x+k 有交的方案数； ncf(x1,y1,x2,y2,k)ncf(x1,y1,x2,y2,k)ncf(x1,y1,x2,y2,k) 为从 (x1,y1)(x1,y1)(x1,y1) 走到 (x2,y2)(x2,y2)(x2,y2)，并且和直线 y=x+ky=x+ky=x+k 没有交的方案数； csf(n,m,k)csf(n,m,k)csf(n,m,k) 为从 (0,0)(0,0)(0,0) 走到 (n,m)(n,m)(n,m) 的所有方案中，和直线 y=x+ky=x+ky=x+k 的交点个数和； cbf(n,k,b)cbf(n,k,b)cbf(n,k,b) 为从 (0,0)(0,0)(0,0) 走到 (n,kn+b)(n,kn+b)(n,kn+b)，并且和直线 y=kx+b+1y=kx+b+1y=kx+b+1 有交的方案数； ncbf(n,k,b)ncbf(n,k,b)ncbf(n,k,b) 为从 (0,0)(0,0)(0,0) 走到 (n,kn+b)(n,kn+b)(n,kn+b)，并且和直线 y=kx+b+1y=kx+b+1y=kx+b+1 没有交的方案数； Part 2 正文 2.1 fff 会有 x2−x1x2-x1x2−x1 步向上，y2−y1y2-y1y2−y1 步向右，它们可以任意排列，则 f(x1,y1,x2,y2)=(x2−x1+y2−y1x2−x1)f(x1,y1,x2,y2)=\\binom{x2-x1+y2-y1}{x2-x1}f(x1,y1,x2,y2)=(x2−x1x2−x1+y2−y1​)。 2.2 cfcfcf 和 ncfncfncf 显然有 ncf=f−cfncf=f-cfncf=f−cf。 则只需要计算 cfcfcf。 分三种情况： 若 x2+k&lt;y1x2+k&lt;y1x2+k&lt;y1 或 x1+k&gt;y2x1+k&gt;y2x1+k&gt;y2 则直线和路径没有任何关系，则 cf=0cf=0cf=0； 若 x2+k≤y2x2+k\\le y2x2+k≤y2 则一定有交，那么 cf=fcf=fcf=f； 否则考虑类似将军饮马的思路，找出 (x2,y2)(x2,y2)(x2,y2) 关于 y=x+ky=x+ky=x+k 的对称点 (y2−k,x2+k)(y2-k,x2+k)(y2−k,x2+k)，则从 (x1,y1)(x1,y1)(x1,y1) 到 (y2−k,x2+k)(y2-k,x2+k)(y2−k,x2+k) 一定有交，且将第一个交点后面的路径关于 y=x+ky=x+ky=x+k 整体翻折后与从 (x1,y1)(x1,y1)(x1,y1) 到 (x2,y2)(x2,y2)(x2,y2) 的和直线相交的路径构成双射： 那么有 cf(x1,y1,x2,y2,k)=f(x1,y1,y2−k,x2+k)cf(x1,y1,x2,y2,k)=f(x1,y1,y2-k,x2+k)cf(x1,y1,x2,y2,k)=f(x1,y1,y2−k,x2+k)； 综上，有： cf(x1,y1,x2,y2)={0x2+k&lt;y1 或 x1+k&gt;y2f(x1,y1,x2,y2)x2+k≤y2f(x1,y1,y2−k,x2+k)x2+k&gt;y2cf(x1,y1,x2,y2)=\\begin{cases} 0&amp; x2+k&lt;y1\\text{ 或 }x1+k&gt;y2\\\\ f(x1,y1,x2,y2)&amp; x2+k\\le y2\\\\ f(x1,y1,y2-k,x2+k)&amp;x2+k&gt;y2 \\end{cases} cf(x1,y1,x2,y2)=⎩⎪⎨⎪⎧​0f(x1,y1,x2,y2)f(x1,y1,y2−k,x2+k)​x2+k&lt;y1 或 x1+k&gt;y2x2+k≤y2x2+k&gt;y2​ ncfncfncf 减一减就出来了。 2.3 csfcsfcsf 对每个 (x,x+k)(x,x+k)(x,x+k) 算贡献，有： csf(n,m,k)=∑i=0nf(0,0,i,i+k)×f(i,i+k,n,m)csf(n,m,k)=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n,m) csf(n,m,k)=i=0∑n​f(0,0,i,i+k)×f(i,i+k,n,m) 似乎没法优化，换一种思路，注意到： 若 n+k≤mn+k\\le mn+k≤m 则一定要交至少一次。那么不妨设 csf(n,m,k)=f(0,0,n,m)+rescsf(n,m,k)=f(0,0,n,m)+rescsf(n,m,k)=f(0,0,n,m)+res，其中 resresres 为不是最后一个交点的交点个数，则有： res=∑i=0nf(0,0,i,i+k)×(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))=∑i=0nf(0,0,i,i+k)×(f(i+1,i+k,n,m)+f(i,i+k+1,m−k,n+k))=∑i=0nf(0,0,i,i+k)×f(i+1,i+k,n,m)×2=2×∑i=0nf(0,0,i,i+k)×f(i,i+k,n−1,m)\\begin{aligned} res&amp;=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))\\\\ &amp;=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(f(i+1,i+k,n,m)+f(i,i+k+1,m-k,n+k))\\\\ &amp;=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i+1,i+k,n,m)\\times 2\\\\ &amp;=2\\times \\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n-1,m)\\\\ \\end{aligned} res​=i=0∑n​f(0,0,i,i+k)×(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))=i=0∑n​f(0,0,i,i+k)×(f(i+1,i+k,n,m)+f(i,i+k+1,m−k,n+k))=i=0∑n​f(0,0,i,i+k)×f(i+1,i+k,n,m)×2=2×i=0∑n​f(0,0,i,i+k)×f(i,i+k,n−1,m)​ 第二行到第三行是因为两个路径关于直线对称，第三行到第四行是因为先往右走一步等价于最后往左走一步。 注意到 ∑i=0nf(0,0,i,i+k)×f(i,i+k,n−1,m)=csf(n−1,m,k)\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n-1,m)=csf(n-1,m,k)i=0∑n​f(0,0,i,i+k)×f(i,i+k,n−1,m)=csf(n−1,m,k)，那么有： res=2×csf(n−1,m,k)res=2\\times csf(n-1,m,k) res=2×csf(n−1,m,k) 那么不断展开下去，直到 n=0n=0n=0，得到： csf(n,m,k)=∑i=0n2n−if(0,0,i,m)=∑i=0n2n−i(m+im)csf(n,m,k)=\\sum\\limits_{i=0}^n 2^{n-i}f(0,0,i,m)=\\sum\\limits_{i=0}^n 2^{n-i}\\binom{m+i}{m} csf(n,m,k)=i=0∑n​2n−if(0,0,i,m)=i=0∑n​2n−i(mm+i​) 对于 n+k&gt;mn+k&gt;mn+k&gt;m 的情况，只有 cf(0,0,n,m,k)cf(0,0,n,m,k)cf(0,0,n,m,k) 种方案会有交。那么仍然是设 csf(n,m,k)=cf(0,0,n,m,k)+rescsf(n,m,k)=cf(0,0,n,m,k)+rescsf(n,m,k)=cf(0,0,n,m,k)+res，resresres 的定义不变，那么有： res=∑i=0nf(0,0,i,i+k)×(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))=∑i=0nf(0,0,i,i+k)×(f(i+1,i+k,m−k,n+k)+f(i,i+k+1,n,m))=∑i=0nf(0,0,i,i+k)×f(i,i+k+1,n,m)×2=2×∑i=0nf(0,0,i,i+k)×f(i,i+k,n,m−1)=2×csf(n,m−1,k)\\begin{aligned} res&amp;=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))\\\\ &amp;=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(f(i+1,i+k,m-k,n+k)+f(i,i+k+1,n,m))\\\\ &amp;=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k+1,n,m)\\times 2\\\\ &amp;=2\\times \\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n,m-1)\\\\ &amp;=2\\times csf(n,m-1,k) \\end{aligned} res​=i=0∑n​f(0,0,i,i+k)×(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))=i=0∑n​f(0,0,i,i+k)×(f(i+1,i+k,m−k,n+k)+f(i,i+k+1,n,m))=i=0∑n​f(0,0,i,i+k)×f(i,i+k+1,n,m)×2=2×i=0∑n​f(0,0,i,i+k)×f(i,i+k,n,m−1)=2×csf(n,m−1,k)​ 所以： csf(n,m,k)=∑i=0m2m−icf(0,0,n,i,k)=∑i=km2m−i(n+in+k)csf(n,m,k)=\\sum\\limits_{i=0}^m 2^{m-i}cf(0,0,n,i,k)=\\sum\\limits_{i=k}^m 2^{m-i}\\binom{n+i}{n+k} csf(n,m,k)=i=0∑m​2m−icf(0,0,n,i,k)=i=k∑m​2m−i(n+kn+i​) 那么问题转变为求解 ∑i=kn2n−i(m+im+k)\\sum\\limits_{i=k}^n 2^{n-i}\\binom{m+i}{m+k}i=k∑n​2n−i(m+km+i​)（n,m,kn,m,kn,m,k 不再是原来那三个 n,m,kn,m,kn,m,k）。 遇到这种组合数求和，不妨放到杨辉三角上看看：（牢记 (nm)=(n−1m)+(n−1m−1)\\binom{n}{m}=\\binom{n-1}{m}+\\binom{n-1}{m-1}(mn​)=(mn−1​)+(m−1n−1​)） 所以有： ∑i=kn2n−i(m+im+k)=∑i=m+k+1m+n+1(m+n+1i)\\sum\\limits_{i=k}^n 2^{n-i}\\binom{m+i}{m+k}=\\sum\\limits_{i=m+k+1}^{m+n+1}\\binom{m+n+1}{i} i=k∑n​2n−i(m+km+i​)=i=m+k+1∑m+n+1​(im+n+1​) 所以： csf(n,m,k)={∑i=m+1m+n+1(m+n+1i)n+k≤m∑i=n+k+1m+n+1(m+n+1i)n+k&gt;mcsf(n,m,k)=\\begin{cases} \\sum\\limits_{i=m+1}^{m+n+1}\\binom{m+n+1}{i}&amp;n+k\\le m\\\\ \\sum\\limits_{i=n+k+1}^{m+n+1}\\binom{m+n+1}{i}&amp;n+k&gt; m \\end{cases} csf(n,m,k)=⎩⎪⎪⎨⎪⎪⎧​i=m+1∑m+n+1​(im+n+1​)i=n+k+1∑m+n+1​(im+n+1​)​n+k≤mn+k&gt;m​ 2.4 cbfcbfcbf 和 ncbfncbfncbf 只需要求 cbfcbfcbf。 设 m=kn+bm=kn+bm=kn+b。 枚举最后一个交点 (p,kp+b+1)(p,kp+b+1)(p,kp+b+1)，则交点之后的路径数为： f(p,kp+b+1,n,m)=(m−kp−b−1+n−p)!(m−kp−b−1)!(n−p)!=(m−kp−b−1+n−p)!(m−kp−b)!(n−p−1)!×m−kp−bn−p=(m−kp−b+n−p−1n−p−1)×m−kp−bn−p=f(p,kp+b+1,n−1,m+1)×kn+b−kp−bn−p=f(p,kp+b+1,n−1,m+1)kf(p,kp+b+1,n,m)\\\\\\begin{aligned}\\\\&amp;=\\frac{(m-kp-b-1+n-p)!}{(m-kp-b-1)!(n-p)!}\\\\&amp;=\\frac{(m-kp-b-1+n-p)!}{(m-kp-b)!(n-p-1)!}\\times\\frac{m-kp-b}{n-p}\\\\&amp;=\\binom{m-kp-b+n-p-1}{n-p-1}\\times\\frac{m-kp-b}{n-p}\\\\&amp;=f(p,kp+b+1,n-1,m+1)\\times\\frac{kn+b-kp-b}{n-p}\\\\&amp;=f(p,kp+b+1,n-1,m+1)k\\\\\\end{aligned} f(p,kp+b+1,n,m)​=(m−kp−b−1)!(n−p)!(m−kp−b−1+n−p)!​=(m−kp−b)!(n−p−1)!(m−kp−b−1+n−p)!​×n−pm−kp−b​=(n−p−1m−kp−b+n−p−1​)×n−pm−kp−b​=f(p,kp+b+1,n−1,m+1)×n−pkn+b−kp−b​=f(p,kp+b+1,n−1,m+1)k​ 由于所有走到 (n−1,m+1)(n-1,m+1)(n−1,m+1) 的路径都一定会和直线相交，所以有交点的路径和最后一个交点在 (n,kn+b+1)(n,kn+b+1)(n,kn+b+1) 的路径构成双射，那么有 cbf(n,k,b)=k(n+mn−1)=k((k+1)n+bn−1)cbf(n,k,b)=k\\binom{n+m}{n-1}=k\\binom{(k+1)n+b}{n-1}cbf(n,k,b)=k(n−1n+m​)=k(n−1(k+1)n+b​)。 Part 3 练习 【2023NOI模拟赛37】商人 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"格路计数入门","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ge-lu-ji-shu-ru-men/","stats":{"text":"15 min read","time":873000,"words":2577,"minutes":15},"date":"2023-10-18 20:11:34","dateFormat":"2023-10-18"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>。</p>\n<p>每次操作你可以：</p>\n<ul>\n<li>选择两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">1\\le j\\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>；</li>\n<li>将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow></msub><msub><mi>a</mi><mi>i</mi></msub><msub><mi>a</mi><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[i+1,n]}a_ia_{[1,i-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>，将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mrow><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow></msub><msub><mi>b</mi><mi>j</mi></msub><msub><mi>b</mi><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b_{[j+1,n]}b_jb_{[1,j-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>构造一组操作使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">p_i=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">q_i=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 且操作次数最少。如果无解，输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2500</mn></mrow><annotation encoding=\"application/x-tex\">1\\leq n,m\\leq 2500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 的排列 aaa 和一个 mmm 的排列 bbb。 每次操作你可以： 选择两个正整数 1≤i≤n1\\le i\\le n1≤i≤n 和 1≤j≤m1\\le j\\le m1≤j≤m； 将 aaa 修改为 a[i+1,n]aia[1,i−1]a_{[i+1,n]}a_ia_{[1,i-1]}a[i+1,n]​ai​a[1,i−1]​，将 bbb 修改为 b[j+1,n]bjb[1,j−1]b_{[j+1,n]}b_jb_{[1,j-1]}b[j+1,n]​bj​b[1,j−1]​； 构造一组操作使得 pi=ip_i=ipi​=i 且 qi=iq_i=iqi​=i 且操作次数最少。如果无解，输出 −1-1−1。 1≤n,m≤25001\\leq n,m\\leq 25001≤n,m≤2500。 显然若求出 ma0/1ma_{0/1}ma0/1​ 和 mb0/1mb_{0/1}mb0/1​ 表示操作次数为奇/偶数时复原 aaa 和复原 bbb 最少需要的操作次数，则最少的操作次数即为 min⁡(max⁡(ma0,mb0),max⁡(ma1,mb1))\\min(\\max(ma_0,mb_0),\\max(ma_1,mb_1))min(max(ma0​,mb0​),max(ma1​,mb1​))。 那么 aaa 和 bbb 独立。 考虑把 aaa 放在环上，并加入一个 000 代表开头。对于一次操作，aaa 从： 0AaiB0Aa_iB 0Aai​B 变成了： 0BaiA=aiA0B0Ba_iA=a_iA0B 0Bai​A=ai​A0B 那么一次操作相当于交换 aia_iai​ 和 000。 那么枚举 000 最终的位置，问题变成了每次交换 aia_iai​ 和 000，求把一个 0∼n0\\sim n0∼n 的排列还原的最小操作次数和方案。 那么把置换环找出来，设 l1∼kl_{1\\sim k}l1∼k​ 为这些环的大小，其中 000 在 l1l_1l1​ 对应的环中，则最小操作次数显然为 l1−1+∑i=2k[li&gt;1](li+1)l_1-1+\\sum\\limits_{i=2}^k [l_i&gt;1](l_i+1)l1​−1+i=2∑k​[li​&gt;1](li​+1)。因为除了 000 所在的环，其它的环都要先和 000 交换一次以便把 000 加入当前环。 构造方案是简单的。 而根据置换环的性质，每次操作一定会改变环数的奇偶性，所以所有还原方案的操作次数奇偶性一定相同。 所以只需要找到最少的操作次数即可。 时间复杂度 O(n2)O(n^2)O(n2)，代码如下： // Problem: Two Permutations (Hard Version) // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1882E2 // Memory Limit: 250 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=2505,inf=1e8; int n,m; int a[S],b[S]; int ta[S]; int fa[S],siz[S],pos[S]; vector&lt;int&gt; ansa,ansb; int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } inline int calc(int n,int a[],int x) { for(int i=0;i&lt;=n;i++) ta[(i+x)%(n+1)]=a[i]; for(int i=0;i&lt;=n;i++) fa[i]=i,siz[i]=0; for(int i=0;i&lt;=n;i++) fa[fnd(i)]=fnd(ta[i]); for(int i=0;i&lt;=n;i++) siz[fnd(i)]++; int res=0; for(int i=0;i&lt;=n;i++) { int rx=fnd(i); if(i==0) res+=siz[rx]-1,siz[rx]=1; else if(siz[rx]!=1) res+=siz[rx]+1,siz[rx]=1; } return res; } inline void getres(int n,int a[],int x,vector&lt;int&gt; &amp;res) { for(int i=0;i&lt;=n;i++) ta[(i+x)%(n+1)]=a[i]; for(int i=0;i&lt;=n;i++) pos[ta[i]]=i; while(pos[0]!=0) { int u=pos[0],v=pos[u]; res.push_back((v-pos[0]+(n+1))%(n+1)); swap(pos[ta[u]],pos[ta[v]]); swap(ta[u],ta[v]); } for(int i=1;i&lt;=n;i++) { if(ta[i]!=i) { res.push_back((i-pos[0]+(n+1))%(n+1)); swap(pos[ta[0]],pos[ta[i]]); swap(ta[0],ta[i]); while(pos[0]!=0) { int u=pos[0],v=pos[u]; res.push_back((v-pos[0]+(n+1))%(n+1)); swap(pos[ta[u]],pos[ta[v]]); swap(ta[u],ta[v]); } } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); int ra[2]={-1,-1},rb[2]={-1,-1}; for(int i=0;i&lt;=n;i++) { int val=calc(n,a,i); if(ra[val&amp;1]==-1||val&lt;calc(n,a,ra[val&amp;1])) ra[val&amp;1]=i; } for(int i=0;i&lt;=m;i++) { int val=calc(m,b,i); if(rb[val&amp;1]==-1||val&lt;calc(m,b,rb[val&amp;1])) rb[val&amp;1]=i; } int r0=inf,r1=inf; if(ra[0]!=-1&amp;&amp;rb[0]!=-1) r0=max(calc(n,a,ra[0]),calc(m,b,rb[0])); if(ra[1]!=-1&amp;&amp;rb[1]!=-1) r1=max(calc(n,a,ra[1]),calc(m,b,rb[1])); if(r0==inf&amp;&amp;r1==inf) return puts(&quot;-1&quot;),0; if(r0&lt;r1) { getres(n,a,ra[0],ansa); getres(m,b,rb[0],ansb); } else { getres(n,a,ra[1],ansa); getres(m,b,rb[1],ansb); } int len=max(ansa.size(),ansb.size()); printf(&quot;%d\\n&quot;,len); for(int i=0;i&lt;len;i++) { if(i&lt;ansa.size()) printf(&quot;%d &quot;,ansa[i]); else printf(&quot;%d &quot;,i&amp;1?1:n); if(i&lt;ansb.size()) printf(&quot;%d\\n&quot;,ansb[i]); else printf(&quot;%d &quot;,i&amp;1?1:m); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1882E2 Two Permutations (Hard Version) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1882e2-two-permutations-hard-version-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":367000,"words":1130,"minutes":7},"date":"2023-10-14 22:25:03","dateFormat":"2023-10-14"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>，一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 01 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 合法当且仅当：</p>\n<ul>\n<li>设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 为所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">S_i=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 构成的子序列，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 为所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">S_i=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 构成的子序列，则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 的前缀最大值个数相等；</li>\n</ul>\n<p>求所有合法的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中字典序最小的那个。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 的排列 PPP，一个长 nnn 的 01 串 SSS 合法当且仅当： 设 AAA 为所有 Si=1S_i=1Si​=1 的 aia_iai​ 构成的子序列，BBB 为所有 Si=0S_i=0Si​=0 的 aia_iai​ 构成的子序列，则 AAA 和 BBB 的前缀最大值个数相等； 求所有合法的 SSS 中字典序最小的那个。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105。 显然 PPP 中的前缀最大值在 AAA 和 BBB 中还是前缀最大值，那么不妨将在 PPP 中就是前缀最大值的数称为“旧的”，在 PPP 中不是但在 AAA 或 BBB 中是前缀最大值的数成为“新的”。 那么有个结论： 若合法的 SSS 存在，那么一定存在某个合法的 SSS 满足 AAA 中的前缀最大值都是旧的。 证明 若 AAA 和 BBB 中都存在新的前缀最大值，那么交换它们管辖（AAA 中 iii 能管辖到 jjj 当且仅当 Ai=max⁡k=1jAkA_i=\\max\\limits_{k=1}^jA_kAi​=k=1maxj​Ak​，BBB 中同理）到的所有数即可。 那么考虑贪心，从前往后枚举 SSS 的每个位，判断这一位填 000 后还存不存在合法的 SSS 即可。 设当前填完了 S[1,i]S_{[1,i]}S[1,i]​，AAA 共有 cxcxcx 个前缀最大值，当前最大值为 mxmxmx；BBB 共有 cycycy 个前缀最大值，当前最大值为 mymymy，P[i+1,n]P_{[i+1,n]}P[i+1,n]​ 中一共有 ccc 个旧的前缀最大值。 不妨假设 AAA 之后的前缀最大值全都是旧的，那么设 BBB 后面共有 kkk 个旧的前缀最大值和 mmm 个新的前缀最大值，则当前填法合法当且仅当有： cx+c−k=cy+k+mm+2k=cx+c−cy\\begin{aligned} cx+c-k&amp;=cy+k+m\\\\ m+2k&amp;=cx+c-cy \\end{aligned} cx+c−km+2k​=cy+k+m=cx+c−cy​ cx+c−cycx+c-cycx+c−cy 是已知的，那么只要判断 m+2km+2km+2k 是否能满足即可。 而这就相当于给旧的前缀最大值赋一个 222 的权值，其它数赋 111，求能否在 P[i+1,n]P_{[i+1,n]}P[i+1,n]​ 中找到一个严格上升子序列 RRR 满足 R1&gt;myR_1&gt;myR1​&gt;my 且 RRR 的权值和为 cx+c−cycx+c-cycx+c−cy。 不难发现若找到了权值和为 xxx 的严格上升子序列，则一定能找到权值和为 x−2x-2x−2 的。所以找到权值和为奇数/偶数的最大的权值和即可。 那么使用值域线段树维护，先倒着扫一遍求出 fi,0/1f_{i,0/1}fi,0/1​ 表示以 iii 开头的权值和为偶数/奇数的严格上升子序列的最大的权值和，在贪心的时候每次把 fPif_{P_i}fPi​​ 删掉即可。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005; struct segment { int mx[S&lt;&lt;2]; inline void upda(int u) { mx[u]=max(mx[u&lt;&lt;1],mx[u&lt;&lt;1|1]); } void upd(int u,int l,int r,int p,int x) { if(l==r) return mx[u]=x,void(); int mid=l+r&gt;&gt;1; if(p&lt;=mid) upd(u&lt;&lt;1,l,mid,p,x); else upd(u&lt;&lt;1|1,mid+1,r,p,x); upda(u); } int que(int u,int l,int r,int L,int R) { if(l&gt;R||r&lt;L) return -1e8; if(l&gt;=L&amp;&amp;r&lt;=R) return mx[u]; int mid=l+r&gt;&gt;1,res=-1e8; if(L&lt;=mid) res=max(res,que(u&lt;&lt;1,l,mid,L,R)); if(R&gt;=mid+1) res=max(res,que(u&lt;&lt;1|1,mid+1,r,L,R)); return res; } }tr[2]; int n,a[S]; bool flg[S]; int ans[S]; inline bool chk(int x,int val) { if(val&lt;0) return false; return tr[val&amp;1].que(1,1,n,x,n)&gt;=val; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1,mx=0;i&lt;=n;i++) { flg[i]=a[i]&gt;mx; mx=max(mx,a[i]); } for(int i=1;i&lt;=n;i++) tr[1].upd(1,1,n,i,-1e8); for(int i=n;i&gt;=1;i--) { int p0=tr[0].que(1,1,n,a[i],n); int p1=tr[1].que(1,1,n,a[i],n); if(flg[i]) { tr[0].upd(1,1,n,a[i],p0+2); tr[1].upd(1,1,n,a[i],p1+2); } else { tr[0].upd(1,1,n,a[i],p1+1); tr[1].upd(1,1,n,a[i],p0+1); } } int c=0; for(int i=1;i&lt;=n;i++) c+=flg[i]; int cx=0,cy=0,mx=0,my=0; for(int i=1;i&lt;=n;i++) { c-=flg[i]; tr[0].upd(1,1,n,a[i],0); tr[1].upd(1,1,n,a[i],-1e8); int nx=cx+(a[i]&gt;mx); int valx=nx+c-cy; int valy=cy+c-nx; if(chk(my,valx)||chk(max(mx,a[i]),valy)) { ans[i]=0; cx+=a[i]&gt;mx; mx=max(mx,a[i]); } else { ans[i]=1; cy+=a[i]&gt;my; my=max(my,a[i]); } } if(cx!=cy) return puts(&quot;-1&quot;),0; for(int i=1;i&lt;=n;i++) putchar(ans[i]+'0'); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"AGC028E High Elements 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/agc028e-high-elements-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":360000,"words":1204,"minutes":7},"date":"2023-10-10 21:10:15","dateFormat":"2023-10-10"},{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 01 序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，对于每一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 划分为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个连续段重排后的最长不下降子序列的最大值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长 nnn 的 01 序列 aaa，对于每一个 1≤k≤n1\\le k\\le n1≤k≤n，求出 aaa 划分为 kkk 个连续段重排后的最长不下降子序列的最大值。 1≤n≤3×1051\\le n\\le 3\\times 10^51≤n≤3×105。 下文称最长不下降子序列为 LNDS。 首先问题等价于划分成 ≤k\\le k≤k 个连续段。 不难发现若 ai=ai+1a_i=a_{i+1}ai​=ai+1​ 则它们一定会被划分进同一个连续段，那么不妨将它们合并。 于是问题转化为了长度为 mmm 的 01 相间序列 bib_ibi​ 且每个 iii 有大小 cic_ici​。 发现由于 LNDS 中相邻两个 bib_ibi​ 相同的元素可以划分进同一段，所以直接做并不好做。那么考虑把不在 LNDS 中的元素删除，并把相邻两个相同元素合并。那么若最后剩下 lll 个元素，则： LNDS 的长度为这 lll 个元素的 cic_ici​ 之和； 若 l≥3l\\ge 3l≥3 则需要划分 l−1l-1l−1 段因为 ∃i,bi=0,bi+1=1\\exist i,b_i=0,b_{i+1}=1∃i,bi​=0,bi+1​=1； 对于 l≤2l\\le 2l≤2 的情况，不妨直接单独做。所以下面默认 l≥3l\\ge 3l≥3。 不难发现如下性质： 若删除边界元素，元素个数会减少 111，否则会减少 222，因为两边的元素会合并； 一定不会同时删除 bib_ibi​ 和 bi+1b_{i+1}bi+1​； 那么先枚举 b1b_1b1​ 和 bmb_mbm​ 有没有被删，则问题转化为要找一些两两不相邻的元素删去，使得删掉的元素的 cic_ici​ 之和最小。 这是一个经典反悔贪心问题。 不难发现对于未被删除的元素中 cic_ici​ 最小的元素 iii，若 iii 没被删掉则 i−1i-1i−1 和 i+1i+1i+1 就一定要都被删掉。 那么用链表+小根堆维护，设当前删掉的元素总和为 smsmsm，每次找到堆顶 ppp： 令 smsmsm 加上 cpc_pcp​； 找到 ppp 的前驱 lll 和后继 rrr： 若 lll 和 rrr 均存在，则 ppp 有可能不被删除，令 cp:=cl+cr−cpc_p:=c_l+c_r-c_pcp​:=cl​+cr​−cp​，在堆中加入 (cp,p)(c_p,p)(cp​,p)。 此时原来的 ppp 已被删除，现在的 ppp 为 lll 和 rrr 合并成的新元素，所以在链表中删除 lll 和 rrr。 否则 ppp 一定会被删除，则在链表中删除 ppp。 此时 lll 和 rrr 一定不会被删除，那么在链表中删除 lll 和 rrr（若存在）。 重复 kkk 次该过程则 LNDS 中将会有 m−(2k+t)m-(2k+t)m−(2k+t)（ttt 为 111 和 mmm 中被删除的元素个数）个元素，需要划分为 m−(2k+t)−1m-(2k+t)-1m−(2k+t)−1 段，那么开个答案数组每次对 smsmsm 取 min⁡\\minmin 即可。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int S=300005; int n; char str[S]; int m,a[S],val[S]; int pre[S],nxt[S]; bool sta[S]; int ans[S]; inline void del(int x) { pre[nxt[x]]=pre[x]; nxt[pre[x]]=nxt[x]; sta[x]=false; } inline void slove(int x,int y) { for(int i=1;i&lt;=m;i++) val[i]=a[i],pre[i]=i-1,nxt[i]=i+1,sta[i]=true; int c=0,sm=0; if(x) c++,sm+=val[1],del(nxt[1]); if(y) c++,sm+=val[m],del(pre[m]); del(1),del(m); priority_queue&lt;pair&lt;int,int&gt;&gt; q; for(int i=1;i&lt;=m;i++) if(sta[i]) q.push(make_pair(-val[i],i)); ans[m-c-1]=min(ans[m-c-1],sm); while(m-c-1&gt;=1&amp;&amp;!q.empty()) { auto u=q.top(); q.pop(); int p=u.second; if(!sta[p]) continue; c+=2; sm+=val[p]; ans[m-c-1]=min(ans[m-c-1],sm); int l=pre[p],r=nxt[p]; if(l!=0&amp;&amp;r!=m+1) { val[p]=val[l]+val[r]-val[p]; q.push(make_pair(-val[p],p)); } else del(p); if(l!=0) del(l); if(r!=m+1) del(r); } } int main() { scanf(&quot;%d%s&quot;,&amp;n,str+1); for(int i=1;i&lt;=n;i++) { if(str[i]=='0') { if(m==0||a[m]&lt;0) a[++m]=1; else a[m]++; } else { if(m==0||a[m]&gt;0) a[++m]=-1; else a[m]--; } } for(int i=1;i&lt;=m;i++) if(a[i]&lt;0) a[i]=-a[i]; for(int i=1;i&lt;=n;i++) ans[i]=1e8; slove(0,0); slove(1,0); slove(0,1); slove(1,1); for(int i=1;i&lt;=n;i++) ans[i]=n-ans[i]; ans[1]=0; int c1=0; for(int i=1;i&lt;=n;i++) c1+=str[i]=='1'; for(int i=1,c0=0;i&lt;=n;i++) { c0+=str[i]=='0'; ans[1]=max(ans[1],c0+c1); c1-=str[i]=='1'; } for(int i=2;i&lt;=n;i++) ans[i]=max(ans[i],ans[i-1]); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"QOJ5013 Astral Birth 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/qoj5013-astral-birth-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":334000,"words":1140,"minutes":6},"date":"2023-10-09 09:51:32","dateFormat":"2023-10-09"},{"abstract":"<blockquote>\n<p>给定长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span>，求有多少个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的有标号简单无向图（无自环重边）满足：</p>\n<ul>\n<li>点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的度数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n<li>点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 有且仅有一条最短路；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">\\forall j&lt;i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的最短路长度大于等于点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的；</li>\n</ul>\n<p>对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding=\"application/x-tex\">3\\le n\\le 300</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><msub><mi>d</mi><mi>i</mi></msub><mo>≤</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">2\\le d_i\\le 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定长 nnn 的序列 ddd，求有多少个 nnn 个点的有标号简单无向图（无自环重边）满足： 点 iii 的度数为 did_idi​； 点 111 到点 iii 有且仅有一条最短路； ∀j&lt;i\\forall j&lt;i∀j&lt;i，点 111 到点 iii 的最短路长度大于等于点 111 到点 jjj 的； 对 998244353998244353998244353 取模。 3≤n≤3003\\le n\\le 3003≤n≤300，2≤di≤32\\le d_i\\le 32≤di​≤3。 考虑 bfs，显然图可以分成若干层，每一层点的编号连续且 bfs 树上的横叉边都在同一层内。 那么不难想到设 fi,jf_{i,j}fi,j​ 表示处理完前 iii 个点，最后一层往下连了 jjj 条边的方案数。 转移时下一层的区间一定是 [i+1,i+j−1][i+1,i+j-1][i+1,i+j−1]，且区间内去掉当前层的 jjj 条边就只剩下一度点和二度点。那么不难想到设 gi,j,kg_{i,j,k}gi,j,k​ 表示一层内有 iii 个 111 度点和 jjj 个二度点，往下一层连了 kkk 条边的内部连边方案数。则有： fi,j×gc1,c2,k×j!→fi+j,kf_{i,j}\\times g_{c1,c2,k}\\times j!\\to f_{i+j,k} fi,j​×gc1,c2,k​×j!→fi+j,k​ 其中 c1c1c1 和 c2c2c2 表示 d[i+1,i+j−1]d_{[i+1,i+j-1]}d[i+1,i+j−1]​ 中 222 和 333 的个数。 但是发现这样会算重，因为二度点无论连哪边都是一样的。 所以若上一层有 lll 个二度点是两边都往下连的，则转移时需要除掉 2l2^l2l。 这个问题是好处理的，只需要把 2l2^l2l 放进 ggg 中即可。 现在来考虑 ggg 怎么求，首先显然有 g0,0,0=1g_{0,0,0}=1g0,0,0​=1。 不难发现一度点和二度点之间的顺序是没有关系的，所以不妨钦定先放一度点再放二度点。 下文 x 表示一度点，o 表示二度点，- 表示层内连边，+ 表示向下一层的连边 对于没有二度点的情况，考虑最后一个一度点 uuu： u+ 型：gi−1,0,k−1g_{i-1,0,k-1}gi−1,0,k−1​； x-u 型：gi−2,0,k×(i−1)g_{i-2,0,k}\\times (i-1)gi−2,0,k​×(i−1)； 对于有二度点的情况，考虑最后一个二度点 uuu。为了避免算重，uuu 多出来的边直接往下连： +u+ 型：gi,j−1,k−2×12g_{i,j-1,k-2}\\times \\frac{1}{2}gi,j−1,k−2​×21​，其中 12\\frac{1}{2}21​ 是转移时的 2l2^l2l； x-u+ 型：gi−1,j−1,k−1×ig_{i-1,j-1,k-1}\\times igi−1,j−1,k−1​×i； -o-u+ 型：连出去的二度点规约为一个一度点，gi+1,j−2,k−1×(j−1)g_{i+1,j-2,k-1}\\times(j-1)gi+1,j−2,k−1​×(j−1)； x-u-x 型：gi−2,j−1,k×i×(i−1)2g_{i-2,j-1,k}\\times \\frac{i\\times(i-1)}{2}gi−2,j−1,k​×2i×(i−1)​； x-u-o- 型：连出去的二度点规约为一个一度点，gi,j−2,k×i×(j−1)g_{i,j-2,k}\\times i\\times (j-1)gi,j−2,k​×i×(j−1)； -o-u-o- 型：两个二度点都规约为一度点，gi+2,j−3,k×(j−1)×(j−2)2g_{i+2,j-3,k}\\times \\frac{(j-1)\\times(j-2)}{2}gi+2,j−3,k​×2(j−1)×(j−2)​； 时间复杂度 O(n3)O(n^3)O(n3)，空间复杂度 O(n3)O(n^3)O(n3)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=305,p=1000000007,inv2=(p+1)/2; int fra[S]; int n,a[S]; int g[S][S][S],f[S][S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int main() { fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); g[0][0][0]=1; for(int k=0;k&lt;=n;k++) { for(int j=0;j&lt;=n&amp;&amp;j+k&lt;=n;j++) { for(int i=0;i&lt;=n&amp;&amp;i+j+k&lt;=n;i++) { if(i+j*2&lt;k) continue; if(i+j+k==0) continue; int &amp;u=g[i][j][k]; if(j==0) { // u- if(k&gt;=1) add(u,g[i-1][j][k-1]); // u-x if(i&gt;=2) add(u,1ll*g[i-2][j][k]*(i-1)%p); } else { // x-u-x if(i&gt;=2) add(u,1ll*g[i-2][j-1][k]*i%p*(i-1)%p*inv2%p); // x-u-o- OR -o-u-x if(i&gt;=1&amp;&amp;j&gt;=2) add(u,1ll*g[i][j-2][k]*i%p*(j-1)%p); // -o-u-o- if(j&gt;=3) add(u,1ll*g[i+2][j-3][k]*(j-1)%p*(j-2)%p*inv2%p); if(k&gt;=1) { // x-u- OR -u-x if(i&gt;=1) add(u,1ll*g[i-1][j-1][k-1]*i%p); // -o-u- OR -u-o- if(j&gt;=2) add(u,1ll*g[i+1][j-2][k-1]*(j-1)%p); if(k&gt;=2) { // -u- add(u,1ll*g[i][j-1][k-2]*inv2%p); } } } } } } f[1][a[1]]=qpow(fra[a[1]],p-2); for(int i=1;i&lt;=n-1;i++) { int c1=0,c2=0; for(int j=i+1;j&lt;=n;j++) { c1+=a[j]==2; c2+=a[j]==3; for(int k=0;k&lt;=n&amp;&amp;k&lt;=c1+c2*2;k++) { int pre=1ll*f[i][j-i]*g[c1][c2][k]%p*fra[j-i]%p; add(f[j][k],pre); } } } printf(&quot;%d\\n&quot;,f[n][0]); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"LOJ6094 「Codeforces Round #418」归乡迷途 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/loj6094-codeforces-round-418-gui-xiang-mi-tu-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":409000,"words":1318,"minutes":7},"date":"2023-10-06 22:07:28","dateFormat":"2023-10-06"},{"abstract":"","content":"Part 1 定义 在长链剖分中，我们定义 uuu 的长儿子为： uuu 的所有儿子 vvv 中，子树最高的那个 vvv； 与重链剖分一样，每个点和它的长儿子划分到同一条长链。 Part 2 性质 2.1 每个点属于且仅属于一条长链 2.2 一个点到根的路径上长链的条数是 O(n)O(\\sqrt n)O(n​) 的 对于一个子树高度为 kkk 的节点 uuu，若它的父亲 fafafa 和 uuu 并不在一条长链中，则 fafafa 的子树大小至少为 2k+12k+12k+1。 那么如果跳了 xxx 条长链，则子树大小至少为 ∑i=1xi\\sum\\limits_{i=1}^x ii=1∑x​i。 所以一个节点到根的路径上，长链的条数是 O(n)O(\\sqrt n)O(n​) 的。 2.3 一个点的 kkk 级祖先所在的长链的长度至少为 kkk Part 3 应用 3.1 O(nlog⁡n)/O(1)O(n\\log n)/O(1)O(nlogn)/O(1) 在线求 kkk 级祖先 根据性质 2.1 和 2.3，不难想到 uuu 的 kkk 级祖先距离 uuu 的 2⌊log⁡2k⌋2^{\\lfloor\\log_2k\\rfloor}2⌊log2​k⌋ 级祖先所在的长链 lnklnklnk 的链头一定不超过 ∣lnk∣|lnk|∣lnk∣ 个节点。 那么维护出每个点 uuu 的 2j2^j2j 级祖先 fau,jfa_{u,j}fau,j​，并维护每条长 lenlenlen 的长链链头的 0∼len0\\sim len0∼len 级祖先和链上节点的顺序。 查询的时候只需要找到 uuu 的 2⌊log⁡2k⌋2^{\\lfloor\\log_2k\\rfloor}2⌊log2​k⌋ 级祖先 fau,⌊log⁡2k⌋fa_{u,\\lfloor\\log_2k\\rfloor}fau,⌊log2​k⌋​，然后从链头开始跳即可。 3.2 优化树形 dp 某些树形 dp 的第二维只和深度有关系，且转移时的整体变化可以快速维护，则可以使用长链剖分优化。 例如 CF1009F Dominant Indices： 给定一棵以 111 为根，nnn 个节点的树。设 d(u,x)d(u,x)d(u,x) 为 uuu 子树中到 uuu 距离为 xxx 的节点数。 对于每个点，求一个最小的 kkk，使得 d(u,k)d(u,k)d(u,k) 最大。 不难想到一个朴素的 dp：设 fu,if_{u,i}fu,i​ 表示点 uuu 子树内距离 uuu 为 iii 的节点个数。 转移： fu,0=1fu,j=∑v∈sonufv,j−1f_{u,0}=1\\\\ f_{u,j}=\\sum\\limits_{v\\in son_u} f_{v,j-1} fu,0​=1fu,j​=v∈sonu​∑​fv,j−1​ 考虑优化，设点 uuu 距离它所在长链的链头 tputp_utpu​ 为 depudep_udepu​，则考虑用 tputp_utpu​ 向下 depu+jdep_u+jdepu​+j 个位置的点来保存 uuu 的信息。根据性质 2.2，这样的点一定存在。 那么把 fu,jf_{u,j}fu,j​ 挂到 ftpu,depu+jf_{tp_u,dep_{u}+j}ftpu​,depu​+j​ 上，则每个点的转移相当于直接继承它长儿子的信息，并把其它儿子的长链上信息暴力合并。 由于每条长链只会被合并一次且长链的总长为 nnn，所以这样做的时间复杂度为 O(n)O(n)O(n)。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=1000005; int n; vector&lt;int&gt; g[S]; int len[S],mx[S]; int top[S],dep[S]; int mxp[S]; vector&lt;int&gt; f[S]; int ans[S]; void dfs(int u,int fa) { for(int v:g[u]) { if(v==fa) continue; dfs(v,u); len[u]=max(len[u],len[v]); if(len[v]&gt;len[mx[u]]) mx[u]=v; } len[u]++; } void dfs2(int u,int fa,int tp) { top[u]=tp; dep[u]=u==tp?1:dep[fa]+1; if(mx[u]!=0) dfs2(mx[u],u,tp); for(int v:g[u]) { if(v==fa||v==mx[u]) continue; dfs2(v,u,v); } } void dfs3(int u,int fa) { if(mx[u]!=0) dfs3(mx[u],u); int id=top[u]; for(int v:g[u]) { if(v==fa||v==mx[u]) continue; dfs3(v,u); for(int j=1;j&lt;f[v].size();j++) { int idx=dep[u]+j; f[id][idx]+=f[v][j]; if(f[id][idx]&gt;f[id][mxp[id]]) mxp[id]=idx; else if(f[id][idx]==f[id][mxp[id]]&amp;&amp;idx&lt;mxp[id]) mxp[id]=idx; } } int idx=dep[u]; f[id][idx]++; if(f[id][idx]&gt;f[id][mxp[id]]) mxp[id]=idx; else if(f[id][idx]==f[id][mxp[id]]&amp;&amp;idx&lt;mxp[id]) mxp[id]=idx; ans[u]=mxp[id]-dep[u]; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(y),g[y].push_back(x); } dfs(1,0),dfs2(1,0,1); for(int i=1;i&lt;=n;i++) f[i]={0}; for(int i=1;i&lt;=n;i++) f[top[i]].push_back(0); dfs3(1,0); for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } 更多例题 P9655 『GROI-R2』 Beside You ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"长链剖分学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/chang-lian-pou-fen-xue-xi-bi-ji/","stats":{"text":"6 min read","time":322000,"words":1102,"minutes":6},"date":"2023-09-29 16:45:58","dateFormat":"2023-09-29"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向图，求有哪些边满足删掉这一条边后的图是二分图。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le m\\le 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>，要求线性。</p>\n</blockquote>\n","content":" 给定一张 nnn 个点 mmm 条边的无向图，求有哪些边满足删掉这一条边后的图是二分图。 1≤n≤1041\\le n\\le 10^41≤n≤104，0≤m≤1040\\le m\\le 10^40≤m≤104，要求线性。 显然要求的是所有奇环的交。 考虑图的任意一棵生成树，称只包含一条返祖边的环为本源环，那么有个结论就是所有简单环都可以通过若干个本源环异或得到。 证明是显然的，每个简单环都等价于环中非树边对应的本源环异或起来。 接下来开始 Jelly Wen 定理，挖掘一条边可以成为答案的必要条件： 必须要被所有奇本源环覆盖，这个显然； 不能被任何偶本源环覆盖，这是因为删掉这条边后随便找一个奇本源环异或上覆盖它的偶本源环就可以得到一个奇环： 现在来证明这些必要条件的并是充要条件： 所有奇环都是由奇数个奇本源环异或上若干个偶本源环得到的； 被删掉的这条边被所有奇本源环覆盖且不被任何偶本源环覆盖； 所以所有奇环中，被删掉的这条边都被本源环覆盖了奇数次； 所以最后的图不存在奇环； 那么用树上差分维护即可，时间复杂度 O(n)O(n)O(n)。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=10005; int n,m; vector&lt;pair&lt;int,int&gt;&gt; g[S]; bool vis[S]; vector&lt;int&gt; son[S]; int fid[S],dep[S],col[S]; int ctt,tot[S]; void dfs(int u,int fa) { dep[u]=dep[fa]+1; col[u]=col[fa]^1; son[fa].push_back(u); vis[u]=true; int cnt=0; for(auto t:g[u]) { int v=t.first; if(!vis[v]) fid[v]=t.second,dfs(v,u); else if(v==fa) { if(++cnt&gt;=2) ctt++,tot[u]--,tot[fa]++; } else if(dep[v]&lt;dep[u]) { if(col[u]==col[v]) ctt++,tot[u]++,tot[v]--; else tot[u]--,tot[v]++; } } } void dfs2(int u) { vis[u]=true; for(int v:son[u]) { dfs2(v); tot[u]+=tot[v]; } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back({y,i}),g[y].push_back({x,i}); } for(int i=1;i&lt;=n;i++) if(!vis[i]) dfs(i,0); if(ctt==0) { printf(&quot;%d\\n&quot;,m); for(int i=1;i&lt;=m;i++) printf(&quot;%d &quot;,i); printf(&quot;\\n&quot;); return 0; } for(int i=1;i&lt;=n;i++) vis[i]=false; for(int i=1;i&lt;=n;i++) if(!vis[i]) dfs2(i); vector&lt;int&gt; ans; for(int i=1;i&lt;=n;i++) if(tot[i]==ctt&amp;&amp;fid[i]!=0) ans.push_back(fid[i]); if(ctt==1) { for(int u=1;u&lt;=n;u++) { for(auto t:g[u]) { int v=t.first; if(v&lt;u&amp;&amp;col[u]==col[v]) ans.push_back(t.second); } } } sort(ans.begin(),ans.end()); printf(&quot;%d\\n&quot;,ans.size()); for(int u:ans) printf(&quot;%d &quot;,u); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF19E Fairy 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf19e-fairy-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":211000,"words":727,"minutes":4},"date":"2023-09-26 19:26:51","dateFormat":"2023-09-26"},{"abstract":"<blockquote>\n<p>给定两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 以及 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 组限制 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><msub><mn>1</mn><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>r</mi><msub><mn>1</mn><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>l</mi><msub><mn>2</mn><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>r</mi><msub><mn>2</mn><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">l1_i,r1_i,l2_i,r2_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，求是否存在一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">\\forall 1\\le i\\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 都有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mi>l</mi><msub><mn>1</mn><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>r</mi><msub><mn>1</mn><mi>i</mi></msub><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[l1_i,r1_i]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> 的字典序严格小于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mi>l</mi><msub><mn>2</mn><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>r</mi><msub><mn>2</mn><mi>i</mi></msub><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[l2_i,r2_i]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定两个正整数 n,mn,mn,m 以及 mmm 组限制 l1i,r1i,l2i,r2il1_i,r1_i,l2_i,r2_il1i​,r1i​,l2i​,r2i​，求是否存在一个长 nnn 的序列 aaa 满足 ∀1≤i≤m\\forall 1\\le i\\le m∀1≤i≤m 都有 a[l1i,r1i]a_{[l1_i,r1_i]}a[l1i​,r1i​]​ 的字典序严格小于 a[l2i,r2i]a_{[l2_i,r2_i]}a[l2i​,r2i​]​。 1≤n,m≤2×1031\\le n,m\\le 2\\times 10^31≤n,m≤2×103。 比较巧妙的建模题。 对于每个限制，先考虑其第一个字符的大小关系，显然有 al1i≤al2ia_{l1_i}\\le a_{l2_i}al1i​​≤al2i​​。考虑建出一个 nnn 个点的图 GGG，对于第 iii 个限制，从 l1il1_il1i​ 向 l2il2_il2i​ 连一条有向边表示它们的大小关系。 那么不难发现 GGG 中同一个强连通分量中的点对应位置上的字符是相同的。那么不妨把 GGG 缩点。缩点后对于第 iii 个限制，设 a[l1i,r1i]a_{[l1_i,r1_i]}a[l1i​,r1i​]​ 和 a[l2i,r2i]a_{[l2_i,r2_i]}a[l2i​,r2i​]​ 长 stist_isti​ 前缀已知相同，那么让 l1il1_il1i​ 和 l2il2_il2i​ 均加上 stist_isti​，即可转化为子问题。 无解当且仅当某一时刻某条限制 iii 满足 l1i+sti≤r1il1_i+st_i\\le r1_il1i​+sti​≤r1i​ 且 l2i+sti&gt;r2il2_i+st_i&gt; r2_il2i​+sti​&gt;r2i​，有解则当且仅当这个过程可以不断进行下去，不难发现只有前 nnn 次缩点是有效的。 时间复杂度 O(n2)O(n^2)O(n2)。 代码如下： // Problem: [ARC165D] Substring Comparison // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_arc165_d // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=2005; struct node { int l1,r1,l2,r2; }a[S]; int n,m; int fa[S]; vector&lt;int&gt; g[S]; int cnt,dfn[S],low[S]; int top,sta[S]; bool vis[S],inst[S]; int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } void dfs(int u) { low[u]=dfn[u]=++cnt; vis[u]=true; sta[++top]=u; inst[u]=true; for(int v:g[u]) { if(!vis[v]) dfs(v),low[u]=min(low[u],low[v]); else if(inst[v]) low[u]=min(low[u],dfn[v]); } if(low[u]==dfn[u]) { while(1) { int v=sta[top--]; fa[fnd(v)]=fnd(u); inst[v]=false; if(v==u) break; } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;a[i].l1,&amp;a[i].r1,&amp;a[i].l2,&amp;a[i].r2); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) g[a[i].l1].push_back(a[i].l2); for(int T=1;T&lt;=n;T++) { cnt=0; for(int i=1;i&lt;=n;i++) vis[i]=inst[i]=false; top=0; for(int i=1;i&lt;=n;i++) if(!vis[i]) dfs(i); for(int i=1;i&lt;=n;i++) g[i].clear(); for(int i=1;i&lt;=m;i++) { int &amp;l1=a[i].l1,&amp;l2=a[i].l2; int r1=a[i].r1,r2=a[i].r2; while(l1&lt;=r1&amp;&amp;l2&lt;=r2&amp;&amp;fnd(l1)==fnd(l2)) l1++,l2++; if(l2&gt;r2) return puts(&quot;No&quot;),0; if(l1&gt;r1) continue; g[fnd(l1)].push_back(fnd(l2)); } } puts(&quot;Yes&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"ARC165D Substring Comparison 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc165d-substring-comparison-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":227000,"words":714,"minutes":4},"date":"2023-09-21 08:27:32","dateFormat":"2023-09-21"},{"abstract":"<blockquote>\n<p>给定长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，每次操作可以选定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，并 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">swap</mi><mo>⁡</mo><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><msub><mi>a</mi><mi>i</mi></msub></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{swap}(a_i,a_{a_i})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0001em;vertical-align:-0.2501em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">s</span><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">w</span><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">p</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。求能通过进行任意次这种操作得到的不同序列数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">n\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定长度为 nnn 的序列 aaa，每次操作可以选定一个 iii，并 swap⁡(ai,aai)\\operatorname{swap}(a_i,a_{a_i})swap(ai​,aai​​)。求能通过进行任意次这种操作得到的不同序列数。 n≤106n\\le 10^6n≤106。 不妨称能经过若干次操作得到的序列为合法序列。 看到这个操作形式可以想到建立一个 nnn 个点的图 GGG 且从 iii 向 aia_iai​ 连一条有向边。那么 GGG 一定是一棵内向基环树。 那么发现一次操作相当于： 那么对于一个固定的 iii，操作若干次相当于： 设 iii 最后指向的点为 pip_ipi​，显然 pip_ipi​ 一定是 iii 的某个祖先。则不难发现 GGG 中每个点会且仅会被一条 [i,pi)[i,p_i)[i,pi​) 的链（i→pii\\to p_ii→pi​ 的去掉 pip_ipi​ 的路径）包含，那么每一个 GGG 的链剖分方案都能对应一个合法序列（不一定是一一对应，一个合法序列有可能对应多个链剖分方案）： 设 sonu=∑i=1n[ai=u]son_u=\\sum\\limits_{i=1}^n [a_i=u]sonu​=i=1∑n​[ai​=u] 即 uuu 的儿子个数，那么显然 GGG 的链剖分方案个数就是 ∏i=1nsoni+1\\prod\\limits_{i=1}^n son_i+1i=1∏n​soni​+1 即每个点可以选一个儿子的链接上或者不接。 对于树的情况，容易发现链剖分方案和合法序列一一对应。但是由于是基环树，所以会出现这种情况： 也就是绕了一圈回来了。 不难证明只有这种情况不合法，那么减掉这种链剖分的个数 ∑i=1n[i∈cir]soni×∏i=1n[i∉cir](soni+1)\\sum\\limits_{i=1}^n [i\\in cir]son_{i}\\times \\prod\\limits_{i=1}^n[i\\notin cir](son_i+1)i=1∑n​[i∈cir]soni​×i=1∏n​[i∈/​cir](soni​+1) 即可（在环上的每个点都可以选择某个儿子的链接上再绕一圈，不在环上的点不影响）。 时间复杂度 O(n)O(n)O(n)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int S=1000005,p=1000000007; int fra[S]; int n,a[S]; vector&lt;int&gt; g[S]; int ind[S]; int son[S],fa[S]; int siz[S],res[S],ans[S]; int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } int main() { fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) g[i].push_back(a[i]),ind[a[i]]++; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) if(ind[i]==0) q.push(i); while(!q.empty()) { int u=q.front(); q.pop(); for(int v:g[u]) if(--ind[v]==0) q.push(v); } for(int i=1;i&lt;=n;i++) son[a[i]]++,fa[i]=i; for(int i=1;i&lt;=n;i++) fa[i]=fnd(a[i]); for(int i=1;i&lt;=n;i++) siz[i]=0,res[i]=ans[i]=1; for(int i=1;i&lt;=n;i++) { int ri=fnd(i); if(ind[i]==0) res[ri]=1ll*res[ri]*(son[i]+1)%p; else siz[ri]+=son[i],ans[ri]=1ll*ans[ri]*(son[i]+1)%p; } int val=1; for(int i=1;i&lt;=n;i++) { if(fa[i]!=i) continue; val=1ll*val*((ans[i]-siz[i])%p+p)%p*res[i]%p; } printf(&quot;%d\\n&quot;,val); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1863G Swaps 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1863g-swaps-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":232000,"words":797,"minutes":4},"date":"2023-09-20 17:11:12","dateFormat":"2023-09-20"},{"abstract":"<blockquote>\n<p>给定两个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，每次操作可以选择一个满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i&lt;n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 并把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 改为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\max(a_i,a_{i+1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，求任意次操作后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>[</mo><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{i=1}^n[a_i=b_i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.329066em;vertical-align:-0.9776689999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3513970000000004em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9776689999999999em;\"><span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> 的最大值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i,b_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定两个长 nnn 的序列 aaa 和 bbb，每次操作可以选择一个满足 1≤i&lt;n1\\le i&lt;n1≤i&lt;n 的 iii 并把 aia_iai​ 和 ai+1a_{i+1}ai+1​ 改为 max⁡(ai,ai+1)\\max(a_i,a_{i+1})max(ai​,ai+1​)，求任意次操作后 ∑i=1n[ai=bi]\\sum\\limits_{i=1}^n[a_i=b_i]i=1∑n​[ai​=bi​] 的最大值。 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤ai,bi≤1091\\le a_i,b_i\\le 10^91≤ai​,bi​≤109。 设操作完后的 aaa 序列为 a′a&#x27;a′。 显然操作相当于每个 aia_iai​ 不断往外拓展，设 aia_iai​ 拓展成了 a[li,ri]′a&#x27;_{[l_i,r_i]}a[li​,ri​]′​（没有任何 aj’a_j’aj​’ 由 aia_iai​ 拓展来则把 aia_iai​ 删掉），那么有个结论： 一组 [li,ri][l_i,r_i][li​,ri​] 合法当且仅当 ∀i&lt;j\\forall i&lt;j∀i&lt;j 都有 ri&lt;ljr_i&lt;l_jri​&lt;lj​，即区间不交且相对顺序和 iii 的相对顺序相同。 那么不妨设 ai′a&#x27;_iai′​ 是由 pip_ipi​ 拓展而来的，不难发现 pip_ipi​ 单调递增。 发现钦定 ai′=bia&#x27;_i=b_iai′​=bi​ 的所有 iii 都满足 pip_ipi​ 为 max⁡j≤i,aj=bi{j}\\max\\limits_{j\\le i,a_j=b_i}\\{j\\}j≤i,aj​=bi​max​{j} 或 min⁡j≥i,aj=bi{j}\\min\\limits_{j\\ge i,a_j=b_i}\\{j\\}j≥i,aj​=bi​min​{j} 并不影响答案，那么不妨设这两个位置分别为 lbilb_ilbi​ 和 rbirb_irbi​（不存在则为 −1-1−1）。 又发现 pip_ipi​ 可以为 lbilb_ilbi​ 当且仅当 lbi=−1lb_{i}\\not=-1lbi​​=−1 且 a[lbi,i]a_{[lb_i,i]}a[lbi​,i]​ 中的最大值 ≤bi\\le b_i≤bi​，可以为 rbirb_irbi​ 同理。那么不妨把所有不合法的 lblblb 和 rbrbrb 都赋值为 −1-1−1。 那么不难发现 iii 对答案有贡献当且仅当： lbi=−1lb_i\\not= -1lbi​​=−1 且 pi−1≤lbip_{i-1}\\le lb_ipi−1​≤lbi​； rbi=−1rb_i\\not=-1rbi​​=−1 且 pi−1≤rbip_{i-1}\\le rb_ipi−1​≤rbi​； 因为 lbi=−1lb_i\\not=-1lbi​​=−1 和 rbi=−1rb_i\\not=-1rbi​​=−1 已经解决掉所有值域上的限制，只剩下 [li,ri][l_i,r_i][li​,ri​] 相对顺序的限制。 那么考虑一个朴素的 dp：设 fi,jf_{i,j}fi,j​ 表示处理完 a[1,i]′a&#x27;_{[1,i]}a[1,i]′​ 且 ai′=aja&#x27;_i=a_jai′​=aj​ 时 ∑k=1i[ak′=bk]\\sum\\limits_{k=1}^i[a&#x27;_k=b_k]k=1∑i​[ak′​=bk​] 的最大值。显然有转移： fi,j=fi−1,j若 lbi=−1,fi,lbi=max⁡j≤lbi{fi−1,j}+1若 rbi=−1,fi,rbi=max⁡j≤rbi{fi−1,j}+1f_{i,j}=f_{i-1,j}\\\\ \\text{若 }lb_i\\not=-1,f_{i,lb_i}=\\max\\limits_{j\\le lb_i}\\{f_{i-1,j}\\}+1\\\\ \\text{若 }rb_i\\not=-1,f_{i,rb_i}=\\max\\limits_{j\\le rb_i}\\{f_{i-1,j}\\}+1 fi,j​=fi−1,j​若 lbi​​=−1,fi,lbi​​=j≤lbi​max​{fi−1,j​}+1若 rbi​​=−1,fi,rbi​​=j≤rbi​max​{fi−1,j​}+1 发现可以用树状数组维护前缀 max 解决，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; int n,a[S],b[S]; int m,tb[S*2]; int top,sta[S],pre[S],nxt[S]; int pos[S*2],lb[S],rb[S]; int c[S]; inline void add(int p,int val) { for(int i=p;i&lt;=n;i+=i&amp;-i) c[i]=max(c[i],val); } inline int que(int p) { int res=0; for(int i=p;i&gt;=1;i-=i&amp;-i) res=max(res,c[i]); return res; } int main() { freopen(&quot;copy.in&quot;,&quot;r&quot;,stdin); freopen(&quot;copy.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) tb[++m]=a[i],tb[++m]=b[i]; sort(tb+1,tb+m+1); m=unique(tb+1,tb+m+1)-tb-1; for(int i=1;i&lt;=n;i++) { a[i]=lower_bound(tb+1,tb+m+1,a[i])-tb; b[i]=lower_bound(tb+1,tb+m+1,b[i])-tb; } sta[top=0]=0; for(int i=1;i&lt;=n;i++) { while(top&gt;0&amp;&amp;a[sta[top]]&lt;a[i]) top--; pre[i]=sta[top]; sta[++top]=i; } sta[top=0]=n+1; for(int i=n;i&gt;=1;i--) { while(top&gt;0&amp;&amp;a[sta[top]]&lt;a[i]) top--; nxt[i]=sta[top]; sta[++top]=i; } for(int i=1;i&lt;=m;i++) pos[i]=-1; for(int i=1;i&lt;=n;i++) { pos[a[i]]=i; lb[i]=pos[b[i]]; if(lb[i]!=-1&amp;&amp;nxt[lb[i]]&lt;=i) lb[i]=-1; } for(int i=1;i&lt;=m;i++) pos[i]=-1; for(int i=n;i&gt;=1;i--) { pos[a[i]]=i; rb[i]=pos[b[i]]; if(rb[i]!=-1&amp;&amp;pre[rb[i]]&gt;=i) rb[i]=-1; } // for(int i=1;i&lt;=n;i++) printf(&quot;%d %d\\n&quot;,lb[i],rb[i]); for(int i=1;i&lt;=n;i++) { if(rb[i]!=-1) add(rb[i],que(rb[i])+1); if(lb[i]!=-1&amp;&amp;lb[i]!=rb[i]) add(lb[i],que(lb[i])+1); } printf(&quot;%d\\n&quot;,que(n)); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOIP模拟赛22】摘抄文档 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noip-mo-ni-sai-22-zhai-chao-wen-dang-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":371000,"words":1133,"minutes":7},"date":"2023-09-19 19:50:21","dateFormat":"2023-09-19"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人来过，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个人在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 时刻来在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 时刻走，每个人可以在来时或走时登记，问可能的登记顺序有多少种。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">n\\leqslant 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7733399999999999em;vertical-align:-0.13667em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⩽</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i,b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 互不相同，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\forall i&lt;n,a_i&lt;a_{i+1},b_{i}&lt;b_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个人来过，第 iii 个人在 aia_iai​ 时刻来在 bib_ibi​ 时刻走，每个人可以在来时或走时登记，问可能的登记顺序有多少种。 n⩽5×105n\\leqslant 5\\times 10^5n⩽5×105，ai,bia_i,b_iai​,bi​ 互不相同，∀i&lt;n,ai&lt;ai+1,bi&lt;bi+1\\forall i&lt;n,a_i&lt;a_{i+1},b_{i}&lt;b_{i+1}∀i&lt;n,ai​&lt;ai+1​,bi​&lt;bi+1​。 容斥。 观察到一个 iii 选 aia_iai​ 和选 bib_ibi​ 本质不同当且仅当 [ai,bi][a_i,b_i][ai​,bi​] 中有其他人选。 那么容斥一下，钦定 yyy 个不同的 iii 满足 [ai,bi][a_i,b_i][ai​,bi​] 中没有其他人选，则对答案的贡献为 2x(−1)y2^{x}(-1)^y2x(−1)y，其中 xxx 为与这 yyy 个区间没有交的区间个数。 那么设 fif_{i}fi​ 表示算完了前 iii 个人，钦定了 [ai,bi][a_i,b_i][ai​,bi​] 中没有其他人选的总贡献和。 转移直接枚举上一个钦定的人即可。 可以用前缀和优化，时间复杂度 O(n)O(n)O(n)。 代码如下：（O(nlog⁡n)O(n\\log n)O(nlogn) 树状数组） // Problem: [AGC061C] First Come First Serve // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_agc061_c // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=500005,p=998244353,inv2=499122177; struct node { int l,r; }a[S]; int n; int iv2[S],pw2[S]; int lst[S],nxt[S]; int f[S],sum[S*2]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline void addt(int p,int y) { if(p==0) return add(sum[p],y); for(int i=p;i&lt;=2*n;i+=i&amp;-i) add(sum[i],y); } inline int quet(int p) { int res=sum[0]; for(int i=p;i&gt;=1;i-=i&amp;-i) add(res,sum[i]); return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r); iv2[0]=pw2[0]=1; for(int i=1;i&lt;=S-3;i++) iv2[i]=1ll*iv2[i-1]*inv2%p; for(int i=1;i&lt;=S-3;i++) pw2[i]=1ll*pw2[i-1]*2%p; for(int i=1;i&lt;=n;i++) { lst[i]=i==1?1:lst[i-1]; while(a[lst[i]].r&lt;a[i].l) lst[i]++; } for(int i=n;i&gt;=1;i--) { nxt[i]=i==n?n:nxt[i+1]; while(a[nxt[i]].l&gt;a[i].r) nxt[i]--; } f[0]=1; addt(0,1ll*f[0]*iv2[0]%p); for(int i=1;i&lt;=n;i++) { int pre=p-1ll*pw2[lst[i]-1]*quet(a[i].l-1)%p; addt(a[nxt[i]].r,1ll*pre*iv2[nxt[i]]%p); } printf(&quot;%d\\n&quot;,1ll*pw2[n]*quet(2*n)%p); return 0; } ","tags":[{"name":"容斥","slug":"1Ur0PWueZ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/1Ur0PWueZ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"AGC061C First Come First Serve 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/agc061c-first-come-first-serve-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":198000,"words":611,"minutes":4},"date":"2023-09-12 21:17:42","dateFormat":"2023-09-12"},{"abstract":"<blockquote>\n<p>给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 01 串，求最多可以选出多少互不相交的子串，满足这些子串按照原串中的顺序，字典序严格升序。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2.5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2.5\\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长度为 nnn 的 01 串，求最多可以选出多少互不相交的子串，满足这些子串按照原串中的顺序，字典序严格升序。 1≤n≤2.5×1041\\le n\\le 2.5\\times 10^41≤n≤2.5×104。 不要再自然根号了。 设最终选出的子串为 s1,s2,…,sks_1,s_2,\\dots,s_ks1​,s2​,…,sk​，则 ∀1≤i&lt;k\\forall 1\\le i&lt;k∀1≤i&lt;k，必定有 ∣si+1∣≤∣si∣+1|s_{i+1}|\\le |s_i|+1∣si+1​∣≤∣si​∣+1。 并且必定有 ∣s1∣=1|s_1|=1∣s1​∣=1。 那么不难得出， ∑i=1max⁡{∣si∣}i≤n\\sum\\limits_{i=1}^{\\max\\{|s_i|\\}}i\\le ni=1∑max{∣si​∣}​i≤n，因为对于所有 iii 都必定存在 jjj 满足 ∣sj∣=∣si∣−1|s_j|=|s_i|-1∣sj​∣=∣si​∣−1。 所以 max⁡{∣si∣}≤2n\\max\\{|s_i|\\}\\le \\sqrt{2n}max{∣si​∣}≤2n​。 那么设 fif_ifi​ 表示 s[1,i]s_{[1,i]}s[1,i]​ 的答案，把所有长度 ≤2n\\le \\sqrt{2n}≤2n​ 的子串都拉出来放到 trie 上，用树状数组维护 fif_ifi​ 的转移即可。 答案即为 max⁡{fi}\\max\\{f_i\\}max{fi​}，时间复杂度 O(nnlog⁡n)O(n\\sqrt n\\log n)O(nn​logn)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=25005,M=250,MS=10000005; int n; char a[S]; int cnt,son[MS][2]; vector&lt;pair&lt;int,int&gt;&gt; idx[MS]; int c[S],f[S]; inline void addt(int u,int val) { for(int i=u;i&lt;=n;i+=i&amp;-i) c[i]=max(c[i],val); } inline int quet(int u) { int res=0; for(int i=u;i&gt;=1;i-=i&amp;-i) res=max(res,c[i]); return res; } void dfs(int u) { for(auto u:idx[u]) { int l=u.first,r=u.second; f[r]=max(f[r],quet(l-1)+1); addt(r,f[r]); } if(son[u][0]!=0) dfs(son[u][0]); if(son[u][1]!=0) dfs(son[u][1]); } int main() { scanf(&quot;%d%s&quot;,&amp;n,a+1); for(int i=n;i&gt;=1;i--) { int u=0; for(int j=i;j&lt;=n&amp;&amp;j&lt;=i+M-1;j++) { int id=a[j]-'0'; if(son[u][id]==0) son[u][id]=++cnt; u=son[u][id]; idx[u].push_back({i,j}); } } dfs(0); int ans=0; for(int i=1;i&lt;=n;i++) ans=max(ans,f[i]); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ABC240Ex Sequence of Substrings 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc240ex-sequence-of-substrings-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":166000,"words":509,"minutes":3},"date":"2023-09-11 11:47:27","dateFormat":"2023-09-11"},{"abstract":"<blockquote>\n<p>给定一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的<strong>无标号</strong>基环树和颜色数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，给每个节点染上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 种颜色中的一种，求有多少种本质不同的染色方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">3\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一棵 nnn 个节点的无标号基环树和颜色数 mmm，给每个节点染上 mmm 种颜色中的一种，求有多少种本质不同的染色方案。 3≤n≤1053\\le n\\le 10^53≤n≤105，1≤m≤1091\\le m\\le 10^91≤m≤109。 首先有根树的方案数是好算的，把儿子按同构情况分类（判断同构使用树哈希），同一类用插板法处理即可。因为： (nm)≡∏i=n mod p−m+1n mod pim!(modp)\\dbinom{n}{m}\\equiv \\dfrac{\\prod\\limits_{i=n\\text{ mod }p-m+1}^{n\\text{ mod }p} i}{m!}\\pmod{p} (mn​)≡m!i=n mod p−m+1∏n mod p​i​(modp) 且组合数的 ∑m=O(n)\\sum m=O(n)∑m=O(n)，所以有根树的方案数可以在 O(n)O(n)O(n) 的时间复杂度内算出。 对于基环树，找出环后求出环上每一个点的子树的答案和哈希值，然后套 Burnside 引理即可。 具体考虑枚举循环移位的次数，用序列哈希判断循环移位后是否同构。设移位了 iii 次，则会形成 gcd⁡(∣cir∣,i)\\gcd(|cir|,i)gcd(∣cir∣,i) 个置换环（circircir 为环上节点按顺序形成的序列）。设置换环集合为 SSS，则由于同一个置换环中的所有元素必定同构，所以只需要算 ∏x∈Sfx1\\prod\\limits_{x\\in S}f_{x_1}x∈S∏​fx1​​ 即可，其中 fuf_ufu​ 表示 uuu 子树的答案。 而注意到 cir1∼gcd⁡(∣cir∣,i)cir_{1\\sim \\gcd(|cir|,i)}cir1∼gcd(∣cir∣,i)​ 一定在不同的置换环中，所以 Burnside 引理中的 ∣Xg∣|X^g|∣Xg∣ 即为 ∏j=1gcd⁡(∣cir∣,i)fcirj\\prod\\limits_{j=1}^{\\gcd(|cir|,i)}f_{cir_j}j=1∏gcd(∣cir∣,i)​fcirj​​。 时间复杂度 O(n)O(n)O(n)，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; typedef unsigned long long ull; const int S=300005,p=1000000007; const ull bse=114513,mask=1145143191981ull; int inv[S]; int n,m; vector&lt;int&gt; g[S],son[S]; bool vis[S],ins[S]; int top,sta[S]; vector&lt;int&gt; cir; ull h[S]; int res[S]; ull mul[S],sum[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { int res=1; for(int i=n;i&gt;=n-m+1;i--) res=1ll*res*((i%p+p)%p)%p; for(int i=1;i&lt;=m;i++) res=1ll*res*inv[i]%p; return res; } void dfs(int u) { vis[u]=true; sta[++top]=u; ins[u]=true; for(int v:g[u]) { if(vis[v]) { if(ins[v]) { while(1) { cir.push_back(sta[top--]); if(sta[top+1]==v) break; } } } else dfs(v); if(!cir.empty()) return; } top--; ins[u]=false; } inline ull shift(ull x) { x^=mask; x^=x&lt;&lt;13; x^=x&gt;&gt;7; x^=x&lt;&lt;17; x^=mask; return x; } void calc(int u) { for(int v:son[u]) calc(v); sort(son[u].begin(),son[u].end(),[&amp;](int x,int y){return h[x]&lt;h[y];}); h[u]=1145141; for(int v:son[u]) h[u]+=shift(h[v]); res[u]=m; for(int i=0,cnt=0;i&lt;son[u].size();i++) { cnt++; if(i==son[u].size()-1||h[son[u][i]]!=h[son[u][i+1]]) { res[u]=1ll*res[u]*C(res[son[u][i]]+cnt-1,cnt)%p; cnt=0; } } } inline int gcd(int x,int y) { if(x==0||y==0) return x+y; int t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } int main() { freopen(&quot;color.in&quot;,&quot;r&quot;,stdin); freopen(&quot;color.out&quot;,&quot;w&quot;,stdout); mul[0]=1; for(int i=1;i&lt;=S-3;i++) inv[i]=qpow(i,p-2),mul[i]=mul[i-1]*bse; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); g[x].push_back(i); } for(int i=1;i&lt;=n;i++) { if(!vis[i]) { while(top&gt;0) ins[sta[top--]]=false; dfs(i); if(cir.size()&gt;0) break; } } int len=cir.size(); for(int i=0;i&lt;len/2;i++) swap(cir[i],cir[len-i-1]); for(int i=1;i&lt;=n;i++) vis[i]=false; for(int i=0;i&lt;len;i++) vis[cir[i]]=true; for(int i=1;i&lt;=n;i++) { if(vis[i]) continue; for(int v:g[i]) son[i].push_back(v); } for(int i=0;i&lt;len;i++) { int u=cir[i],r=cir[(i+1)%len]; for(int v:g[u]) if(v!=r) son[u].push_back(v); calc(u); } sum[0]=h[cir[0]]; for(int i=1;i&lt;len;i++) sum[i]=sum[i-1]*bse+h[cir[i]]; int ans=0,cnt=0; for(int i=0;i&lt;len;i++) { ull pre=sum[len-1]; if(i&gt;0) pre=(sum[len-1]-sum[i-1]*mul[len-i])*mul[i]+sum[i-1]; if(pre==sum[len-1]) { cnt++; int now=1,g=gcd(len,i); for(int j=0;j&lt;g;j++) now=1ll*now*res[cir[j]]%p; ans=(ans+now)%p; } } ans=1ll*ans*qpow(cnt,p-2)%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛27】美术作业 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-27-mei-zhu-zuo-ye-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":357000,"words":1084,"minutes":6},"date":"2023-09-07 20:52:40","dateFormat":"2023-09-07"},{"abstract":"<blockquote>\n<p>给定长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><msub><mi>a</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">a_1=a_n=\\max\\{a_i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>。</p>\n<p>构建一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的无向图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 如下：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\forall 1\\le i&lt;j\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，若存在某个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo>≥</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">a_i,a_j\\ge k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.922078em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo>&lt;</mo><mi>p</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">\\forall i&lt;p&lt;j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 都有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>p</mi></msub><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">a_p&lt;k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8252079999999999em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中存在边 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>；</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问，每次询问点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">y_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 之间的<strong>最短路长度减一</strong>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,q\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定长 nnn 的序列 aia_iai​，满足 a1=an=max⁡{ai}a_1=a_n=\\max\\{a_i\\}a1​=an​=max{ai​}。 构建一个 nnn 个点的无向图 GGG 如下： ∀1≤i&lt;j≤n\\forall 1\\le i&lt;j\\le n∀1≤i&lt;j≤n，若存在某个正整数 kkk 满足 ai,aj≥ka_i,a_j\\ge kai​,aj​≥k 且 ∀i&lt;p&lt;j\\forall i&lt;p&lt;j∀i&lt;p&lt;j 都有 ap&lt;ka_p&lt;kap​&lt;k，则 GGG 中存在边 (i,j)(i,j)(i,j)； qqq 次询问，每次询问点 xix_ixi​ 和 yiy_iyi​ 之间的最短路长度减一。 1≤n,q≤1051\\le n,q\\le 10^51≤n,q≤105，1≤ai≤n1\\le a_i\\le n1≤ai​≤n。 不妨称满足 ai,aj≥ka_i,a_j\\ge kai​,aj​≥k 且 ∀i&lt;p&lt;j\\forall i&lt;p&lt;j∀i&lt;p&lt;j 都有 ap&lt;ka_p&lt;kap​&lt;k 的边 (i,j)(i,j)(i,j) 为 k−边k-\\text{边}k−边。 不难发现若把边 (x,y)(x,y)(x,y) 看作区间 [x,y−1][x,y-1][x,y−1]，则： 任意两个区间要么包含要么相离； 对于同一个 kkk，所有 k−边k-\\text{边}k−边 对应的区间的并为 [1,n−1][1,n-1][1,n−1]（整个序列）； 对于某条 k−边k-边k−边 (l,r)(l,r)(l,r)，∀k′&lt;k\\forall k&#x27;&lt; k∀k′&lt;k，所有满足 l≤x≤y≤rl\\le x\\le y\\le rl≤x≤y≤r 的 k′−边k&#x27;-边k′−边 (x,y)(x,y)(x,y) 对应的区间的并为 [l,r−1][l,r-1][l,r−1]； 那么这些边形成了类似树的结构：把每一条边看作一个点，则对于每一条 k−边k-\\text{边}k−边 (x,y)(x,y)(x,y)，所有端点在 [x,y][x,y][x,y] 内的 (k−1)−边(k-1)-\\text{边}(k−1)−边 都是它的儿子。 那么最短路的形态肯定是不断往父亲走，走到 lca\\text{lca}lca 后再往儿子走。 也就是说，设路径序列为 ppp，则： 存在一个分界点 lll，满足 ∀i&lt;l\\forall i&lt; l∀i&lt;l，api≤api+1a_{p_i}\\le a_{p_{i+1}}api​​≤api+1​​ 且 ∀i&gt;l\\forall i&gt;l∀i&gt;l，api−1≥apia_{p_{i-1}}\\ge a_{p_i}api−1​​≥api​​，即路径上的 aia_iai​ 先增再减； ∀pi&lt;j&lt;pi+1\\forall p_i&lt;j&lt;p_{i+1}∀pi​&lt;j&lt;pi+1​，都有 aj≤min⁡(api,api+1)a_j\\le \\min(a_{p_i},a_{p_{i+1}})aj​≤min(api​​,api+1​​)，否则把 jjj 加入 ppp 肯定不劣； 那么考虑倍增，不妨设 lbi,jlb_{i,j}lbi,j​ 和 rbi,jrb_{i,j}rbi,j​ 分别表示 ppp 长度为 2j2^j2j 且 p1=ip_1=ip1​=i 时 pjp_jpj​ 可能的最小值和最大值，显然 ∀lbi,j&lt;k&lt;rbi,j\\forall lb_{i,j}&lt;k&lt;rb_{i,j}∀lbi,j​&lt;k&lt;rbi,j​ 都有 ak&lt;min⁡(albi,j,arbi,j)a_k&lt;\\min(a_{lb_{i,j}},a_{rb_{i,j}})ak​&lt;min(albi,j​​,arbi,j​​)。 那么根据之前的结论，有： lbi,j=min⁡(lblbi,j−1,j−1,lbrbi,j−1,j−1)rbi,j=max⁡(rblbi,j−1,j−1,rbrbi,j−1,j−1)lb_{i,j}=\\min(lb_{lb_{i,j-1},j-1},lb_{rb_{i,j-1},j-1})\\\\ rb_{i,j}=\\max(rb_{lb_{i,j-1},j-1},rb_{rb_{i,j-1},j-1})\\\\ lbi,j​=min(lblbi,j−1​,j−1​,lbrbi,j−1​,j−1​)rbi,j​=max(rblbi,j−1​,j−1​,rbrbi,j−1​,j−1​) 而 lbi,0lb_{i,0}lbi,0​ 和 rbi,0rb_{i,0}rbi,0​ 分别为 iii 左边和右边第一个 aj&gt;aia_j&gt;a_iaj​&gt;ai​ 的 jjj。 不妨令询问的 xi≤yix_i\\le y_ixi​≤yi​，则每次询问： 从 xix_ixi​ 开始在 rb&lt;yirb&lt;y_irb&lt;yi​ 的情况下不断跳 rbrbrb，设最后跳到了 rrr； 从 yiy_iyi​ 开始在 lb&gt;rlb&gt;rlb&gt;r 的情况下不断跳 lblblb； 时间复杂度 O((n+q)log⁡n)O((n+q)\\log n)O((n+q)logn)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005,BS=25; int n,k,q,a[S]; int top,sta[S]; int lb[S][BS],rb[S][BS]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;q); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); top=0; for(int i=1;i&lt;=n;i++) { while(top&gt;0&amp;&amp;a[sta[top]]&lt;a[i]) top--; lb[i][0]=top==0?i:sta[top]; sta[++top]=i; } top=0; for(int i=n;i&gt;=1;i--) { while(top&gt;0&amp;&amp;a[sta[top]]&lt;a[i]) top--; rb[i][0]=top==0?i:sta[top]; sta[++top]=i; } for(int j=1;j&lt;=BS-3;j++) { for(int i=1;i&lt;=n;i++) { int l=lb[i][j-1],r=rb[i][j-1]; lb[i][j]=min(lb[l][j-1],lb[r][j-1]); rb[i][j]=max(rb[l][j-1],rb[r][j-1]); } } while(q--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x&gt;y) swap(x,y); int ans=0; int l=x,r=x; for(int i=BS-3;i&gt;=0;i--) { if(max(rb[l][i],rb[r][i])&lt;y) { ans+=1&lt;&lt;i; int tl=l,tr=r; l=min(lb[tl][i],lb[tr][i]); r=max(rb[tl][i],rb[tr][i]); } } int u=r; l=y,r=y; for(int i=BS-3;i&gt;=0;i--) { if(min(lb[l][i],lb[r][i])&gt;u) { ans+=1&lt;&lt;i; int tl=l,tr=r; l=min(lb[tl][i],lb[tr][i]); r=max(rb[tl][i],rb[tr][i]); } } printf(&quot;%d\\n&quot;,ans); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"}],"title":"JOISC2017F 鉄道旅行 (Railway Trip) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/joisc2017f-tie-dao-lu-xing-railway-trip-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":397000,"words":1230,"minutes":7},"date":"2023-09-06 14:58:35","dateFormat":"2023-09-06"},{"abstract":"<blockquote>\n<p>有一个正 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 边形，你要在上面走路。经过顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 和顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>（顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>）之间的边的代价是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>这个正 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 边形上有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n-3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 条对角线，这些对角线把这个多边形剖成了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">−</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n−2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord\">−</span><span class=\"mord\">2</span></span></span></span> 个三角形，经过每条对角线的代价都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问，每次问从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 走到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">y_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的代价。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5.2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5.2\\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mord\">.</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le q\\le 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个正 nnn 边形，你要在上面走路。经过顶点 iii 和顶点 i+1i+1i+1（顶点 n+1n+1n+1 为顶点 111）之间的边的代价是 111。 这个正 nnn 边形上有 n−3n-3n−3 条对角线，这些对角线把这个多边形剖成了 n−2n−2n−2 个三角形，经过每条对角线的代价都是 111。 有 qqq 次询问，每次问从顶点 xix_ixi​ 走到顶点 yiy_iyi​ 的代价。 1≤n≤5.2×1041\\le n\\le 5.2\\times 10^41≤n≤5.2×104，1≤q≤2n1\\le q\\le 2n1≤q≤2n。 首先有一个结论，由于是三角剖分，所以一定存在某一条对角线满足它两边的顶点数都至少有 n3\\frac{n}{3}3n​ 个。 证明如图： 那么分治，每次找到两边顶点数最接近的一条对角线，以它的两个端点 x,yx,yx,y 出发跑最短路，用 xi→x→yix_i\\to x\\to y_ixi​→x→yi​、xi→y→yix_i\\to y\\to y_ixi​→y→yi​ 的最短路更新第 iii 次询问的答案。然后删掉这条边，两边内部分治下去。 由于有那个结论，所以分治层数是 O(log⁡23n)O\\left(\\log_{\\frac{2}{3}}n\\right)O(log32​​n) 的，那么时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 为了避免死循环，可以在顶点数 ≤500\\le 500≤500 的时候暴力。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int S=52005,BS=500; struct ed{int x,y;}; struct que{int x,y,id;}; int n,q; vector&lt;int&gt; g[S]; vector&lt;que&gt; qs[S]; int idx[S],dis[2][S]; int ans[S*2]; inline void bfs(int x,int st,vector&lt;int&gt; &amp;V,vector&lt;ed&gt; &amp;E) { for(int &amp;u:V) g[u].clear(),dis[x][u]=n+1; for(int i=1;i&lt;V.size();i++) g[V[i-1]].push_back(V[i]),g[V[i]].push_back(V[i-1]); g[V.back()].push_back(V[0]),g[V[0]].push_back(V.back()); for(auto &amp;u:E) g[u.x].push_back(u.y),g[u.y].push_back(u.x); dis[x][st]=0; queue&lt;int&gt; q; q.push(st); while(!q.empty()) { int u=q.front(); q.pop(); for(int &amp;v:g[u]) if(dis[x][u]+1&lt;dis[x][v]) dis[x][v]=dis[x][u]+1,q.push(v); } } void slove(vector&lt;int&gt; V,vector&lt;ed&gt; E,vector&lt;que&gt; Q) { if(Q.size()==0) return; if(V.size()&lt;=BS) { for(int &amp;u:V) qs[u].clear(); for(auto &amp;u:Q) qs[u.x].push_back(u); for(int &amp;u:V) { bfs(0,u,V,E); for(auto &amp;v:qs[u]) ans[v.id]=min(ans[v.id],dis[0][v.y]); } return; } for(int i=0;i&lt;V.size();i++) idx[V[i]]=i; for(auto &amp;u:E) if(idx[u.x]&gt;idx[u.y]) swap(u.x,u.y); for(auto &amp;u:Q) if(idx[u.x]&gt;idx[u.y]) swap(u.x,u.y); int mx=-1,x=-1,y=-1; for(auto &amp;u:E) { int cnt=idx[u.y]-idx[u.x]; int pre=min(cnt,(int)V.size()-cnt); if(pre&gt;mx) mx=pre,x=u.x,y=u.y; } bfs(0,x,V,E),bfs(1,y,V,E); for(auto &amp;u:Q) { ans[u.id]=min({ans[u.id], dis[0][u.x]+dis[0][u.y], dis[1][u.x]+dis[1][u.y] }); } vector&lt;int&gt; tV; vector&lt;ed&gt; tE; vector&lt;que&gt; tQ; for(int i=idx[x];i&lt;=idx[y];i++) tV.push_back(V[i]); for(auto &amp;u:E) if(idx[u.x]&gt;=idx[x]&amp;&amp;idx[u.y]&lt;=idx[y]&amp;&amp;(u.x!=x||u.y!=y)) tE.push_back(u); for(auto &amp;u:Q) if(idx[u.x]&gt;idx[x]&amp;&amp;idx[u.y]&lt;idx[y]&amp;&amp;(u.x!=x&amp;&amp;u.y!=y)) tQ.push_back(u); slove(tV,tE,tQ); for(int i=0;i&lt;V.size();i++) idx[V[i]]=i; tV.clear(),tE.clear(),tQ.clear(); for(int i=0;i&lt;=idx[x];i++) tV.push_back(V[i]); for(int i=idx[y];i&lt;V.size();i++) tV.push_back(V[i]); for(auto &amp;u:E) if(((idx[u.x]&lt;=idx[x]||idx[u.x]&gt;=idx[y])&amp;&amp;(idx[u.y]&lt;=idx[x]||idx[u.y]&gt;=idx[y]))&amp;&amp;(u.x!=x||u.y!=y)) tE.push_back(u); for(auto &amp;u:Q) if(((idx[u.x]&lt;=idx[x]||idx[u.x]&gt;=idx[y])&amp;&amp;(idx[u.y]&lt;=idx[x]||idx[u.y]&gt;=idx[y]))&amp;&amp;(u.x!=x&amp;&amp;u.y!=y)) tQ.push_back(u); slove(tV,tE,tQ); } int main() { freopen(&quot;drive.in&quot;,&quot;r&quot;,stdin); freopen(&quot;drive.out&quot;,&quot;w&quot;,stdout); vector&lt;int&gt; V; vector&lt;ed&gt; E; vector&lt;que&gt; Q; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) V.push_back(i); for(int i=1;i&lt;=n-3;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); E.push_back({x,y}); } scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=q;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); Q.push_back({x,y,i}); ans[i]=n+1; } slove(V,E,Q); for(int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"【2023NOI模拟赛26】开开车 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-26-kai-kai-che-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":374000,"words":1113,"minutes":7},"date":"2023-09-05 16:50:57","dateFormat":"2023-09-05"},{"abstract":"<blockquote>\n<p>给定一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的树，每个点有一个权值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 合法当且仅当 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mn>1</mn><mo>≤</mo><mi>u</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\forall 1\\le u\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，都存在两个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 满足：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le x,y\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x\\not=y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 的简单路径上；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo>)</mo><mo>≥</mo><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\min(b_x,b_y)\\ge a_u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>输出所有合法的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 中最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一棵 nnn 个点的树，每个点有一个权值 aia_iai​。 一个长度为 nnn 的序列 bbb 合法当且仅当 ∀1≤u≤n\\forall 1\\le u\\le n∀1≤u≤n，都存在两个整数 x,yx,yx,y 满足： 1≤x,y≤n1\\le x,y\\le n1≤x,y≤n； x=yx\\not=yx​=y； uuu 在 xxx 到 yyy 的简单路径上； min⁡(bx,by)≥au\\min(b_x,b_y)\\ge a_umin(bx​,by​)≥au​； 输出所有合法的 bbb 中最小的 ∑bi\\sum b_i∑bi​。 2≤n≤2×1052\\le n\\le 2\\times 10^52≤n≤2×105，1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109。 首先不难发现只有叶子（一度点）的 bi=0b_i\\not=0bi​​=0。 令 aia_iai​ 最大的点 rtrtrt 做根，那么其余的点 uuu 只要满足在它子树内存在 bv≥aub_v\\ge a_ubv​≥au​ 的 vvv 即可。 那么按照深度从深往浅贪心，贪到 uuu 时选 uuu 子树内 bvb_vbv​ 最大的 vvv 让 bv→max⁡(bv,au)b_v\\to \\max(b_v,a_u)bv​→max(bv​,au​) 即可。 最后选树中最大和次大的 bib_ibi​ 令它们为 arta_{rt}art​ 即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=200005; int n,a[S]; vector&lt;int&gt; g[S]; int val[S]; int mx[S],mx2[S]; void dfs(int u,int fa) { bool f=false; for(int v:g[u]) { if(v==fa) continue; f=true; dfs(v,u); if(val[mx[v]]&gt;val[mx[u]]) mx2[u]=mx[u],mx[u]=mx[v]; else if(val[mx[v]]&gt;val[mx2[u]]) mx2[u]=mx[v]; } if(!f) mx[u]=u; val[mx[u]]=max(val[mx[u]],a[u]); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(y),g[y].push_back(x); } int rt=1; for(int i=1;i&lt;=n;i++) if(a[i]&gt;a[rt]) rt=i; dfs(rt,0); if(mx2[rt]==0) mx2[rt]=rt; val[mx[rt]]=val[mx2[rt]]=a[rt]; long long ans=0; for(int i=1;i&lt;=n;i++) ans+=val[i]; printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1637F Towers 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1637f-towers-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":153000,"words":476,"minutes":3},"date":"2023-09-04 11:11:47","dateFormat":"2023-09-04"},{"abstract":"<blockquote>\n<p>给定非负整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">n,x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，对于所有满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\sum \\limits_{i=1}^n a_i=x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.329066em;vertical-align:-0.9776689999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3513970000000004em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9776689999999999em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 按位或和为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>⊕</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\oplus_{i=1}^n a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.923056em;vertical-align:-0.258664em;\"></span><span class=\"mord\"><span class=\"mbin\">⊕</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.441336em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.258664em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的异或和。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2^{40}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><msup><mn>2</mn><mn>60</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le x&lt; 2^{60}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">6</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le x&lt; 2^{20}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定非负整数 n,x,yn,x,yn,x,y，对于所有满足 ∑i=1nai=x\\sum \\limits_{i=1}^n a_i=xi=1∑n​ai​=x，所有 aia_iai​ 按位或和为 yyy 的序列 aaa，求出 ⊕i=1nai\\oplus_{i=1}^n a_i⊕i=1n​ai​ 的异或和。 1≤n≤2401\\le n\\le 2^{40}1≤n≤240，0≤x&lt;2600\\le x&lt; 2^{60}0≤x&lt;260，0≤x&lt;2200\\le x&lt; 2^{20}0≤x&lt;220。 不难发现由于可以任意调换位置，所以所有 aia_iai​ 本质相同，也就是说，nnn 为偶数时答案为 000。 考虑 nnn 为奇数的情况，此时只需要统计所有 a1a_1a1​ 的异或和即可。 考虑拆位，对每个 iii 计算 a1a_1a1​ 第 iii 位为 111 的方案数 mod 2\\text{mod }2mod 2 的结果 cnticnt_icnti​，则答案即为 ∑2icnti\\sum 2^icnt_i∑2icnti​。 考虑通过容斥计算 cnticnt_icnti​，设 f(y′)f(y&#x27;)f(y′) 表示 aia_iai​ 的或和为 y′y&#x27;y′ 的子集且 a1a_1a1​ 第 iii 位为 111 的方案数，则： cnti=⊕y′⊆y(−1)∣y∣−∣y′∣f(y′)=⊕y′⊆yf(y′)cnt_i=\\oplus_{y&#x27;\\subseteq y}(-1)^{|y|-|y&#x27;|}f(y&#x27;)=\\oplus_{y&#x27;\\subseteq y}f(y&#x27;) cnti​=⊕y′⊆y​(−1)∣y∣−∣y′∣f(y′)=⊕y′⊆y​f(y′) 考虑计算 f(y′)f(y&#x27;)f(y′)，由于 a1a_1a1​ 第 iii 位一定为 111，所以不妨令 a1→a1−yia_1\\to a_1-y^ia1​→a1​−yi，则有： f(y′)=∑a1+a2+⋯+an=x−2i[a1⊆(y′−2i)]∏i=2n[ai⊆y′]mod 2f(y&#x27;)=\\sum\\limits_{a_1+a_2+\\dots+a_n=x-2^i}[a_1\\subseteq (y&#x27;-2^i)]\\prod\\limits_{i=2}^n[a_i\\subseteq y&#x27;]\\mod 2 f(y′)=a1​+a2​+⋯+an​=x−2i∑​[a1​⊆(y′−2i)]i=2∏n​[ai​⊆y′]mod2 注意到 (nm) mod 2=[m⊆n]\\binom{n}{m}\\text{ mod }2=[m\\subseteq n](mn​) mod 2=[m⊆n]，所以： f(y′)=∑a1+a2+⋯+an=x−2i(y′−2ia1)∏i=2n(y′ai)mod 2=(ny′−2ix−2i)mod 2=[(x−2i)⊆(ny′−2i)]\\begin{aligned} f(y&#x27;)&amp;=\\sum\\limits_{a_1+a_2+\\dots+a_n=x-2^i}\\binom{y&#x27;-2^i}{a_1}\\prod\\limits_{i=2}^n\\binom{y&#x27;}{a_i}\\mod 2\\\\ &amp;=\\binom{ny&#x27;-2^i}{x-2^i}\\mod 2\\\\ &amp;=[(x-2^i)\\subseteq(ny&#x27;-2^i)]\\\\ \\end{aligned} f(y′)​=a1​+a2​+⋯+an​=x−2i∑​(a1​y′−2i​)i=2∏n​(ai​y′​)mod2=(x−2iny′−2i​)mod2=[(x−2i)⊆(ny′−2i)]​ 所以答案为： ∑2i⊕y′⊆y[(x−2i)⊆(ny′−2i)]\\sum 2^i\\oplus_{y&#x27;\\subseteq y}[(x-2^i)\\subseteq(ny&#x27;-2^i)] ∑2i⊕y′⊆y​[(x−2i)⊆(ny′−2i)] 时间复杂度 O(ylog⁡y)O(y\\log y)O(ylogy)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; long long n,x; int y; int main() { scanf(&quot;%lld%lld%d&quot;,&amp;n,&amp;x,&amp;y); if(n&amp;1^1) return puts(&quot;0&quot;),0; int ans=0; for(int i=0;i&lt;20;i++) { int f=0; for(int j=y;j&gt;0;j=(j-1)&amp;y) { if(j&gt;&gt;i&amp;1^1) continue; f^=((x-(1&lt;&lt;i))|(n*j-(1&lt;&lt;i)))==(n*j-(1&lt;&lt;i)); } ans+=f&lt;&lt;i; } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1770F Koxia and Sequence 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1770f-koxia-and-sequence-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":221000,"words":671,"minutes":4},"date":"2023-08-25 16:43:24","dateFormat":"2023-08-25"},{"abstract":"<blockquote>\n<p>给定长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>，求满足以下条件的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 的个数模 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 的结果：</p>\n<ul>\n<li>值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1, n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的个数不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">B_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的个数不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>A</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le A_i\\le n \\le 500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定长度为 nnn 的序列 AAA，求满足以下条件的序列 BBB 的个数模 998244353998244353998244353 的结果： 值域 [1,n][1, n][1,n]； iii 的个数不超过 AiA_iAi​； BiB_iBi​ 的个数不超过 AiA_iAi​； 1≤Ai≤n≤5001 \\le A_i\\le n \\le 5001≤Ai​≤n≤500。 刚开始想的是把 AAA 从大到小排序，这样每个数的出现次数就由它最后一次出现的位置决定，设 fi,j,kf_{i,j,k}fi,j,k​ 表示处理完前 A[1,i]A_{[1,i]}A[1,i]​，一共填了 jjj 个位置，一共填了 kkk 种数的方案数，但是发现是 O(n4)O(n^4)O(n4) 的。 看题解发现忽略了一个很重要的东西：调和级数 ∑i=1nO(ni)=O(nln⁡n)\\sum\\limits_{i=1}^n O(\\frac{n}{i})=O(n\\ln n)i=1∑n​O(in​)=O(nlnn)。 设 did_idi​ 表示 iii 的出现次数，观察 ddd 需要满足什么性质： di≤Aid_i\\le A_idi​≤Ai​； 对于所有满足 di≤Ajd_i\\le A_jdi​≤Aj​ 的位置 jjj，BjB_jBj​ 可以等于 iii； 观察到 ∀di&lt;dj\\forall d_i&lt;d_j∀di​&lt;dj​，jjj 能放的位置 iii 都能放，即 iii 的决策包含 jjj。 那么设 fi,j,kf_{i,j,k}fi,j,k​ 表示决定完 dx∈[i,n]d_x\\in[i,n]dx​∈[i,n] 的 xxx，共放了 jjj 种不同的数，消耗了 kkk 个位置的答案。 转移直接枚举有多少个 xxx 满足 dx=id_x=idx​=i 即可。 由于 jjj 的上界是 ni\\frac{n}{i}in​，dx=id_x=idx​=i 的 xxx 的个数上界也是 ni\\frac{n}{i}in​，所以时间复杂度为 O(n∑i=1nn2i2)O(n\\sum\\limits_{i=1}^n\\frac{n^2}{i^2})O(ni=1∑n​i2n2​)，约为 O(n2ln⁡3n)O(n^2\\ln^3 n)O(n2ln3n)，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=505,p=998244353; int n,a[S]; int fra[S],inv[S],pinv[S][S],C[S][S],f[S][S][S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); for(int i=0;i&lt;=n;i++) { fra[i]=i==0?1:1ll*i*fra[i-1]%p; C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } inv[n]=qpow(fra[n],p-2); for(int i=n;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; for(int i=0;i&lt;=n;i++) { pinv[i][0]=1; for(int j=1;j&lt;=n;j++) pinv[i][j]=1ll*pinv[i][j-1]*inv[i]%p; } f[n+1][0][0]=1; for(int i=n,pp=n+1;i&gt;=1;i--) { while(pp&gt;1&amp;&amp;a[pp-1]&gt;=i) pp--; int len=n-pp+1; for(int j=0;j&lt;=n/i&amp;&amp;j&lt;=len;j++) { for(int k=0;k&lt;=n;k++) { for(int l=0;l&lt;=j&amp;&amp;l&lt;=n/i&amp;&amp;l&lt;=k/i;l++) { int bse=1ll*C[len-j+l][l]*C[len-k+i*l][i*l]%p*fra[i*l]%p*pinv[i][l]%p; add(f[i][j][k],1ll*bse*f[i+1][j-l][k-i*l]%p); } } } } int ans=0; for(int i=1;i&lt;=n;i++) add(ans,f[1][i][n]); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ARC162E Strange Constraints 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc162e-strange-constraints-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":252000,"words":786,"minutes":5},"date":"2023-08-23 15:31:16","dateFormat":"2023-08-23"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi><mo>×</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">H\\times W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span></span></span></span> 的矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 和一个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n<p>起初在任意格子上放置一个棋子，接下来操作 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 次，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 次操作：</p>\n<ul>\n<li>若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 是奇数，则把棋子移动到当前所在<strong>行</strong>中任意一个格子（可以不动）；</li>\n<li>若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 是偶数，则把棋子移动到当前所在<strong>列</strong>中任意一个格子（可以不动）；</li>\n</ul>\n<p>把每次操作完后棋子所在的格子上的数依次写下，形成一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，请你求出有多少种可能的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>H</mi><mo separator=\"true\">,</mo><mi>W</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">1\\le H,W\\leq10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\leq 300</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">1\\le c_{i,j}\\le 9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.922078em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 H×WH\\times WH×W 的矩阵 ccc 和一个整数 nnn。 起初在任意格子上放置一个棋子，接下来操作 nnn 次，第 iii 次操作： 若 iii 是奇数，则把棋子移动到当前所在行中任意一个格子（可以不动）； 若 iii 是偶数，则把棋子移动到当前所在列中任意一个格子（可以不动）； 把每次操作完后棋子所在的格子上的数依次写下，形成一个长度为 2n2n2n 的序列 bbb，请你求出有多少种可能的序列 bbb，对 998244353998244353998244353 取模。 1≤H,W≤101\\le H,W\\leq101≤H,W≤10，1≤n≤3001\\le n\\leq 3001≤n≤300，1≤ci,j≤91\\le c_{i,j}\\le 91≤ci,j​≤9。 发现奇数次操作之前不关心所在列，偶数次操作之前不关心所在行，那么一个朴素的想法是设 fi,jf_{i,j}fi,j​ 表示第 iii 次操作完后在第 jjj 行/列的答案。 但是由于有可能有数字重复的格子，所以可能会算重。 观察到一个性质：设 f(b)f(b)f(b) 为所有能形成 bbb 的路径的末尾位置的集合，那么两个 bbb 相同当且仅当 f(b)f(b)f(b) 相同。 证明是显然的。 那么设 fi,Sf_{i,S}fi,S​ 表示第 iii 次操作完了后 f(b)=Sf(b)=Sf(b)=S（只保留行或列）的答案。 转移是显然的，时间复杂度 O(n(2H+2W)HW)O(n(2^H+2^W)HW)O(n(2H+2W)HW)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=15,BS=1&lt;&lt;10,KS=605,p=998244353; int n,m,k; int a[S][S]; int f[KS][BS]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); k*=2; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot; %c&quot;,&amp;a[i][j]),a[i][j]-='0'; int nl=1&lt;&lt;n,ml=1&lt;&lt;m; f[0][nl-1]=1; for(int i=0;i&lt;=k-1;i++) { if(i&amp;1^1) { for(int j=1;j&lt;nl;j++) { for(int v=1;v&lt;=9;v++) { int nv=0; for(int x=1;x&lt;=n;x++) { if(j&gt;&gt;x-1&amp;1^1) continue; for(int y=1;y&lt;=m;y++) if(a[x][y]==v) nv|=1&lt;&lt;y-1; } add(f[i+1][nv],f[i][j]); } } } else { for(int j=1;j&lt;ml;j++) { for(int v=1;v&lt;=9;v++) { int nv=0; for(int y=1;y&lt;=m;y++) { if(j&gt;&gt;y-1&amp;1^1) continue; for(int x=1;x&lt;=n;x++) if(a[x][y]==v) nv|=1&lt;&lt;x-1; } add(f[i+1][nv],f[i][j]); } } } } int ans=0; for(int i=1;i&lt;nl;i++) add(ans,f[k][i]); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ABC228G Digits on Grid 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc228g-digits-on-grid-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":200000,"words":672,"minutes":4},"date":"2023-08-23 10:18:51","dateFormat":"2023-08-23"},{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的元素两两不同的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\forall 1\\le i&lt;j\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i&lt;a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，则让 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 向 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 连一条无向边。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次修改数组某个位置的值，每次修改后输出图中连通块个数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,q\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，保证任意时刻数组中元素两两不同。</p>\n</blockquote>\n","content":" 给定一个长 nnn 的元素两两不同的序列 aaa，∀1≤i&lt;j≤n\\forall 1\\le i&lt;j\\le n∀1≤i&lt;j≤n，若 ai&lt;aja_i&lt;a_jai​&lt;aj​，则让 iii 向 jjj 连一条无向边。 qqq 次修改数组某个位置的值，每次修改后输出图中连通块个数。 1≤n,q≤5×1051\\le n,q\\le 5\\times 10^51≤n,q≤5×105，1≤ai≤1061\\le a_i\\le 10^61≤ai​≤106，保证任意时刻数组中元素两两不同。 首先有个结论： 若 iii 和 jjj 满足 ai&lt;aja_i&lt;a_jai​&lt;aj​，则 ∀i≤k≤j\\forall i\\le k\\le j∀i≤k≤j，kkk 与 iii、jjj 连通。 证明是显然的。 根据这个结论，每个连通块一定是一个连续段。 那么注意到 ∀2≤i≤n\\forall 2\\le i\\le n∀2≤i≤n，i−1i-1i−1 和 iii 不在同一个连通块中当且仅当 min⁡j=1i−1aj&gt;max⁡j=inaj\\min\\limits_{j=1}^{i-1} a_j&gt;\\max\\limits_{j=i}^n a_jj=1mini−1​aj​&gt;j=imaxn​aj​。而由于每个连通块都是连续段，所以连通块个数就是这样的 iii 的个数 +1+1+1。 定义 xxx 的前驱 pre(x)\\text{pre}(x)pre(x) 为满足 0≤i≤n,ai&lt;x0\\le i\\le n,a_i&lt;x0≤i≤n,ai​&lt;x 且 aia_iai​ 最大的 iii，令 bi=∑j=1n[pre(aj)+1≤i≤j]b_i=\\sum\\limits_{j=1}^n [\\text{pre}(a_j)+1\\le i\\le j]bi​=j=1∑n​[pre(aj​)+1≤i≤j]，则一定有： b1=0b_1=0b1​=0； bbb 中 000 的个数就是连通块个数，因为每个 bi=0b_i=0bi​=0 的 iii 显然都满足 min⁡j=1i−1aj&gt;max⁡j=inaj\\min\\limits_{j=1}^{i-1} a_j&gt;\\max\\limits_{j=i}^n a_jj=1mini−1​aj​&gt;j=imaxn​aj​； 那么用 set 维护前驱后继、线段树维护 bbb 中最小值以及最小值个数即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=500005; int n,q,a[S]; int tag[S&lt;&lt;2],mn[S&lt;&lt;2],mnc[S&lt;&lt;2]; set&lt;pair&lt;int,int&gt;&gt; st; inline void upda(int u) { int ls=u&lt;&lt;1,rs=u&lt;&lt;1|1; mnc[u]=0; mn[u]=min(mn[ls],mn[rs]); if(mn[ls]==mn[u]) mnc[u]+=mnc[ls]; if(mn[rs]==mn[u]) mnc[u]+=mnc[rs]; } inline void addtag(int u,int val) { tag[u]+=val; mn[u]+=val; } inline void dwntag(int u) { if(tag[u]==0) return; addtag(u&lt;&lt;1,tag[u]),addtag(u&lt;&lt;1|1,tag[u]); tag[u]=0; } void build(int u,int l,int r) { if(l==r) return tag[u]=0,mn[u]=0,mnc[u]=1,void(); int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r); upda(u); } void upd(int u,int l,int r,int L,int R,int val) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) return addtag(u,val); dwntag(u); int mid=l+r&gt;&gt;1; if(L&lt;=mid) upd(u&lt;&lt;1,l,mid,L,R,val); if(R&gt;=mid+1) upd(u&lt;&lt;1|1,mid+1,r,L,R,val); upda(u); } inline void updd(int l,int r,int x) { if(l==0||r==n+1) return; r=min(r,n); if(l+1&gt;r) return; upd(1,1,n,l+1,r,x); } inline void ins(int p,int x) { st.insert(make_pair(x,p)); auto lb=st.lower_bound(make_pair(x,p)); auto rb=st.lower_bound(make_pair(x,p)); lb--,rb++; updd(lb-&gt;second,rb-&gt;second,-1); updd(lb-&gt;second,p,1); updd(p,rb-&gt;second,1); } inline void del(int p,int x) { auto lb=st.lower_bound(make_pair(x,p)); auto rb=st.lower_bound(make_pair(x,p)); lb--,rb++; updd(lb-&gt;second,p,-1); updd(p,rb-&gt;second,-1); updd(lb-&gt;second,rb-&gt;second,1); st.erase(make_pair(x,p)); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); build(1,1,n); st.insert(make_pair(-1e9,0)),st.insert(make_pair(1e9,n+1)); for(int i=1;i&lt;=n;i++) ins(i,a[i]); while(q--&gt;0) { int p,x; scanf(&quot;%d%d&quot;,&amp;p,&amp;x); del(p,a[p]); a[p]=x; ins(p,a[p]); printf(&quot;%d\\n&quot;,mnc[1]); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF1270H Number of Components 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1270h-number-of-components-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":310000,"words":930,"minutes":6},"date":"2023-08-22 11:50:25","dateFormat":"2023-08-22"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的 DAG，每个点出度至多为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>。可以删除不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mn>4</mn><mn>7</mn></mfrac><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\frac{4}{7}n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">7</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点，使得删点后的图中不存在包含三个点的链。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq n \\leq 2 \\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一张 nnn 个点 mmm 条边的 DAG，每个点出度至多为 222。可以删除不超过 47n\\frac{4}{7}n74​n 个点，使得删点后的图中不存在包含三个点的链。 1≤n≤2×1051 \\leq n \\leq 2 \\times 10^51≤n≤2×105。 做题时可以设出一些未知量，写出一些已知条件方便思考。 图中的点一定能分成三个集合： 删去的点集 SSS； 删完点后没有入度的点集 AAA； 删完点后有入度但没有出度的点集 BBB； 注意到原图每个点出度至多为 222，所以一定有 ∣B∣≤2∣A∣|B|\\le 2|A|∣B∣≤2∣A∣。发现只有 BBB 中点出边指向的点才会删掉，所以有 ∣S∣≤2∣B∣|S|\\le 2|B|∣S∣≤2∣B∣。那么有 ∣S∣≤2∣B∣≤4∣A∣|S|\\le 2|B|\\le 4|A|∣S∣≤2∣B∣≤4∣A∣，即 ∣S∣|S|∣S∣ 最大不超过 47n\\frac{4}{7}n74​n。 那么考虑增量构造，遍历每个点： 若它没有入边或入边都来自 SSS 则加入 AAA； 若它没有入边来自 BBB 则加入 BBB； 否则加入 SSS； 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)（log⁡n\\log nlogn 来自 set），代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; const int S=200005; int n,m; vector&lt;int&gt; g[S]; set&lt;int&gt; as,bs,st; inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) g[i].clear(); as.clear(),bs.clear(),st.clear(); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[y].push_back(x); } for(int i=1;i&lt;=n;i++) { if(g[i].size()==0) as.insert(i); else { bool f=false,f2=false; for(int v:g[i]) f|=bs.count(v),f2|=as.count(v); if(f) st.insert(i); else if(f2) bs.insert(i); else as.insert(i); } } printf(&quot;%d\\n&quot;,st.size()); for(int u:st) printf(&quot;%d &quot;,u); printf(&quot;\\n&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1368E Ski Accidents 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1368e-ski-accidents-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":144000,"words":485,"minutes":3},"date":"2023-08-19 15:31:06","dateFormat":"2023-08-19"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 表示存在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个宝箱和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 把钥匙，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 把钥匙需要 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 元，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个宝箱内部有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 元。</p>\n<p>现在进行一场游戏，Bob 是本场游戏的玩家，而 Alice 则是场景布置者，Alice 可以给每个宝箱上一些锁（第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 种锁需要第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 种钥匙打开）</p>\n<p>如果 Bob 可以购买一些钥匙，然后打开一些宝箱，使得 Bob 的收益大于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，那么 Bob 就赢得了游戏，反之 Alice 获得了胜利。</p>\n<p>现在 Alice 打算布置宝箱上的锁，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个宝箱上放置第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 种锁的花费为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">c_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，请帮助 Alice 找到一种布置锁的方案，使得花费最小，且 Alice 将取得胜利。</p>\n<p>注意：一个箱子上可以放置若干把锁，Bob 需打开所有锁才能获得内部的钱。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>6</mn><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>4</mn><mo separator=\"true\">,</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">n,m\\le 6,a_i,b_i\\le 4,c_{i,j}\\le 10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9305479999999999em;vertical-align:-0.286108em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 n,mn,mn,m 表示存在 nnn 个宝箱和 mmm 把钥匙，第 iii 把钥匙需要 bib_ibi​ 元，第 iii 个宝箱内部有 aia_iai​ 元。 现在进行一场游戏，Bob 是本场游戏的玩家，而 Alice 则是场景布置者，Alice 可以给每个宝箱上一些锁（第 jjj 种锁需要第 jjj 种钥匙打开） 如果 Bob 可以购买一些钥匙，然后打开一些宝箱，使得 Bob 的收益大于 000，那么 Bob 就赢得了游戏，反之 Alice 获得了胜利。 现在 Alice 打算布置宝箱上的锁，第 iii 个宝箱上放置第 jjj 种锁的花费为 ci,jc_{i,j}ci,j​，请帮助 Alice 找到一种布置锁的方案，使得花费最小，且 Alice 将取得胜利。 注意：一个箱子上可以放置若干把锁，Bob 需打开所有锁才能获得内部的钱。 n,m≤6,ai,bi≤4,ci,j≤107n,m\\le 6,a_i,b_i\\le 4,c_{i,j}\\le 10^7n,m≤6,ai​,bi​≤4,ci,j​≤107。 设箱子 iii 上的锁的集合为 LiL_iLi​，那么 LLL 需要满足： ∀S⊆{1,2,3,…n},∑u∈Sau≤∑v∈(∪u∈SLu)bv\\forall S\\subseteq\\{1,2,3,\\dots n\\},\\sum\\limits_{u\\in S} a_u\\le \\sum\\limits_{v\\in (\\cup_{u\\in S}L_u)}b_v ∀S⊆{1,2,3,…n},u∈S∑​au​≤v∈(∪u∈S​Lu​)∑​bv​ 注意到这个东西很像 Hall 定理，那么考虑建立一张这样的二分图： 左部每个箱子拆成 aia_iai​ 个点，共有 ∑i=1nai\\sum\\limits_{i=1}^n a_ii=1∑n​ai​ 个点； 右部每个锁拆成 bib_ibi​ 个点，共有 ∑i=1mbi\\sum\\limits_{i=1}^m b_ii=1∑m​bi​ 个点； 若 iii 号箱子有 jjj 号锁，那么从 iii 号箱子拆出的所有点和 jjj 号锁拆出的所有点之间连一条边； 问题等价于最小化有连边的锁的 bib_ibi​ 和，使得二分图存在大小为 ∑i=1nai\\sum\\limits_{i=1}^n a_ii=1∑n​ai​ 的匹配。 那么直接找大小为 ∑i=1nai\\sum\\limits_{i=1}^n a_ii=1∑n​ai​ 的匹配即可。设 dpi,stdp_{i,st}dpi,st​ 为前 iii 个箱子拆出来的点都匹配完了，锁拆出来的点的状态为 ststst（五进制，每个锁拆出来的点还有多少个）时的最小代价。那么转移直接枚举当前箱子拆出来的每个点匹配了哪个锁拆成的点，如果匹配了至少一个锁 jjj 拆出来的点，则需要加上 ci,jc_{i,j}ci,j​ 的代价。 时间复杂度 O(nm22n)O(nm2^{2n})O(nm22n)，跑不满所以能过。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int S=8,SS=45,BS=20005; int n,m; int a[S],b[S],c[S][S]; int tot[SS],sta[SS][BS][S]; int st[S],pst[S]; int dp[S][BS]; inline int getval() { int val=0; for(int i=1;i&lt;=m;i++) { val*=5; val+=st[i]; } return val; } inline void getsta(int val) { for(int i=m;i&gt;=1;i--) { st[i]=val%5; val/=5; } } inline void tmin(int &amp;x,int y) { x=min(x,y); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;c[i][j]); for(int i=1;i&lt;=m;i++) st[i]=b[i]; int mxval=getval(); for(int i=0;i&lt;=mxval;i++) { getsta(i); int cnt=0; for(int j=1;j&lt;=m;j++) cnt+=st[j]; tot[cnt]++; for(int j=1;j&lt;=m;j++) sta[cnt][tot[cnt]][j]=st[j]; } memset(dp,127,sizeof(dp)); int inf=dp[0][0]; dp[0][mxval]=0; for(int i=0;i&lt;=n-1;i++) { for(int j=0;j&lt;=mxval;j++) { if(dp[i][j]==inf) continue; getsta(j); for(int k=1;k&lt;=m;k++) pst[k]=st[k]; for(int k=1;k&lt;=tot[a[i+1]];k++) { for(int l=1;l&lt;=m;l++) st[l]=pst[l]; bool f=true; int sum=0; for(int l=1;l&lt;=m&amp;&amp;f;l++) { int u=sta[a[i+1]][k][l]; if(u&gt;st[l]) f=false; if(u&gt;0) sum+=c[i+1][l]; st[l]-=u; } if(f) { int idx=getval(); tmin(dp[i+1][idx],dp[i][j]+sum); } } } } int ans=inf; for(int i=0;i&lt;=mxval;i++) tmin(ans,dp[n][i]); printf(&quot;%d\\n&quot;,ans==inf?-1:ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1519F Chests and Keys 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1519f-chests-and-keys-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":304000,"words":1022,"minutes":6},"date":"2023-08-16 19:51:23","dateFormat":"2023-08-16"},{"abstract":"<blockquote>\n<p>给定长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[1,n]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>输出最长的满足不同的众数（出现次数最多的数）至少有两个的区间的长度。</p>\n<p>D1：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>100</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le \\min(100,n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>；</p>\n<p>D2：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>；</p>\n</blockquote>\n","content":" 给定长 nnn 的序列 a[1,n]a_{[1,n]}a[1,n]​。 输出最长的满足不同的众数（出现次数最多的数）至少有两个的区间的长度。 D1：1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤ai≤min⁡(100,n)1\\le a_i\\le \\min(100,n)1≤ai​≤min(100,n)； D2：1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤ai≤n1\\le a_i\\le n1≤ai​≤n； 现特判掉整个序列不同众数个数 &gt;1&gt;1&gt;1 的情况。 设 XXX 为整个序列的众数，有个结论： XXX 一定是答案区间的其中一个众数。 证明考虑反证，若 XXX 不是答案区间的众数，因为 XXX 是序列中最多的数，所以一定可以向左向右拓展答案区间使得 XXX 是答案区间的众数，这样一定不劣因为原来的众数还是众数。 那么 D1 就可以直接枚举答案区间的另一个众数 YYY 然后 O(n)O(n)O(n) 找到最长的满足 XXX 和 YYY 出现次数相等的区间，总时间复杂度 O(nV)O(nV)O(nV)。 对于 D2，注意到是颜色题，所以考虑根号分治。 对于出现次数 &gt;n&gt; \\sqrt n&gt;n​ 的数，直接用 D1 的做法，这部分总时间复杂度 O(nn)O(n\\sqrt n)O(nn​)； 对于出现次数 ≤n\\le \\sqrt n≤n​ 的数，直接枚举众数的出现次数然后双指针找到最长的合法区间，这部分总时间复杂度 O(nn)O(n\\sqrt n)O(nn​)； 总时间复杂度 O(nn)O(n\\sqrt n)O(nn​)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=200005,B=450; int n,a[S]; int cnt[S]; int mnp[S*2],b[S]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) cnt[a[i]]++; int mx=0,val; for(int i=1;i&lt;=n;i++) if(cnt[i]&gt;mx) mx=cnt[i],val=i; for(int i=1;i&lt;=n;i++) if(i!=val&amp;&amp;cnt[i]==mx) return printf(&quot;%d\\n&quot;,n),0; int ans=0; for(int i=1;i&lt;=n;i++) { if(i==val) continue; if(cnt[i]&gt;B) { for(int j=0;j&lt;=n+n;j++) mnp[j]=0; int cnt=0; for(int j=1;j&lt;=n;j++) { if(a[j]==i) cnt--; if(a[j]==val) cnt++; if(cnt==0||mnp[n+cnt]!=0) ans=max(ans,j-mnp[n+cnt]); else mnp[n+cnt]=j; } } } for(int i=1;i&lt;=B;i++) { for(int j=1;j&lt;=n;j++) b[j]=0; int l=1,cnt=0; for(int r=1;r&lt;=n;r++) { cnt+=++b[a[r]]==i; while(l&lt;=r&amp;&amp;b[a[r]]&gt;i) { cnt-=b[a[l++]]--==i; } if(cnt&gt;=2) ans=max(ans,r-l+1); } } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1446D1&2 Frequency Problem 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1446d1and2-frequency-problem-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":202000,"words":674,"minutes":4},"date":"2023-08-16 19:50:05","dateFormat":"2023-08-16"},{"abstract":"<blockquote>\n<p>定义集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 合法当且仅当满足以下条件：</p>\n<ul>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>⊆</mo><mo>{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">S \\subseteq \\{1,2,...,n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">}</span></span></span></span>；</p>\n</li>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>a</mi><mo>∈</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">\\forall a\\in S,b\\in S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>， <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mo>−</mo><mi>b</mi><mi mathvariant=\"normal\">∣</mi><mpadded width=\"0px\"><mo></mo></mpadded><mo>∈</mo><mo>{</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">|a-b|\\not\\in\\{x,y\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}</span></span></span></span>；</p>\n</li>\n</ul>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">n,x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，求最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|S|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>≤</mo><mn>22</mn></mrow><annotation encoding=\"application/x-tex\">1\\le x,y\\le 22</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">2</span></span></span></span>。</p>\n</blockquote>\n","content":" 定义集合 SSS 合法当且仅当满足以下条件： S⊆{1,2,...,n}S \\subseteq \\{1,2,...,n\\}S⊆{1,2,...,n}； ∀a∈S,b∈S\\forall a\\in S,b\\in S∀a∈S,b∈S， ∣a−b∣∈{x,y}|a-b|\\not\\in\\{x,y\\}∣a−b∣​∈{x,y}； 给定 n,x,yn,x,yn,x,y，求最大的 ∣S∣|S|∣S∣。 1≤n≤1091\\le n\\le 10^91≤n≤109，1≤x,y≤221\\le x,y\\le 221≤x,y≤22。 问题等价于找到一个长 nnn 的 01 序列满足序列中任意两个 111 的位置差不为 xxx 或 yyy，最大化 01 序列中 111 的个数。 引理 1 任意长 x+yx+yx+y 的合法的 01 序列无限重复构成的 01 序列仍然合法。 证明 反证法。 若存在一个长 x+yx+yx+y 的合法的 01 序列 sss 满足其无限重复构成的 01 序列 aaa 中： aia_iai​ 和 ai+xa_{i+x}ai+x​ 均为 111：不妨假设 i≤x+y,i+x&gt;x+yi\\le x+y,i+x&gt;x+yi≤x+y,i+x&gt;x+y，那么此时一定有 ai+x−x−y=ai−y=1a_{i+x-x-y}=a_{i-y}=1ai+x−x−y​=ai−y​=1，注意到 aia_iai​ 为 111，i−y≤x+yi-y\\le x+yi−y≤x+y，所以此时 sss 一定不合法； aia_iai​ 和 ai+ya_{i+y}ai+y​ 均为 111：同理，一定有 ai=ai−x=1a_i=a_{i-x}=1ai​=ai−x​=1； Q.E.D. 定理 1 最优解一定是某个长 x+yx+yx+y 的合法 01 序列无限重复构成的 01 序列的长度为 nnn 的前缀。 证明 n≡0(modx+y)n\\equiv 0\\pmod {x+y}n≡0(modx+y) 的情况下显然成立。 设 n≡r(modx+y)n\\equiv r\\pmod{x+y}n≡r(modx+y)（r=0r\\not=0r​=0），现在来证明最后一小段长 rrr 的跟着前面循环是不劣的： 反证法，设最后一小段长 rrr 的 01 序列为 ttt，设循环节（长度为 x+yx+yx+y 的不断出现的 01 串）为 sss； ttt 不跟着前面循环更优，当且仅当 ststst（拼起来）合法但用 ttt 替换掉 sss 的长 ∣t∣|t|∣t∣ 的前缀不合法，不妨设用 ttt 替换掉 sss 的长 ∣t∣|t|∣t∣ 的前缀得到的字符串为 ts′ts&#x27;ts′； 设 ts′ts&#x27;ts′ 中不合法的两个位置为 iii 和 i+xi+xi+x（i+yi+yi+y 同理），那么一定有 i≤∣t∣,i+x&gt;∣t∣i\\le |t|,i+x&gt;|t|i≤∣t∣,i+x&gt;∣t∣； 考察答案的后缀 ts′tts&#x27;tts′t，由于位置 iii 和 i+xi+xi+x 都是 111，那么位置 i+xi+xi+x 和 i+x+yi+x+yi+x+y 一定也都是 111，那么 s′ts&#x27;ts′t 不合法，所以 ststst 不合法，矛盾； Q.E.D. 那么 O((x+y)2max⁡(x,y))O((x+y)2^{\\max(x,y)})O((x+y)2max(x,y)) 状压 dp 即可，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int BS=1&lt;&lt;22; int n,x,y; int f[2][BS]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;x,&amp;y); if(x&lt;y) swap(x,y); memset(f,128,sizeof(f)); int p=0; f[p][0]=0; for(int i=0;i&lt;=x+y-1&amp;&amp;i&lt;=n-1;i++) { p^=1; memset(f[p],128,sizeof(f[p])); for(int j=0;j&lt;(1&lt;&lt;x);j++) { int s0=(j&lt;&lt;1)&amp;((1&lt;&lt;x)-1),s1=s0|1; if((s0&amp;(j&gt;&gt;x-1))==0&amp;&amp;(s0&amp;(j&gt;&gt;y-1))==0) f[p][s0]=max(f[p][s0],f[p^1][j]); if((s1&amp;(j&gt;&gt;x-1))==0&amp;&amp;(s1&amp;(j&gt;&gt;y-1))==0) f[p][s1]=max(f[p][s1],f[p^1][j]+n/(x+y)+(i+1&lt;=n%(x+y))); } } int ans=0; for(int i=0;i&lt;(1&lt;&lt;x);i++) ans=max(ans,f[p][i]); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1463F Max Correct Set 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1463f-max-correct-set-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":276000,"words":905,"minutes":5},"date":"2023-08-16 19:19:11","dateFormat":"2023-08-16"},{"abstract":"","content":"Part 1 前言 基本子串结构是许廷强在 2023 年集训队论文《一类基础子串数据结构》中提出的一种新型字符串数据结构，可以同时处理前缀和后缀的信息，是一种很强力的字符串数据结构。 论文链接：国家集训队2023论文集 另外感谢 《一类基础子串数据结构》摘抄及注解 - crashed。 Part 2 基础定义 字符串 SSS：若无特殊说明，SSS 为给定的某个字符串； 字符集大小：默认 O(1)O(1)O(1)； ∣S∣|S|∣S∣ 和 S[l,r]S_{[l,r]}S[l,r]​： ∣S∣|S|∣S∣ 为字符串 SSS 的长度； S[l,r]S_{[l,r]}S[l,r]​ 为字符串 SlSl+1…SrS_lS_{l+1}\\dots S_rSl​Sl+1​…Sr​ 即字符串 SSS 从 SlS_lSl​ 到 SrS_rSr​ 的子串； occS(T)\\text{occ}_S(T)occS​(T)、endposS(T)\\text{endpos}_S(T)endposS​(T) 和 srtposS(T)\\text{srtpos}_S(T)srtposS​(T)： occS(T)\\text{occ}_S(T)occS​(T) 为字符串 TTT 在字符串 SSS 中的出现次数； endposS(T)\\text{endpos}_S(T)endposS​(T) 为字符串 TTT 在 SSS 中出现时的右端点位置的集合； srtposS(T)\\text{srtpos}_S(T)srtposS​(T) 为字符串 TTT 在 SSS 中出现时的左端点位置的集合； 易知 occS(T)=endposS(T)=srtposS(T)\\text{occ}_S(T)=\\text{endpos}_S(T)=\\text{srtpos}_S(T)occS​(T)=endposS​(T)=srtposS​(T)。 若无特殊说明，下标中的 SSS 略去时表示 SSS 为给定的字符串 SSS； S∈TS\\in TS∈T：表示字符串 SSS 是字符串 TTT 的子串，S∉TS\\notin TS∈/​T 同理； T0T_0T0​ 和 T1T_1T1​： T0T_0T0​ 为正串的 SAM 的 parent 树； T1T_1T1​ 为反串的 SAM 的 parent 树； 默认 parent 树上的节点等价于 SAM 中的对应节点； Part 3 理论 3.1 拓展串 定义 3.1（拓展串） ∀t∈S\\forall t\\in S∀t∈S，定义 ext(t)\\text{ext}(t)ext(t) 为最长的 SSS 的子串 t′t&#x27;t′ 满足 t∈t′t\\in t&#x27;t∈t′ 且 occ(t)=occ(t′)\\text{occ}(t)=\\text{occ}(t&#x27;)occ(t)=occ(t′)。 这个显然是良定义的，对于子串 ttt，只要不断往左往右添加字符即可找到 ext(t)\\text{ext}(t)ext(t)。 定理 3.1 设 t=S[l,r],ext(t)=S[L,R]t=S_{[l,r]},\\text{ext}(t)=S_{[L,R]}t=S[l,r]​,ext(t)=S[L,R]​，则 ∀l′∈[L,l],r′∈[r,R]\\forall l&#x27;\\in[L,l],r&#x27;\\in[r,R]∀l′∈[L,l],r′∈[r,R] 都有 ext(S[l′,r′])=SL,R\\text{ext}(S_{[l&#x27;,r&#x27;]})=S_{L,R}ext(S[l′,r′]​)=SL,R​。 由于子串 ttt 找 ext(t)\\text{ext}(t)ext(t) 是往左往右不断添加字符。 3.2 等价类 定义 3.2.1（等价关系） ∀s∈S,t∈S\\forall s\\in S,t\\in S∀s∈S,t∈S，sss 与 ttt 等价当且仅当 ext(s)=ext(t)\\text{ext(s)}=\\text{ext(t)}ext(s)=ext(t)。 易证明该关系具有传递性、自反性、对称性。 定义 3.2.2（等价类和代表元） ∀s∈S\\forall s\\in S∀s∈S： 定义 sss 所在的等价类 E(s)={t∣t∈S,ext(t)=ext(s)}\\text{E}(s)=\\{t|t\\in S,\\text{ext}(t)=\\text{ext}(s)\\}E(s)={t∣t∈S,ext(t)=ext(s)}。 定义 sss 所在的等价类的代表元 R(s)=t∣t∈E(s),t=ext(t)\\text{R}(s)=t|t\\in \\text{E}(s),t=\\text{ext}(t)R(s)=t∣t∈E(s),t=ext(t)。 容易发现根据定理 3.1，∀s∈S\\forall s\\in S∀s∈S，R(s)\\text{R}(s)R(s) 存在且唯一。 定理 3.2 t∈E(s)t\\in \\text{E}(s)t∈E(s) 当且仅当存在一个可空字符串 ccc 满足以下两者之一： sss 和 ttt 每次在 SSS 中出现都是以 tcstcstcs 的形式出现； sss 和 ttt 每次在 SSS 中出现都是以 sctsctsct 的形式出现； 根据定理 3.1 易得。 3.3 引入二维平面 将 SSS 的 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 个子串放在二维平面上，(i,j)(i,j)(i,j) 即第 iii 行第 jjj 列的点表示 S[i,j]S_{[i,j]}S[i,j]​。 若无特殊说明，(i,j)(i,j)(i,j) 等价于 S[i,j]S_{[i,j]}S[i,j]​。 定理 3.3（阶梯） 每个等价类中的字符串对应的坐标最小的点在二维平面中构成了一个的右、上边界与坐标轴平行，左、下边界呈阶梯状的图形。 注意：一个等价类构成的阶梯状图形可能会重复出现很多次。 根据定理 3.1 易得。 直观感受一下，这里以 S=abaabS=abaabS=abaab 为例： 相同颜色的串在同一个等价类中，这里一共有三个等价类。 定义 3.3（周长） 定义一个等价类 ggg 的周长 len(g)\\text{len}(g)len(g) 为 ggg 对应的阶梯状图形的宽度加上长度。 推论 3.3.1（凸性） 对于任意两行 (a,∗),(b,∗)(a,*),(b,*)(a,∗),(b,∗)，存在某个 iii 满足： ∀j≥i\\forall j\\ge i∀j≥i，(a,j)(a,j)(a,j) 与 (b,j)(b,j)(b,j) 在同一个等价类中； ∀j&lt;i\\forall j&lt;i∀j&lt;i，(a,j)(a,j)(a,j) 与 (b,j)(b,j)(b,j) 在同一个等价类中； 对于任意两列 (∗,a),(∗,b)(*,a),(*,b)(∗,a),(∗,b)，存在某个 iii 满足： ∀j≤i\\forall j\\le i∀j≤i，(j,a)(j,a)(j,a) 与 (j,b)(j,b)(j,b) 在同一个等价类中； ∀j&gt;i\\forall j&gt;i∀j&gt;i，(j,a)(j,a)(j,a) 与 (j,b)(j,b)(j,b) 在同一个等价类中； 即不存在这样的情况： 证明 由于 TTT 和 aTaTaT 在同一个等价类中，所以 endpos(T)=endpos(aT)\\text{endpos}(T)=\\text{endpos}(aT)endpos(T)=endpos(aT)。所以 TTT 每次都是以 aTaTaT 的形式出现的，那么 TbTbTb 每次肯定都是以 aTbaTbaTb 的形式出现的，根据定理 3.2，aTbaTbaTb 一定和 TbTbTb 在一个等价类中。 推论 3.3.2 ∀t∈S\\forall t\\in S∀t∈S，occ(t)\\text{occ}(t)occ(t) 等于 E(t)\\text{E}(t)E(t) 对应的阶梯型出现的次数。 3.4 与 SAM 的关系 和 SAM 联系起来。 3.4.1 与节点以及 parent 树中的边的关系 定理 3.4.1.1（与节点的关系） 对于某个等价类对应的阶梯形，每一列对应 T0T_0T0​ 中的一个节点，每一行对应 T1T_1T1​ 中的一个节点。 证明 单看一行，所有字符串都是最长的那个的前缀，所以这些字符串等价当且仅当它们的 srtpos\\text{srtpos}srtpos 相等。 单看一列，所有字符串都是最长的那个的后缀，所以这些字符串等价当且仅当它们的 endpos\\text{endpos}endpos 相等。 定理 3.4.1.2（与边的关系） 对于二维平面中的第 uuu 列，若 (u,i)(u,i)(u,i) 和 (u,i+1)(u,i+1)(u,i+1) 不在同一个等价类中则 (u,i+1)(u,i+1)(u,i+1) 对应的 T0T_0T0​ 中的节点是 (u,i)(u,i)(u,i) 对应的 T0T_0T0​ 中的节点的儿子； 对于二维平面中的第 uuu 行，若 (i,u)(i,u)(i,u) 和 (i+1,u)(i+1,u)(i+1,u) 不在同一个等价类中则 (i+1,u)(i+1,u)(i+1,u) 对应的 T1T_1T1​ 中的节点是 (i,u)(i,u)(i,u) 对应的 T1T_1T1​ 中的节点的儿子； 反过来： 在 T0T_0T0​ 上往父亲走相当于在平面上往上走到相邻的等价类； 在 T1T_1T1​ 上往父亲走相当于在平面上往右走到相邻的等价类； 直观一点：（T1T_1T1​ 上的连边在平面上的体现） 挺显然的，根据定理 3.4.1.1 立得。 推论 3.4.1（总周长线性） 对于所有等价类 ggg，len(g)\\text{len}(g)len(g) 的和是 O(∣S∣)O(|S|)O(∣S∣) 级别的。 注意：同一个等价类对应的阶梯状图形只算一次。 证明 len(g)\\text{len}(g)len(g) 的和相当于满足属于不同等价类的相邻点的对数，根据定理 3.4.1.2，这样的一对点对应着 T0T_0T0​ 或 T1T_1T1​ 中的一条边，由于 T0T_0T0​ 和 T1T_1T1​ 中的边的条数都是 O(∣S∣)O(|S|)O(∣S∣) 的，所以这样的点对也是 O(∣S∣)O(|S|)O(∣S∣) 的。 定理 3.4.1.3（同等价类同构） 对于在同一个等价类中的同一棵 parent 树上的节点 u,vu,vu,v，它们的子树同构。 即把它们的子树看作无标号有根树后节点一一对应，且对应的两个点满足：包含的串的个数，包含的串的 occ\\text{occ}occ 相同，它们在二维平面上的位置差（两横/竖条的横纵距离）和 u,vu,vu,v 在二维平面上的位置差相同。 证明 等价于对应的两个点在同一个等价类中。 根据定理 3.4.1.2，uuu 和 vvv 的子树中的点一定在 uuu 和 vvv 对应的横/竖条的上/右边，而根据推论 3.3.1，同一行/列且在同一个的两个点同时往上/右走后还在同一个等价类中。 3.4.2 再见，SAM 中的边 考虑正串 SAM 中的一条边，体现在二维平面上就是往右走，而反串 SAM 中的一条边体现在二维平面上就是往上走。 定理 3.4.2 对于 SAM 中的一条边，它连接的两个节点对应的横条/竖列在同一个等价类当且仅当它们中字符串的 endpos\\text{endpos}endpos 集合大小相同，且这样的边构成若干条链。 该定理根据定理 3.4.1.1 以及 SAM 的性质易得。 根据定理 3.4.2 和定理 3.4.1.2，容易发现正串 SAM 中的一条连接不同两个等价类的边等价于 T1T_1T1​ 中的一条边，反串 SAM 中的一条连接不同等价类的边等价于 T0T_0T0​ 中的一条边。 而若把一个等价类看作一个点，去掉自环，只保留每个等价类代表元的出边，那么 SAM 中的边就和另一棵 parent 树中的边一一对应了！ Part 4 实践 4.1 构建 先想清楚需要什么： 每个等价类的阶梯状结构（底边长、每个竖条的长度）； 每个等价类的代表元的第一次出现的左右端点； 不同等价类之间的连边： 只保留每个等价类代表元的出边； 横向边的和纵向边的分开； 边上标注上 SAM 中对应边的字符所在的可能的最小的位置（方便定位等价类的相对位置）； 根据定理 3.4.2，把正串 SAM 中满足连接的两个节点的 endpos\\text{endpos}endpos 集合大小相同的边抽出来，不妨把这些边叫做关键边。 找到这些关键边构成的若干条链，每条链对应了一个等价类： 链的长度（点数）就是等价类底边的长度，链中每个点对应等价类中的一竖条，点中字符串的个数就是对应竖条的长度。 链尾的点中最长的字符串就是这个等价类的代表元，第一次出现的右端点可以通过在 parent 树上做子树 min 得到，第一次出现的左端点可以通过第一次出现的右端点得出。 对于不同等价类之间的边，只需要通过哈希表找到代表元在正反串 SAM 中对应的节点 AAA 和 BBB（AAA 是正串 SAM 上的），AAA 的所有出边即为代表元横向的出边，BBB 的则为代表元纵向的出边。 每条出边的字符所在的可能的最小的位置就是出边指向的节点的 endpos\\text{endpos}endpos 集合中的最小值，可以通过在 parent 树上做子树 min 得到。 梳理一下流程： 建出正反 SAM，通过在 parent 树上做子树 min 得到每个节点的 endpos\\text{endpos}endpos 集合中的最小值； 在正 SAM 中找到满足连接的两个节点的 endpos\\text{endpos}endpos 集合大小相同的边构成的若干条链； 遍历一次所有链，对于每条链： 给这条链代表的等价类分配一个新的点 ididid，把链上节点都标记上 ididid； 得出链代表的等价类的宽度（链的长度）； 遍历一次链，得出链代表的等价类每一列的长度； 找到链尾节点 TTT 中最长的字符串第一次出现的位置 S[l,r]S_{[l,r]}S[l,r]​，在哈希表把 (l,r)(l,r)(l,r) 标记为 ididid； 再遍历一次所有链，对于每条链： 找到链代表的节点 AAA； 遍历链尾节点 TTT 的所有出边 uuu： 找到 uuu 连向的点的 endpos\\text{endpos}endpos 集合中的最小值 xxx； 找到 uuu 连向的点的标记 BBB； 从 AAA 向 BBB 连一条权值为 xxx 的横向边； 在反 SAM 中找到满足连接的两个节点的 endpos\\text{endpos}endpos 集合大小相同的边构成的若干条链； 遍历一次所有链，对于每条链： 找到链尾节点 TTT 中最长的字符串第一次出现的位置 S[l,r]S_{[l,r]}S[l,r]​，找到哈希表中 (l,r)(l,r)(l,r) 的标记 ididid（这条链代表的节点）； 把链上节点都标记上 ididid； 再遍历一次所有链，对于每条链： 找到链代表的节点 AAA； 遍历链尾节点 TTT 的所有出边 uuu： 找到 uuu 连向的点的 endpos\\text{endpos}endpos 集合中的最小值 xxx； 找到 uuu 连向的点的标记 BBB； 从 AAA 向 BBB 连一条权值为 xxx 的纵向边； 时间复杂度 O(n)O(n)O(n)，哈希表使用 map 实现则为 O(nlog⁡n)O(n\\log n)O(nlogn)。 看起来很复杂，但是看代码应该很好懂。 展开代码 struct SBOOK { int n; char str[S]; int tot; struct node { int l,r; // 代表元位置 vector&lt;int&gt; len; // 每一列的长度 vector&lt;pair&lt;int,int&gt;&gt; tor,tol; // 横向边，纵向边 }a[S*2]; int nxt[S*2],til[S*2],idx[S*2]; bool vis[S*2]; struct SAM { int lst; int cnt,len[S*2],to[S*2][V],link[S*2]; vector&lt;int&gt; son[S*2]; int siz[S*2],mnr[S*2]; inline void init() { for(int i=0;i&lt;=cnt;i++) { len[i]=link[i]=siz[i]=0; mnr[i]=1e8; memset(to[i],0,sizeof(to[i])); son[i].clear(); } cnt=lst=0; link[0]=-1; } inline void ins(int r,int x) { int pre=++cnt; len[pre]=len[lst]+1; int p=lst; while(p!=-1&amp;&amp;to[p][x]==0) to[p][x]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][x]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++cnt; len[cpy]=len[p]+1; siz[cpy]=0,mnr[cpy]=1e8; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][x]==q) to[p][x]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; siz[pre]=1; mnr[pre]=r; } inline void build(){for(int i=1;i&lt;=cnt;i++) son[link[i]].push_back(i);} void dfs(int u=0) { for(int v:son[u]) { dfs(v); siz[u]+=siz[v]; mnr[u]=min(mnr[u],mnr[v]); } } }sam[2]; struct HASH { int n; static const int mod=114547; vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt; vec[mod]; inline void init(int x) { n=x; for(int i=0;i&lt;mod;i++) vec[i].clear(); } inline void ins(pair&lt;int,int&gt; u,int val) { int idx=(1ll*u.first*n%mod+u.second)%mod; for(auto &amp;v:vec[idx]) if(v.first==u) return v.second=val,void(); vec[idx].push_back(make_pair(u,val)); } inline int que(pair&lt;int,int&gt; u) { int idx=(1ll*u.first*n%mod+u.second)%mod; for(auto &amp;v:vec[idx]) if(v.first==u) return v.second; return -1; } }mp; inline void build() { // 清空 for(int i=1;i&lt;=tot;i++) a[i].l=a[i].r=0,a[i].len.clear(),a[i].tor.clear(),a[i].tol.clear(); tot=0; mp.init(n); // 建正反 SAM &amp; 预处理节点 endpos 集合中最小值 sam[0].init(),sam[1].init(); for(int i=1;i&lt;=n;i++) sam[0].ins(i,str[i]-'a'); for(int i=n;i&gt;=1;i--) sam[1].ins(i,str[i]-'a'); sam[0].build(),sam[1].build(); sam[0].dfs(),sam[1].dfs(); // 正 SAM 找链 for(int i=1;i&lt;=sam[0].cnt;i++) nxt[i]=vis[i]=til[i]=0; for(int u=1;u&lt;=sam[0].cnt;u++) { for(int i=0;i&lt;V;i++) { int v=sam[0].to[u][i]; if(v!=0&amp;&amp;sam[0].siz[u]==sam[0].siz[v]) { nxt[u]=v; vis[v]=true; } } } // 正 SAM 第一次遍历链 for(int u=1;u&lt;=sam[0].cnt;u++) { if(!vis[u]) { tot++; int x=u; while(1) { idx[x]=tot; a[tot].len.push_back(sam[0].len[x]-sam[0].len[sam[0].link[x]]); if(nxt[x]==0) break; x=nxt[x]; } til[u]=x; a[tot].r=sam[0].mnr[x],a[tot].l=a[tot].r-sam[0].len[x]+1; mp.ins(make_pair(a[tot].l,a[tot].r),tot); } } // 正 SAM 第二次遍历链 for(int u=1;u&lt;=sam[0].cnt;u++) { if(!vis[u]) { int x=til[u]; for(int j=0;j&lt;V;j++) { int y=sam[0].to[x][j]; if(y==0) continue; int B=idx[y],val=sam[0].mnr[y]; a[idx[x]].tor.push_back(make_pair(B,val)); } } } // 反 SAM 找链 for(int i=1;i&lt;=sam[1].cnt;i++) nxt[i]=vis[i]=til[i]=0; for(int u=1;u&lt;=sam[1].cnt;u++) { for(int i=0;i&lt;V;i++) { int v=sam[1].to[u][i]; if(v!=0&amp;&amp;sam[1].siz[u]==sam[1].siz[v]) { nxt[u]=v; vis[v]=true; } } } // 反 SAM 第一次遍历链 for(int u=1;u&lt;=sam[1].cnt;u++) { if(!vis[u]) { int x=u; while(1) { if(nxt[x]==0) break; x=nxt[x]; } til[u]=x; int l=sam[1].mnr[x],r=l+sam[1].len[x]-1; int id=mp.que(make_pair(l,r)); x=u; while(x!=0) { idx[x]=id; x=nxt[x]; } } } // 反 SAM 第二次遍历链 for(int u=1;u&lt;=sam[1].cnt;u++) { if(!vis[u]) { int x=til[u]; for(int j=0;j&lt;V;j++) { int y=sam[1].to[x][j]; if(y==0) continue; int B=idx[y],val=sam[1].mnr[y]; a[idx[x]].tol.push_back(make_pair(B,val)); } } } } }; 4.2 例题 CF1817F Entangled Substrings 题解 建出基本子串结构后，合法的 aaa 和 bbb 一定在同一个等价类中且满足它们在 SSS 中第一次出现位置不交。 由于已知代表元第一次出现的位置，所以等价类中每个字符串的第一次出现的位置都是可以求出来的，由于阶梯型本身具有单调性，所以对于每个阶梯型做一遍双指针即可。 时间复杂度 O(n)O(n)O(n)。 核心代码： __int128 ans=0; for(int i=1;i&lt;=bok.tot;i++) { SBOOK::node &amp;pre=bok.a[i]; int m=pre.len.size(); int lb=pre.l,rb=pre.r-m+1; __int128 sm=0; for(int j=m-1,k=m;j&gt;=0;j--) { int pr=rb+j; while(k&gt;=1&amp;&amp;lb+pre.len[k-1]-1&gt;=pr) sm+=pre.len[--k]; ans+=pre.len[j]*(sm-1ll*(pr-lb+1)*(m-k)); } } 【2023NOI模拟赛35】字符串 ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"基本子串结构 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ji-ben-zi-chuan-jie-gou-xue-xi-bi-ji/","stats":{"text":"21 min read","time":1257000,"words":4600,"minutes":21},"date":"2023-08-15 15:26:18","dateFormat":"2023-08-15"},{"abstract":"<blockquote>\n<p>你有一个包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 共 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>。你必须执行恰好 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le k \\le n \\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>）次操作，每个操作都是以下两种其中之一：</p>\n<ul>\n<li>\n<p>将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">1, 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span></span></span></span> 个元素删去。</p>\n</li>\n<li>\n<p>将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi></mrow><mn>2</mn></mfrac><mo separator=\"true\">,</mo><mfrac><mrow><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{|S|}2, \\frac{|S|}2 + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∣</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mtight\">∣</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∣</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mtight\">∣</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个元素删去。（显然 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|S|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span></span></span></span> 一直是偶数，所以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{|S|}2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∣</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mtight\">∣</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 也一定是整数）</p>\n</li>\n</ul>\n<p>请你统计，通过这些操作可以获得多少个本质不同的最终集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>？答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n</blockquote>\n","content":" 你有一个包含 1∼2n1 \\sim 2n1∼2n 共 2n2n2n 个整数的集合 SSS。你必须执行恰好 kkk（1≤k≤n≤1061 \\le k \\le n \\le 10^61≤k≤n≤106）次操作，每个操作都是以下两种其中之一： 将 SSS 中第 1,21, 21,2 个元素删去。 将 SSS 中第 ∣S∣2,∣S∣2+1\\frac{|S|}2, \\frac{|S|}2 + 12∣S∣​,2∣S∣​+1 个元素删去。（显然 ∣S∣|S|∣S∣ 一直是偶数，所以 ∣S∣2\\frac{|S|}22∣S∣​ 也一定是整数） 请你统计，通过这些操作可以获得多少个本质不同的最终集合 SSS？答案对 998244353998244353998244353 取模。 Jerry Wen 定理。 考虑什么样的序列有可能得到（找必要条件），不妨关心被删除的数。 考虑被删除的数的连续段，由于每次是删除相邻两个数，所以每个连续段的长度一定是偶数。 不难发现，第一个连续段一定可以被操作一删掉，为了防止算重，不妨钦定第一个连续段是被操作一删掉的。而之后的连续段一定不能被操作一删掉，所以除了第一个之外的连续段都是被操作二删掉的。 继续观察，发现第 iii 次操作时中位数中较大的那个一定是 n+in+in+i，所以被删除的最大的数不超过 n+kn+kn+k。 发现操作二删除连续段有两种方式： ((()))((()))((())) 型，即不进行操作一，只进行操作二； ()()()()()()()()() 型，即一二交替； 发现只有第二个连续段可能使用第一种方式删除，且只有这种方式能删去 ≤n\\le n≤n 的数。所以若第二个连续段中第一个数为 ppp 且 p≤np\\le np≤n，则 [p,2n+1−p][p,2n+1-p][p,2n+1−p] 一定都在第二个连续段中。 考虑对于所有满足上述加粗条件的连续段集合 SSS，一定能构造出合法的操作序列：对于 SSS 中的每个连续段的右半部分，若中位数中较大的一个在其中则执行操作二，否则执行操作一。 那么只要数这样的 SSS 即可。 为了计数方便，设 f(n,m)f(n,m)f(n,m) 表示从 nnn 个数中选出 2m2m2m 个数且这些数构成的所有连续段长度均为偶数的方案数。这相当于从 n−mn-mn−m 个数中选出 mmm 个，每数再扩充成两个，所以 f(n,m)=(n−mm)f(n,m)=\\binom{n-m}{m}f(n,m)=(mn−m​)。 枚举第一段的长度 2i2i2i： 首先有可能剩下的所有连续段都是一二交替地删除的，即第二段的第一个数 &gt;n&gt;n&gt;n，这部分的方案数是 f(min⁡(k,k−2i+n−1),k−i)f(\\min(k,k-2i+n-1),k-i)f(min(k,k−2i+n−1),k−i)； 若 2i&lt;n2i&lt;n2i&lt;n 则第二段的第一个数有可能 ≤n\\le n≤n，那么需要枚举 ppp 即第二段的第一个数，方案数是： ∑p=2i+2nf(k−n+p−1,k−i−n−1+p)=∑p=2i+2nf(k−n+p−1,k−i−n+p−1)=∑p=2i+2n(ik−i−n+p−1)\\begin{aligned} \\sum\\limits_{p=2i+2}^nf(k-n+p-1,k-i-n-1+p)&amp;=\\sum\\limits_{p=2i+2}^nf(k-n+p-1,k-i-n+p-1)\\\\ &amp;=\\sum\\limits_{p=2i+2}^n\\binom{i}{k-i-n+p-1}\\\\ \\end{aligned} p=2i+2∑n​f(k−n+p−1,k−i−n−1+p)​=p=2i+2∑n​f(k−n+p−1,k−i−n+p−1)=p=2i+2∑n​(k−i−n+p−1i​)​ 发现相当于是求 ∑j=LiRi(ij)\\sum\\limits_{j=L_i}^{R_i} \\binom{i}{j}j=Li​∑Ri​​(ji​)，注意到 [Li,Ri][L_i,R_i][Li​,Ri​] 到 [Li+1,Ri+1][L_{i+1},R_{i+1}][Li+1​,Ri+1​] 两端指针的移动是 O(1)O(1)O(1) 的，并且若已知 sml=∑j=LiRi(i−1j)sml=\\sum\\limits_{j=L_i}^{R_i} \\binom{i-1}{j}sml=j=Li​∑Ri​​(ji−1​) 也可以快速求出 smp=∑j=LiRi(ij)smp=\\sum\\limits_{j=L_i}^{R_i} \\binom{i}{j}smp=j=Li​∑Ri​​(ji​) 因为 smp=2sml+(i−1Li−1)−(i−1Ri)smp=2sml+\\binom{i-1}{L_i-1}-\\binom{i-1}{R_i}smp=2sml+(Li​−1i−1​)−(Ri​i−1​)，那么双指针维护即可； 时间复杂度 O(n)O(n)O(n)，代码如下： // Problem: Minimums or Medians // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1784F // Memory Limit: 500 MB // Time Limit: 4000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; int mod; // fastmod struct mint { int val; inline mint(){val=0;} operator int(){return val;} template&lt;typename T&gt;inline mint(T x){val=(x%mod+mod)%mod;} inline mint operator-(){return mod-val;} template&lt;typename T&gt;inline mint operator^(T b) { mint tmp=*this,res=1; for(;b&gt;0;b&gt;&gt;=1,tmp*=tmp) res=b&amp;1?res*tmp:res; return res; } template&lt;typename T&gt;inline mint operator^=(T b){return *this=*this^b;} inline mint inv(){return this-&gt;operator^(mod-2);} inline mint operator+(mint b){return val+b.val-(val+b.val&gt;=mod?mod:0);} inline mint operator-(mint b){return val-b.val+(val-b.val&lt;0?mod:0);} inline mint operator*(mint b){return 1ll*val*b.val%mod;} inline mint operator/(mint b){return 1ll*val*b.inv().val%mod;} inline mint operator+=(mint b){return val=val+b.val-(val+b.val&gt;=mod?mod:0);} inline mint operator-=(mint b){return val=val-b.val+(val-b.val&lt;0?mod:0);} inline mint operator*=(mint b){return val=1ll*val*b.val%mod;} inline mint operator/=(mint b){return val=1ll*val*b.inv().val%mod;} template&lt;typename T&gt;inline mint operator+(T b){return this-&gt;operator+(mint(b));}; template&lt;typename T&gt;inline mint operator-(T b){return this-&gt;operator-(mint(b));}; template&lt;typename T&gt;inline mint operator*(T b){return this-&gt;operator*(mint(b));}; template&lt;typename T&gt;inline mint operator/(T b){return this-&gt;operator/(mint(b));}; template&lt;typename T&gt;inline mint operator+=(T b){return this-&gt;operator+=(mint(b));}; template&lt;typename T&gt;inline mint operator-=(T b){return this-&gt;operator-=(mint(b));}; template&lt;typename T&gt;inline mint operator*=(T b){return this-&gt;operator*=(mint(b));}; template&lt;typename T&gt;inline mint operator/=(T b){return this-&gt;operator/=(mint(b));}; }; using namespace std; const int S=10000005; mint fra[S],inv[S]; int n,k; inline mint C(int n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return fra[n]*inv[n-m]*inv[m]; } inline mint f(int n,int m) { return C(n-m,m); } int main() { mod=998244353; fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=fra[i-1]*i; inv[S-3]=fra[S-3].inv(); for(int i=S-3;i&gt;=1;i--) inv[i-1]=inv[i]*i; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); mint ans=0; int lb=1,rb=0,pr=-1; mint sum=0; for(int i=0;i&lt;=k;i++) { ans+=i==n?(mint)1:f(min(k,k-i*2+n-1),k-i); if(i*2&lt;n) { int L=k-n+i+1,R=k-i-1; if(pr&gt;=0) sum=sum*2+C(pr,lb-1)-C(pr,rb); pr++; while(lb&gt;L) sum+=C(pr,--lb); while(rb&lt;R) sum+=C(pr,++rb); while(lb&lt;L) sum-=C(pr,lb++); while(rb&gt;R) sum-=C(pr,rb--); ans+=sum; } } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1784F Minimums or Medians 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1784f-minimums-or-medians-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":500000,"words":1642,"minutes":9},"date":"2023-08-12 15:09:59","dateFormat":"2023-08-12"},{"abstract":"<blockquote>\n<p>一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向带权简单连通图，其上一条路径的权值为其中所有边权的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>max</mi><mo>⁡</mo></mrow><annotation encoding=\"application/x-tex\">\\max</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mop\">max</span></span></span></span>。</p>\n<p>考虑这张图的补图，补图中一条边的权值为原图中该边两端点间的最短路（路径长度的定义同上）。保证补图亦是连通图。</p>\n<p>对于原图中每条边，求出其两端点在补图中的最短路（定义仍同上）。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，边权范围 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,10^9]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>。</p>\n</blockquote>\n","content":" 一张 nnn 个点 mmm 条边的无向带权简单连通图，其上一条路径的权值为其中所有边权的 max⁡\\maxmax。 考虑这张图的补图，补图中一条边的权值为原图中该边两端点间的最短路（路径长度的定义同上）。保证补图亦是连通图。 对于原图中每条边，求出其两端点在补图中的最短路（定义仍同上）。 1≤n,m≤2×1051\\le n,m\\le 2\\times 10^51≤n,m≤2×105，边权范围 [0,109][0,10^9][0,109]。 下文所有最短路的定义都与题目中一致。 建出 kruskal 重构树，那么两点间的最短路就是它们 lca 的权值，而 lca 越深权值越小，所以在重构树的 dfn 序中到 uuu 的最短路最小的点一定是 uuu 左边离它最近的点或 uuu 右边离它最近的点。 考虑找出补图的最小生成树，易证明两点在补图中的最短路等与它们在补图的最小生成树中的最短路。 发现补图是个稠密图，所以考虑 Boruvka 算法。 考虑怎么找到补图中距离某个连通块最近的点，可以转化为求出补图中到每个点最近的点。考虑给 nnn 个点按照 dfs 序排序，那么相当于找到 uuu 左边和右边最近的不在 uuu 的连通块且在原图中与 uuu 没有直接连边的点。这个可以考虑预处理同一个连通块的连续段，对于点 uuu，直接暴力往左往右依次找，遇到连续的与 uuu 在同一个连通块的点就直接快速跳，遇到和 uuu 有直接连边的点就跳过。 这样做的话 Boruvka 一轮时间复杂度是 O(m)O(m)O(m)，那么总时间复杂度为 O(mlog⁡n)O(m\\log n)O(mlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; // fastI template&lt;typename T&gt; inline void read(T &amp;x) { x=0; bool fl=false; char c=getchar(); while(c&lt;'0'||c&gt;'9') fl^=c=='-',c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+(c^48),c=getchar(); x=fl?-x:x; } template&lt;&gt;inline void read&lt;char&gt;(char &amp;x) { x=getchar(); while(x==' '||x=='\\r'||x=='\\n') x=getchar(); } inline void read(){return;}; template&lt;typename T,typename ...Args&gt; inline void read(T &amp;x,Args&amp;...args){read(x),read(args...);} // fastO template&lt;typename T&gt; void write(T x){x&gt;9?write(x/10),putchar(x%10|48):putchar(x%10|48);} template&lt;&gt;inline void write&lt;char&gt;(char x){putchar(x);} template&lt;typename T,typename ...Args&gt; inline void write(T x,Args...args){write(x),write(args...);} const int S=200005,TS=400005,BS=25; struct node { int x,y,w,id; }ed[S],ed2[S]; int n,m; int fa[TS]; int cnt,b[TS]; vector&lt;int&gt; son[TS]; int fat[TS],dep[TS],tot,dfn[TS],a[TS],mlog[TS],mn[TS][BS]; vector&lt;int&gt; vc[S]; int pp[S]; int lb[S],rb[S],el[S],er[S],nxt[S],lst[S]; int mnl[S],mnr[S],mnlu[S],mnru[S],mnlv[S],mnrv[S]; int m2; int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } void dfs(int u,int fa) { fat[u]=fa; dep[u]=dep[fa]+1; a[dfn[u]=++tot]=u; for(int v:son[u]) dfs(v,u); } inline void initlca() { mlog[0]=-1; for(int i=1;i&lt;=tot;i++) mlog[i]=mlog[i&gt;&gt;1]+1,mn[i][0]=i; for(int j=1;j&lt;=mlog[tot];j++) { for(int i=1;i&lt;=tot-(1&lt;&lt;j)+1;i++) { int x=mn[i][j-1],y=mn[i+(1&lt;&lt;j-1)][j-1]; mn[i][j]=dep[a[x]]&lt;dep[a[y]]?x:y; } } } inline int quelca(int x,int y) { if(x==y) return x; x=dfn[x],y=dfn[y]; if(x&gt;y) swap(x,y); x++; int k=mlog[y-x+1]; int aa=mn[x][k],bb=mn[y-(1&lt;&lt;k)+1][k]; if(dep[a[aa]]&lt;dep[a[bb]]) return fat[a[aa]]; else return fat[a[bb]]; } inline void kruskal(node *ed,int m) { for(int i=1;i&lt;=n*2;i++) son[i].clear(); sort(ed+1,ed+m+1,[&amp;](node x,node y){return x.w&lt;y.w;}); for(int i=1;i&lt;=n*2;i++) fa[i]=i; cnt=n; for(int i=1;i&lt;=n;i++) b[i]=0; for(int i=1;i&lt;=m;i++) { int x=ed[i].x,y=ed[i].y; int rx=fnd(x),ry=fnd(y); if(rx==ry) continue; fa[rx]=fa[ry]=++cnt; son[cnt].push_back(rx),son[cnt].push_back(ry); b[cnt]=ed[i].w; } tot=0; dfs(cnt,0); initlca(); } inline void boruvka() { for(int i=1;i&lt;=n;i++) vc[i].clear(); for(int i=1;i&lt;=n;i++) pp[i]=i; sort(pp+1,pp+n+1,[&amp;](int x,int y){return dfn[x]&lt;dfn[y];}); for(int i=1;i&lt;=m;i++) vc[ed[i].x].push_back(ed[i].y),vc[ed[i].y].push_back(ed[i].x); for(int i=1;i&lt;=n;i++) sort(vc[i].begin(),vc[i].end(),[&amp;](int x,int y){return dfn[x]&lt;dfn[y];}); m2=0; for(int i=1;i&lt;=n;i++) fa[i]=i; while(1) { for(int i=1;i&lt;=n;i++) { int j=i; while(j&lt;n&amp;&amp;fnd(pp[j+1])==fnd(pp[i])) j++; for(int k=i;k&lt;=j;k++) lb[pp[k]]=i-1,rb[pp[k]]=j+1; nxt[i]=j,lst[j]=i; i=j; } if(nxt[1]==n) break; for(int i=1;i&lt;=n;i++) { el[i]=vc[i].size()-1; for(int j=0;j&lt;vc[i].size();j++) { if(dfn[vc[i][j]]&gt;dfn[pp[lb[i]]]) { el[i]=j-1; break; } } er[i]=0; for(int j=vc[i].size()-1;j&gt;=0;j--) { if(dfn[vc[i][j]]&lt;dfn[pp[rb[i]]]) { er[i]=j+1; break; } } } for(int i=1;i&lt;=n;i++) mnlv[i]=mnrv[i]=2e9; for(int i=1;i&lt;=n;i++) { int x=pp[i]; while(lb[x]&gt;=1&amp;&amp;(el[x]&gt;=0&amp;&amp;vc[x][el[x]]==pp[lb[x]])) { lb[x]--,el[x]--; if(lb[x]&gt;=1&amp;&amp;fnd(pp[lb[x]])==fnd(x)) lb[x]=lst[lb[x]]-1; while(el[x]&gt;0&amp;&amp;dfn[vc[x][el[x]-1]]&gt;=dfn[pp[lb[x]]]) el[x]--; } if(lb[x]&gt;=1&amp;&amp;b[quelca(pp[lb[x]],x)]&lt;mnlv[fnd(x)]) { mnl[fnd(x)]=pp[lb[x]]; mnlu[fnd(x)]=x; mnlv[fnd(x)]=b[quelca(pp[lb[x]],x)]; } while(rb[x]&lt;=n&amp;&amp;(er[x]&lt;=vc[x].size()-1&amp;&amp;vc[x][er[x]]==pp[rb[x]])) { rb[x]++,er[x]++; if(rb[x]&lt;=n&amp;&amp;fnd(pp[rb[x]])==fnd(x)) rb[x]=nxt[rb[x]]+1; while(er[x]&lt;vc[x].size()-1&amp;&amp;dfn[vc[x][er[x]+1]]&lt;=dfn[pp[rb[x]]]) er[x]++; } if(rb[x]&lt;=n&amp;&amp;b[quelca(pp[rb[x]],x)]&lt;mnrv[fnd(x)]) { mnr[fnd(x)]=pp[rb[x]]; mnru[fnd(x)]=x; mnrv[fnd(x)]=b[quelca(pp[rb[x]],x)]; } } for(int i=1;i&lt;=n;i++) { if(fa[i]==i) { if(mnlv[i]&lt;mnrv[i]) { int p=mnl[i]; if(fnd(p)!=i) { ed2[++m2]={p,mnlu[i],mnlv[i],0}; fa[fnd(p)]=i; } } else { int p=mnr[i]; if(fnd(p)!=i) { ed2[++m2]={p,mnru[i],mnrv[i],0}; fa[fnd(p)]=i; } } } } } } inline void slove() { read(n,m); for(int i=1;i&lt;=m;i++) read(ed[i].x,ed[i].y,ed[i].w),ed[i].id=i; kruskal(ed,m); boruvka(); kruskal(ed2,m2); sort(ed+1,ed+m+1,[&amp;](node x,node y){return x.id&lt;y.id;}); for(int i=1;i&lt;=m;i++) write(b[quelca(ed[i].x,ed[i].y)],' '); write('\\n'); } int main() { int T; read(T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1648E Air Reform 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1648e-air-reform-zuo-ti-ji-lu/","stats":{"text":"10 min read","time":541000,"words":1644,"minutes":10},"date":"2023-08-12 09:43:51","dateFormat":"2023-08-12"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mclose\">]</span></span></span></span> 中均匀随机的整数随机变量 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{1\\sim n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">∼</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，求一个最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">ans</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">s</span></span></span></span> 满足找不出：</p>\n<ul>\n<li>一组非负整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">y_{1\\sim n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">∼</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">ans=\\sum x_iy_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n</ul>\n<p>满足有解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>50</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">50\\le n\\le 10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le m\\le 10^8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个在 [1,m][1,m][1,m] 中均匀随机的整数随机变量 a1∼na_{1\\sim n}a1∼n​，求一个最大的 ansansans 满足找不出： 一组非负整数 y1∼ny_{1\\sim n}y1∼n​ 满足 ans=∑xiyians=\\sum x_iy_ians=∑xi​yi​。 满足有解。 50≤n≤10750\\le n\\le 10^750≤n≤107，2≤m≤1082\\le m\\le 10^82≤m≤108。 设 mn=min⁡{ai}mn=\\min\\{a_i\\}mn=min{ai​}，考虑以 mnmnmn 为模跑同余最短路，则 disi+k×mndis_i+k\\times mndisi​+k×mn 都能被表示出来，所以答案为 max⁡{disi−mn}\\max\\{dis_i-mn\\}max{disi​−mn}。 由于数据随机，所以 mnmnmn 的期望为 mn+1\\frac{m}{n+1}n+1m​，同余最短路时间复杂度为 O(mn+1nlog⁡mn+1)O(\\frac{m}{n+1}n\\log \\frac{m}{n+1})O(n+1m​nlogn+1m​) 但是跑不满，所以能过。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;random&gt; #include &lt;queue&gt; using namespace std; const int S=10000005,MS=2000005; int n,m,seed,a[S]; int dis[MS]; bool vis[MS]; priority_queue&lt;pair&lt;int,int&gt;&gt; q; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;seed); mt19937 rng(seed); auto get=[&amp;]() { uniform_int_distribution&lt;int&gt; qwq(2,m); return qwq(rng); }; int mn=m; for(int i=1;i&lt;=n;i++) mn=min(mn,a[i]=get()); for(int i=0;i&lt;mn;i++) dis[i]=1e9; dis[0]=0; q.push(make_pair(0,0)); while(!q.empty()) { int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=true; for(int i=1;i&lt;=n;i++) { int v=(u+a[i])%mn; if(dis[u]+a[i]&lt;dis[v]) { dis[v]=dis[u]+a[i]; q.push(make_pair(-dis[v],v)); } } } int ans=0; for(int i=0;i&lt;mn;i++) ans=max(ans,dis[i]-mn); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"【2023NOIP模拟赛09】补幺梨 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noip-mo-ni-sai-09-bu-yao-li-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":129000,"words":392,"minutes":3},"date":"2023-08-08 21:10:34","dateFormat":"2023-08-08"},{"abstract":"","content":"数学期望和组合计数有许多共通之处，可以看作是带系数的计数。 Part 1 记号和定义 在本文中： 仅讨论在值域中均匀随机的随机变量； 设 xxx 为某随机变量，即取值在值域中随机的变量，则 Px(i)P_x(i)Px​(i) 为 xxx 取到 iii 的概率； 设 xxx 为某随机变量，则 E(x)\\mathbb E(x)E(x) 表示 xxx 的期望值，即 ∑ii⋅Px(i)\\sum\\limits_{i} i\\cdot P_x(i)i∑​i⋅Px​(i) 或 ∫i⋅Px(i) di\\int i\\cdot P_x(i)\\,di∫i⋅Px​(i)di； Part 2 性质和技巧 把期望看作带系数计数 与 考虑组合意义 都是常用的推导方法。 2.0 约定 证明中只用到了 ∑\\sum∑ 且没有特殊说明：这里只证明值域离散（随机变量只能取整数）的情况下的性质，值域连续（随机变量可以取实数）的情况下也有这些性质，将这些证明中的 ∑i\\sum\\limits_{i}i∑​ 换成 ∫ di\\int\\,di∫di 即可证明； 证明中用到了 ∫\\int∫ 且没有特殊说明：这些性质只有在值域连续的情况下才能存在； 2.1 基础性质 设 xxx 和 yyy 为某两随机变量（不一定无关，即它们可能会互相影响）。 可加性： E(x+y)=E(x)+E(y)\\mathbb E(x+y)=\\mathbb E(x)+\\mathbb E(y) E(x+y)=E(x)+E(y) 证明 E(x+y)=∑ii⋅∑jPx(j)Py(i−j)=∑jPx(j)∑kPy(k)⋅(j+k)=∑jj⋅Px(j)+∑kk⋅Py(k)\\begin{aligned} \\mathbb E(x+y)&amp;=\\sum\\limits_{i} i\\cdot \\sum \\limits_{j}P_x(j)P_y(i-j)\\\\ &amp;=\\sum\\limits_{j}P_x(j)\\sum\\limits_{k}P_y(k)\\cdot(j+k)\\\\ &amp;=\\sum\\limits_{j}j\\cdot P_x(j)+\\sum\\limits_{k}k\\cdot P_y(k) \\end{aligned} E(x+y)​=i∑​i⋅j∑​Px​(j)Py​(i−j)=j∑​Px​(j)k∑​Py​(k)⋅(j+k)=j∑​j⋅Px​(j)+k∑​k⋅Py​(k)​ Q.E.D. 线性性： 对于某常数 α\\alphaα，有： E(αx)=αE(x)\\mathbb E(\\alpha x)=\\alpha \\mathbb E(x) E(αx)=αE(x) 证明 E(αx)=∑iα⋅Px(i)=α∑ii⋅Px(i)=αE(x)\\mathbb E(\\alpha x)=\\sum\\limits_{i}\\alpha \\cdot P_x(i)=\\alpha\\sum\\limits_{i}i\\cdot P_x(i)=\\alpha\\mathbb E(x) E(αx)=i∑​α⋅Px​(i)=αi∑​i⋅Px​(i)=αE(x) Q.E.D. 无关可乘性： 若 xxx 与 yyy 无关，即一个的取值不会影响到另一个，则有： E(xy)=E(x)⋅E(y)\\mathbb E(xy)=\\mathbb E(x)\\cdot\\mathbb E(y) E(xy)=E(x)⋅E(y) 证明 E(xy)=∑i∑jij⋅Px(i)Py(j)=E(x)⋅E(y)\\mathbb E(xy)=\\sum\\limits_{i}\\sum\\limits_{j}ij\\cdot P_x(i)P_y(j)=\\mathbb E(x)\\cdot \\mathbb E(y) E(xy)=i∑​j∑​ij⋅Px​(i)Py​(j)=E(x)⋅E(y) Q.E.D. 2.2 常用技巧 若无特殊说明，公式中出现的变量均为随机变量。 发生事件期望所需次数： 若某事件每次发生的概率为 aaa，其中 aaa 是一个确定的实数，则发生该事件所需的期望次数为 1a\\frac{1}{a}a1​。 证明 E=a+(1−a)(E+1)E=a+E+1−aE−aaE=1E=1a\\mathbb E=a+(1-a)(\\mathbb E+1)\\\\ \\mathbb E=a+\\mathbb E+1-a\\mathbb E-a\\\\ a\\mathbb E=1\\\\ \\mathbb E=\\frac{1}{a} E=a+(1−a)(E+1)E=a+E+1−aE−aaE=1E=a1​ Q.E.D. 分配： E((a+b)(c+d))=E(ac)+E(ad)+E(bc)+E(bd)\\mathbb E((a+b)(c+d))=\\mathbb E(ac)+\\mathbb E(ad)+\\mathbb E(bc)+\\mathbb E(bd) E((a+b)(c+d))=E(ac)+E(ad)+E(bc)+E(bd) E(∏i=1n∑j=1mxi,j)=E(x1,1×x2,1×⋯×xn,1)+E(x1,2×x2,1×⋯×xn,1)+⋯+E(x1,m×x2,m×⋯×xn,m)\\mathbb E\\left(\\prod\\limits_{i=1}^n\\sum\\limits_{j=1}^m x_{i,j}\\right)=\\\\ \\mathbb E(x_{1,1}\\times x_{2,1}\\times \\dots \\times x_{n,1})+E(x_{1,2}\\times x_{2,1}\\times \\dots \\times x_{n,1})+\\dots+E(x_{1,m}\\times x_{2,m}\\times \\dots \\times x_{n,m}) E(i=1∏n​j=1∑m​xi,j​)=E(x1,1​×x2,1​×⋯×xn,1​)+E(x1,2​×x2,1​×⋯×xn,1​)+⋯+E(x1,m​×x2,m​×⋯×xn,m​) 即每一个 E()\\mathbb E()E() 中一共有 nnn 项相乘，第 iii 项可以是 xi,[1,m]x_{i,[1,m]}xi,[1,m]​ 中的任意一个。 拆括号后运用期望的可加性即可证明，第二条是第一条的拓展。 nnn 个值域相同的随机变量的第 kkk 小值的期望： 设 nnn 个在 [0,1][0,1][0,1] 间的连续随机变量 x1∼nx_{1\\sim n}x1∼n​，则 E(kth-mink{xi})=kn+1\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)=\\frac{k}{n+1}E(kth-mink​{xi​})=n+1k​。 设 nnn 个在 [1,m][1,m][1,m] 间的离散随机变量 x1∼nx_{1\\sim n}x1∼n​，则 E(kth-mink{xi})=kmn+1\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)=\\frac{km}{n+1}E(kth-mink​{xi​})=n+1km​。 证明 先证明第一条。 引入另一个 [0,1][0,1][0,1] 间的连续随机变量 yyy，设 P(i)P(i)P(i) 为 i≤kth-mink{xi}i\\le\\text{kth-min}_k\\{x_i\\}i≤kth-mink​{xi​} 的概率，那么 E(kth-mink{xi})=∫01P(i) di1=P(y)\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)=\\frac{\\int_0^1 P(i)\\,di}{1}=P(y)E(kth-mink​{xi​})=1∫01​P(i)di​=P(y)。 考虑给所有随机变量升序排序，相同则按原来的位置排，那么一共有 (n+1)!(n+1)!(n+1)! 种顺序，其中 yyy 排在前 kkk 位的一共有 kn!kn!kn! 种顺序，具体的考虑插入即可。 那么 P(y)=kn!(n+1)!=kn+1=E(kth-mink{xi})P(y)=\\frac{kn!}{(n+1)!}=\\frac{k}{n+1}=\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)P(y)=(n+1)!kn!​=n+1k​=E(kth-mink​{xi​})。 第二条相当于第一条把 xix_ixi​ 乘上 mmm 然后取整转化为离散情况。 Q.E.D. Part 3 例题 3.1 期望参与答案计算 CF1523E Crypto Lights | 题解 CF1278F Cards 查看题解 考虑设第 iii 次洗牌后第一张牌的情况为 xix_ixi​（是王牌则 xi=1x_i=1xi​=1，否则 xi=0x_i=0xi​=0），那么显然 E(xi)=1m\\mathbb E(x_i)=\\frac{1}{m}E(xi​)=m1​。 发现答案等价于 E((∑i=1nxi)k)\\mathbb E\\left(\\left(\\sum\\limits_{i=1}^n x_i\\right)^k\\right)E((i=1∑n​xi​)k)，根据 2.2 中的分配技巧，这个东西相当于： E(x1k)+E(x1k−1x2)+⋯+E(xnk)\\mathbb E(x_1^k)+\\mathbb E(x_1^{k-1}x_2)+\\dots+\\mathbb E(x_n^k) E(x1k​)+E(x1k−1​x2​)+⋯+E(xnk​) 即每一个 E()\\mathbb E()E() 中一共有 kkk 项相乘，第 iii 项可以是 x[1,n]x_{[1,n]}x[1,n]​ 中的任意一个。 考虑一项一项填入 E()\\mathbb E()E() 中，由于不同的 xpx_pxp​ 互相独立且本质相同，则 ∀p1=p2,E(xp1xp2)=E(xp1)E(xp2)=1m2\\forall p_1\\not=p_2,\\mathbb E(x_{p_1}x_{p_2})=\\mathbb E(x_{p_1})\\mathbb E(x_{p_2})=\\frac{1}{m^2}∀p1​​=p2​,E(xp1​​xp2​​)=E(xp1​​)E(xp2​​)=m21​。而相同的 xpx_pxp​ 取值肯定一样，那么我们只需要关心有多少个不同的 xpx_pxp​。 设 fi,jf_{i,j}fi,j​ 表示确定了前 iii 项，其中一共有 jjj 个不同的 xpx_pxp​。显然 f0,0=1f_{0,0}=1f0,0​=1，转移考虑下一位填入的 xpx_pxp​ 是否出现过： fi,j=fi−1,j×j+fi−1,j−1×(n−j+1)×1mf_{i,j}=f_{i-1,j}\\times j+f_{i-1,j-1}\\times (n-j+1)\\times \\frac{1}{m} fi,j​=fi−1,j​×j+fi−1,j−1​×(n−j+1)×m1​ 最后答案即为 ∑i=0kfk,i\\sum\\limits_{i=0}^k f_{k,i}i=0∑k​fk,i​。 时间复杂度 O(k2)O(k^2)O(k2)。 CF1842G Tenzing and Random Operations 3.2 期望参与时间复杂度计算 【2023NOIP模拟赛09】补幺梨 ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"数学期望学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/shu-xue-qi-wang-xue-xi-bi-ji/","stats":{"text":"10 min read","time":540000,"words":1801,"minutes":10},"date":"2023-08-08 20:50:23","dateFormat":"2023-08-08"},{"abstract":"<blockquote>\n<p>给定一个如图所示的计算方法：</p>\n<figure data-type=\"image\" tabindex=\"1\"><img src=\"https://www.ckjweb.tk/post-images/1691492484006.webp\" alt=\"\" loading=\"lazy\"></figure>\n<p>现在给定长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，要求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>sum</mtext><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{sum}(a,l_i,r_i,p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">sum</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span></span></span></span> 的值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>p</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le p\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">|a_i|\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个如图所示的计算方法： 现在给定长 nnn 的数组 aaa 和 ppp，要求 qqq 次询问 sum(a,li,ri,p)\\text{sum}(a,l_i,r_i,p)sum(a,li​,ri​,p) 的值。 1≤n≤1061\\le n\\le 10^61≤n≤106，1≤m≤2×1051\\le m\\le 2\\times 10^51≤m≤2×105，1≤p≤1091\\le p\\le 10^91≤p≤109，∣ai∣≤109|a_i|\\le 10^9∣ai​∣≤109。 设 F(x,l,r)F(x,l,r)F(x,l,r) 表示 xxx 经过区间 [l,r][l,r][l,r] 后要减多少次 ppp，发现这个是分成 r−l+1r-l+1r−l+1 段的分段函数。 直接线段树，设 cu,xc_{u,x}cu,x​ 表示最小的 xxx 满足经过节点 uuu 对应的区间后减了 xxx 次 ppp，那么空间复杂度是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，询问时可以直接二分找到应该减去的值，单次询问时间复杂度 O(nlog⁡2n)O(n\\log ^2n)O(nlog2n)。 考虑如何合并 uuu 的左右儿子，cls,xc_{ls,x}cls,x​ 和 crs,yc_{rs,y}crs,y​ 可以贡献到 cu,x+yc_{u,x+y}cu,x+y​ 当且仅当： cls,x+1−1+sumls−xp≥crs,yc_{ls,x+1}-1+sum_{ls}-xp\\ge c_{rs,y} cls,x+1​−1+sumls​−xp≥crs,y​ 因为在区间 cls,x+1−1c_{ls,x+1}-1cls,x+1​−1 是经过左区间要减 xxx 次 ppp 的最大的数。 那么对于一对合法的 x,yx,yx,y 有： cu,x+y=min⁡(cu,x+y,max⁡(cls,x,crs,y−sumls+xp))c_{u,x+y}=\\min(c_{u,x+y},\\max(c_{ls,x},c_{rs,y}-sum_{ls}+xp)) cu,x+y​=min(cu,x+y​,max(cls,x​,crs,y​−sumls​+xp)) 但是直接做是 O(n2)O(n^2)O(n2) 的，发现： cu,x+1≥cu,x+pc_{u,x+1}\\ge c_{u,x}+p cu,x+1​≥cu,x​+p 因为 cu,xc_{u,x}cu,x​ 是减 xxx 次 ppp 的最小的数，它经过区间时每一次 MODADDMODADDMODADD 的结果的最大值一定是 000，那么想要让它减多一次 ppp 就至少要给它加上 ppp。 那么对于合法的 x,yx,yx,y，设 f(x,y)=max⁡(cls,x,crs,y−sumls+xp)f(x,y)=\\max(c_{ls,x},c_{rs,y}-sum_{ls}+xp)f(x,y)=max(cls,x​,crs,y​−sumls​+xp)，则一定有： f(x,y)&lt;f(x+1,y−1)f(x,y)&lt;f(x+1,y-1) f(x,y)&lt;f(x+1,y−1) 因为： cls,x+1−1+sumls−xp≥crs,ycrs,y−sumls+xp+1≤cls,x+1crs,y−sumls+xp&lt;cls,x+1c_{ls,x+1}-1+sum_{ls}-xp\\ge c_{rs,y}\\\\ c_{rs,y}-sum_{ls}+xp+1\\le c_{ls,x+1}\\\\ c_{rs,y}-sum_{ls}+xp&lt;c_{ls,x+1}\\\\ cls,x+1​−1+sumls​−xp≥crs,y​crs,y​−sumls​+xp+1≤cls,x+1​crs,y​−sumls​+xp&lt;cls,x+1​ 所以 f(x,y)&lt;cls,x+1=f(x+1,y−1)f(x,y)&lt;c_{ls,x+1}=f(x+1,y-1)f(x,y)&lt;cls,x+1​=f(x+1,y−1)。 由于 cu,x+1≥cu,x+pc_{u,x+1}\\ge c_{u,x}+pcu,x+1​≥cu,x​+p 所以若 x,yx,yx,y 合法则 x+1,yx+1,yx+1,y 也一定合法，那么能动 yyy 就尽量先动 yyy 即可。 时间复杂度 O(nlog⁡n+mlog⁡2n)O(n\\log n+m\\log^2n)O(nlogn+mlog2n)，代码如下： // Problem: Nauuo and Bug // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1172F // Memory Limit: 1000 MB // Time Limit: 4000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=1000005; int n,m; long long p,a[S]; long long sum[S&lt;&lt;2]; vector&lt;long long&gt; c[S&lt;&lt;2]; inline void merge(int u) { int ls=u&lt;&lt;1,rs=u&lt;&lt;1|1; sum[u]=sum[ls]+sum[rs]; int lc=c[ls].size()-1,rc=c[rs].size()-1; for(int i=1;i&lt;=lc+rc;i++) c[u][i]=1e17; for(int x=0,y=0;x&lt;=lc;x++) { if(y&gt;rc) y--; while(y&lt;=rc) { if(x!=lc&amp;&amp;c[ls][x+1]-1+sum[ls]-x*p&lt;c[rs][y]) { if(y&gt;0) y--; break; } c[u][x+y]=min(c[u][x+y],max(c[ls][x],c[rs][y]-sum[ls]+x*p)); y++; } } } void build(int u,int l,int r) { c[u]=vector&lt;long long&gt;(r-l+2,0); c[u][0]=-1e17; if(l==r) return sum[u]=a[l],c[u][1]=p-a[l],void(); int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r); merge(u); } long long que(int u,int l,int r,int L,int R,long long val) { if(l&gt;R||r&lt;L) return val; if(l&gt;=L&amp;&amp;r&lt;=R) return val+sum[u]-(upper_bound(c[u].begin(),c[u].end(),val)-c[u].begin()-1)*p; int mid=l+r&gt;&gt;1; return que(u&lt;&lt;1|1,mid+1,r,L,R,que(u&lt;&lt;1,l,mid,L,R,val)); } int main() { scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;m,&amp;p); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); build(1,1,n); while(m--) { int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%lld\\n&quot;,que(1,1,n,l,r,0)); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF1172F Nauuo and Bug & P5609 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1172f-nauuo-and-bug-and-p5609-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":387000,"words":1160,"minutes":7},"date":"2023-08-08 18:59:20","dateFormat":"2023-08-08"},{"abstract":"<blockquote>\n<p>你有一个长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_1,x_2,\\dots,x_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，一开始全部为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，你现在可以以任意顺序进行任意次以下两种操作：</p>\n<ol>\n<li>选定整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 与不下降非负整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_1,c_2,\\dots,c_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，对所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i \\le k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li>选定整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 与不上升非负整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_1,c_2,\\dots,c_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，对所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i \\le k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mi>i</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">x_{n-k+i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n</ol>\n<p>问最少进行多少次操作使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i=a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 你有一个长为 nnn 的序列 x1,x2,…,xnx_1,x_2,\\dots,x_nx1​,x2​,…,xn​，一开始全部为 000，你现在可以以任意顺序进行任意次以下两种操作： 选定整数 1≤k≤n1\\le k\\le n1≤k≤n 与不下降非负整数序列 c1,c2,…,ckc_1,c_2,\\dots,c_kc1​,c2​,…,ck​，对所有 1≤i≤k1\\le i \\le k1≤i≤k，令 xix_ixi​ 加上 cic_ici​。 选定整数 1≤k≤n1\\le k\\le n1≤k≤n 与不上升非负整数序列 c1,c2,…,ckc_1,c_2,\\dots,c_kc1​,c2​,…,ck​，对所有 1≤i≤k1\\le i \\le k1≤i≤k，令 xn−k+ix_{n-k+i}xn−k+i​ 加上 cic_ici​。 问最少进行多少次操作使得 xi=aix_i=a_ixi​=ai​。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109。 对于这种和单调性有关的情况，一般考虑差分序列。那么设 bi=xi+1−xib_i=x_{i+1}-x_ibi​=xi+1​−xi​。 考虑只有一种操作怎么做，显然两种操作是对称的，所以只用考虑第一种操作。不难发现第一种操作相当于把 b[1,k−1]b_{[1,k-1]}b[1,k−1]​ 都加上任意非负整数， 把 bkb_kbk​ 减去任意非负整数。而我们的目的是让 bi=ai+1−aib_i=a_{i+1}-a_ibi​=ai+1​−ai​，所以答案即为 ∑i=1n−1[ai&gt;ai+1]+1\\sum\\limits_{i=1}^{n-1}[a_i&gt;a_{i+1}]+1i=1∑n−1​[ai​&gt;ai+1​]+1。 同理，只有第二种操作时的答案为 ∑i=1n−1[ai&lt;ai+1]+1\\sum\\limits_{i=1}^{n-1} [a_i&lt;a_{i+1}]+1i=1∑n−1​[ai​&lt;ai+1​]+1。 考虑设 yiy_iyi​ 表示第一种操作让 xix_ixi​ 增加了多少（yn+1=an+1=y0=a0=0y_{n+1}=a_{n+1}=y_0=a_0=0yn+1​=an+1​=y0​=a0​=0），则答案为 ∑i=1n+1[yi−1&gt;yi]+[ai−1−yi−1&lt;ai−yi]\\sum\\limits_{i=1}^{n+1}[y_{i-1}&gt;y_i]+[a_{i-1}-y_{i-1}&lt;a_{i}-y_{i}]i=1∑n+1​[yi−1​&gt;yi​]+[ai−1​−yi−1​&lt;ai​−yi​]。 设 dpi,jdp_{i,j}dpi,j​ 表示确定完 y[1,i]y_{[1,i]}y[1,i]​ 且 yi=jy_i=jyi​=j 的前 iii 项的答案，不难发现对于同一个 iii，jjj 越大 dpi,jdp_{i,j}dpi,j​ 越小，而转移时 j′j&#x27;j′ 越小 dpi−1,j′dp_{i-1,j&#x27;}dpi−1,j′​ 转移到 dpi,jdp_{i,j}dpi,j​ 的代价越小。注意到对于同一个 iii，dpi,jdp_{i,j}dpi,j​ 最多只有三种取值，那么记录下这三种取值的值和最小的 jjj 即可转移。 时间复杂度 O(n)O(n)O(n)，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005,inf=1e9; int n,a[S]; int f[S][3],g[S][3]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); a[0]=a[n+1]=0; f[0][0]=0,g[0][0]=0; f[0][1]=g[0][1]=inf; f[0][2]=g[0][2]=inf; for(int i=1;i&lt;=n+1;i++) { int y[7],dp[7]={inf,inf,inf,inf,inf,inf,inf}; for(int j=0;j&lt;3;j++) y[j]=a[i]-a[i-1]+f[i-1][j]; for(int j=3;j&lt;6;j++) y[j]=f[i-1][j-3]; y[6]=0; for(int j=0;j&lt;7;j++) { int v=y[j]; if(v&lt;0||v&gt;a[i]) continue; for(int k=0;k&lt;3;k++) { int u=f[i-1][k]; if(u&lt;0||u&gt;a[i-1]) continue; dp[j]=min(dp[j],g[i-1][k]+(u&gt;v)+(a[i-1]-u&lt;a[i]-v)); } } int id[7]={0,1,2,3,4,5,6}; sort(id,id+7,[&amp;](int a,int b){return dp[a]&lt;dp[b]||(dp[a]==dp[b]&amp;&amp;y[a]&lt;y[b]);}); int p=0; for(int j=0;j&lt;7&amp;&amp;p&lt;3;j++) { int k=id[j]; if(p==0||dp[k]!=g[i][p-1]) { f[i][p]=y[k],g[i][p]=dp[k]; p++; } } for(int j=p;j&lt;3;j++) f[i][j]=g[i][j]=inf; } printf(&quot;%d\\n&quot;,g[n+1][0]); return 0; } // (y[i]&gt;y[i+1])+(a[i]-y[i]&lt;a[i+1]-y[i+1]) ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"AGC040E Prefix Suffix Addition 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/agc040e-prefix-suffix-addition-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":307000,"words":963,"minutes":6},"date":"2023-08-07 08:31:00","dateFormat":"2023-08-07"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> , 问有多少个序列组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msub><mi>A</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(A_0,A_1,\\dots,A_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 满足：</p>\n<ul>\n<li>序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的元素个数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>；</li>\n<li>所有元素都在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span> 内；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\forall i\\in[0,n-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 的子序列且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的字典序小于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,k\\le 300</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le m\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn, kkk, mmm , 问有多少个序列组 (A0,A1,…,An)(A_0,A_1,\\dots,A_n)(A0​,A1​,…,An​) 满足： 序列 AiA_iAi​ 的元素个数为 iii； 所有元素都在 [1,k][1,k][1,k] 内； ∀i∈[0,n−1]\\forall i\\in[0,n-1]∀i∈[0,n−1]，AiA_iAi​ 是 Ai+1A_{i+1}Ai+1​ 的子序列且 AiA_iAi​ 的字典序小于 Ai+1A_{i+1}Ai+1​； 答案对 mmm 取模。 1≤n,k≤3001\\le n,k\\le 3001≤n,k≤300，2≤m≤1092\\le m\\le 10^92≤m≤109。 等价于不断插入 [1,k][1,k][1,k] 之间的元素。 设当前序列为 aaa，考虑若在 aia_iai​ 之前插入 xxx，显然需要满足以下条件中至少一个： i=n+1i=n+1i=n+1； x&gt;aix&gt;a_ix&gt;ai​； 设 toi=min⁡j&gt;i,aj=aijto_i=\\min\\limits_{j&gt;i,a_j\\not=a_i}jtoi​=j&gt;i,aj​​=ai​min​j，ai&gt;atoia_i&gt;a_{to_i}ai​&gt;atoi​​； 发现第三种情况等价于在 atoia_{to_i}atoi​​ 之前插入 xxx，那不妨钦定只能有第一种和第二种情况，这样钦定刚好避免算重。 令 an+1=0a_{n+1}=0an+1​=0，则只能在比 xxx 小的元素前插入。 但是还是不好做，设 nti=min⁡j&gt;i,aj&lt;aijnt_i=\\min\\limits_{j&gt;i,a_j&lt;a_i}jnti​=j&gt;i,aj​&lt;ai​min​j，则 [i,nti][i,nt_i][i,nti​] 这些区间肯定要么相交要么包含。不妨从 iii 向 ntint_inti​ 连边，这样会形成一棵以 n+1n+1n+1 为根的树（注意儿子之间是有顺序的），只需要对树的方案计数即可。 注意到我们只关心树根元素的大小和树的大小，于是设 fi,uf_{i,u}fi,u​ 表示大小为 iii，树根元素为 jjj 的树的方案数，转移考虑枚举最大的儿子 vvv，则 vvv 一定要是 uuu 的第一个儿子（序列中最靠近 uuu），那么有转移： fi,u=∑j=1i−1(i−2j−1)×fi−j,u×∑v&gt;ufj,vf_{i,u}=\\sum\\limits_{j=1}^{i-1}\\binom{i-2}{j-1}\\times f_{i-j,u}\\times\\sum\\limits_{v&gt;u}f_{j,v} fi,u​=j=1∑i−1​(j−1i−2​)×fi−j,u​×v&gt;u∑​fj,v​ 使用前缀和优化可以做到 O(n2k)O(n^2k)O(n2k)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=305; int n,k,p; int C[S][S],f[S][S],sum[S][S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;p); for(int i=0;i&lt;=n;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } for(int i=0;i&lt;=k;i++) f[1][i]=1; for(int i=k;i&gt;=0;i--) sum[1][i]=(sum[1][i+1]+f[1][i])%p; for(int i=2;i&lt;=n+1;i++) { for(int j=0;j&lt;=k;j++) { for(int s=1;s&lt;=i-1;s++) { add(f[i][j],1ll*sum[s][j+1]*C[i-2][s-1]%p*f[i-s][j]%p); } } for(int j=k;j&gt;=0;j--) sum[i][j]=(sum[i][j+1]+f[i][j])%p; } printf(&quot;%d\\n&quot;,f[n+1][0]); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"AGC024E Sequence Growing Hard 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/agc024e-sequence-growing-hard-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":228000,"words":746,"minutes":4},"date":"2023-07-21 15:11:40","dateFormat":"2023-07-21"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>&lt;</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">&lt; 2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> 的非负整数变量 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_1,x_2,\\dots,x_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的取值范围是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l_i,r_i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>。</p>\n<p>给出数列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>c</mi><mrow><mi>K</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">c_0,c_1,\\dots,c_{K-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">K</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>，并由此定义一个代价函数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span></span></span></span>：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>(</mo><mo>⌊</mo><mfrac><mi>x</mi><msup><mn>2</mn><mi>i</mi></msup></mfrac><mo>⌋</mo><mtext> </mtext><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>)</mo><mo>⋅</mo><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">f(x)=\\sum_{i=0}^{k-1}(\\lfloor\\tfrac x{2^i}\\rfloor\\bmod 2)\\cdot c_i\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.1137820000000005em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8361130000000003em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.300005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7570857142857143em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>确定每个变量的取值，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=2}^nf(x_i\\oplus x_{i-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.104002em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 最小，输出该最小值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>r</mi><mi>i</mi></msub><mo>&lt;</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">0\\le l_i\\le r_i&lt; 2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>c</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le c_i\\le10^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 和 kkk，有 nnn 个 &lt;2k&lt; 2^k&lt;2k 的非负整数变量 x1,x2,…,xnx_1,x_2,\\dots,x_nx1​,x2​,…,xn​，其中 xix_ixi​ 的取值范围是 [li,ri][l_i,r_i][li​,ri​]。 给出数列 c0,c1,…,cK−1c_0,c_1,\\dots,c_{K-1}c0​,c1​,…,cK−1​，并由此定义一个代价函数 f(x)f(x)f(x)： f(x)=∑i=0k−1(⌊x2i⌋ mod 2)⋅cif(x)=\\sum_{i=0}^{k-1}(\\lfloor\\tfrac x{2^i}\\rfloor\\bmod 2)\\cdot c_i f(x)=i=0∑k−1​(⌊2ix​⌋mod2)⋅ci​ 确定每个变量的取值，使得 ∑i=2nf(xi⊕xi−1)\\sum_{i=2}^nf(x_i\\oplus x_{i-1})∑i=2n​f(xi​⊕xi−1​) 最小，输出该最小值。 2≤n≤502\\le n\\le502≤n≤50，1≤k≤501\\le k\\le501≤k≤50，0≤li≤ri&lt;2k0\\le l_i\\le r_i&lt; 2^k0≤li​≤ri​&lt;2k，0≤ci≤10120\\le c_i\\le10^{12}0≤ci​≤1012。 考虑二进制意义下从高往低一位一位填，若当前填到了第 ppp 位且 x[l,r]x_{[l,r]}x[l,r]​ 之后的位无论怎么填都不会超出 [li,ri][l_i,r_i][li​,ri​] 的限制，则 x[l,r]x_{[l,r]}x[l,r]​ 后面的位可以贪心地和 xl−1x_{l-1}xl−1​ 一样，所以 x[l,r]x_{[l,r]}x[l,r]​ 可以删掉。 不妨能删就删，即钦定 xl−1x_{l-1}xl−1​ 和 xr+1x_{r+1}xr+1​ 的高 ppp 位都顶着上界和下界中的至少一个。 那么有一个朴素的 dp，设 fp,l,r,0/1,0/1f_{p,l,r,0/1,0/1}fp,l,r,0/1,0/1​ 表示填完高 ppp 位，删掉了区间 x[l,r]x_{[l,r]}x[l,r]​，xl−1x_{l-1}xl−1​ 顶到上界/下界，xr+1x_{r+1}xr+1​ 顶到上界/下界。 发现这样转移不了，因为若 xkx_kxk​ 在第 ppp 位时解除了限制，则它的第 ppp 位需要翻转。不妨把这个东西加入状态，设 fp,l,r,0/1,0/1,0/1,0/1f_{p,l,r,0/1,0/1,0/1,0/1}fp,l,r,0/1,0/1,0/1,0/1​ 表示填完高 ppp 位，删掉了区间 x[l,r]x_{[l,r]}x[l,r]​；xl−1x_{l-1}xl−1​ 顶到上界/下界，是否在第 ppp 位解除限制；xr+1x_{r+1}xr+1​ 顶到上界/下界，是否在第 ppp 位解除限制。 注意这样设计状态后 f∗,∗,∗,∗,0,∗,0f_{*,*,*,*,0,*,0}f∗,∗,∗,∗,0,∗,0​ 才是我们想要的东西，f∗,∗,∗,∗,1,∗,∗f_{*,*,*,*,1,*,*}f∗,∗,∗,∗,1,∗,∗​ 和 f∗,∗,∗,∗,∗,∗,1f_{*,*,*,*,*,*,1}f∗,∗,∗,∗,∗,∗,1​ 只是中间状态。 转移较为简单，注意到 fp,l,r,∗,∗,∗,∗f_{p,l,r,*,*,*,*}fp,l,r,∗,∗,∗,∗​ 只有两个来源，即 fp+1,l,r,∗,0,∗,0+第 p 位的代价f_{p+1,l,r,*,0,*,0}+\\text{第 }p\\text{ 位的代价}fp+1,l,r,∗,0,∗,0​+第 p 位的代价 和 fp,l,k−1,∗,∗,∗,1+fp,k+1,r,∗,1,∗,∗f_{p,l,k-1,*,*,*,1}+f_{p,k+1,r,*,1,*,*}fp,l,k−1,∗,∗,∗,1​+fp,k+1,r,∗,1,∗,∗​。前者对应 x[l,r]x_{[l,r]}x[l,r]​ 没有在第 ppp 位解除限制的变量，后者则对应有这样的变量。 注意 p=0p=0p=0 时后面没有位了，要特判。 时间复杂度 O(kn3)O(kn^3)O(kn3)，使用记忆化搜索实现会简洁很多，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int S=55; const long long inf=1e18; int n,m; long long L[S],R[S],c[S]; long long f[S][S][S][2][2][2][2]; inline void tom(long long &amp;x,long long y){x=min(x,y);} long long g(int p,int l,int r,int l0,int l1,int r0,int r1) { if(p==m) return l&gt;r?0:inf; long long &amp;u=f[p][l][r][l0][l1][r0][r1]; if(u!=-1) return u; int stl=(((l0==0?L[l-1]:R[l-1])&gt;&gt;p)&amp;1)^l1; int str=(((r0==0?L[r+1]:R[r+1])&gt;&gt;p)&amp;1)^r1; u=inf; tom(u,g(p+1,l,r,l0,0,r0,0)+(l!=1&amp;&amp;r!=n&amp;&amp;stl!=str)*c[p]); for(int k=l;k&lt;=r;k++) { for(int t=0;t&lt;=1;t++) { if(p==0) tom(u,g(p,l,k-1,l0,l1,t,0)+g(p,k+1,r,t,0,r0,r1)); long long vk=(t==0?L[k]:R[k])^(1ll&lt;&lt;p); if((vk&amp;(~((1ll&lt;&lt;p)-1)))&gt;=L[k]&amp;&amp;(vk|((1ll&lt;&lt;p)-1))&lt;=R[k]) { tom(u,g(p,l,k-1,l0,l1,t,1)+g(p,k+1,r,t,1,r0,r1)); } } } return u; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;L[i],&amp;R[i]); for(int i=0;i&lt;=m-1;i++) scanf(&quot;%lld&quot;,&amp;c[i]); memset(f,-1,sizeof(f)); printf(&quot;%lld\\n&quot;,g(0,1,n,0,0,0,0)); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1456E XOR-ranges 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1456e-xor-ranges-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":346000,"words":1100,"minutes":6},"date":"2023-07-20 21:17:05","dateFormat":"2023-07-20"},{"abstract":"<blockquote>\n<p>给定两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n,k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 和一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，你需要进行任意次下列操作把所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 变成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>：</p>\n<ul>\n<li>选择一段长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l,r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 和一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span>，把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[l,r]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> 中所有小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 的数改为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>；</li>\n</ul>\n<p>最小化所有操作的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 的和。</p>\n<p>对于每一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的前缀 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[1,i]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>，你要求出它的答案 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>f</mi><mi>i</mi></msub><mn>2</mn><msup><mn>3</mn><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msup><mspace></mspace><mspace width=\"0.6666666666666666em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mo>(</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{i=1}^nf_i23^{n-i}\\mod (10^9+7)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.329066em;vertical-align:-0.9776689999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3513970000000004em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9776689999999999em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathdefault mtight\">i</span></span></span></span></span></span></span></span></span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">7</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 2\\times 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，时间复杂度要求线性。</p>\n</blockquote>\n","content":" 给定两个正整数 n,kn,kn,k 和一个长度为 nnn 的整数序列 aia_iai​，你需要进行任意次下列操作把所有 aia_iai​ 变成 000： 选择一段长度为 kkk 的区间 [l,r][l,r][l,r] 和一个正整数 EEE，把 a[l,r]a_{[l,r]}a[l,r]​ 中所有小于等于 EEE 的数改为 000； 最小化所有操作的 EEE 的和。 对于每一个 aaa 的前缀 a[1,i]a_{[1,i]}a[1,i]​，你要求出它的答案 fif_{i}fi​，输出 ∑i=1nfi23n−imod (109+7)\\sum\\limits_{i=1}^nf_i23^{n-i}\\mod (10^9+7)i=1∑n​fi​23n−imod(109+7)。 1≤n≤1071\\le n\\le 10^71≤n≤107，1≤ai≤2×1091\\le a_i\\le 2\\times 10^91≤ai​≤2×109，时间复杂度要求线性。 原题 n≤2.5×106n\\le 2.5\\times 10^6n≤2.5×106 时限 0.25 S0.25\\text{ S}0.25 S 放了 O(nlog⁡n)O(n\\log n)O(nlogn) 过。 考虑一个朴素的 dp，设 fif_ifi​ 为 a[1,i]a_{[1,i]}a[1,i]​ 的答案。由于每次操作可以看作花费 max⁡l≤i≤rai\\max\\limits_{l\\le i\\le r} a_il≤i≤rmax​ai​ 的代价把满足 r−l+1≤kr-l+1\\le kr−l+1≤k 的 a[l,r]a_{[l,r]}a[l,r]​ 变成 000，所以转移可以考虑枚举把 aia_iai​ 变成 000 的那次操作的 lll： fi=min⁡j=max⁡(1,i−k+1)i{fj−1max⁡j≤p≤iap}f_i=\\min\\limits_{j=\\max(1,i-k+1)}^{i} \\{f_{j-1}\\max\\limits_{j\\le p\\le i} a_p\\} fi​=j=max(1,i−k+1)mini​{fj−1​j≤p≤imax​ap​} 显然 fif_ifi​ 单调递增，所以只统计满足 ap&gt;max⁡p&lt;l≤iala_p&gt;\\max\\limits_{p&lt;l\\le i} a_lap​&gt;p&lt;l≤imax​al​ 的 fp−1+apf_{p-1}+a_pfp−1​+ap​ 的最小值即可。 这样的 ppp 可以很方便地用单调队列维护，但是发现由于单调队列中既会加入会删除，fp−1+apf_{p-1}+a_pfp−1​+ap​ 只能 O(log⁡n)O(\\log n)O(logn) 维护。 考虑优化，发现满足 p≤i,i−p≤kp\\le i,i-p\\le kp≤i,i−p≤k 的 ppp 才对 fif_ifi​ 有贡献，所以考虑按 kkk 分块（[1,k][1,k][1,k]、[k+1,2k][k+1,2k][k+1,2k] 等等为一块）。设 SSS 为合法的 ppp 构成的集合，则： 贡献可以分为块内贡献和块间（iii 所在块和上一块）贡献； 块内贡献：正着扫，SSS 中只会加入新元素； 块间贡献：倒着扫，SSS 中同样只会加入新元素； 注意要先处理块间贡献。 时间复杂度 O(n)O(n)O(n)，实测 10710^7107 只跑了 0.9 S0.9\\text{ S}0.9 S，不知道为什么原题不开 n≤107n\\le 10^7n≤107 时限 1 S1\\text{ S}1 S。 还可以双栈。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; char buf[1&lt;&lt;23],*p1=buf,*p2=buf,obuf[1&lt;&lt;23],*O=obuf; #define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++) inline int read() { int x=0,f=1;char ch=getchar(); while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();} while(isdigit(ch)) x=x*10+(ch^48),ch=getchar(); return x*f; } const int S=10000005,p=1000000007; const long long inf=1e17; int n,k,a[S],_23[S]; long long f[S]; int top,sta[S]; long long stb[S]; int mx[S],tot,mxp[S]; int main() { freopen(&quot;op.in&quot;,&quot;r&quot;,stdin); freopen(&quot;op.out&quot;,&quot;w&quot;,stdout); n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); _23[0]=1; for(int i=1;i&lt;=n;i++) _23[i]=1ll*_23[i-1]*23%p; #define R(x) (min(n,((x-1)/k+1)*k)) f[0]=0; for(int i=1;i&lt;=n;i++) f[i]=inf; for(int l=1;l&lt;=n;l=R(l)+1) { int r=R(l); // 上一块 - 当前块 if(l&gt;1) { int l2=l-k,r2=l-1; mx[l-1]=0; for(int i=l;i&lt;=r;i++) mx[i]=max(mx[i-1],a[i]); tot=0; for(int i=r2,mx=0;i&gt;=l2;i--) if(a[i]&gt;mx) mx=a[i],mxp[++tot]=i; long long mn=inf; for(int i=r,lb=1,rb=-1;i&gt;=l;i--) { int p=i-k; while(lb&lt;=tot&amp;&amp;mxp[lb]&gt;=p) { if(mx[i]&lt;=a[mxp[lb]]) { if(rb==-1) rb=lb; else mn=min(mn,f[mxp[lb]]+a[mxp[lb-1]]); } lb++; } if(rb==-1&amp;&amp;mx[i]&lt;=a[mxp[lb-1]]) rb=lb-1; if(rb!=-1) { while(rb-1&lt;=tot&amp;&amp;a[mxp[rb-1]]&gt;=mx[i]) { mn=min(mn,f[mxp[rb]]+a[mxp[rb-1]]); rb--; } } f[i]=min(f[i],min(mn,min( f[p]+max(a[mxp[lb-1]],mx[i]), rb!=-1?f[mxp[rb]]+mx[i]:inf ))); } } // 当前块内 top=0,sta[0]=l-1,stb[0]=inf; for(int i=l;i&lt;=r;i++) { while(top&gt;0&amp;&amp;a[sta[top]]&lt;a[i]) top--; top++; sta[top]=i,stb[top]=min(stb[top-1],f[sta[top-1]]+a[i]); f[i]=min(f[i],stb[top]); } } int ans=0; for(int i=1;i&lt;=n;i++) ans=(ans+1ll*f[i]%p*_23[n-i]%p)%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"}],"title":"【2023成都集训模拟赛04】op 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023-cheng-du-ji-xun/","stats":{"text":"7 min read","time":374000,"words":1167,"minutes":7},"date":"2023-07-19 15:02:50","dateFormat":"2023-07-19"},{"abstract":"","content":"Part 1 简介 启发式分裂是一种基于启发式合并思想的分治。 通常应用于： 统计所有区间 [i,j][i,j][i,j] 的有关区间内某个代表元（极值、不合法的位置）的贡献； 注意 [l,r][l,r][l,r] 的代表元 xxx 需要满足 ∀x∈[l′,r′]∈[l,r]\\forall x\\in [l&#x27;,r&#x27;]\\in [l,r]∀x∈[l′,r′]∈[l,r]，xxx 是 [l′,r′][l&#x27;,r&#x27;][l′,r′] 的代表元，例如极值就满足这个性质。请注意同一个区间的代表元可能有多个。 做题时一般较难想到，需要注意一下可以往这方面想。 Part 2 算法流程 考虑当前分治区间 [l,r][l,r][l,r]，显然可以： 遍历一次区间找到代表元 xxx； 处理 l′∈[l,x],r′∈[x,r]l&#x27;\\in [l,x],r&#x27;\\in [x,r]l′∈[l,x],r′∈[x,r] 的 [l′,r′][l&#x27;,r&#x27;][l′,r′] 的贡献； 分治处理 [l,x−1][l,x-1][l,x−1] 和 [x+1,r][x+1,r][x+1,r]； 但是这样做的时间复杂度最劣是 O(n2)O(n^2)O(n2) 的，考虑类似 meet-in-middle 的思想： 从左右两端同时往中间遍历区间 / 预处理，找到代表元 xxx； 处理 l′∈[l,x],r′∈[x,r]l&#x27;\\in [l,x],r&#x27;\\in [x,r]l′∈[l,x],r′∈[x,r] 的 [l′,r′][l&#x27;,r&#x27;][l′,r′] 的贡献： 若 x−l+1&lt;r−x+1x-l+1&lt;r-x+1x−l+1&lt;r−x+1，即 [l,x][l,x][l,x] 更短，则枚举 l′l&#x27;l′，快速计算所有 r′r&#x27;r′ 的贡献和 / 对 [x+1,r][x+1,r][x+1,r] 的影响； 否则枚举 r′r&#x27;r′，快速计算所有 l′l&#x27;l′ 的贡献和 / 对 [l,x−1][l,x-1][l,x−1] 的影响； 分治处理 [l,x−1][l,x-1][l,x−1] 和 [x+1,r][x+1,r][x+1,r]； 这样做的本质可以看做在 dfs 树上启发式合并，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 有些时候需要注意分治处理时左右区间的顺序。 Part 3 例题 3.1 P4755 Beautiful Pair 小 D 有个数列 {a}\\{a\\}{a}，当一个数对 (i,j)(i,j)(i,j)（i≤ji \\le ji≤j）满足 aia_iai​ 和 aja_jaj​ 的积不大于 ai,ai+1,…,aja_i, a_{i+1}, \\ldots, a_jai​,ai+1​,…,aj​ 中的最大值时，小 D 认为这个数对是美丽的。请你求出美丽的数对的数量。 1≤n≤1051\\le n\\le{10}^51≤n≤105，1≤ai≤1091\\le a_i\\le{10}^91≤ai​≤109。 题解 启发式分裂，先离散化，在处理 [1,n][1,n][1,n] 前把所有 aia_iai​ 扔进树状数组里。 处理 [l,r][l,r][l,r] 时： 若 l&gt;rl&gt;rl&gt;r，直接返回； 若 l=rl=rl=r，在树状数组中删除 ala_lal​ 并返回； 预处理 ST 表快速找到 [l,r][l,r][l,r] 中最大值的位置 xxx; 处理 l′∈[l,x],r′∈[x,r]l&#x27;\\in [l,x],r&#x27;\\in [x,r]l′∈[l,x],r′∈[x,r] 的 [l′,r′][l&#x27;,r&#x27;][l′,r′] 的贡献： 若 x−l+1&lt;r−x+1x-l+1&lt;r-x+1x−l+1&lt;r−x+1： 在树状数组中删除 a[l,x−1]a_{[l,x-1]}a[l,x−1]​； 遍历 l′∈[l,x]l&#x27;\\in [l,x]l′∈[l,x]，算出树状数组中 ≤⌊axal′⌋\\le \\lfloor\\frac{a_x}{a_{l&#x27;}}\\rfloor≤⌊al′​ax​​⌋ 的数的个数 cntcntcnt，令答案增加 cntcntcnt； 在树状数组中删除 axa_{x}ax​； 分治处理 [x+1,r][x+1,r][x+1,r]，注意处理后树状数组中的 a[x+1,r]a_{[x+1,r]}a[x+1,r]​ 已经被删除； 在树状数组中加入 a[l,x−1]a_{[l,x-1]}a[l,x−1]​ 并分治处理 [l,x−1][l,x-1][l,x−1]； 否则枚举 r′r&#x27;r′，处理方法类似，注意要先分治处理 [l,x−1][l,x-1][l,x−1]； 时间复杂度 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005,BS=25; int n,a[S]; int m,b[S]; int mlog[S],mx[S][BS]; int c[S]; long long ans; inline int que(int l,int r) { int k=mlog[r-l+1]; int x=mx[l][k],y=mx[r-(1&lt;&lt;k)+1][k]; return a[x]&gt;a[y]?x:y; } inline void addtr(int pos,int val) { for(int i=pos;i&lt;=m;i+=i&amp;-i) c[i]+=val; } inline int quetr(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } void slove(int l,int r) { if(l&gt;r) return; if(l==r) return ans+=b[a[l]]==1,addtr(a[l],-1),void(); int x=que(l,r); if(x-l+1&lt;r-x+1) { for(int i=l;i&lt;=x-1;i++) addtr(a[i],-1); for(int i=l;i&lt;=x;i++) { int p=upper_bound(b+1,b+m+1,b[a[x]]/b[a[i]])-b-1; ans+=quetr(p); } addtr(a[x],-1); slove(x+1,r); for(int i=l;i&lt;=x-1;i++) addtr(a[i],1); slove(l,x-1); } else { for(int i=x+1;i&lt;=r;i++) addtr(a[i],-1); for(int i=x;i&lt;=r;i++) { int p=upper_bound(b+1,b+m+1,b[a[x]]/b[a[i]])-b-1; ans+=quetr(p); } addtr(a[x],-1); slove(l,x-1); for(int i=x+1;i&lt;=r;i++) addtr(a[i],1); slove(x+1,r); } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[++m]=a[i]; sort(b+1,b+m+1),m=unique(b+1,b+m+1)-b-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b; mlog[0]=-1; for(int i=1;i&lt;=n;i++) mlog[i]=mlog[i&gt;&gt;1]+1,mx[i][0]=i; for(int j=1;j&lt;=BS-3;j++) { for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++) { int x=mx[i][j-1],y=mx[i+(1&lt;&lt;j-1)][j-1]; mx[i][j]=a[x]&gt;a[y]?x:y; } } for(int i=1;i&lt;=n;i++) addtr(a[i],1); slove(1,n); printf(&quot;%lld\\n&quot;,ans); return 0; } 3.2 LOJ6198 谢特 给定一个长 nnn 的字符串 SSS 和 nnn 个整数 wiw_iwi​，定义二元组 (i,j)(i,j)(i,j)（i=ji\\not=ji​=j）的权值为 LCP(S[i,n],S[j,n])+(wi⊕wj)\\text{LCP}(S_{[i,n]},S_{[j,n]})+(w_i\\oplus w_j)LCP(S[i,n]​,S[j,n]​)+(wi​⊕wj​)，其中 ⊕\\oplus⊕ 为按位异或运算。对于所有 (i,j)(i,j)(i,j)（i=ji\\not=ji​=j），求出最大的权值。 1≤n≤1051\\le n\\le 10^51≤n≤105，0≤wi&lt;n0\\le w_i&lt;n0≤wi​&lt;n。 题解 如果不往启发式分裂这方面想是挺难想到的。 LCP(S[i,n],S[j,n])\\text{LCP}(S_{[i,n]},S_{[j,n]})LCP(S[i,n]​,S[j,n]​) 相当于跑 SA 之后的 min⁡k=rkirkj−1heightk\\min\\limits_{k=rk_i}^{rk_j-1}height_kk=rki​minrkj​−1​heightk​，即某个区间中的最小值，而最大异或又很好维护，所以直接 SA + trie + 启发式分裂即可。 时间复杂度 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 3.3 【2023NOIP模拟赛06】我是 C 题 ","tags":[{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"},{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"启发式分裂 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/qi-fa-shi-fen-lie-xue-xi-bi-ji/","stats":{"text":"9 min read","time":518000,"words":1671,"minutes":9},"date":"2023-07-17 20:43:39","dateFormat":"2023-07-17"},{"abstract":"<blockquote>\n<p>给定两个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，求出最大的正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 使得存在某个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\le l\\le n-k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>l</mi><mo>+</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[l,l+k-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> 内出现过的所有数的出现次数都不小于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">0\\le a_i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\le b_i\\le n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b_i\\ge b_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定两个长度为 nnn 的整数序列 aia_iai​ 和 bib_ibi​，求出最大的正整数 kkk 使得存在某个 1≤l≤n−k+11\\le l\\le n-k+11≤l≤n−k+1 使得 a[l,l+k−1]a_{[l,l+k-1]}a[l,l+k−1]​ 内出现过的所有数的出现次数都不小于 bkb_kbk​。 1≤n≤1061\\le n\\le 10^61≤n≤106，0≤ai≤n0\\le a_i\\le n0≤ai​≤n，1≤bi≤n+11\\le b_i\\le n+11≤bi​≤n+1，bi≥bi+1b_i\\ge b_{i+1}bi​≥bi+1​。 考虑对所有合法的区间的长度取 max。 对于一个区间 [l,r][l,r][l,r]，由于 bbb 单调递减，所以所有满足在 [l,r][l,r][l,r] 中出现次数小于 br−l+1b_{r-l+1}br−l+1​ 的 aia_iai​ 都不能选，那么把这些 aia_iai​ 删掉后： 若 [l,r][l,r][l,r] 分裂成若干个小区间，则每个区间可以递归下去处理； 若 [l,r][l,r][l,r] 没有分裂，则 [l,r][l,r][l,r] 是一个合法的答案； 考虑优化。不难发现，由于 bbb 单调递减，所以只需要找到某一个 x∈[l,r]x\\in [l,r]x∈[l,r] 满足 axa_xax​ 在 [l,r][l,r][l,r] 中出现次数小于 br−l+1b_{r-l+1}br−l+1​ 然后递归处理 [l,x−1][l,x-1][l,x−1] 和 [x+1,r][x+1,r][x+1,r] 即可。 但是这样做的时间复杂度是 O(n2)O(n^2)O(n2) 的，继续优化。 考虑启发式分裂，把这样的 axa_xax​ 看作代表元，那么所有跨过 xxx 的区间的贡献都是 000，不用考虑。而可以通过类似 meet-in-middle 的方法，从 lll 和 rrr 同时向中间遍历，快速找到代表元，这样的时间复杂度就是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。 具体实现流程 在处理 [1,n][1,n][1,n] 前把所有 aia_iai​ 扔进桶里。 处理 [l,r][l,r][l,r] 时： 若 l&gt;rl&gt;rl&gt;r，直接返回； 从 lll 和 rrr 出发往中间遍历找到代表元 axa_xax​； 若找不到满足条件的 axa_xax​，扫一遍把 a[l,r]a_{[l,r]}a[l,r]​ 从桶中删除，否则： 若 x−l+1&lt;r−x+1x-l+1&lt;r-x+1x−l+1&lt;r−x+1： 扫一遍，在桶中删除 a[l,x−1]a_{[l,x-1]}a[l,x−1]​； 分治处理 [x+1,r][x+1,r][x+1,r]，注意处理后桶中的 a[x+1,r]a_{[x+1,r]}a[x+1,r]​ 已经被删除； 扫一遍，在桶中加入 a[l,x−1]a_{[l,x-1]}a[l,x−1]​ 并分治处理 [l,x−1][l,x-1][l,x−1]； 否则处理方法也类似，注意要先分治处理 [l,x−1][l,x-1][l,x−1]； 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005; int n,a[S],b[S]; int app[S]; int ans; void slove(int l,int r) { if(r&lt;l) return; int p1=l,p2=r,pp=-1; while(p1&lt;=p2) { if(app[a[p1]]&lt;b[r-l+1]) { pp=p1; break; } if(app[a[p2]]&lt;b[r-l+1]) { pp=p2; break; } p1++; p2--; } if(pp==-1) { for(int i=l;i&lt;=r;i++) app[a[i]]--; ans=max(ans,r-l+1); return; } app[a[pp]]--; if(pp-l&lt;r-pp) { for(int i=l;i&lt;pp;i++) app[a[i]]--; slove(pp+1,r); for(int i=l;i&lt;pp;i++) app[a[i]]++; slove(l,pp-1); } else { for(int i=pp+1;i&lt;=r;i++) app[a[i]]--; slove(l,pp-1); for(int i=pp+1;i&lt;=r;i++) app[a[i]]++; slove(pp+1,r); } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) app[a[i]]++; slove(1,n); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"},{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"}],"title":"【2023NOIP模拟赛06】我是 C 题 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noip-mo-ni-sai-06-wo-shi-c-ti-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":280000,"words":930,"minutes":5},"date":"2023-07-17 20:40:52","dateFormat":"2023-07-17"},{"abstract":"<blockquote>\n<p>给定一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的无根树，每条边有一个未知的正整数边权。</p>\n<p>对于所有的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le i &lt; n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，给出点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 到点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的距离 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，请还原出任意一组合法的边权，可能无解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>d</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le d_i\\le 10^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一棵 nnn 个点的无根树，每条边有一个未知的正整数边权。 对于所有的 1≤i&lt;n1 \\le i &lt; n1≤i&lt;n，给出点 iii 到点 i+1i + 1i+1 的距离 did_idi​，请还原出任意一组合法的边权，可能无解。 2≤n≤1052\\le n\\le 10^52≤n≤105，1≤di≤10121\\le d_i\\le 10^{12}1≤di​≤1012。 逐位确定。 令根为点 111，设 depudep_{u}depu​ 为 uuu 到根的距离，那么有 di=depi+depi+1−2deplcad_i=dep_{i}+dep_{i+1}-2dep_{lca}di​=depi​+depi+1​−2deplca​，并且我们已知 dep1=0dep_1=0dep1​=0。 注意到 2deplca≡0(mod2)2dep_{lca}\\equiv 0\\pmod 22deplca​≡0(mod2)，所以可以知道 depi mod 2dep_i\\text{ mod }2depi​ mod 2；然后注意到 2deplca mod 4=2(deplca mod 2)2dep_{lca}\\text{ mod }4=2(dep_{lca}\\text{ mod }2)2deplca​ mod 4=2(deplca​ mod 2)，所以接下来就可以知道 depi mod 4dep_i\\text{ mod }4depi​ mod 4 …… 这启发我们从小到大枚举 kkk，依次确定 depi mod 2kdep_{i}\\text{ mod } 2^kdepi​ mod 2k。 由于 di≤1012d_i\\le 10^{12}di​≤1012，所以 depi mod 260=depidep_i\\text{ mod }2^{60}=dep_idepi​ mod 260=depi​，再做一次 dfs 即可知道边权。 注意若求出的边权 ≤0\\le 0≤0 或 2depi&gt;2602dep_i&gt;2^{60}2depi​&gt;260 则无解。 时间复杂度 O(nlog⁡V)O(n\\log V)O(nlogV)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=100005,BS=25,B=60; int n; vector&lt;pair&lt;int,int&gt;&gt; g[S]; long long a[S]; int dep[S],fat[S][BS]; int b[S]; long long tmp[S],res[S],ans[S]; void dfs(int u,int fa) { dep[u]=dep[fa]+1; fat[u][0]=fa; for(int i=1;i&lt;=BS-3;i++) fat[u][i]=fat[fat[u][i-1]][i-1]; for(auto v:g[u]) if(v.first!=fa) dfs(v.first,u); } inline int getlca(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); for(int i=BS-3;i&gt;=0;i--) if(dep[fat[x][i]]&gt;=dep[y]) x=fat[x][i]; if(x==y) return x; for(int i=BS-3;i&gt;=0;i--) if(fat[x][i]!=fat[y][i]) x=fat[x][i],y=fat[y][i]; return fat[x][0]; } void getans(int u,int fa,int faid) { if(faid!=0) ans[faid]=res[u]-res[fa]; for(auto v:g[u]) if(v.first!=fa) getans(v.first,u,v.second); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(make_pair(y,i)),g[y].push_back(make_pair(x,i)); } for(int i=1;i&lt;=n-1;i++) scanf(&quot;%lld&quot;,&amp;a[i]); dfs(1,0); for(int i=1;i&lt;=n-1;i++) b[i]=getlca(i,i+1); for(int i=1;i&lt;=B;i++) { long long pre=1ll&lt;&lt;i; for(int j=1;j&lt;=n-1;j++) tmp[j+1]=((a[j]+2*res[b[j]]%pre-tmp[j])%pre+pre)%pre; for(int j=1;j&lt;=n;j++) res[j]=tmp[j]; } for(int j=2;j&lt;=n;j++) if(res[j]==0||2*res[j]&gt;(1ll&lt;&lt;B)) return puts(&quot;-1&quot;),0; getans(1,0,0); for(int i=1;i&lt;=n-1;i++) if(ans[i]&lt;=0) return puts(&quot;-1&quot;),0; for(int i=1;i&lt;=n-1;i++) printf(&quot;%lld\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1844G Tree Weights 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1844g-tree-weights-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":243000,"words":721,"minutes":5},"date":"2023-07-17 15:19:55","dateFormat":"2023-07-17"},{"abstract":"<blockquote>\n<p>对于排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>p</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{p_i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>，定义一次操作为按顺序执行以下步骤：</p>\n<ol>\n<li>令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为排列中最大的满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mi mathvariant=\"normal\">≠</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">p_i\\neq i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的数；</li>\n<li>令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 为排列中最小的满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">j&gt;i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的数；</li>\n<li>交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>；<br>\n定义 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span></span></span></span> 为将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 升序排序所需的操作次数。</li>\n</ol>\n<p>给定一个排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，会进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><msub><mi>x</mi><mi>i</mi></msub></msub><mo separator=\"true\">,</mo><msub><mi>p</mi><msub><mi>y</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">p_{x_i},p_{y_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 的操作，每次操作后输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span></span></span></span>，交换操作是永久的。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le q\\le 5\\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 对于排列 {pi}\\{p_i\\}{pi​}，定义一次操作为按顺序执行以下步骤： 令 pip_ipi​ 为排列中最大的满足 pi≠ip_i\\neq ipi​​=i 的数； 令 pjp_jpj​ 为排列中最小的满足 j&gt;ij&gt;ij&gt;i 的数； 交换 pip_ipi​ 和 pjp_jpj​； 定义 f(p)f(p)f(p) 为将 ppp 升序排序所需的操作次数。 给定一个排列 ppp，会进行 qqq 次交换 pxi,pyip_{x_i},p_{y_i}pxi​​,pyi​​ 的操作，每次操作后输出 f(p)f(p)f(p)，交换操作是永久的。 2≤n≤5×1052\\le n\\le 5\\times 10^52≤n≤5×105，1≤q≤5×1041\\le q\\le 5\\times 10^41≤q≤5×104。 人类智慧题。 考虑排序过程中一次操作对逆序对个数 cntcntcnt 做出的改变，由于 p[i+1,j−1]p_{[i+1,j-1]}p[i+1,j−1]​ 均在 [pi+1,pj−1][p_i+1,p_j-1][pi​+1,pj​−1] 内，所以一次操作会让逆序对个数减少 2(j−i)−12(j-i)-12(j−i)−1。 接下来就很人类智慧。 首先发现 pip_ipi​ 这个数在排序过程中只会向它的目的地 pip_ipi​ 单向移动。 证明 只需要考虑移动太多导致要反向移动的情况。 首先一次操作中 pjp_jpj​ 显然不会移动太多，因为有 pj≤ip_j\\le ipj​≤i。 证明 若 ∀j&gt;i,pj&gt;i\\forall j&gt;i,p_j&gt;i∀j&gt;i,pj​&gt;i，则 p[i+1,n]p_{[i+1,n]}p[i+1,n]​ 一定构成子排列，那么一定有 pi&lt;ip_i&lt;ipi​&lt;i。 此时找到满足 pk=ip_k=ipk​=i 的 kkk，则一定有 pk=kp_k\\not=kpk​​=k 且 pk&gt;pip_k&gt;p_ipk​&gt;pi​，与 iii 的定义矛盾。 然后一定有 j≤pij\\le p_ij≤pi​，因为把 ppp 的满足 pi=ip_i=ipi​=i 的极长后缀删掉后 pip_ipi​ 一定是最大值。 那么设 sum=∑k=1nmax⁡(pk−k,0)sum=\\sum\\limits_{k=1}^n\\max(p_k-k,0)sum=k=1∑n​max(pk​−k,0)，考虑排序过程中一次操作对这个东西的影响： 一定有 pi&gt;ip_i&gt;ipi​&gt;i，所以 max⁡(pi−i,0)=pi−i\\max(p_i-i,0)=p_i-imax(pi​−i,0)=pi​−i； 一定有 pj≤i&lt;jp_j\\le i&lt;jpj​≤i&lt;j，所以 max⁡(pj−j,0)=0\\max(p_j-j,0)=0max(pj​−j,0)=0； 一定有 pj≤ip_j\\le ipj​≤i，所以 max⁡(pj−i,0)=0\\max(p_j-i,0)=0max(pj​−i,0)=0； 一定有 pi≥jp_i\\ge jpi​≥j，所以 max⁡(pi−j,0)=pi−j\\max(p_i-j,0)=p_i-jmax(pi​−j,0)=pi​−j； 那么一次操作让 sumsumsum 减少了： Δsum=(max⁡(pi−i,0)+max⁡(pj−j,0))−(max⁡(pj−i,0)+max⁡(pi−j,0))=(pi−i+0)−(0+pi−j)=j−i\\begin{aligned} \\Delta sum&amp;=(\\max(p_i-i,0)+\\max(p_j-j,0))-(\\max(p_j-i,0)+\\max(p_i-j,0))\\\\ &amp;=(p_i-i+0)-(0+p_i-j)\\\\ &amp;=j-i \\end{aligned} Δsum​=(max(pi​−i,0)+max(pj​−j,0))−(max(pj​−i,0)+max(pi​−j,0))=(pi​−i+0)−(0+pi​−j)=j−i​ 发现 Δcnt=2(j−i)−1\\Delta cnt=2(j-i)-1Δcnt=2(j−i)−1，所以 2Δsum−Δcnt=12\\Delta sum-\\Delta cnt=12Δsum−Δcnt=1。 所以 f(p)=2sum−cntf(p)=2sum-cntf(p)=2sum−cnt。 sumsumsum 是很好维护的，cntcntcnt 的维护相当于三维偏序，可以考虑 cdq 分治。 时间复杂度 O(nlog⁡2n)O(n\\log ^2 n)O(nlog2n)，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; struct node { int tme,pos,val,w; }; const int S=500005; int n,q,a[S]; int tot; node que[S*2]; int c[S]; long long res[S],ans[S]; inline void addt(int p,int val) { for(int i=p;i&lt;=n;i+=i&amp;-i) c[i]+=val; } inline int quet(int p) { int res=0; for(int i=p;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } inline void clrt(int p) { for(int i=p;i&lt;=n;i+=i&amp;-i) c[i]=0; } void cdq(int l,int r) { if(l&gt;=r) return; int mid=l+r&gt;&gt;1; cdq(l,mid); cdq(mid+1,r); auto cmp=[&amp;](node x,node y){return x.pos&lt;y.pos;}; sort(que+l,que+mid+1,cmp),sort(que+mid+1,que+r+1,cmp); int p=l; for(int i=mid+1;i&lt;=r;i++) { while(p&lt;=mid&amp;&amp;que[p].pos&lt;que[i].pos) addt(n-que[p].val+1,que[p].w),p++; ans[que[i].tme]+=quet(n-que[i].val)*que[i].w; } for(int i=l;i&lt;p;i++) clrt(n-que[i].val+1); p=mid; for(int i=r;i&gt;=mid+1;i--) { while(p&gt;=l&amp;&amp;que[p].pos&gt;que[i].pos) addt(que[p].val,que[p].w),p--; ans[que[i].tme]+=quet(que[i].val-1)*que[i].w; } for(int i=p+1;i&lt;=mid;i++) clrt(que[i].val); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); que[++tot]=(node){0,i,a[i],true}; res[0]+=max(a[i]-i,0); } for(int i=1;i&lt;=q;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); que[++tot]=(node){i*2-1,x,a[x],-1}; que[++tot]=(node){i*2-1,x,a[y],1}; que[++tot]=(node){i*2,y,a[y],-1}; que[++tot]=(node){i*2,y,a[x],1}; res[i]=res[i-1]; res[i]-=max(a[x]-x,0); res[i]-=max(a[y]-y,0); swap(a[x],a[y]); res[i]+=max(a[x]-x,0); res[i]+=max(a[y]-y,0); } cdq(1,tot); for(int i=1;i&lt;=q*2;i++) ans[i]+=ans[i-1]; for(int i=1;i&lt;=q;i++) printf(&quot;%lld\\n&quot;,2*res[i]-ans[i*2]); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"}],"title":"CF1830E Bully Sort 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1830e-bully-sort-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":403000,"words":1244,"minutes":7},"date":"2023-07-17 07:46:10","dateFormat":"2023-07-17"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个台灯，初始时都是暗的，每次等概率随机一个暗台灯将其点亮，若点亮后<strong>存在</strong>一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的连续段有<strong>大于一个</strong>台灯被点亮则立刻停止，求期望点亮多少台灯。对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le k\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个台灯，初始时都是暗的，每次等概率随机一个暗台灯将其点亮，若点亮后存在一个长度为 kkk 的连续段有大于一个台灯被点亮则立刻停止，求期望点亮多少台灯。对 109+710^9+7109+7 取模。 2≤k≤n≤1052\\le k\\le n\\le 10^52≤k≤n≤105。 考虑期望的本质，设 pip_ipi​ 为恰好在点亮第 iii 个台灯后停止，则答案为： ∑i=1ni⋅pi\\sum\\limits_{i=1}^{n} i\\cdot p_i i=1∑n​i⋅pi​ 发现若设 si=∑j=inpjs_i=\\sum\\limits_{j=i}^{n}p_jsi​=j=i∑n​pj​ 即 ppp 的后缀和，那么答案等于： ∑i=1nsi\\sum\\limits_{i=1}^{n} s_i i=1∑n​si​ 发现 sis_isi​ 可以看作是点亮了前 i−1i-1i−1 个台灯仍未停止的概率，所以 si=(n−(k−1)(i−2)i−1)(i−1)!(ni−1)(i−1)!=(n−(k−1)(i−2)i−1)(ni−1)s_i=\\frac{\\binom{n-(k-1)(i-2)}{i-1}(i-1)!}{\\binom{n}{i-1}(i-1)!}=\\frac{\\binom{n-(k-1)(i-2)}{i-1}}{\\binom{n}{i-1}}si​=(i−1n​)(i−1)!(i−1n−(k−1)(i−2)​)(i−1)!​=(i−1n​)(i−1n−(k−1)(i−2)​)​。 其中分子的计算方式是在确定完亮的台灯的位置后在相邻两个亮的台灯之间插入 k−1k-1k−1 个暗的台灯。 那么直接计算即可，不过 s1=1s_1=1s1​=1 要特判。时间复杂度 O(n)O(n)O(n)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005,p=1000000007; int n,k; int fra[S],inv[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(long long n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } int main() { fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); int ans=0; for(int i=1;i&lt;=n;i++) { int si=i==1?1:1ll*C(n-1ll*(k-1)*(i-2),i-1)*qpow(C(n,i-1),p-2)%p; ans=(ans+si)%p; } printf(&quot;%d\\n&quot;,ans); } return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":" CF1523E Crypto Lights 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1523e-crypto-lights-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":175000,"words":558,"minutes":3},"date":"2023-07-16 11:46:09","dateFormat":"2023-07-16"},{"abstract":"","content":"关于名称 关于主题 主题由著名的 Next 主题修改而来，增加了许多功能，修复了一些 bug。 由于技术和时间原因，不保证该主题改配置后显示仍然正常。 Github 地址：Expert-Next 关于索引类文章的消失 没必要了，想找文章直接按标签筛选和使用搜索即可。 推销 Gridea for Windows Upload Helper Web_Sever.h Videos of B Satck fixing tool ","tags":[],"title":"关于本博客","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/guan-yu-ben-bo-ke/","stats":{"text":"1 min read","time":25000,"words":111,"minutes":1},"date":"2023-07-14 20:47:40","dateFormat":"2023-07-14"},{"abstract":"<blockquote>\n<p>对于一个 01 序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，定义 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>b</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mo>∑</mo><mo>[</mo><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>]</mo></mrow><mrow><mi mathvariant=\"normal\">∣</mi><mi>b</mi><mi mathvariant=\"normal\">∣</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">f(b)=\\frac{\\sum\\limits [b_i=1]}{|b|}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.530007em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0100069999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∣</span><span class=\"mord mathdefault mtight\">b</span><span class=\"mord mtight\">∣</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485007em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop op-symbol small-op mtight\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mopen mtight\">[</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，即 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的个数除以它的长度。</p>\n<p>现给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，请你找到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的若干不相交子串使得这些它们拼起来后得到的 01 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>p</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">|p|=m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">p</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(p)=f(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span></span></span></span>。输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 对于一个 01 序列 bbb，定义 f(b)=∑[bi=1]∣b∣f(b)=\\frac{\\sum\\limits [b_i=1]}{|b|}f(b)=∣b∣∑[bi​=1]​，即 bbb 中 111 的个数除以它的长度。 现给定一个长度为 nnn 的序列 aaa 和一个正整数 mmm，请你找到 aaa 的若干不相交子串使得这些它们拼起来后得到的 01 串 ppp 满足 ∣p∣=m|p|=m∣p∣=m 且 f(p)=f(a)f(p)=f(a)f(p)=f(a)。输出方案。 1≤m≤n≤2×1051\\le m\\le n\\le 2\\times 10^51≤m≤n≤2×105。 设 c1=∑[ai=1],x=c1⋅mnc1=\\sum[a_i=1],x=\\frac{c1\\cdot m}{n}c1=∑[ai​=1],x=nc1⋅m​ 即 ppp 中需要的 111 的个数。 首先显然若 c1⋅mn\\frac{c1\\cdot m}{n}nc1⋅m​ 不是整数即 mmm 不是 ngcd⁡(n,c1)\\frac{n}{\\gcd(n,c1)}gcd(n,c1)n​ 的倍数则无解，否则一定有解。 对于这种题，一般猜想答案 ≤2\\le 2≤2。那么猜想最多只需要两段，考虑证明。 考虑最多两段不交的区间可能是什么，不难想到它有可能是一个环上的一段区间。那么考虑把 aaa 放到环上，即令 ai+n=aia_{i+n}=a_iai+n​=ai​。设 ci=∑j=ii+m−1[aj=1]c_i=\\sum\\limits_{j=i}^{i+m-1}[a_j=1]ci​=j=i∑i+m−1​[aj​=1]，考察 ccc 的性质： ∣ci−ci+1∣≤1|c_{i}-c_{i+1}|\\le 1∣ci​−ci+1​∣≤1：显然，因为滑动窗口不可能同时加入/删除两个 111； ∀y∈N,min⁡{ci}≤y≤max⁡{ci},∃ck=y\\forall y\\in \\mathbb{N},\\min\\{c_i\\}\\le y\\le \\max\\{c_i\\},\\exist c_k=y∀y∈N,min{ci​}≤y≤max{ci​},∃ck​=y：通过第一条性质不难得出，因为无法“跳过”某个 yyy； min⁡{ci}≤x≤max⁡{ci}\\min\\{c_i\\}\\le x\\le \\max\\{c_i\\}min{ci​}≤x≤max{ci​}： 考虑反证，假设 min⁡{ci}&gt;x\\min\\{c_i\\}&gt;xmin{ci​}&gt;x，则 ∑i=1nci&gt;c1⋅m\\sum\\limits_{i=1}^n c_i&gt;c1\\cdot mi=1∑n​ci​&gt;c1⋅m。注意到 ∑i=1nci=c1⋅m\\sum\\limits_{i=1}^n c_i=c1\\cdot mi=1∑n​ci​=c1⋅m 因为每个 111 都被计算了 mmm 次。所以有 c1⋅m&gt;c1⋅mc1\\cdot m&gt;c1\\cdot mc1⋅m&gt;c1⋅m，矛盾。 max⁡{ci}≥x\\max\\{c_i\\}\\ge xmax{ci​}≥x 的证明同理。 根据第二条和第三条性质可以得出 ∃ck=x\\exist c_k=x∃ck​=x，那么找到这个 kkk 即可找到环上符合条件的区间，即序列上最多两个不交的区间。 所以最多只需要两段。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005; int n,m; char a[S]; int c1,c[S]; inline int gcd(int x,int y) { int t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,a+1); for(int i=1;i&lt;=n;i++) c[i]=c1=0; for(int i=1;i&lt;=n;i++) c1+=a[i]=='1'; if(m%(n/gcd(n,c1))!=0) return puts(&quot;-1&quot;),void(); int x=1ll*c1*m/n; for(int i=1;i&lt;=m;i++) c[1]+=a[i]=='1'; for(int i=2;i&lt;=n;i++) { c[i]=c[i-1]; c[i]-=a[i-1]=='1'; c[i]+=a[(i+m-1-1)%n+1]=='1'; } for(int i=1;i&lt;=n;i++) { if(c[i]==x) { if(i+m-1&lt;=n) printf(&quot;1\\n%d %d\\n&quot;,i,i+m-1); else printf(&quot;2\\n%d %d\\n%d %d\\n&quot;,i,n,1,i+m-1-n); return; } } } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1658F Juju and Binary String 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1658f-juju-and-binary-string-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":255000,"words":824,"minutes":5},"date":"2023-07-14 20:24:27","dateFormat":"2023-07-14"},{"abstract":"<blockquote>\n<p><a href=\"http://poj.org/problem?id=3834\">题目链接</a></p>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向图，一开始所有边都没有被染色。Alice 和 Bob 在这张图上轮流操作直到所有边都被染色，Alice 先手。他们的操作为：</p>\n<ul>\n<li>Alice：选择一条没被染色的边，染上红色；</li>\n<li>Bob：选择一条没被染色的边，染上蓝色；</li>\n</ul>\n<p>若最终被染上蓝色的边连通了整张图，那么 Bob 赢，否则 Alice 赢。</p>\n<p>若两个人都足够聪明，求谁会赢。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac><mo separator=\"true\">,</mo><mn>30</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le \\min(\\frac{n(n-1)}{2},30)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span>。</p>\n</blockquote>\n","content":" 题目链接 给定一张 nnn 个点 mmm 条边的无向图，一开始所有边都没有被染色。Alice 和 Bob 在这张图上轮流操作直到所有边都被染色，Alice 先手。他们的操作为： Alice：选择一条没被染色的边，染上红色； Bob：选择一条没被染色的边，染上蓝色； 若最终被染上蓝色的边连通了整张图，那么 Bob 赢，否则 Alice 赢。 若两个人都足够聪明，求谁会赢。 1≤n≤101\\le n\\le 101≤n≤10，1≤m≤min⁡(n(n−1)2,30)1\\le m\\le \\min(\\frac{n(n-1)}{2},30)1≤m≤min(2n(n−1)​,30)。 考虑 Jerry Wen 定理，找必要/充分条件。 对于 Bob 必胜，有一个不那么显然的必要条件： 能在原图中找到两棵边集不交的生成树； 考虑证明它是充要条件： 必要性： 设两棵生成树分别为 AAA 与 BBB，若某一步 Alice 选择了 AAA 中的一条边，把图分裂成了两个连通块，则 Bob 一定可以选择 BBB 中的一条跨越这两个连通块的边；Alice 选择 BBB 中的边也是同理。 充分性： 若没有生成树（图不连通），显然 Bob 必败。 若不存在边不交的两棵生成树但图联通，则考虑某次 Alice 操作时 Bob 的必胜条件： 图去掉所有红边，把所有蓝边复制一次后，能找到两棵边不交的生成树。 显然刚开始并不满足这个条件，若 Bob 存在一种策咯使得他某次操作后满足了这个条件（必胜策略），则由于 Alice 是先手，所以她一定能把 Bob 的策略照搬过来，使得她某一次操作后满足： 图去掉所有蓝边，把所有红边复制一次后，能找到两棵边不交的生成树。 也就是说，角色互换了。所以若 Bob 存在必胜策略，则 Alice 存在可以让红边构成一棵生成树的策略。由于不存在边相交的两颗生成树，所以 Bob 必败，与 Bob 存在必胜策略矛盾。 所以 Bob 不存在必胜策略。 Q.E.D. 观察到 (309)=14307150\\binom{30}{9}=14307150(930​)=14307150 比较小，所以可以直接爆搜，但是要注意剪枝。代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=15; struct node { int x,y; }b[S*S]; int n,m; int fa[S]; bool vis[S*S]; set&lt;int&gt; st; int fnd(int x){return fa[x]==x?x:fa[x]=fnd(fa[x]);} inline bool chk(int sta) { for(int i=1;i&lt;=m;i++) vis[i]=false; for(int i=1;i&lt;=m;i++) if(sta&gt;&gt;i-1&amp;1) vis[i]=true; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) if(!vis[i]) fa[fnd(b[i].x)]=fnd(b[i].y); int r1=fnd(1); for(int i=1;i&lt;=n;i++) if(fnd(i)!=r1) return false; return true; } bool dfs(int s1,int s2) { if(!chk(s1)) return false; if(s2==(1&lt;&lt;n)-1) return true; if(st.count(s1)) return false; st.insert(s1); for(int i=1;i&lt;=m;i++) { if(s1&gt;&gt;i-1&amp;1) continue; if((s2&gt;&gt;b[i].x-1&amp;1)+(s2&gt;&gt;b[i].y-1&amp;1)!=1) continue; if(dfs(s1|(1&lt;&lt;i-1),s2|(1&lt;&lt;b[i].x-1)|(1&lt;&lt;b[i].y-1))) return true; } return false; } inline void slove() { st.clear(); puts(dfs(0,1)?&quot;YES&quot;:&quot;NO&quot;); } int main() { while(1) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n==-1&amp;&amp;m==-1) break; for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;b[i].x,&amp;b[i].y); for(int i=1;i&lt;=m;i++) b[i].x++,b[i].y++; slove(); } return 0; } ","tags":[{"name":"博弈论","slug":"6A-_b3w3J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/6A-_b3w3J/"},{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"POJ3834 Graph Game 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/poj3834-graph-game-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":247000,"words":898,"minutes":5},"date":"2023-07-14 18:49:14","dateFormat":"2023-07-14"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>，有一些边有向，剩下的边无向。你要给每条无向边定向使得定向后的有向图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span></span></span></span> 强连通。输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 5000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 个点 mmm 条边的图 GGG，有一些边有向，剩下的边无向。你要给每条无向边定向使得定向后的有向图 HHH 强连通。输出方案。 1≤n,m≤50001\\le n,m\\le 50001≤n,m≤5000。 Jerry Wen 定理，考虑找有解的若干必要/充分条件，再证明这些条件的并是充要的： 若把所有有向边看作无向边，则 GGG 一定是一个点双； 若把所有无向边看作双向边（两条有向边：u→vu\\to vu→v 和 v→uv\\to uv→u），则 GGG 一定强连通； 这些条件的并显然是必要的，考虑证明它们的并是充要的： 必要性显然； 充分性： 考虑反证。若某个时刻满足这两个条件，且对于某条无向边 (u,v)(u,v)(u,v)，无论如何定向都不能同时满足这两个条件，则： 由于第一个条件定向后一定仍满足，所以一定是不满足第二个条件； 由于定向前满足第二个条件，定向后不满足，所以 u→vu\\to vu→v 与 v→uv\\to uv→u 一定都要被经过，那么图一定是长这样的： 但是这样显然可以把这两个环合并得到一个大环，不需要走 (u,v)(u,v)(u,v) 这条边。 所以不存在这种情况。 Q.E.D. 由于题目保证了一定有解，所以第一个条件一定满足，只用判断第二个条件是否满足。 那么直接枚举每条边，O(n+m)O(n+m)O(n+m) 判断哪种定向合法即可，时间复杂度 O(m(n+m))O(m(n+m))O(m(n+m))。注意判合法只要判断定向后 uuu 和 vvv 能否互相到达。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=5005; struct node { int x,y,t; }ed[S]; int n,m; vector&lt;int&gt; g[S]; bool vis[S]; int ans[S]; bool chk(int u,int v,int ban) { vis[u]=true; if(u==v) return true; for(int i:g[u]) { if(i==ban) continue; int too=-1; if(ed[i].x==u) { if(ed[i].t==0||ed[i].t==1) too=ed[i].y; } else { if(ed[i].t==0||ed[i].t==2) too=ed[i].x; } if(v!=-1&amp;&amp;!vis[too]&amp;&amp;chk(too,v,ban)) return true; } return false; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;ed[i].x,&amp;ed[i].y,&amp;ed[i].t); for(int i=1;i&lt;=m;i++) g[ed[i].x].push_back(i),g[ed[i].y].push_back(i); for(int i=1;i&lt;=m;i++) { if(ed[i].t==0) { for(int j=1;j&lt;=n;j++) vis[j]=false; if(chk(ed[i].y,ed[i].x,i)) ed[i].t=1,ans[i]=0; else ed[i].t=2,ans[i]=1; } else ans[i]=0; } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"UOJ134 App 管理器 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/uoj134-app-guan-li-qi-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":197000,"words":704,"minutes":4},"date":"2023-07-13 14:54:20","dateFormat":"2023-07-13"},{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的正整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，Alice 会把整个序列任意排列，然后 Bob 可以进行任意次操作，每次选择两个相邻的互质的数交换位置。</p>\n<p>Alice 希望最终序列的字典序尽量小，而 Bob 希望字典序尽量大。</p>\n<p>若 Alice 和 Bob 都足够聪明，求最终序列。</p>\n</blockquote>\n","content":" 给定一个长 nnn 的正整数序列 aia_iai​，Alice 会把整个序列任意排列，然后 Bob 可以进行任意次操作，每次选择两个相邻的互质的数交换位置。 Alice 希望最终序列的字典序尽量小，而 Bob 希望字典序尽量大。 若 Alice 和 Bob 都足够聪明，求最终序列。 考虑建立一个 nnn 个点的无向图 GGG， ∀1≤i&lt;j≤n,gcd⁡(ai,aj)=1\\forall 1\\le i&lt;j\\le n,\\gcd(a_i,a_j)\\not=1∀1≤i&lt;j≤n,gcd(ai​,aj​)​=1 都有 (i,j)∈G(i,j)\\in G(i,j)∈G。 考虑 Alice 的操作对 Bob 的影响，设他任意排列后的序列为 bbb。那么 ∀1≤i&lt;j≤n,gcd⁡(bi,bj)=1\\forall 1\\le i&lt;j\\le n,\\gcd(b_i,b_j)\\not=1∀1≤i&lt;j≤n,gcd(bi​,bj​)​=1，Bob 都无法把 bjb_jbj​ 移到 bib_ibi​ 前面。所以 Alice 相当于是给 GGG 中每条边都定向，使得得到的有向图 HHH 是个 DAG，Bob 则会找到 HHH 中字典序最大的拓扑序。 那么问题转化为给 GGG 中的边定向使得得到的有向图 HHH 是 DAG 且拓扑序字典序最大值最小。考虑 HHH 固定时 Bob 如何找到字典序最大的拓扑序，显然只要用大根堆拓扑就行了。也就是说，若当前入度为 000 的点集为 SSS，Bob 会选择 SSS 中最大的元素进行拓展。 考虑如何定向，显然要让 SSS 中最小的元素 xxx 控制（即指向）尽可能多的其它元素，这样这些元素都会被放到 xxx 的后面。那么按 aia_iai​ 从小到大对每一个 iii 跑 dfs，dfs uuu 时对于所有与 uuu 有连边的点 vvv 再按照 ava_vav​ 从小到大 dfs 即可： set&lt;int&gt; g[S]; void dfs(int x) { vis[x]=true; for(int v:g[x]) if(!vis[v]) g2[x].push_back(v),ind[v]++,dfs(v); } 这样做的正确性比较显然，考虑 uuu 在拓扑时删掉后剩下的若干互不连通的子图，子图之间在拓扑序中的顺序显然 Alice 无法控制，而子图内部一定是让目前能拓展的字典序最小的点（vvv）控制尽可能多的其它点。 时间复杂度 O(n2log⁡V)O(n^2\\log V)O(n2logV)（log⁡V\\log VlogV 来自于计算 gcd⁡\\gcdgcd），代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;queue&gt; using namespace std; const int S=2005; int n,a[S]; set&lt;int&gt; g[S]; bool vis[S]; vector&lt;int&gt; g2[S]; int ind[S]; int tt,ans[S]; inline int gcd(int x,int y) { int t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } void dfs(int x) { vis[x]=true; for(int v:g[x]) if(!vis[v]) g2[x].push_back(v),ind[v]++,dfs(v); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i==j) continue; if(gcd(a[i],a[j])&gt;1) g[i].insert(j); } } for(int i=1;i&lt;=n;i++) if(!vis[i]) dfs(i); priority_queue&lt;pair&lt;int,int&gt;&gt; q; for(int i=1;i&lt;=n;i++) if(ind[i]==0) q.push(make_pair(a[i],i)); while(!q.empty()) { int u=q.top().second; q.pop(); ans[++tt]=u; for(int v:g2[u]) if(--ind[v]==0) q.push(make_pair(a[v],v)); } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[ans[i]]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"AGC010E Rearranging 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/agc010e-rearranging-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":241000,"words":845,"minutes":5},"date":"2023-07-12 19:56:10","dateFormat":"2023-07-12"},{"abstract":"","content":"Part 0 声明 本文若无特殊说明，所有集合皆为有限集合。 Part 1 群定义 1.1 群 称一个集合 GGG 和某种二元运算 ⋅\\cdot⋅ 构成群当且仅当： 存在单位元：∃e∈G\\exists e\\in G∃e∈G 满足 ∀g∈G\\forall g\\in G∀g∈G 有 e⋅g=g⋅e=ge\\cdot g=g\\cdot e=ge⋅g=g⋅e=g； 满足结合律：∀g1,g2,g3∈G\\forall g_1,g_2,g_3\\in G∀g1​,g2​,g3​∈G，有 g1⋅(g2⋅g3)=(g1⋅g2)⋅g3g_1\\cdot(g_2\\cdot g_3)=(g_1\\cdot g_2)\\cdot g_3g1​⋅(g2​⋅g3​)=(g1​⋅g2​)⋅g3​； 封闭：∀g1,g2∈G\\forall g_1,g_2\\in G∀g1​,g2​∈G，满足 g1⋅g2∈Gg_1\\cdot g_2\\in Gg1​⋅g2​∈G； 存在逆元：∀g∈G\\forall g\\in G∀g∈G，有 g−1∈Gg^{-1}\\in Gg−1∈G 满足 g⋅g−1=g−1⋅g=eg\\cdot g^{-1}=g^{-1}\\cdot g=eg⋅g−1=g−1⋅g=e； 注意 GGG 不一定满足交换律，满足交换律的群叫交换群或阿贝尔群。 集合 GGG 和运算 ⋅\\cdot⋅ 构成的群记为 (G,⋅)(G,\\cdot)(G,⋅)，本文为了方便省略了运算 ⋅\\cdot⋅，统一记作群 GGG。 1.2 子群 对于一个群 GGG，称群 HHH 为 GGG 的子群当且仅当 H⊆GH\\subseteq GH⊆G。 例如模 333 意义下的乘法群 {1}\\{1\\}{1} 是模 333 意义下的乘法群 {1,2}\\{1,2\\}{1,2} 的子群。 1.3 左陪集和右陪集 对于一个群 GGG、它的子群 HHH 和一个 g∈Gg\\in Gg∈G： 定义 g⋅H={g⋅h∣h∈H}g\\cdot H=\\{g\\cdot h|h\\in H\\}g⋅H={g⋅h∣h∈H} 为 HHH 的左陪集； 定义 H⋅g={h⋅g∣h∈H}H\\cdot g=\\{h\\cdot g|h\\in H\\}H⋅g={h⋅g∣h∈H} 为 HHH 的右陪集； 例如 {2}\\{2\\}{2} 是模 333 意义下的乘法群 {1,2}\\{1,2\\}{1,2} 的子群 {1}\\{1\\}{1} 的左陪集，也是它的右陪集。 Part 2 群性质 2.1 群皆可逆矩阵群 考虑一个大小为 nnn 的群 GGG，∀g∈G\\forall g\\in G∀g∈G，显然可以把 ggg 写成一个 n×nn\\times nn×n 的 01 矩阵且保证写出的矩阵集仍是一个群。 所以任意群都和全体可逆矩阵群的一个子群同构。 2.2 陪集的性质和 Lagrange 定理 2.2.1 陪集的性质 考虑群 GGG 的任意子群 HHH 和任意 a,b∈Ga,b\\in Ga,b∈G：（这里考虑右陪集，左陪集同理） H⋅a∈GH\\cdot a\\in GH⋅a∈G：由于 GGG 是群所以封闭； a∈H⋅aa\\in H\\cdot aa∈H⋅a：因为 e∈He\\in He∈H； a∈H⇔H⋅a=Ha\\in H\\Leftrightarrow H\\cdot a=Ha∈H⇔H⋅a=H：由于 HHH 是群所以封闭； b∈H⋅a⇔H⋅a=H⋅bb\\in H\\cdot a\\Leftrightarrow H\\cdot a=H\\cdot bb∈H⋅a⇔H⋅a=H⋅b； 证明 右到左显然，左到右： ∃h∈H,h⋅a=b\\exist h\\in H,h\\cdot a=b∃h∈H,h⋅a=b，所以 H⋅b=H⋅(h⋅a)=(H⋅h)⋅a=H⋅aH\\cdot b=H\\cdot(h\\cdot a)=(H\\cdot h)\\cdot a=H\\cdot aH⋅b=H⋅(h⋅a)=(H⋅h)⋅a=H⋅a。（根据 2） Q.E.D. H⋅aH\\cdot aH⋅a 与 H⋅bH\\cdot bH⋅b 要么相等要么不交； 证明 若有交则 ∃c∈H⋅a,c∈H⋅b\\exist c\\in H\\cdot a,c\\in H\\cdot b∃c∈H⋅a,c∈H⋅b，根据 3，H⋅a=H⋅c=H⋅bH\\cdot a=H\\cdot c=H\\cdot bH⋅a=H⋅c=H⋅b。 Q.E.D. ∣H⋅a∣=∣H∣|H\\cdot a|=|H|∣H⋅a∣=∣H∣； 证明 若 ∣H⋅a∣=∣H∣|H\\cdot a|\\not=|H|∣H⋅a∣​=∣H∣，则一定有 ∣H⋅a∣&lt;∣H∣|H\\cdot a|&lt;|H|∣H⋅a∣&lt;∣H∣，则有 h1,h2∈Hh_1,h_2\\in Hh1​,h2​∈H 满足 h1=h2h_1\\not=h_2h1​​=h2​ 且 h1⋅a=h2⋅ah_1\\cdot a=h_2\\cdot ah1​⋅a=h2​⋅a。 由于 a∈Ga\\in Ga∈G，所以 a−1∈Ga^{-1}\\in Ga−1∈G，所以 h1⋅a⋅a−1=h2⋅a⋅a−1h_1\\cdot a\\cdot a^{-1}=h_2\\cdot a\\cdot a^{-1}h1​⋅a⋅a−1=h2​⋅a⋅a−1，h1=h2h_1=h_2h1​=h2​，矛盾。 所以 ∣H⋅a∣=∣H∣|H\\cdot a|=|H|∣H⋅a∣=∣H∣，Q.E.D. 2.2.2 Lagrange 定理 对于群 GGG 的任意子群 SSS，均有 ∣G∣|G|∣G∣ 是 ∣S∣|S|∣S∣ 的因子。 证明是显然的，根据 2.2.1 中的 1、5、6 立得。 推论：∀gcd⁡(x,p)=1,xφ(p)≡1(modp)\\forall \\gcd(x,p)=1,x^{\\varphi(p)}\\equiv 1\\pmod p∀gcd(x,p)=1,xφ(p)≡1(modp) 考虑模 mmm 的乘法群 Sp={x∣1≤x&lt;p,gcd⁡(x,p)=1}S_p=\\{x|1\\le x&lt;p,\\gcd(x,p)=1\\}Sp​={x∣1≤x&lt;p,gcd(x,p)=1}，显然有 ∣Sp∣=φ(p)|S_p|=\\varphi(p)∣Sp​∣=φ(p)。 对于 SpS_pSp​ 的幂子群 Hx={xy mod p∣y∈N}(x∈Sp)H_x=\\{x^y\\text{ mod } p|y\\in \\mathbb{N}\\}(x\\in S_p)Hx​={xy mod p∣y∈N}(x∈Sp​)，均有 ∣Hx∣|H_x|∣Hx​∣ 是 ∣Sp∣|S_p|∣Sp​∣ 即 φ(p)\\varphi(p)φ(p) 的因数。 因为 x∣Hx∣≡1(modp)x^{|H_x|}\\equiv 1\\pmod px∣Hx​∣≡1(modp)，所以 xφ(p)≡(x∣Hx∣)φ(p)∣Hx∣≡1(modp)x^{\\varphi(p)}\\equiv (x^{|H_x|})^{\\frac{\\varphi(p)}{|H_x|}}\\equiv 1\\pmod pxφ(p)≡(x∣Hx​∣)∣Hx​∣φ(p)​≡1(modp)。 Part 3 群作用 考虑一个置换群 GGG 和一个集合 XXX，满足 ∀x∈X,g∈G\\forall x\\in X,g\\in G∀x∈X,g∈G 都有 x⋅g∈Xx\\cdot g\\in Xx⋅g∈X。 这时称 GGG 是 XXX 上的作用，例如 nnn 阶置换群就是 nnn 阶排列集上的作用。 3.1 轨道和定点 ∀x∈X\\forall x\\in X∀x∈X，定义 GGG 作用在 XXX 上的轨道 OxO_xOx​ 和定作用集（其实是群） GxG_xGx​： Ox={x⋅g∣g∈G}Gx={g∣g∈G,x⋅g=x}O_x=\\{x\\cdot g|g\\in G\\}\\\\ G_x=\\{g|g\\in G,x\\cdot g=x\\}\\\\ Ox​={x⋅g∣g∈G}Gx​={g∣g∈G,x⋅g=x} OxO_xOx​ 实际上是在 GGG 作用下 XXX 中与 xxx 等价元素的集合。 考察 GxG_xGx​ 的性质： Gx⊆GG_x\\subseteq GGx​⊆G； 存在单位元：e∈Gxe\\in G_xe∈Gx​，这很显然； 满足结合律：∀g1,g2,g3∈Gx\\forall g_1,g_2,g_3\\in G_x∀g1​,g2​,g3​∈Gx​，有 g1⋅(g2⋅g3)=(g1⋅g2)⋅g3g_1\\cdot(g_2\\cdot g_3)=(g_1\\cdot g_2)\\cdot g_3g1​⋅(g2​⋅g3​)=(g1​⋅g2​)⋅g3​，这也很显然； 封闭：∀g1,g2∈Gx\\forall g_1,g_2\\in G_x∀g1​,g2​∈Gx​ 有 g1⋅g2∈Gxg_1\\cdot g_2\\in G_xg1​⋅g2​∈Gx​，因为 x⋅g1⋅g2=(x⋅g1)⋅g2=x⋅g2=xx\\cdot g_1\\cdot g_2=(x\\cdot g_1)\\cdot g_2=x\\cdot g_2=xx⋅g1​⋅g2​=(x⋅g1​)⋅g2​=x⋅g2​=x； 存在逆元：∀g∈Gx\\forall g\\in G_x∀g∈Gx​ 有 g−1∈Gxg^{-1}\\in G_xg−1∈Gx​，因为 x⋅g=x⇔x=x⋅g−1x\\cdot g=x\\Leftrightarrow x=x\\cdot g^{-1} x⋅g=x⇔x=x⋅g−1； 所以 GxG_xGx​ 是 GGG 的子群。 3.2 Burnside 引理和 Polya 定理 3.2.1 轨道-不动点引理（Orbit-stabilizer 引理） ∣Ox∣×∣Gx∣=∣G∣|O_x|\\times |G_x|=|G| ∣Ox​∣×∣Gx​∣=∣G∣ 证明 有： ∀g1,g2∈G,x⋅g1=x⋅g2Gx⋅g1=Gx⋅g2\\forall g_1,g_2\\in G,x\\cdot g_1=x\\cdot g_2\\\\ G_x\\cdot g_1=G_x\\cdot g_2\\\\ ∀g1​,g2​∈G,x⋅g1​=x⋅g2​Gx​⋅g1​=Gx​⋅g2​ 证明 ∵x⋅g1⋅g2−1=x∴g1⋅g2−1∈Gx∴g1∈Gx⋅g2,g2∈Gx⋅g1∴Gx⋅g1=Gx⋅g2\\begin{aligned} &amp;\\because x\\cdot g_1\\cdot g_2^{-1}=x\\\\ &amp;\\therefore g_1\\cdot g_2^{-1}\\in G_{x}\\\\ &amp;\\therefore g_1\\in G_x\\cdot g_2,g_2\\in G_x\\cdot g_1\\\\ &amp;\\therefore G_x\\cdot g_1=G_x\\cdot g_2 \\end{aligned} ​∵x⋅g1​⋅g2−1​=x∴g1​⋅g2−1​∈Gx​∴g1​∈Gx​⋅g2​,g2​∈Gx​⋅g1​∴Gx​⋅g1​=Gx​⋅g2​​ Q.E.D. 也就是说，每个满足 x⋅gy∈Oxx\\cdot g_y\\in O_xx⋅gy​∈Ox​ 的 gyg_ygy​ 都在 Gx⋅gyG_x\\cdot g_yGx​⋅gy​ 这个右陪集中，并且每个 y∈Oxy\\in O_xy∈Ox​ 都单独对应一个 GxG_xGx​ 的右陪集。由于子群的不同右陪集互不相交、大小相等且覆盖整个大群（Lagrange 定理、陪集的性质），所以： ∴∣Ox∣=∣G/Gx∣=∣{Gx⋅g∣g∈G}∣\\begin{aligned} \\therefore |O_x|=|G/G_x|=|\\{G_x\\cdot g|g\\in G\\}| \\end{aligned} ∴∣Ox​∣=∣G/Gx​∣=∣{Gx​⋅g∣g∈G}∣​ 那么显然有： ∣Ox∣×∣Gx∣=∣G∣|O_x|\\times |G_x|=|G| ∣Ox​∣×∣Gx​∣=∣G∣ Q.E.D. 3.2.2 Burnside 引理 设 Xg={x∣x∈X,x⋅g=x}X^g=\\{x|x\\in X,x\\cdot g=x\\}Xg={x∣x∈X,x⋅g=x}，X/G={Ox∣x∈X}X/G=\\{O_x|x\\in X\\}X/G={Ox​∣x∈X} 即 XXX 在 GGG 作用下的轨道集合（∣X/G∣|X/G|∣X/G∣ 即为 XXX 在 GGG 作用下本质不同元素个数），则： ∣X/G∣=1∣G∣∑g∈G∣Xg∣|X/G|=\\frac{1}{|G|}\\sum\\limits_{g\\in G}|X^g| ∣X/G∣=∣G∣1​g∈G∑​∣Xg∣ 证明 根据轨道-不动点引理： ∣Ox∣×∣Gx∣=∣G∣|O_x|\\times |G_x|=|G| ∣Ox​∣×∣Gx​∣=∣G∣ 并且注意到： ∑x∈X∣Gx∣=∑g∈G∣Xg∣∑x∈X/G∣x∣=∣X∣∀y1,y2∈Ox,Gy1=Gy2\\sum\\limits_{x\\in X} |G_x|=\\sum\\limits_{g\\in G}|X^g|\\\\ \\sum\\limits_{x\\in X/G}|x|=|X|\\\\ \\forall y_1,y_2\\in O_x,G_{y_1}=G_{y_2} x∈X∑​∣Gx​∣=g∈G∑​∣Xg∣x∈X/G∑​∣x∣=∣X∣∀y1​,y2​∈Ox​,Gy1​​=Gy2​​ 所以： ∑g∈G∣Xg∣=∑x∈X∣Gx∣=∑Ox∈X/G∑y∈Ox∣Gy∣=∑Ox∈X/G∣Ox∣×∣Gx∣=∣X/G∣×∣G∣\\begin{aligned} \\sum\\limits_{g\\in G}|X^g|&amp;=\\sum\\limits_{x\\in X} |G_x|=\\sum\\limits_{O_x\\in X/G}\\sum\\limits_{y\\in O_x}|G_y|\\\\ &amp;=\\sum\\limits_{O_x\\in X/G}|O_x|\\times |G_x|\\\\ &amp;=|X/G|\\times |G| \\end{aligned} g∈G∑​∣Xg∣​=x∈X∑​∣Gx​∣=Ox​∈X/G∑​y∈Ox​∑​∣Gy​∣=Ox​∈X/G∑​∣Ox​∣×∣Gx​∣=∣X/G∣×∣G∣​ Q.E.D. 3.2.3 Polya 定理 考虑给所有满足 x∈Xx\\in Xx∈X 的 xxx 中元素染上 mmm 种不同颜色（相同颜色元素本质相同）。∀g∈G\\forall g\\in G∀g∈G，设 c(g)c(g)c(g) 为 ggg 中轮换个数（置换中环的个数），则在 GGG 作用下本质不同染色方案数为： 1∣G∣∑g∈Gmc(g)\\frac{1}{|G|}\\sum\\limits_{g\\in G}m^{c(g)} ∣G∣1​g∈G∑​mc(g) 证明 只需证明 ∣Xg∣=mc(g)|X^g|=m^{c(g)}∣Xg∣=mc(g)。 由于对于每一个 ggg 的轮换 ooo，ooo 中元素染相同颜色才能在应用变换 ggg 后保持不变，所以每个轮换有 mmm 种染色方案。而一共有 c(g)c(g)c(g) 个轮换，所以有 mc(g)m^{c(g)}mc(g) 种染色方式在应用变换 ggg 后保持不变。 所以 ∣Xg∣=mc(g)|X^g|=m^{c(g)}∣Xg∣=mc(g)，Q.E.D. Tips： 观察 Ploya 定理的证明过程，不难发现对于置换作用 ggg，满足 x⋅g=xx\\cdot g=xx⋅g=x 的 x∈Xx\\in Xx∈X 必定满足位于同一个轮换的元素本质相同。 这方便了 Burnside 引理的应用。 Part 4 群例题 P4980 【模板】Pólya 定理 查看题解 考虑 nnn 阶顺时针旋转置换构成的集合 GGG： 存在单位元：置换 pi=ip_i=ipi​=i 在 GGG 中； 满足结合律：显然； 封闭：显然； 存在逆元：显然，可以绕一大圈再回来； 所以 GGG 是一个群。 考虑 Polya 定理： ∣X[m]/G∣=1∣G∣∑g∈Gmc(g)|X[m]/G|=\\frac{1}{|G|}\\sum\\limits_{g\\in G}m^{c(g)} ∣X[m]/G∣=∣G∣1​g∈G∑​mc(g) 注意到 ∀g∈G\\forall g\\in G∀g∈G，若 p⋅gp\\cdot gp⋅g 后 p1→pxp_1\\to p_xp1​→px​，则 ggg 中置换环有 gcd⁡(x,n)\\gcd(x,n)gcd(x,n) 个，即 c(g)=gcd⁡(x,n)c(g)=\\gcd(x,n)c(g)=gcd(x,n)。证明考虑从 iii 向 i+x−1 mod n+1i+x-1\\text{ mod }n+1i+x−1 mod n+1 即旋转后的点连边。 所以答案即为： 1n∑d∣nnd∑i=1nd[gcd⁡(i,nd)=1]=1n∑d∣nndφ(nd)\\frac{1}{n}\\sum\\limits_{d|n}n^d\\sum\\limits_{i=1}^{\\frac{n}{d}}[\\gcd(i,\\frac{n}{d})=1]=\\frac{1}{n}\\sum\\limits_{d|n} n^d\\varphi(\\frac{n}{d}) n1​d∣n∑​ndi=1∑dn​​[gcd(i,dn​)=1]=n1​d∣n∑​ndφ(dn​) 有一个神奇的结论，∑d∣nO(d)=O(n34)\\sum\\limits_{d|n}O(\\sqrt d)=O(n^{\\frac{3}{4}})d∣n∑​O(d​)=O(n43​)，所以暴力计算 φ(nd)\\varphi(\\frac{n}{d})φ(dn​) 能过。 考虑时间复杂度更正确的做法，实际上可以把 nnn 质因数分解，求 φ(nd)\\varphi(\\frac{n}{d})φ(dn​) 时再 O(log⁡n)O(\\log n)O(logn) 分解质因数根据 φ\\varphiφ 的积性算出 φ(nd)\\varphi(\\frac{n}{d})φ(dn​)。单次时间复杂度 O(nlog⁡n)O(\\sqrt n\\log n)O(n​logn)。 代码如下：（O(Tnlog⁡n)O(T\\sqrt n\\log n)O(Tn​logn) 做法） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=100005,BS=35,p=1000000007; int n; bool nop[S]; int tot,prime[S]; int cp,ps[S],pi[S][BS]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline void init() { nop[0]=nop[1]=true; for(int i=2;i&lt;=S-3;i++) { if(!nop[i]) prime[++tot]=i; for(int j=1;j&lt;=tot;j++) { if(1ll*i*prime[j]&gt;S-3) break; nop[i*prime[j]]=true; if(i%prime[j]==0) break; } } } inline void slove() { scanf(&quot;%d&quot;,&amp;n); cp=0; int tn=n; for(int i=1;1ll*prime[i]*prime[i]&lt;=tn;i++) { if(tn%prime[i]==0) { ++cp; int tt=1; ps[cp]=prime[i],pi[cp][0]=1,pi[cp][1]=ps[cp]-1; while(tn%ps[cp]==0) tn/=ps[cp],pi[cp][tt+1]=pi[cp][tt]*ps[cp],tt++; } } if(tn&gt;1) cp++,ps[cp]=tn,pi[cp][0]=1,pi[cp][1]=tn-1; int sum=0; for(int i=1;1ll*i*i&lt;=n;i++) { if(n%i==0) { int d=i,pid=1; for(int j=1;j&lt;=cp;j++) { int ct=0; while(d%ps[j]==0) ct++,d/=ps[j]; pid*=pi[j][ct]; } sum=(sum+1ll*qpow(n,n/i)*pid%p)%p; if(i*i!=n) { d=n/i,pid=1; for(int j=1;j&lt;=cp;j++) { int ct=0; while(d%ps[j]==0) ct++,d/=ps[j]; pid*=pi[j][ct]; } sum=(sum+1ll*qpow(n,i)*pid%p)%p; } } } sum=1ll*sum*qpow(n,p-2)%p; printf(&quot;%d\\n&quot;,sum); } int main() { init(); int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } 【2023NOI模拟赛27】美术作业 洛谷题目列表&amp;tag=Polya 定理 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"群论入门","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/qun-lun-ru-men/","stats":{"text":"17 min read","time":1003000,"words":3180,"minutes":17},"date":"2023-07-11 20:53:23","dateFormat":"2023-07-11"},{"abstract":"<blockquote>\n<p>有一些鱼和一个一条鱼宽的长条鱼缸（鱼在鱼缸中只能排成一条直线）。若鱼缸中相邻两条鱼 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 大小分别为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 则：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x&gt;y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 能吃掉 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x&lt;y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 能吃掉 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x=y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 都能吃掉对方；</li>\n</ul>\n<p>一条大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 的鱼吃掉一条大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 的鱼后它的大小会增加 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>。</p>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 条鱼，大小依次为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\dots ,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次操作，每次操作为以下两种操作中的一种：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mi>x</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">1\\, x\\, y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>：把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 改为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mtext> </mtext><mi>l</mi><mtext> </mtext><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">2\\, l\\, r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span>：求若把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_l,a_{l+1},\\dots,a_r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 依次放入鱼缸中，最后有多少条鱼可能吃光其它鱼，询问互相独立，即鱼不会真的互相吃；</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,q\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>y</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i, y\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le l\\le r\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 有一些鱼和一个一条鱼宽的长条鱼缸（鱼在鱼缸中只能排成一条直线）。若鱼缸中相邻两条鱼 a,ba,ba,b 大小分别为 x,yx,yx,y 则： x&gt;yx&gt;yx&gt;y：aaa 能吃掉 bbb； x&lt;yx&lt;yx&lt;y：bbb 能吃掉 aaa； x=yx=yx=y：aaa 和 bbb 都能吃掉对方； 一条大小为 xxx 的鱼吃掉一条大小为 yyy 的鱼后它的大小会增加 yyy。 给定 nnn 条鱼，大小依次为 a1,a2,…,ana_1,a_2,\\dots ,a_na1​,a2​,…,an​。qqq 次操作，每次操作为以下两种操作中的一种： 1 x y1\\, x\\, y1xy：把 axa_xax​ 改为 yyy； 2 l r2\\, l\\, r2lr：求若把 al,al+1,…,ara_l,a_{l+1},\\dots,a_ral​,al+1​,…,ar​ 依次放入鱼缸中，最后有多少条鱼可能吃光其它鱼，询问互相独立，即鱼不会真的互相吃； 1≤n,q≤1051\\le n,q\\le 10^51≤n,q≤105，1≤ai,y≤1091\\le a_i, y\\le 10^91≤ai​,y≤109，1≤l≤r≤n1\\le l\\le r\\le n1≤l≤r≤n。 直接上线段树，不难发现区间 [L,R][L,R][L,R] 中有可能对答案有贡献的鱼肯定满足以下条件中至少一个： 能吃完 [L,R][L,R][L,R] 中的其它鱼； 能吃完 [L,li][L,l_i][L,li​] 即某个前缀中的其它鱼； 能吃完 [ri,R][r_i,R][ri​,R] 即某个后缀中的其它鱼； 不难发现 lil_ili​ 和 rir_iri​ 分别只有 O(log⁡V)O(\\log V)O(logV) 个，因为只有满足 ai&gt;∑j=Li−1aja_i&gt;\\sum\\limits_{j=L}^{i-1}a_jai​&gt;j=L∑i−1​aj​ 或 ai&gt;∑j=i+1Raja_i&gt;\\sum\\limits_{j=i+1}^{R}a_jai​&gt;j=i+1∑R​aj​ 的 iii 才有可能成为 li+1l_i+1li​+1 和 ri−1r_{i}-1ri​−1。 那么线段树上每个节点开两个 vector 维护一下这些端点就行了，具体实现看代码注释。 时间复杂度 O((n+q)log⁡nlog⁡V)O((n+q)\\log n\\log V)O((n+q)lognlogV)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int S=100005,MS=35; struct ndd { int p; // 吃掉这个端点后最远可以吃到哪里（左端点往右吃，右端点往左吃） long long s,v; // 吃掉这个端点可以长大多少，这个端点的值 int c; // 有多少鱼可以吃掉这个端点 inline ndd(){p=s=v=c=0;} inline ndd(int x,long long y,long long z,int w){p=x,s=y,v=z,c=w;} }; int smcl[S],smcr[S]; struct node { vector&lt;ndd&gt; lb,rb; // 前缀端点（从前到后）、后缀端点（从后到前） inline node(int x=0,long long y=0) { if(x==0) lb.clear(),rb.clear(); else lb=rb={ndd(x,y,y,1)}; // 只有一条鱼的区间 } inline node(vector&lt;ndd&gt; &amp;rl,vector&lt;ndd&gt; &amp;rr){lb=rl,rb=rr;} }tr[S&lt;&lt;2]; inline node operator+(node a,node b) { if(a.lb.size()==0) return b; if(b.lb.size()==0) return a; vector&lt;ndd&gt; rl=a.lb,rr=b.rb; int al=a.lb.size(),ar=a.rb.size(),bl=b.lb.size(),br=b.rb.size(); // left long long sum=0; for(int i=0;i&lt;al;i++) sum+=a.lb[i].s; // 吃完左边有多大 for(ndd pre:b.lb) { if(sum&gt;=pre.v) rl[rl.size()-1].s+=pre.s,rl[rl.size()-1].p=pre.p; // 这个端点可以被吃掉 else rl.push_back(pre); // 不能被吃掉 sum+=pre.s; } // right 同理 sum=0; for(int i=0;i&lt;br;i++) sum+=b.rb[i].s; for(ndd pre:a.rb) { if(sum&gt;=pre.v) rr[rr.size()-1].s+=pre.s,rr[rr.size()-1].p=pre.p; else rr.push_back(pre); sum+=pre.s; } // c // 清空 for(ndd &amp;u:rl) smcl[u.p]=0; for(ndd &amp;u:rr) smcr[u.p]=0; // 左区间的左端点和右区间的右端点 for(int i=0;i&lt;al;i++) smcl[rl[i].p]+=rl[i].c; for(int i=0;i&lt;br;i++) smcr[rr[i].p]+=rr[i].c; // 可以吃光整个大区间的鱼特殊处理 if(rl.size()==al) smcr[rr[rr.size()-1].p]+=a.lb[al-1].c; if(rr.size()==br) smcl[rl[rl.size()-1].p]+=b.rb[br-1].c; // 被左边的右端点困住，通过吃右边完成逃离 sum=0; int l=0,r=0; for(int i=0;i&lt;ar-1;i++) { while(l&lt;=i) sum+=a.rb[l].s,l++; // 获取这些鱼被困时多大 bool f=true; while(f) // 往左往右吃 { f=false; while(r&lt;bl&amp;&amp;sum&gt;=b.lb[r].v) sum+=b.lb[r++].s,f=true; while(l&lt;ar&amp;&amp;sum&gt;=a.rb[l].v) sum+=a.rb[l++].s,f=true; } if(l==ar) smcl[b.lb[r-1].p]+=a.rb[i].c; // 如果可以吃完左区间，即吃掉大区间的一个前缀 if(r==bl) smcr[a.rb[l-1].p]+=a.rb[i].c; // 如果可以吃完右区间，即吃掉大区间的一个后缀 } // 同理 sum=0; l=0,r=0; for(int i=0;i&lt;bl-1;i++) { while(l&lt;=i) sum+=b.lb[l].s,l++; bool f=true; while(f) { f=false; while(r&lt;ar&amp;&amp;sum&gt;=a.rb[r].v) sum+=a.rb[r++].s,f=true; while(l&lt;bl&amp;&amp;sum&gt;=b.lb[l].v) sum+=b.lb[l++].s,f=true; } if(l==bl) smcr[a.rb[r-1].p]+=b.lb[i].c; if(r==ar) smcl[b.lb[l-1].p]+=b.lb[i].c; } for(ndd &amp;u:rl) u.c=smcl[u.p]; for(ndd &amp;u:rr) u.c=smcr[u.p]; return node(rl,rr); } int n,q; long long a[S]; void build(int u,int l,int r) { if(l==r) return tr[u]=node(l,a[l]),void(); int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r); tr[u]=tr[u&lt;&lt;1]+tr[u&lt;&lt;1|1]; } void upd(int u,int l,int r,int pos,long long y) { if(l==r) return tr[u]=node(l,a[l]=y),void(); int mid=l+r&gt;&gt;1; if(pos&lt;=mid) upd(u&lt;&lt;1,l,mid,pos,y); else upd(u&lt;&lt;1|1,mid+1,r,pos,y); tr[u]=tr[u&lt;&lt;1]+tr[u&lt;&lt;1|1]; } void que(int u,int l,int r,int L,int R,node &amp;res) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) return res=res+tr[u],void(); int mid=l+r&gt;&gt;1; if(L&lt;=mid) que(u&lt;&lt;1,l,mid,L,R,res); if(R&gt;=mid+1) que(u&lt;&lt;1|1,mid+1,r,L,R,res); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); build(1,1,n); scanf(&quot;%d&quot;,&amp;q); while(q--) { int op,x,y; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y); if(op==1) upd(1,1,n,x,y); else { node res; que(1,1,n,x,y,res); printf(&quot;%d\\n&quot;,res.lb[res.lb.size()-1].c); } } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"JOISC2022K 魚 2 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/joisc2022k-yu-2-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":498000,"words":1561,"minutes":9},"date":"2023-07-11 20:48:41","dateFormat":"2023-07-11"},{"abstract":"","content":"Part 1 简介 FFT 本质上是处理加法卷积，即 AiBjA_iB_jAi​Bj​ 贡献到 Ci+jC_{i+j}Ci+j​。而 FWT 则是处理位运算卷积，即 AiBjA_iB_jAi​Bj​ 贡献到 Ci⋆jC_{i\\star j}Ci⋆j​，其中 ⋆\\star⋆ 是某种位运算。 FWT 的思想与 FFT 相近，也是创造一种数列到数列的线性变换 FWT⁡(A)\\operatorname{FWT}(A)FWT(A) 满足它与它的逆变换都可以快速计算且 FWT⁡(A⋆B)=FWT⁡(A)⋅FWT⁡(B)\\operatorname{FWT}(A\\star B)=\\operatorname{FWT}(A)\\cdot\\operatorname{FWT}(B)FWT(A⋆B)=FWT(A)⋅FWT(B)，其中 ⋅\\cdot⋅ 表示两个数列对应位置相乘。 有了这样的线性变换就可以先求出 FWT⁡(A)\\operatorname{FWT}(A)FWT(A) 和 FWT⁡(A)\\operatorname{FWT}(A)FWT(A)，算出 FWT⁡(A⋆B)=FWT⁡(A)⋅FWT⁡(B)\\operatorname{FWT}(A\\star B)=\\operatorname{FWT}(A)\\cdot\\operatorname{FWT}(B)FWT(A⋆B)=FWT(A)⋅FWT(B)，最后求出 C=IFWT⁡(A⋆B)C=\\operatorname{IFWT}(A\\star B)C=IFWT(A⋆B)。 本文中假定 ∣A∣=∣B∣=n|A|=|B|=n∣A∣=∣B∣=n 且 nnn 是 222 的整次幂。 Part 2 原理 先来解决 FWT⁡(A)\\operatorname{FWT}(A)FWT(A) 如何求解，不妨设 FWT⁡(A)i=∑j=0n−1ci,jAj\\operatorname{FWT}(A)_i=\\sum\\limits_{j=0}^{n-1}c_{i,j}A_jFWT(A)i​=j=0∑n−1​ci,j​Aj​，然后探讨 ccc 需要满足的条件。那么有： (FWT(A)⋅FWT(B))i=∑j=0n−1ci,jAj∑k=0n−1ci,kBk=∑j=0n−1∑k=0n−1ci,jci,kAjBkFWT(A⋆B)i=FWT(C)=∑j=0n−1ci,jCj=∑j=0n−1ci,j∑1≤k,l≤n,k⋆l=jAkBl=∑j=0n−1∑k=0n−1ci,j⋆kAjBk\\begin{aligned} (\\text{FWT}(A)\\cdot \\text{FWT}(B))_i&amp;=\\sum\\limits_{j=0}^{n-1} c_{i,j}A_j\\sum\\limits_{k=0}^{n-1}c_{i,k}B_k\\\\ &amp;=\\sum\\limits_{j=0}^{n-1}\\sum\\limits_{k=0}^{n-1} c_{i,j}c_{i,k}A_jB_k\\\\ \\text{FWT}(A\\star B)_i=\\text{FWT}(C)&amp;=\\sum\\limits_{j=0}^{n-1} c_{i,j}C_j\\\\ &amp;=\\sum\\limits_{j=0}^{n-1}c_{i,j}\\sum\\limits_{1\\le k,l\\le n,k\\star l=j} A_kB_l\\\\ &amp;=\\sum\\limits_{j=0}^{n-1}\\sum\\limits_{k=0}^{n-1} c_{i,j\\star k}A_jB_k \\end{aligned} (FWT(A)⋅FWT(B))i​FWT(A⋆B)i​=FWT(C)​=j=0∑n−1​ci,j​Aj​k=0∑n−1​ci,k​Bk​=j=0∑n−1​k=0∑n−1​ci,j​ci,k​Aj​Bk​=j=0∑n−1​ci,j​Cj​=j=0∑n−1​ci,j​1≤k,l≤n,k⋆l=j∑​Ak​Bl​=j=0∑n−1​k=0∑n−1​ci,j⋆k​Aj​Bk​​ 所以有： ci,jci,k=ci,j⋆kc_{i,j}c_{i,k}=c_{i,j\\star k} ci,j​ci,k​=ci,j⋆k​ 注意到由于 ⋆\\star⋆ 是位运算，所以不妨钦定 ccc 也可以拆位处理。令 (a)2=a0a1a2…‾(a)_2=\\overline{a_0a_1a_2\\dots}(a)2​=a0​a1​a2​…​ 即 aaa 的二进制表示，不妨钦定 ccc 满足 ci,j=ci0,j0ci1,j1ci2,j2…c_{i,j}=c_{i_0,j_0}c_{i_1,j_1}c_{i_2,j_2}\\dotsci,j​=ci0​,j0​​ci1​,j1​​ci2​,j2​​…，这样做的好处是只要知道 c0/1,0/1c_{0/1,0/1}c0/1,0/1​ 就可以求出 ci,jc_{i,j}ci,j​，而且也有： cil,jlcil,kl=cil,jl⋆kl⇔ci,jci,k=ci,j⋆kc_{i_l,j_l}c_{i_l,k_l}=c_{i_l,j_l\\star k_l}\\Leftrightarrow c_{i,j}c_{i,k}=c_{i,j\\star k} cil​,jl​​cil​,kl​​=cil​,jl​⋆kl​​⇔ci,j​ci,k​=ci,j⋆k​ 但是暴力求 FWT(A)\\text{FWT}(A)FWT(A) 是 O(n2)O(n^2)O(n2) 的，考虑优化，令 a′a&#x27;a′ 为 aaa 去掉二进制最高位的数，按位折半即有： FWT(A)i=∑j=0n2−1ci0,j0ci′,j′Aj+∑j=n2n−1ci0,j0ci′,j′Aj=ci0,0∑j=0n2−1ci′,j′Aj+ci0,1∑j=n2n−1ci′,j′Aj\\begin{aligned} \\text{FWT}(A)_i&amp;=\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i_0,j_0}c_{i&#x27;,j&#x27;}A_{j}+\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i_0,j_0}c_{i&#x27;,j&#x27;}A_{j}\\\\ &amp;=c_{i_0,0}\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i&#x27;,j&#x27;}A_{j}+c_{i_0,1}\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i&#x27;,j&#x27;}A_{j} \\end{aligned} FWT(A)i​​=j=0∑2n​−1​ci0​,j0​​ci′,j′​Aj​+j=2n​∑n−1​ci0​,j0​​ci′,j′​Aj​=ci0​,0​j=0∑2n​−1​ci′,j′​Aj​+ci0​,1​j=2n​∑n−1​ci′,j′​Aj​​ 那么考虑 i0i_0i0​ 的取值，有： FWT(A)i={c0,0∑j=0n2−1ci′,j′Aj+c0,1∑j=n2n−1ci′,j′Aj0≤i≤n2−1c1,0∑j=0n2−1ci′,j′Aj+c1,1∑j=n2n−1ci′,j′Ajn2≤i≤n−1\\text{FWT}(A)_i=\\begin{cases} c_{0,0}\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i&#x27;,j&#x27;}A_{j}+c_{0,1}\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i&#x27;,j&#x27;}A_{j}&amp;0\\le i\\le \\frac{n}{2}-1\\\\ c_{1,0}\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i&#x27;,j&#x27;}A_{j}+c_{1,1}\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i&#x27;,j&#x27;}A_{j}&amp;\\frac{n}{2}\\le i\\le n-1 \\end{cases} FWT(A)i​=⎩⎪⎪⎪⎨⎪⎪⎪⎧​c0,0​j=0∑2n​−1​ci′,j′​Aj​+c0,1​j=2n​∑n−1​ci′,j′​Aj​c1,0​j=0∑2n​−1​ci′,j′​Aj​+c1,1​j=2n​∑n−1​ci′,j′​Aj​​0≤i≤2n​−12n​≤i≤n−1​ 设 A0A0A0 为 AAA 中下标二进制最高位为 000 的部分，A1A1A1 为最高位为 111的部分，那么有： FWT(A)i={c0,0FWT(A0)i+c0,1FWT(A1)i0≤i≤n2−1c1,0FWT(A0)i−n2+c1,1FWT(A1)i−n2n2≤i≤n−1\\text{FWT}(A)_i=\\begin{cases} c_{0,0}\\text{FWT}(A0)_i+c_{0,1}\\text{FWT}(A1)_i&amp;0\\le i\\le \\frac{n}{2}-1\\\\ c_{1,0}\\text{FWT}(A0)_{i-\\frac{n}{2}}+c_{1,1}\\text{FWT}(A1)_{i-\\frac{n}{2}}&amp;\\frac{n}{2}\\le i\\le n-1 \\end{cases} FWT(A)i​={c0,0​FWT(A0)i​+c0,1​FWT(A1)i​c1,0​FWT(A0)i−2n​​+c1,1​FWT(A1)i−2n​​​0≤i≤2n​−12n​≤i≤n−1​ 假设 n=2mn=2^mn=2m，则可以在 O(m2m)O(m2^m)O(m2m) 即 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度内求解 FWT(A)\\text{FWT(A)}FWT(A)。 对于 IFWT(A)\\text{IFWT}(A)IFWT(A)，只需要构造出 c0/1,0/1c_{0/1,0/1}c0/1,0/1​ 的逆即可。 Part 3 具体实现 根据 ci,jci,k=ci,j⋆kc_{i,j}c_{i,k}=c_{i,j\\star k}ci,j​ci,k​=ci,j⋆k​ 和 ci0,j0ci1,j1=c2i0+i1,2j0+j1c_{i_0,j_0}c_{i_1,j_1}=c_{2i_0+i_1,2j_0+j_1}ci0​,j0​​ci1​,j1​​=c2i0​+i1​,2j0​+j1​​ 构造 c0/1,0/1c_{0/1,0/1}c0/1,0/1​ 即可，称其为位矩阵。 构造过程比较人类智慧，注意矩阵必须要有逆，即每一行和每一列都有至少一个位置不为 000 且不能有两行或者两列完全一样，否则就会有维度被丢失（线性代数说法）。 由于不同的位运算的 FWT\\text{FWT}FWT 本质相同，只是 ccc 不同，所以不妨设 FWT(A,[c0,0c0,1c1,0c1,1])\\text{FWT}\\left(A,\\begin{bmatrix}c_{0,0}&amp;c_{0,1}\\\\c_{1,0}&amp;c_{1,1}\\end{bmatrix}\\right)FWT(A,[c0,0​c1,0​​c0,1​c1,1​​]) 为 AAA 在对应的 ccc 意义下的 FWT\\text{FWT}FWT 结果，那么有 FWT(FWT(A,c),c−1)=A\\text{FWT}\\left(\\text{FWT}\\left(A,c\\right),c^{-1}\\right)=AFWT(FWT(A,c),c−1)=A。 3.1 OR\\text{OR}OR 卷积 考虑构造满足 ci,jci,k=ci,j∣kc_{i,j}c_{i,k}=c_{i,j|k}ci,j​ci,k​=ci,j∣k​ 且存在逆的位矩阵。 c0,0c0,0=c0,0∣0=c0,0⇒c0,0∈{0,1}c_{0,0}c_{0,0}=c_{0,0|0}=c_{0,0}\\Rightarrow c_{0,0}\\in\\{0,1\\}c0,0​c0,0​=c0,0∣0​=c0,0​⇒c0,0​∈{0,1}。 同理，c0/1,0/1∈{0,1}c_{0/1,0/1}\\in\\{0,1\\}c0/1,0/1​∈{0,1}。 由于 c0,0c0,1=c0,1c_{0,0}c_{0,1}=c_{0,1}c0,0​c0,1​=c0,1​，所以 c0,0=1,c0,1=0c_{0,0}=1,c_{0,1}=0c0,0​=1,c0,1​=0 或者 c0,0=1,c0,1=1c_{0,0}=1,c_{0,1}=1c0,0​=1,c0,1​=1。 同理，c1,0=1,c1,1=0c_{1,0}=1,c_{1,1}=0c1,0​=1,c1,1​=0 或者 c1,0=1,c1,1=1c_{1,0}=1,c_{1,1}=1c1,0​=1,c1,1​=1。 那么位矩阵就有两种构造方式： [1011][1110]\\begin{bmatrix} 1&amp;0\\\\1&amp;1 \\end{bmatrix} \\begin{bmatrix} 1&amp;1\\\\1&amp;0 \\end{bmatrix} [11​01​][11​10​] Tips： 观察这个位矩阵： [1011]\\begin{bmatrix} 1&amp;0\\\\1&amp;1 \\end{bmatrix} [11​01​] 注意到它满足 ci,j=[i&amp;j=j]c_{i,j}=[i\\&amp;j=j]ci,j​=[i&amp;j=j]，也就是说这种情况下 FWT(A,c)\\text{FWT}(A,c)FWT(A,c) 实际上相当于子集求和。 这启发我们形如 Bi=∑i⋆j=iAjB_i=\\sum\\limits_{i\\star j=i}A_jBi​=i⋆j=i∑​Aj​ 和 Bi=∑i⋆j=jAjB_i=\\sum\\limits_{i\\star j=j}A_jBi​=i⋆j=j∑​Aj​ 这样的和式（⋆\\star⋆ 是某种位运算）也可以用 FWT\\text{FWT}FWT 来快速求。 由于第一个位矩阵满足 ci,j=[i&amp;j=j]c_{i,j}=[i\\&amp;j=j]ci,j​=[i&amp;j=j]，所以下面采用第一个位矩阵，则设 c−1=[xyzw]c^{-1}=\\begin{bmatrix}x&amp;y\\\\z&amp;w\\end{bmatrix}c−1=[xz​yw​]，则有： {x+0z=1y+0w=0x+z=0y+w=1\\begin{cases} x+0z=1\\\\ y+0w=0\\\\ x+z=0\\\\ y+w=1 \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​x+0z=1y+0w=0x+z=0y+w=1​ 解得： {x=1y=0z=−1w=1\\begin{cases} x=1\\\\ y=0\\\\ z=-1\\\\ w=1 \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​x=1y=0z=−1w=1​ 所以 c−1=[10−11]c^{-1}=\\begin{bmatrix}1&amp;0\\\\-1&amp;1\\end{bmatrix}c−1=[1−1​01​]。 3.2 AND\\text{AND}AND 卷积 c0,0c0,0=c0,0&amp;0=c0,0⇒c0,0∈{0,1}c_{0,0}c_{0,0}=c_{0,0\\&amp;0}=c_{0,0}\\Rightarrow c_{0,0}\\in\\{0,1\\}c0,0​c0,0​=c0,0&amp;0​=c0,0​⇒c0,0​∈{0,1}。 同理，c0/1,0/1∈{0,1}c_{0/1,0/1}\\in\\{0,1\\}c0/1,0/1​∈{0,1}。 由于 c0,0c0,1=c0,0c_{0,0}c_{0,1}=c_{0,0}c0,0​c0,1​=c0,0​，所以 c0,0=0,c0,1=1c_{0,0}=0,c_{0,1}=1c0,0​=0,c0,1​=1 或 c0,0=1,c0,1=1c_{0,0}=1,c_{0,1}=1c0,0​=1,c0,1​=1。 同理，c1,0=0,c1,1=1c_{1,0}=0,c_{1,1}=1c1,0​=0,c1,1​=1 或 c1,0=1,c1,1=1c_{1,0}=1,c_{1,1}=1c1,0​=1,c1,1​=1。 那么位矩阵就有两种构造方式： [0111][1101]\\begin{bmatrix} 0&amp;1\\\\1&amp;1 \\end{bmatrix} \\begin{bmatrix} 1&amp;1\\\\0&amp;1 \\end{bmatrix} [01​11​][10​11​] 由于第一个位矩阵满足 ci,j=[i∣j=2k−1]c_{i,j}=[i|j=2^k-1]ci,j​=[i∣j=2k−1]，所以采用第一个位矩阵，同理，待定系数法求逆得 c−1=[−1110]c^{-1}=\\begin{bmatrix}-1&amp;1\\\\1&amp;0\\end{bmatrix}c−1=[−11​10​]。 3.3 XOR\\text{XOR}XOR 卷积 由于对于任意的 x,yx,yx,y，均有 c0,0cx,y=cx,yc_{0,0}c_{x,y}=c_{x,y}c0,0​cx,y​=cx,y​，所以 c0,0=1c_{0,0}=1c0,0​=1。 根据 c1,1c1,1=c1,0c_{1,1}c_{1,1}=c_{1,0}c1,1​c1,1​=c1,0​ 且矩阵不存在为 000 的行，所以 c1,0c_{1,0}c1,0​ 与 c1,1c_{1,1}c1,1​ 均非 000​。 根据 c1,0c1,0=c1,0c_{1,0}c_{1,0}=c_{1,0}c1,0​c1,0​=c1,0​ 且 c1,0=0c_{1,0}\\not=0c1,0​​=0 可得 c1,0=1c_{1,0}=1c1,0​=1。 根据，c0,1c0,1=c1,0c_{0,1}c_{0,1}=c_{1,0}c0,1​c0,1​=c1,0​，可得 c0,1=−1c_{0,1}=-1c0,1​=−1 或 c0,1=1c_{0,1}=1c0,1​=1。 同理，c1,1c1,1=c1,0c_{1,1}c_{1,1}=c_{1,0}c1,1​c1,1​=c1,0​，c1,1=−1c_{1,1}=-1c1,1​=−1 或 c1,1=1c_{1,1}=1c1,1​=1。 那么位矩阵就有两种构造方式： [1−111][111−1]\\begin{bmatrix} 1&amp;-1\\\\1&amp;1 \\end{bmatrix} \\begin{bmatrix} 1&amp;1\\\\1&amp;-1 \\end{bmatrix} [11​−11​][11​1−1​] 同样的，由于第二个位矩阵满足 ci,j=(−1)∣i&amp;j∣c_{i,j}=(-1)^{|i\\&amp;j|}ci,j​=(−1)∣i&amp;j∣（∣a∣|a|∣a∣ 为 aaa 二进制表示中 111 的个数），所以采用第二个位矩阵，求逆得 c−1=[121212−12]c^{-1}=\\begin{bmatrix}\\frac{1}{2}&amp;\\frac{1}{2}\\\\\\frac{1}{2}&amp;-\\frac{1}{2}\\end{bmatrix}c−1=[21​21​​21​−21​​]。 3.4 代码实现 直接套 FWT(A)i={c0,0FWT(A0)i+c0,1FWT(A1)i0≤i≤n2−1c1,0FWT(A0)i−n2+c1,1FWT(A1)i−n2n2≤i≤n−1\\text{FWT}(A)_i=\\begin{cases} c_{0,0}\\text{FWT}(A0)_i+c_{0,1}\\text{FWT}(A1)_i&amp;0\\le i\\le \\frac{n}{2}-1\\\\ c_{1,0}\\text{FWT}(A0)_{i-\\frac{n}{2}}+c_{1,1}\\text{FWT}(A1)_{i-\\frac{n}{2}}&amp;\\frac{n}{2}\\le i\\le n-1 \\end{cases} FWT(A)i​={c0,0​FWT(A0)i​+c0,1​FWT(A1)i​c1,0​FWT(A0)i−2n​​+c1,1​FWT(A1)i−2n​​​0≤i≤2n​−12n​≤i≤n−1​ 即可，P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT) 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int p=998244353,inv2=499122177; inline int getlen(int n) { int res=1; while(res&lt;n) res&lt;&lt;=1; return res; } const int ORC[2][2]={{1,0},{1,1}},IORC[2][2]={{1,0},{p-1,1}}; const int ANDC[2][2]={{0,1},{1,1}},IANDC[2][2]={{p-1,1},{1,0}}; const int XORC[2][2]={{1,1},{1,p-1}},IXORC[2][2]={{inv2,inv2},{inv2,p-inv2}}; inline void FWT(int n,int a[],const int c[2][2]) { for(int len=2;len&lt;=n;len&lt;&lt;=1) { int mid=len&gt;&gt;1; for(int l=0;l&lt;=n-len;l+=len) { for(int k=0;k&lt;mid;k++) { int x=a[l+k],y=a[l+mid+k]; a[l+k]=(1ll*c[0][0]*x%p+1ll*c[0][1]*y%p)%p; a[l+mid+k]=(1ll*c[1][0]*x%p+1ll*c[1][1]*y%p)%p; } } } } int n; int a[1&lt;&lt;17],b[1&lt;&lt;17],c[1&lt;&lt;17]; int main() { scanf(&quot;%d&quot;,&amp;n); n=1&lt;&lt;n; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;b[i]); FWT(n,a,ORC),FWT(n,b,ORC); for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*b[i]%p; FWT(n,c,IORC); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,c[i]); printf(&quot;\\n&quot;); FWT(n,a,IORC),FWT(n,b,IORC); FWT(n,a,ANDC),FWT(n,b,ANDC); for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*b[i]%p; FWT(n,c,IANDC); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,c[i]); printf(&quot;\\n&quot;); FWT(n,a,IANDC),FWT(n,b,IANDC); FWT(n,a,XORC),FWT(n,b,XORC); for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*b[i]%p; FWT(n,c,IXORC); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,c[i]); printf(&quot;\\n&quot;); return 0; } Part 4 更多拓展 有些时候考的往往不是裸的 FWT\\text{FWT}FWT。 下文中若 AAA 与 BBB 为数列，⋆\\star⋆ 为某种位运算，那么 A⋆BA\\star BA⋆B 表示 AAA 与 BBB 在 ⋆\\star⋆ 运算下的卷积结果，即 (A⋆B)i=∑j⋆k=iAjBk(A\\star B)_i=\\sum\\limits_{j\\star k=i}A_jB_k(A⋆B)i​=j⋆k=i∑​Aj​Bk​。 FWT\\text{FWT}FWT 应用时往往要利用它是线性变换来优化，即 FWT(A)+FWT(B)=FWT(A+B)\\text{FWT}(A)+\\text{FWT}(B)=\\text{FWT(A+B)}FWT(A)+FWT(B)=FWT(A+B) 且 FWT(aA)=aFWT(A)\\text{FWT}(aA)=a\\text{FWT}(A)FWT(aA)=aFWT(A)。 若 AAA 只有少数项非 000 则可能有分类讨论优化时间复杂度的做法。 一些例题： CF1119H Triple，题解 4.1 离线子集卷积 Ck=∑i∣j=k,i&amp;j=0AiBj=∑i⊆kAiBk−iC_{k}=\\sum\\limits_{i|j=k,i\\&amp;j=0}A_iB_j=\\sum\\limits_{i\\subseteq k}A_iB_{k-i} Ck​=i∣j=k,i&amp;j=0∑​Ai​Bj​=i⊆k∑​Ai​Bk−i​ 发现 i&amp;j=0i\\&amp;j=0i&amp;j=0 很烦，但是不难发现它等价于 ∣i∣+∣j∣=∣k∣|i|+|j|=|k|∣i∣+∣j∣=∣k∣（∣a∣|a|∣a∣ 表示 aaa 二进制表示中的 111 的个数），所以可以令 SAi,j=[∣j∣=i]Aj,SBi,j=[∣j∣=i]BjSA_{i,j}=[|j|=i]A_j,SB_{i,j}=[|j|=i]B_jSAi,j​=[∣j∣=i]Aj​,SBi,j​=[∣j∣=i]Bj​，那么有： Ri=∑j=0iSAj∣SBi−jR_i=\\sum\\limits_{j=0}^iSA_j|SB_{i-j} Ri​=j=0∑i​SAj​∣SBi−j​ 由于 FWT\\text{FWT}FWT 是线性变换，所以有： Ri=IFWT(∑j=0iFWT(SAj)⋅FWT(SBi−j))R_i=\\text{IFWT}\\left(\\sum\\limits_{j=0}^i\\text{FWT}(SA_j)\\cdot \\text{FWT}(SB_{i-j})\\right) Ri​=IFWT(j=0∑i​FWT(SAj​)⋅FWT(SBi−j​)) 答案即为 R∣i∣,iR_{|i|,i}R∣i∣,i​，时间复杂度 O(m22m)O(m^22^m)O(m22m)，参考代码：（P6097 【模板】子集卷积） int main() { scanf(&quot;%d&quot;,&amp;n); n=1&lt;&lt;n; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;(1&lt;&lt;20);i++) for(int j=0;j&lt;20;j++) popc[i]+=i&gt;&gt;j&amp;1; for(int i=0;i&lt;=20;i++) for(int j=0;j&lt;n;j++) sa[i][j]=(popc[j]==i)*a[j],sb[i][j]=(popc[j]==i)*b[j]; for(int i=0;i&lt;=20;i++) FWT(n,sa[i],ORC),FWT(n,sb[i],ORC); for(int i=0;i&lt;=20;i++) for(int j=0;j&lt;=i;j++) for(int k=0;k&lt;(1&lt;&lt;20);k++) r[i][k]=(r[i][k]+1ll*sa[j][k]*sb[i-j][k]%p)%p; for(int i=0;i&lt;=20;i++) FWT(n,r[i],IORC); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,r[popc[i]][i]); printf(&quot;\\n&quot;); return 0; } 4.2 半在线子集卷积 Ck=Bk∑i∣j=k,i&amp;j=0,i=kCiAj=Bk∑i⊂kCiAk−iC_k=B_k\\sum\\limits_{i|j=k,i\\&amp;j=0,i\\not=k}C_iA_j=B_k\\sum\\limits_{i\\subset k}C_iA_{k-i} Ck​=Bk​i∣j=k,i&amp;j=0,i​=k∑​Ci​Aj​=Bk​i⊂k∑​Ci​Ak−i​ 和离线子集卷积类似，令 SAi,j=[∣j∣=i]Aj,SCi,j=[∣j∣=i]CjSA_{i,j}=[|j|=i]A_j,SC_{i,j}=[|j|=i]C_jSAi,j​=[∣j∣=i]Aj​,SCi,j​=[∣j∣=i]Cj​，那么有： SCi=B⋅∑k=0i−1SCk∣SAi−k=B⋅IFWT(∑j=0iFWT(SCj)⋅FWT(SAi−j))\\begin{aligned} SC_{i}&amp;=B\\cdot\\sum\\limits_{k=0}^{i-1}SC_k|SA_{i-k}\\\\ &amp;=B\\cdot\\text{IFWT}\\left(\\sum\\limits_{j=0}^i\\text{FWT}(SC_j)\\cdot \\text{FWT}(SA_{i-j})\\right) \\end{aligned} SCi​​=B⋅k=0∑i−1​SCk​∣SAi−k​=B⋅IFWT(j=0∑i​FWT(SCj​)⋅FWT(SAi−j​))​ 那么从小到大枚举 iii 计算即可。 ","tags":[{"name":"FWT","slug":"UjstJwYTZ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/UjstJwYTZ/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"快速沃尔什变换（FWT）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kuai-su-wo-er-shi-bian-huan-fwtxue-xi-bi-ji/","stats":{"text":"24 min read","time":1397000,"words":4155,"minutes":24},"date":"2023-07-09 21:17:00","dateFormat":"2023-07-09"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数组，每个数组里有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，保证  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>&lt;</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">0\\le a_i,b_i,c_i&lt;2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p>对于每一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>t</mi><mo>&lt;</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">0\\le t&lt;2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65418em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span>，求有多少种从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数组中分别选一个数的方式，使得这些数异或起来等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span>，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le 17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个数组，每个数组里有 xxx 个 aia_iai​、yyy 个 bib_ibi​ 和 zzz 个 cic_ici​，保证 0≤ai,bi,ci&lt;2k0\\le a_i,b_i,c_i&lt;2^k0≤ai​,bi​,ci​&lt;2k。 对于每一个 0≤t&lt;2k0\\le t&lt;2^k0≤t&lt;2k，求有多少种从 nnn 个数组中分别选一个数的方式，使得这些数异或起来等于 ttt，对 998244353998244353998244353 取模。 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤k≤171\\le k\\le 171≤k≤17。 首先显然可以求出 Bi=FWT(Ai)B_i=\\text{FWT}(A_i)Bi​=FWT(Ai​) 点乘起来再求 IFWT\\text{IFWT}IFWT，但是这样时间复杂度为 O(nk2k)O(nk2^k)O(nk2k)，显然会 T。 发现 Bi,j=Cj,aix+Cj,biy+Cj,cizB_{i,j}=C_{j,a_i}x+C_{j,b_i}y+C_{j,c_i}zBi,j​=Cj,ai​​x+Cj,bi​​y+Cj,ci​​z，而且 Xor 卷积满足 Ci,j=(−1)∣i&amp;j∣C_{i,j}=(-1)^{|i\\&amp;j|}Ci,j​=(−1)∣i&amp;j∣（∣a∣|a|∣a∣ 为 aaa 二进制表示中 111 的个数），所以有 Bi,j=(−1)∣j&amp;ai∣x+(−1)∣j&amp;bi∣y+(−1)∣j&amp;ci∣zB_{i,j}=(-1)^{|j\\&amp;a_i|}x+(-1)^{|j\\&amp;b_i|}y+(-1)^{|j\\&amp;c_i|}zBi,j​=(−1)∣j&amp;ai​∣x+(−1)∣j&amp;bi​∣y+(−1)∣j&amp;ci​∣z。 由于异或有自反性，所以考虑令 ai,bi,cia_i,b_i,c_iai​,bi​,ci​ 都异或上 aia_iai​，最后求答案时再把下标异或上 ⊕ai\\oplus a_i⊕ai​。则有 Bi,j=x+(−1)∣j&amp;bi∣y+(−1)∣j&amp;ci∣zB_{i,j}=x+(-1)^{|j\\&amp;b_i|}y+(-1)^{|j\\&amp;c_i|}zBi,j​=x+(−1)∣j&amp;bi​∣y+(−1)∣j&amp;ci​∣z。 此时 Bi,jB_{i,j}Bi,j​ 共有四种取值，考虑对于每一个 (∏Bi)j(\\prod B_{i})_j(∏Bi​)j​ 求出每种取值分别的数量 c1,c2,c3,c4c1,c2,c3,c4c1,c2,c3,c4，则 (∏Bi)j=(x+y+z)c1(x+y−z)c2(x−y+z)c3(x−y−z)c4(\\prod B_{i})_j=(x+y+z)^{c1}(x+y-z)^{c2}(x-y+z)^{c3}(x-y-z)^{c4}(∏Bi​)j​=(x+y+z)c1(x+y−z)c2(x−y+z)c3(x−y−z)c4，然后做 IFWT\\text{IFWT}IFWT。 考虑列方程求解 c1,c2,c3,c4c1,c2,c3,c4c1,c2,c3,c4，只需要列出四条一次方程即可。 首先有 c1+c2+c3+c4=nc1+c2+c3+c4=nc1+c2+c3+c4=n。(1) 接下来考虑利用 Bi,j=x+(−1)∣j&amp;bi∣y+(−1)∣j&amp;ci∣zB_{i,j}=x+(-1)^{|j\\&amp;b_i|}y+(-1)^{|j\\&amp;c_i|}zBi,j​=x+(−1)∣j&amp;bi​∣y+(−1)∣j&amp;ci​∣z 的性质： 由于 FWT(A)+FWT(B)=FWT(A+B)\\text{FWT}(A)+\\text{FWT}(B)=\\text{FWT}(A+B)FWT(A)+FWT(B)=FWT(A+B)，所以可以令 Fi,j=[j=bi]F_{i,j}=[j=b_i]Fi,j​=[j=bi​]，此时 FWT(Fi)j=(−1)∣j&amp;bi∣\\text{FWT}(F_i)_j=(-1)^{|j\\&amp;b_i|}FWT(Fi​)j​=(−1)∣j&amp;bi​∣。 那么设 p1=∑FWT(Fi)j=FWT(∑Fi)j=∑(−1)∣j&amp;bi∣p1=\\sum\\text{FWT}(F_i)_j=\\text{FWT}(\\sum F_i)_j=\\sum (-1)^{|j\\&amp;b_i|}p1=∑FWT(Fi​)j​=FWT(∑Fi​)j​=∑(−1)∣j&amp;bi​∣，则根据 yyy 的系数得 c1+c2−c3−c4=p1c1+c2-c3-c4=p1c1+c2−c3−c4=p1。(2) 令 Fi,j=[j=ci]F_{i,j}=[j=c_i]Fi,j​=[j=ci​]，此时 FWT(Fi)j=(−1)∣j&amp;ci∣\\text{FWT}(F_i)_j=(-1)^{|j\\&amp;c_i|}FWT(Fi​)j​=(−1)∣j&amp;ci​∣。 设 p2=FWT(∑Fi)j=∑(−1)∣j&amp;ci∣p2=\\text{FWT}(\\sum F_i)_j=\\sum (-1)^{|j\\&amp;c_i|}p2=FWT(∑Fi​)j​=∑(−1)∣j&amp;ci​∣，则根据 zzz 的系数得 c1−c2+c3−c4=p2c1-c2+c3-c4=p2c1−c2+c3−c4=p2。(3) 令 Fi,j=[j=bi⊕ci]F_{i,j}=[j=b_i\\oplus c_i]Fi,j​=[j=bi​⊕ci​]，此时 FWT(Fi)j=(−1)∣j&amp;bi∣(−1)∣j&amp;ci∣\\text{FWT}(F_i)_j=(-1)^{|j\\&amp;b_i|}(-1)^{|j\\&amp;c_i|}FWT(Fi​)j​=(−1)∣j&amp;bi​∣(−1)∣j&amp;ci​∣。 设 p3=FWT(∑Fi)j=∑(−1)∣j&amp;bi∣(−1)∣j&amp;ci∣p3=\\text{FWT}(\\sum F_i)_j=\\sum (-1)^{|j\\&amp;b_i|}(-1)^{|j\\&amp;c_i|}p3=FWT(∑Fi​)j​=∑(−1)∣j&amp;bi​∣(−1)∣j&amp;ci​∣，则根据 yyy 和 zzz 的系数得 c1−c2−c3+c4=p3c1-c2-c3+c4=p3c1−c2−c3+c4=p3。(4) 则可以列出方程： {c1+c2+c3+c4=nc1+c2−c3−c4=p1c1−c2+c3−c4=p2c1−c2−c3+c4=p3\\begin{cases} c1+c2+c3+c4=n\\\\ c1+c2-c3-c4=p1\\\\ c1-c2+c3-c4=p2\\\\ c1-c2-c3+c4=p3 \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​c1+c2+c3+c4=nc1+c2−c3−c4=p1c1−c2+c3−c4=p2c1−c2−c3+c4=p3​ 解得： {2(c3+c4)=n−p12(c3−c4)=p2−p3c1=p1+p2+p3+n4c2=p1+n−p2−p34c3=n−p1+p2−p34c4=n−p1−p2+p34\\begin{cases} 2(c3+c4)=n-p1\\\\ 2(c3-c4)=p2-p3\\\\ c1=\\frac{p1+p2+p3+n}{4}\\\\ c2=\\frac{p1+n-p2-p3}{4}\\\\ c3=\\frac{n-p1+p2-p3}{4}\\\\ c4=\\frac{n-p1-p2+p3}{4} \\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​2(c3+c4)=n−p12(c3−c4)=p2−p3c1=4p1+p2+p3+n​c2=4p1+n−p2−p3​c3=4n−p1+p2−p3​c4=4n−p1−p2+p3​​ c1,c2,c3,c4c1,c2,c3,c4c1,c2,c3,c4 可以用 long long 存下。 时间复杂度 O(n+k2k)O(n+k2^k)O(n+k2k)，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int p=998244353,inv2=499122177; inline int qpow(int x,long long y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline void FWT(int n,long long a[]) { for(int len=2;len&lt;=n;len&lt;&lt;=1) { int mid=len&gt;&gt;1; for(int l=0;l&lt;n-len+1;l+=len) { for(int k=0;k&lt;mid;k++) { long long x=a[l+k],y=a[l+mid+k]; a[l+k]=x+y; a[l+mid+k]=x-y; } } } } inline void IFWT(int n,int a[]) { for(int len=2;len&lt;=n;len&lt;&lt;=1) { int mid=len&gt;&gt;1; for(int l=0;l&lt;n-len+1;l+=len) { for(int k=0;k&lt;mid;k++) { int x=a[l+k],y=a[l+mid+k]; a[l+k]=(1ll*inv2*x%p+1ll*inv2*y%p)%p; a[l+mid+k]=(1ll*inv2*x%p+1ll*(p-inv2)*y%p)%p; } } } } int n,k; int X,Y,Z; int sm; long long F1[1&lt;&lt;17],F2[1&lt;&lt;17],F3[1&lt;&lt;17]; int ans[1&lt;&lt;17]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z); for(int i=1;i&lt;=n;i++) { int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); sm^=a,b^=a,c^=a; F1[b]++,F2[c]++,F3[b^c]++; } FWT(1&lt;&lt;k,F1),FWT(1&lt;&lt;k,F2),FWT(1&lt;&lt;k,F3); int v1=((long long)X+Y+Z)%p; int v2=((long long)X+Y-Z)%p; int v3=((long long)X-Y+Z)%p; int v4=((long long)X-Y-Z)%p; for(int i=0;i&lt;(1&lt;&lt;k);i++) { long long p1=F1[i],p2=F2[i],p3=F3[i]; long long c1=(p1+p2+p3+n)/4; long long c2=(p1+n-p2-p3)/4; long long c3=(n-p1+p2-p3)/4; long long c4=(n-p1-p2+p3)/4; ans[i]=(1ll*qpow(v1,c1)*qpow(v2,c2)%p*qpow(v3,c3)%p*qpow(v4,c4)%p+p)%p; } IFWT(1&lt;&lt;k,ans); for(int i=0;i&lt;(1&lt;&lt;k);i++) printf(&quot;%d &quot;,ans[i^sm]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"FWT","slug":"UjstJwYTZ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/UjstJwYTZ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1119H Triple 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1119h-triple-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":538000,"words":1559,"minutes":9},"date":"2023-07-09 21:00:30","dateFormat":"2023-07-09"},{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中选择一个子序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><mi>i</mi><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum ib_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 最大，输出这个最大值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le |a_i|\\le 10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长 nnn 的序列 aaa，从 aaa 中选择一个子序列 bbb，使得 ∑ibi\\sum ib_i∑ibi​ 最大，输出这个最大值。 1≤n≤1051\\le n\\le 10^51≤n≤105，0≤∣ai∣≤1070\\le |a_i|\\le 10^70≤∣ai​∣≤107。 考虑一个显然的 dp，设 fi,jf_{i,j}fi,j​ 表示 a[1,i]a_{[1,i]}a[1,i]​ 中选了 jjj 个的最大 ∑ibi\\sum ib_i∑ibi​，则有转移： fi,j=max⁡(fi−1,j,fi−1,j−1+jai)f_{i,j}=\\max(f_{i-1,j},f_{i-1,j-1}+ja_i) fi,j​=max(fi−1,j​,fi−1,j−1​+jai​) 有一个神奇的结论，存在 kkk 满足： fi,j={fi−1,jj&lt;kfi−1,j−1+jaij≥kf_{i,j}=\\begin{cases} f_{i-1,j}&amp;j&lt;k\\\\ f_{i-1,j-1}+ja_i&amp;j\\ge k \\end{cases} fi,j​={fi−1,j​fi−1,j−1​+jai​​j&lt;kj≥k​ 具体证明有点复杂，大概就是这个东西的本质是一个贪心的优化。 那么用平衡树动态维护 fi,∗f_{i,*}fi,∗​ 的差分数组即可，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using namespace std; const int S=100005; struct node { int ls,rs,w; int siz; long long val,tag; }; node tr[S]; int trcnt; int nnde(long long x) { tr[++trcnt]=(node){0,0,rand(),1,x,0}; return trcnt; } void upd(int u) { int ls=tr[u].ls,rs=tr[u].rs; tr[u].siz=tr[ls].siz+tr[rs].siz+1; } void dwntag(int u) { int ls=tr[u].ls,rs=tr[u].rs; tr[ls].val+=tr[u].tag,tr[ls].tag+=tr[u].tag; tr[rs].val+=tr[u].tag,tr[rs].tag+=tr[u].tag; tr[u].tag=0; } void split(int u,long long val,int siz,int &amp;x,int &amp;y) { if(u==0) return x=y=0,void(); dwntag(u); int &amp;ls=tr[u].ls,&amp;rs=tr[u].rs; int sz=tr[ls].siz+siz+1; if(tr[u].val&gt;val*sz) split(rs,val,sz,rs,y),x=u; else split(ls,val,siz,x,ls),y=u; upd(u); } void merge(int x,int y,int &amp;u) { if(x==0||y==0) return u=x+y,void(); dwntag(x),dwntag(y); int &amp;xrs=tr[x].rs,&amp;yls=tr[y].ls; if(tr[x].w&lt;tr[y].w) merge(xrs,y,xrs),u=x; else merge(x,yls,yls),u=y; upd(u); } long long getans(int u,long long &amp;sum) { if(u==0) return 0; dwntag(u); long long res=getans(tr[u].ls,sum); res=max(res,sum+=tr[u].val); res=max(res,getans(tr[u].rs,sum)); return res; } int n,rt; int main() { srand(time(NULL)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { long long x; scanf(&quot;%lld&quot;,&amp;x); int rx,ry; split(rt,x,0,rx,ry); int k=tr[rx].siz+1; int pre=nnde(x*k); tr[ry].val+=x,tr[ry].tag+=x; merge(rx,pre,rt); merge(rt,ry,rt); } long long sum=0; printf(&quot;%lld\\n&quot;,getans(rt,sum)); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF573E Bear and Bowling 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf573e-bear-and-bowling-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":216000,"words":631,"minutes":4},"date":"2023-07-09 15:51:23","dateFormat":"2023-07-09"},{"abstract":"<blockquote>\n<p>给定一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，每次等概率从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的所有因子中选择一个，设其为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span>，将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mi>n</mi><mi>d</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">d</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n<p>求期望多少次 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>24</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^{24}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span></span>，输入会给出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的所有不同的质因子 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mrow><mn>1</mn><mo>∼</mo><mi>m</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">p_{1\\sim m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">∼</span><span class=\"mord mathdefault mtight\">m</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个正整数 nnn，每次等概率从 nnn 的所有因子中选择一个，设其为 ddd，将 nnn 变为 nd\\frac{n}{d}dn​。 求期望多少次 nnn 变为 111，对 109+710^9+7109+7 取模。 1≤n≤10241\\le n\\le 10^{24}1≤n≤1024，输入会给出 nnn 的所有不同的质因子 p1∼mp_{1\\sim m}p1∼m​。 设 dpidp_idpi​ 表示 n=in=in=i 时的答案，那么有： dpi=∑d∣i,d≤idpdk+1dpi=∑d∣i,d&lt;idpdk+dpik+1(k−1)dpik=∑d∣i,d&lt;idpdk+1dpi=k+∑d∣i,d&lt;idpdk−1\\begin{aligned} dp_{i}&amp;=\\frac{\\sum\\limits_{d|i,d\\le i}dp_d}{k}+1\\\\ dp_{i}&amp;=\\frac{\\sum\\limits_{d|i,d&lt;i}dp_d}{k}+\\frac{dp_i}{k}+1\\\\ \\frac{(k-1)dp_i}{k}&amp;=\\frac{\\sum\\limits_{d|i,d&lt;i}dp_d}{k}+1\\\\ dp_{i}&amp;=\\frac{k+\\sum\\limits_{d|i,d&lt;i}dp_d}{k-1}\\\\ \\end{aligned} dpi​dpi​k(k−1)dpi​​dpi​​=kd∣i,d≤i∑​dpd​​+1=kd∣i,d&lt;i∑​dpd​​+kdpi​​+1=kd∣i,d&lt;i∑​dpd​​+1=k−1k+d∣i,d&lt;i∑​dpd​​​ 设 n=∏i=1mpiein=\\prod\\limits_{i=1}^m p_i^{e_i}n=i=1∏m​piei​​，那么显然可重集 {e1,e2,…,em}\\{e_1,e_2,\\dots,e_m\\}{e1​,e2​,…,em​} 相同的 nnn 的 dpndp_ndpn​ 是相同的。 注意到由于 {e1,e2,…,em}\\{e_1,e_2,\\dots,e_m\\}{e1​,e2​,…,em​} 是可重集，所以不妨钦定 ei≤ei+1e_i\\le e_{i+1}ei​≤ei+1​，不同的 {e1,e2,…,em}\\{e_1,e_2,\\dots,e_m\\}{e1​,e2​,…,em​} 最多只有 ∏i=1mlog⁡∏j=1ipj(n)\\prod\\limits_{i=1}^m\\log_{\\prod\\limits_{j=1}^ip_j}(n)i=1∏m​logj=1∏i​pj​​(n) 个，实际上只有大概 2×1052\\times 10^52×105 个。 那么设 dp{e1,e2,…,em}dp_{\\{e_1,e_2,\\dots,e_m\\}}dp{e1​,e2​,…,em​}​ 为可重集为 {e1,e2,…,em}\\{e_1,e_2,\\dots,e_m\\}{e1​,e2​,…,em​} 时的答案，则转移是一个高维前缀和，可以设 f{e1,e2,…,em},i=∑{e1′,e2′,…,em′}∏j=1i[ej′≤ej]∏j=i+1m[ej′=ej]dp{e1′,e2′,…,em′}f_{\\{e_1,e_2,\\dots,e_m\\},i}=\\sum\\limits_{\\{e&#x27;_1,e&#x27;_2,\\dots,e&#x27;_m\\}}\\prod\\limits_{j=1}^i[e&#x27;_j\\le e_j]\\prod\\limits_{j=i+1}^m[e&#x27;_j=e_j]dp_{\\{e&#x27;_1,e&#x27;_2,\\dots,e&#x27;_m\\}}f{e1​,e2​,…,em​},i​={e1′​,e2′​,…,em′​}∑​j=1∏i​[ej′​≤ej​]j=i+1∏m​[ej′​=ej​]dp{e1′​,e2′​,…,em′​}​，则有转移： f{e1,e2,…,em},i=f{e1,e2,…,em},i−1+f{e1,e2,…,ei−1,…,em},i+f{e1,e2,…,em},0f_{\\{e_1,e_2,\\dots,e_m\\},i}=f_{\\{e_1,e_2,\\dots,e_m\\},i-1}+f_{\\{e_1,e_2,\\dots,e_i-1,\\dots,e_m\\},i}+f_{\\{e_1,e_2,\\dots,e_m\\},0} f{e1​,e2​,…,em​},i​=f{e1​,e2​,…,em​},i−1​+f{e1​,e2​,…,ei​−1,…,em​},i​+f{e1​,e2​,…,em​},0​ 则 dp{e1,e2,…,em}=f{e1,e2,…,em},0dp_{\\{e_1,e_2,\\dots,e_m\\}}=f_{\\{e_1,e_2,\\dots,e_m\\},0}dp{e1​,e2​,…,em​}​=f{e1​,e2​,…,em​},0​。 由于转移需要的是 f{e1,e2,…,em},m−dp{e1,e2,…,em}f_{\\{e_1,e_2,\\dots,e_m\\},m}-dp_{\\{e_1,e_2,\\dots,e_m\\}}f{e1​,e2​,…,em​},m​−dp{e1​,e2​,…,em​}​，所以不妨先令 f{e1,e2,…,em},0=0f_{\\{e_1,e_2,\\dots,e_m\\},0}=0f{e1​,e2​,…,em​},0​=0，做完高维前缀和再加回去。 时间复杂度 O(2×105×20)O(2\\times 10^5\\times 20)O(2×105×20)。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; const int SS=105,STS=200005,S=25,p=1000000007; struct sta { vector&lt;int&gt; v; inline void push(int x){v.push_back(x);} inline int size(){return v.size();} inline void sort(){::sort(v.begin(),v.end());} inline int&amp; operator[](int x){return v[x];} inline void delbeg(){v.erase(v.begin());} inline bool operator&lt;(const sta &amp;b)const { if(v.size()!=b.v.size()) return v.size()&lt;b.v.size(); for(int i=0;i&lt;v.size();i++) if(v[i]!=b.v[i]) return v[i]&lt;b.v[i]; return false; } }; char str[SS]; __int128 n,a[S]; int m; int tot; map&lt;sta,int&gt; idx; int f[STS][S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int DP(sta &amp;st) { if(idx.find(st)!=idx.end()) return f[idx[st]][0]; idx[st]=++tot; int id=tot; if(st.size()==0) return f[id][0]=0; for(int i=1;i&lt;=st.size();i++) { sta nst=st; nst[i-1]--,nst.sort(); if(nst[0]!=0) DP(nst),f[id][i]=(f[id][i-1]+f[idx[nst]][i])%p; else nst.delbeg(),DP(nst),f[id][i]=(f[id][i-1]+f[idx[nst]][i-1])%p; } int ml=1; for(int i=0;i&lt;st.size();i++) ml=1ll*ml*(st[i]+1)%p; f[id][0]=1ll*qpow(ml-1+p,p-2)*(f[id][st.size()]+ml)%p; for(int i=1;i&lt;=st.size();i++) f[id][i]=(f[id][i]+f[id][0])%p; return f[id][0]; } int main() { freopen(&quot;div.in&quot;,&quot;r&quot;,stdin); freopen(&quot;div.out&quot;,&quot;w&quot;,stdout); ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); while(cin&gt;&gt;str&gt;&gt;m) { int len=strlen(str); n=0; for(int i=0;i&lt;len;i++) n=n*10+str[i]-'0'; sta st; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;str; len=strlen(str); a[i]=0; for(int j=0;j&lt;len;j++) a[i]=a[i]*10+str[j]-'0'; int cnt=0; while(n%a[i]==0) n/=a[i],cnt++; st.push(cnt); } st.sort(); cout&lt;&lt;DP(st)&lt;&lt;'\\n'; } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛24】随机除法 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-24-sui-ji-chu-fa-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":402000,"words":1155,"minutes":7},"date":"2023-07-05 16:29:42","dateFormat":"2023-07-05"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向图（没有重边和自环），求有多少种给边定向的方式满足定向后的图是一个 DAG。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>20</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 20,1\\le m\\le \\frac{n(n-1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一张 nnn 个点 mmm 条边的无向图（没有重边和自环），求有多少种给边定向的方式满足定向后的图是一个 DAG。 1≤n≤20,1≤m≤n(n−1)21\\le n\\le 20,1\\le m\\le \\frac{n(n-1)}{2}1≤n≤20,1≤m≤2n(n−1)​。 考虑拓扑的过程，每一轮会删掉所有入度为 000 的点，这些点在拓扑序中可以任意调换顺序。 由于确定了拓扑序就可以唯一确定定向方式，所以问题变成求有多少种本质不同的拓扑序。 设 fif_ifi​ 表示把集合 iii 中的点单独拿出来拓扑有多少种本质不同的拓扑序，设 gi=[集合 i 中的点之间没有连边]g_i=[\\text{集合 }i\\text{ 中的点之间没有连边}]gi​=[集合 i 中的点之间没有连边]，那么有一个错误的转移： fi=∑j⊂ifjgi−jf_{i}=\\sum\\limits_{j\\subset i}f_jg_{i-j} fi​=j⊂i∑​fj​gi−j​ 即枚举最后一次删掉了哪些点。 这样显然会算重，因为同时删掉 nnn 个点的情况会被算 ∑i=1n(ni)\\sum\\limits_{i=1}^n\\binom{n}{i}i=1∑n​(in​) 次。 那么考虑容斥，弄一个容斥系数 hih_ihi​ 使得 ∑i=1n(ni)hi=1\\sum\\limits_{i=1}^n\\binom{n}{i}h_i=1i=1∑n​(in​)hi​=1。根据二项式定理可知 ∑i=1n(ni)(−1)i−1=[n=0]\\sum\\limits_{i=1}^n\\binom{n}{i}(-1)^{i-1}=[n\\not=0]i=1∑n​(in​)(−1)i−1=[n​=0]，所以 hi=(−1)i−1h_i=(-1)^{i-1}hi​=(−1)i−1 即可。 那么正确的转移就是： fi=∑j⊂ifjgi−j(−1)∣i−j∣−1f_{i}=\\sum\\limits_{j\\subset i}f_jg_{i-j}(-1)^{|i-j|-1} fi​=j⊂i∑​fj​gi−j​(−1)∣i−j∣−1 直接转移是 O(3n)O(3^n)O(3n) 的，但是注意到这个东西是半在线子集卷积，所以可以用 FWT 做到 O(n22n)O(n^22^n)O(n22n)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=25,p=1000000007,inv2=500000004; int n,m; bool a[S][S]; int g[1&lt;&lt;20]; int popc[1&lt;&lt;20],SC[S][1&lt;&lt;20],SA[S][1&lt;&lt;20]; inline void FWT(int n,int a[]) { for(int len=2;len&lt;=n;len&lt;&lt;=1) { int mid=len&gt;&gt;1; for(int l=0;l&lt;=n-len;l+=len) { for(int k=0;k&lt;mid;k++) { int x=a[l+k],y=a[l+mid+k]; a[l+k]=x; a[l+mid+k]=(x+y)%p; } } } } inline void IFWT(int n,int a[]) { for(int len=2;len&lt;=n;len&lt;&lt;=1) { int mid=len&gt;&gt;1; for(int l=0;l&lt;=n-len;l+=len) { for(int k=0;k&lt;mid;k++) { int x=a[l+k],y=a[l+mid+k]; a[l+k]=x; a[l+mid+k]=(y-x+p)%p; } } } } int main() { freopen(&quot;jump.in&quot;,&quot;r&quot;,stdin); freopen(&quot;jump.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); a[x][y]=a[y][x]=true; } for(int i=0;i&lt;(1&lt;&lt;n);i++) for(int j=0;j&lt;n;j++) popc[i]+=i&gt;&gt;j&amp;1; for(int i=0;i&lt;(1&lt;&lt;n);i++) { bool flg=true; for(int j=1;j&lt;=n;j++) { if(i&gt;&gt;(j-1)&amp;1^1) continue; for(int k=1;k&lt;=n;k++) { if(i&gt;&gt;(k-1)&amp;1^1) continue; flg&amp;=!a[j][k]; } } if(flg) g[i]=popc[i]&amp;1?1:p-1; else g[i]=0; } SC[0][0]=1; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) SA[i][j]=(popc[j]==i)*g[j]; FWT(1&lt;&lt;n,SC[0]); for(int i=0;i&lt;=n;i++) FWT(1&lt;&lt;n,SA[i]); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i-1;j++) for(int k=0;k&lt;(1&lt;&lt;n);k++) SC[i][k]=(SC[i][k]+1ll*SC[j][k]*SA[i-j][k]%p)%p; IFWT(1&lt;&lt;n,SC[n]); printf(&quot;%d\\n&quot;,SC[n][(1&lt;&lt;n)-1]); return 0; } ","tags":[{"name":"FWT","slug":"UjstJwYTZ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/UjstJwYTZ/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛23】有限空间跳跃理论 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-23-you-xian-kong-jian-tiao-yue-li-lun-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":297000,"words":930,"minutes":5},"date":"2023-07-05 11:57:24","dateFormat":"2023-07-05"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，求满足以下条件的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的有向图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 的个数：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 是个竞赛图，即 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 没有重边和自环且对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i&lt;j\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 均满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>→</mo><mi>j</mi><mo>)</mo><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">(i\\to j)\\in G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>j</mi><mo>→</mo><mi>i</mi><mo>)</mo><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">(j\\to i)\\in G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中只有一个满足；</li>\n<li>只有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i&lt;j\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>→</mo><mi>j</mi><mo>)</mo><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">(i\\to j)\\in G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>；<br>\n求所有满足条件的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中的强连通分量的个数和，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 30</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le \\frac{n(n-1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</li>\n</ul>\n</blockquote>\n","content":" 给定 n,mn,mn,m，求满足以下条件的 nnn 个点的有向图 GGG 的个数： GGG 是个竞赛图，即 GGG 没有重边和自环且对于所有 1≤i&lt;j≤n1\\le i&lt;j\\le n1≤i&lt;j≤n 均满足 (i→j)∈G(i\\to j)\\in G(i→j)∈G 和 (j→i)∈G(j\\to i)\\in G(j→i)∈G 中只有一个满足； 只有 mmm 个 (i,j)(i,j)(i,j) 满足 1≤i&lt;j≤n1\\le i&lt;j\\le n1≤i&lt;j≤n 且 (i→j)∈G(i\\to j)\\in G(i→j)∈G； 求所有满足条件的 GGG 中的强连通分量的个数和，对 998244353998244353998244353 取模。 1≤n≤301\\le n\\le 301≤n≤30，1≤m≤n(n−1)21\\le m\\le \\frac{n(n-1)}{2}1≤m≤2n(n−1)​。 首先有一个结论： nnn 个点的竞赛图 GGG 中的 SCC（strongly connected components）个数等价于： 把 {1,2,3,…,n}\\{1,2,3,\\dots,n\\}{1,2,3,…,n} 划分为两个集合 AAA 和 BBB（可以为空）使得 ∀u∈A,v∈B\\forall u\\in A,v\\in B∀u∈A,v∈B，(i→j)∈G(i\\to j)\\in G(i→j)∈G 的方案数减一 证明： 考虑缩点，缩完点后的图显然还是竞赛图且是个 DAG，那么它的拓扑序唯一，设其为 {scc1,scc2,scc3,…,sccsz}\\{scc_1,scc_2,scc_3,\\dots,scc_{sz}\\}{scc1​,scc2​,scc3​,…,sccsz​}，那么显然 ∀0≤i≤sz\\forall 0\\le i\\le sz∀0≤i≤sz，A={scc1,scc2,…,scci},B={scci+1,scci+2,…,sccsz}A=\\{scc_1,scc_2,\\dots,scc_i\\},B=\\{scc_{i+1},scc_{i+2},\\dots,scc_{sz}\\}A={scc1​,scc2​,…,scci​},B={scci+1​,scci+2​,…,sccsz​} 是合法的，这样划分一共有 sz+1sz+1sz+1 种方案。 而其它划分方法显然不合法，得证。 考虑设 fi,j,kf_{i,j,k}fi,j,k​ 为加入了编号 [1,i+j][1,i+j][1,i+j] 的点，∣A∣=i,∣B∣=j|A|=i,|B|=j∣A∣=i,∣B∣=j，从编号小的点连向编号大的点的边有 kkk 条的方案数，那么转移考虑新加入一个编号最大的点 i+j+1i+j+1i+j+1： {(il)fi,j,k→fi+1,j,k+j+l(jl)fi,j,k→fi,j+1,k+l\\begin{cases} \\binom{i}{l}f_{i,j,k}\\to f_{i+1,j,k+j+l}\\\\ \\binom{j}{l}f_{i,j,k}\\to f_{i,j+1,k+l} \\end{cases} {(li​)fi,j,k​→fi+1,j,k+j+l​(lj​)fi,j,k​→fi,j+1,k+l​​ 答案即为 ∑i+j=nfi,j,m−(n(n−1)2m)\\sum\\limits_{i+j=n}f_{i,j,m}-\\binom{\\frac{n(n-1)}{2}}{m}i+j=n∑​fi,j,m​−(m2n(n−1)​​)，时间复杂度 O(n3m)O(n^3m)O(n3m)。 代码如下： // Problem: [ARC163D] Sum of SCC // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_arc163_d // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1005,MS=35,p=998244353; int n,m; int C[S][S]; int f[MS][MS][S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { C[0][0]=1; for(int i=1;i&lt;=S-3;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } scanf(&quot;%d%d&quot;,&amp;n,&amp;m); f[0][0][0]=1; for(int i=0;i&lt;=n;i++) { for(int j=0;j&lt;=n-i;j++) { for(int k=0;k&lt;=m;k++) { for(int l=0;l&lt;=i&amp;&amp;k+j+l&lt;=m;l++) add(f[i+1][j][k+j+l],1ll*C[i][l]*f[i][j][k]%p); for(int l=0;l&lt;=j&amp;&amp;k+l&lt;=m;l++) add(f[i][j+1][k+l],1ll*C[j][l]*f[i][j][k]%p); } } } int ans=0; for(int i=0;i&lt;=n;i++) add(ans,f[i][n-i][m]); add(ans,p-C[n*(n-1)/2][m]); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ARC163D Sum of SCC 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc163d-sum-of-scc-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":283000,"words":869,"minutes":5},"date":"2023-07-03 21:32:26","dateFormat":"2023-07-03"},{"abstract":"<blockquote>\n<p>给定一个以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 为根的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的树，编号在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,n-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 范围内，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个点上的权值为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的东西。</p>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个客人前来买东西，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个客人只能买 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">ct_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 子树点上的东西，且一个客人只能买一个东西，一个东西只能被卖给一个客人。</p>\n<p>你需要最大化卖出的东西的权值和。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 3\\times 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，时间复杂度要求低于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个以 000 为根的 nnn 个点的树，编号在 [0,n−1][0,n-1][0,n−1] 范围内，第 iii 个点上的权值为 iii 的东西。 有 mmm 个客人前来买东西，第 iii 个客人只能买 ctict_icti​ 子树点上的东西，且一个客人只能买一个东西，一个东西只能被卖给一个客人。 你需要最大化卖出的东西的权值和。 1≤n,m≤3×1061\\le n,m\\le 3\\times 10^61≤n,m≤3×106，时间复杂度要求低于 O(nlog⁡n)O(n\\log n)O(nlogn)。 首先有个显然的贪心，客人按照 ctict_icti​ 的深度从大到小依次选择子树内权值最大的东西买走。 这等价于按照权值从大到小考虑每个点，选择所有能买它的客人中 ctict_icti​ 深度最大的那一位被他买走。 并查集维护即可，但是我不会并查集。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; inline int read() { int c=0,s=0; while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') s=s*10+c-'0',c=getchar(); return s; } const int S=3000005; int n,m,fat[S],cnt[S]; int fa[S]; int fnd(int u){return fa[u]==u?u:fa[u]=fnd(fa[u]);} int main() { freopen(&quot;shop.in&quot;,&quot;r&quot;,stdin); freopen(&quot;shop.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); for(int i=1;i&lt;=n-1;i++) fat[i]=read(); for(int i=1;i&lt;=m;i++) cnt[read()]++; for(int i=0;i&lt;=n-1;i++) fa[i]=i; long long ans=0; for(int i=n-1;i&gt;=0;i--) { int u=i; while(fnd(u)!=0&amp;&amp;cnt[fnd(u)]==0) { int ru=fnd(u); fa[ru]=fat[ru]; } int ru=fnd(u); if(cnt[ru]&gt;0) { ans+=i; if(--cnt[ru]==0) fa[ru]=fnd(fat[ru]); } } printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"【2023NOI模拟赛22】商店 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-22-shang-dian-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":129000,"words":434,"minutes":3},"date":"2023-07-03 15:19:11","dateFormat":"2023-07-03"},{"abstract":"<blockquote>\n<p>给你一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，你可以对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 进行任意次操作（可以不操作），操作的具体步骤如下：</p>\n<ul>\n<li>选择矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的一个正方形子矩阵；</li>\n<li>选择一个正整数数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\leq x\\leq n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>；</li>\n<li>将子矩阵内的所有元素修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>。</li>\n</ul>\n<p>你需要求出使矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 恰好包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个不同元素所需的最小操作次数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 500,1\\le k\\le n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给你一个 n×nn\\times nn×n 的矩阵 aaa 和一个正整数 kkk，你可以对 aaa 进行任意次操作（可以不操作），操作的具体步骤如下： 选择矩阵 aaa 的一个正方形子矩阵； 选择一个正整数数 xxx，其中 1≤x≤n21\\leq x\\leq n^21≤x≤n2； 将子矩阵内的所有元素修改为 xxx。 你需要求出使矩阵 aaa 恰好包含 kkk 个不同元素所需的最小操作次数。 1≤n≤500,1≤k≤n21\\le n\\le 500,1\\le k\\le n^21≤n≤500,1≤k≤n2。 设操作前有 cntcntcnt 个不同元素，那么若 k≥cntk\\ge cntk≥cnt 则答案一定是 k−cntk-cntk−cnt，因为一次操作最多增加一个不同元素。 考虑 k&lt;cntk&lt;cntk&lt;cnt 的情况，可以证明最多只需要两次操作： 考虑选择一个以 (1,1)(1,1)(1,1) 为左上角的最大的正方形使得它全部替换成 a1,1a_{1,1}a1,1​ 后 aaa 中不同元素个数 ≥k\\ge k≥k 且最小； 接下来这样选择第二个正方形： 因为这个正方形可以选择与第一个的 xxx 相同或不同，所以总有一个满足操作完之后 aaa 中恰好有 kkk 个不同元素； 那么只用判断 111 次和 000 次是否可以即可，做法很显然。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1720E Misha and Paintings 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1720e-misha-and-paintings-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":84000,"words":349,"minutes":2},"date":"2023-06-22 14:47:57","dateFormat":"2023-06-22"},{"abstract":"<blockquote>\n<p>给你一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">N\\times M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 的矩阵，要求在每一个格子内填一个不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span> 的正整数，使得每一行和每一列的数的平方和仍然是一个平方数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给你一个 N×MN\\times MN×M 的矩阵，要求在每一个格子内填一个不超过 10810^8108 的正整数，使得每一行和每一列的数的平方和仍然是一个平方数。 1≤n,m≤1001\\le n,m\\le 1001≤n,m≤100。 降至了，构造矩阵等价于构造一行 aia_iai​ 和一列 bib_ibi​，每个格子 (i,j)(i,j)(i,j) 为 aibja_ib_jai​bj​。 那么行列可以分开构造，并且行列等价，所以问题转化为了构造长度为 nnn 的整数数组 aia_iai​ 满足 1≤ai≤1041\\le a_i\\le 10^41≤ai​≤104 且 ∑ai2\\sum a_i^2∑ai2​ 是平方数。 这很简单，只需要构造 {4,4,4,4,…,4n−5}\\{4,4,4,4,\\dots,4n-5\\} {4,4,4,4,…,4n−5} 即可，代码如下： // Problem: Square Table // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF417E // Memory Limit: 250 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; int n,m; int a[S],b[S]; inline void slove(int n,int a[]) { if(n==1) return a[1]=1,void(); for(int i=1;i&lt;=n-1;i++) a[i]=4; a[n]=4*n-5; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); slove(n,a),slove(m,b); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) printf(&quot;%d &quot;,a[i]*b[j]); printf(&quot;\\n&quot;); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"}],"title":"CF417E Square Table 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf417e-square-table-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":98000,"words":322,"minutes":2},"date":"2023-06-16 22:38:16","dateFormat":"2023-06-16"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向连通图（无重边自环）和一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，每个点的度数至少为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span>。你需要找到以下两个东西的其中一个：</p>\n<ul>\n<li>一条有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个节点的链；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>n</mi><mi>k</mi></mfrac><mo>⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil\\frac{n}{k}\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌉</span></span></span></span> 个环，满足每个环的大小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>&gt;</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">&gt;3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 且不是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 的倍数，且每个环都有至少一个节点在这些环中仅出现一次；</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2.5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2.5\\times 10^5,1\\le m\\le 5\\times 10^5,1\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span></p>\n</blockquote>\n","content":" 给定一个 nnn 个点 mmm 条边的无向连通图（无重边自环）和一个 1≤k≤n1\\le k\\le n1≤k≤n 的 kkk，每个点的度数至少为 333。你需要找到以下两个东西的其中一个： 一条有 kkk 个节点的链； ⌈nk⌉\\lceil\\frac{n}{k}\\rceil⌈kn​⌉ 个环，满足每个环的大小 &gt;3&gt;3&gt;3 且不是 333 的倍数，且每个环都有至少一个节点在这些环中仅出现一次； 1≤n≤2.5×105,1≤m≤5×105,1≤k≤n1\\le n\\le 2.5\\times 10^5,1\\le m\\le 5\\times 10^5,1\\le k\\le n1≤n≤2.5×105,1≤m≤5×105,1≤k≤n 考虑 dfs 树，有一个结论是若一棵树的最大深度（根节点深度为 111） &lt;k&lt; k&lt;k，则一定有至少 ⌈nk⌉\\lceil\\frac{n}{k}\\rceil⌈kn​⌉ 个叶子。 若叶子个数小于 ⌈nk⌉\\lceil\\frac{n}{k}\\rceil⌈kn​⌉，那么由于所有叶子的深度都 &lt;k&lt;k&lt;k，所以所有叶子的深度之和一定 &lt;n&lt;n&lt;n，这显然做不到，因为一个点会至少贡献 111。 那么考虑在 dfs 树最大深度 &lt;k&lt;k&lt;k 选出 ⌈nk⌉\\lceil\\frac{n}{k}\\rceil⌈kn​⌉ 个环，保证每个叶子至多仅出现一次。由于每个点的度数都 ≥3\\ge 3≥3 且无重边，所以设某个叶子 uuu 的深度为 dududu，其中一条返祖边连接的点深度为 dadada，另一条返祖边深度为 dbdbdb，且 du&gt;da&gt;dbdu&gt;da&gt;dbdu&gt;da&gt;db，则： 有三个包含 uuu 和这两个祖先的环，长度分别为：du−da+1du-da+1du−da+1、du−db+1du-db+1du−db+1、da−db+2da-db+2da−db+2； 前两个不能选当且仅当 du−da≡du−db≡2(mod3)du-da\\equiv du-db\\equiv 2\\pmod 3du−da≡du−db≡2(mod3) 即 da≡db(mod3)da\\equiv db\\pmod 3da≡db(mod3)，而这时第三个恰好能选； 所以这三个环中一定有一个环满足条件； 那么求一次 dfs 树即可。 时间复杂度 O(n)O(n)O(n)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005; int n,m,k; int esum,to[S],nxt[S],h[S]; bool vis[S],f[S]; int dep[S],fat[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u) { vis[u]=true; f[u]=true; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(!vis[v]) f[u]=false,dep[v]=dep[u]+1,fat[v]=u,dfs(v); } } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); int tk=k; k=n/k+!!(n%k); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } dep[1]=1; dfs(1); int mx=0; for(int i=1;i&lt;=n;i++) if(dep[i]&gt;dep[mx]) mx=i; if(dep[mx]&gt;=k) { puts(&quot;PATH&quot;); printf(&quot;%d\\n&quot;,k); for(int i=1;i&lt;=k;i++) printf(&quot;%d &quot;,mx),mx=fat[mx]; printf(&quot;\\n&quot;); } else { puts(&quot;CYCLES&quot;); for(int u=1;u&lt;=n&amp;&amp;tk&gt;0;u++) { if(f[u]) { tk--; int a=0,b=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fat[u]) continue; if(a==0) a=v; else b=v; } if(dep[a]&lt;dep[b]) swap(a,b); if((dep[u]-dep[a]+1)%3!=0) { printf(&quot;%d\\n&quot;,dep[u]-dep[a]+1); int x=u; while(x!=a) printf(&quot;%d &quot;,x),x=fat[x]; printf(&quot;%d\\n&quot;,a); } else if((dep[u]-dep[b]+1)%3!=0) { printf(&quot;%d\\n&quot;,dep[u]-dep[b]+1); int x=u; while(x!=b) printf(&quot;%d &quot;,x),x=fat[x]; printf(&quot;%d\\n&quot;,b); } else { printf(&quot;%d\\n&quot;,dep[a]-dep[b]+2); int x=a; while(x!=b) printf(&quot;%d &quot;,x),x=fat[x]; printf(&quot;%d %d\\n&quot;,b,u); } } } } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1103C Johnny Solving 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1103c-johnny-solving-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":280000,"words":899,"minutes":5},"date":"2023-06-13 18:15:15","dateFormat":"2023-06-13"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点，每个点有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">l_i,r_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 两个值，有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条有向边 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(s_i,t_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，你要给每个点确定一个权值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，满足以下条件：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列；</li>\n<li>对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 均有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><msub><mi>s</mi><mi>i</mi></msub></msub><mo>&lt;</mo><msub><mi>a</mi><msub><mi>t</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">a_{s_i}&lt;a_{t_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7892em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68066em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2805559999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n<li>对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 均有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">l_i\\le a_i\\le r_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>判断无解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo separator=\"true\">,</mo><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">0\\le m\\le \\min(n(n-1),4\\times 10^5)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><mi>j</mi><mo>⇒</mo><msub><mi>s</mi><mi>i</mi></msub><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">i\\not=j\\Rightarrow s_i\\not=s_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个点，每个点有 li,ril_i,r_ili​,ri​ 两个值，有 mmm 条有向边 (si,ti)(s_i,t_i)(si​,ti​)，你要给每个点确定一个权值 aia_iai​，满足以下条件： aia_iai​ 是 nnn 的排列； 对于所有 1≤i≤m1\\le i\\le m1≤i≤m 均有 asi&lt;atia_{s_i}&lt;a_{t_i}asi​​&lt;ati​​； 对于所有 1≤i≤n1\\le i\\le n1≤i≤n 均有 li≤ai≤ril_i\\le a_i\\le r_ili​≤ai​≤ri​； 判断无解。 2≤n≤2×1052\\le n\\le 2\\times 10^52≤n≤2×105，0≤m≤min⁡(n(n−1),4×105)0\\le m\\le \\min(n(n-1),4\\times 10^5)0≤m≤min(n(n−1),4×105)，i=j⇒si=sji\\not=j\\Rightarrow s_i\\not=s_ji​=j⇒si​​=sj​。 不难发现若不是 DAG 则无解。 观察到 rsir_{s_i}rsi​​ 实际上可以和 rti−1r_{t_i}-1rti​​−1 取 min⁡\\minmin，因为 asi&lt;atia_{s_i}&lt;a_{t_i}asi​​&lt;ati​​。那么先倒着拓扑一遍求出取完 min⁡\\minmin 的 rir_iri​。 先来考虑没有 lil_ili​ 限制该怎么做，显然拓扑排序的时候每次新入队的 rvr_vrv​ 都会大于把它入队的 rur_uru​，那么使用优先队列拓扑，每次选 rur_uru​ 最小的 uuu 来拓展一定是最优的。 考虑有 lil_ili​ 限制的情况下怎么办，考虑建立一个“寄存器”vecvecvec。拓扑前先把所有入度为 000 的点 uuu 放进 vecluvec_{l_u}veclu​​，然后从 111 到 nnn 遍历，遍历到 iii 时把 vecivec_iveci​ 内的所有元素入队，并取出一个元素 xxx，让 ansx=ians_x=iansx​=i 然后拓展 xxx。vvv 入队的时候： lv&gt;il_v&gt;ilv​&gt;i：先存到 veclvvec_{l_v}veclv​​ 里； lv≤il_v\\le ilv​≤i：直接入队； 这样就能保证 ansi≥lians_i\\ge l_iansi​≥li​，消除了 lil_ili​ 的限制。 代码如下： // Problem: [ABC304Ex] Constrained Topological Sort // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_abc304_h // Memory Limit: 1 MB // Time Limit: 3000 ms // // Powered by CP Editor (https://cpeditor.org)\\ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; const int S=200005; int n,m; int l[S],r[S]; vector&lt;int&gt; g1[S],g2[S]; int ind[S]; vector&lt;int&gt; idx[S]; int ans[S]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g1[x].push_back(y),g2[y].push_back(x); } for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]); queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) ind[i]=g1[i].size(); for(int i=1;i&lt;=n;i++) if(ind[i]==0) q.push(i); while(!q.empty()) { int u=q.front(); q.pop(); for(int v:g2[u]) { r[v]=min(r[v],r[u]-1); if(--ind[v]==0) q.push(v); } } for(int i=1;i&lt;=n;i++) if(ind[i]!=0) return puts(&quot;No&quot;),0; priority_queue&lt;pair&lt;int,int&gt;&gt; q2; for(int i=1;i&lt;=n;i++) ind[i]=g2[i].size(); for(int i=1;i&lt;=n;i++) if(ind[i]==0) idx[l[i]].push_back(i); for(int i=1;i&lt;=n;i++) { for(int j:idx[i]) q2.push(make_pair(-r[j],j)); if(q2.empty()) return puts(&quot;No&quot;),0; int u=q2.top().second; q2.pop(); ans[u]=i; for(int v:g1[u]) { if(--ind[v]==0) { if(l[v]&gt;i) idx[l[v]].push_back(v); else q2.push(make_pair(-r[v],v)); } } } for(int i=1;i&lt;=n;i++) if(ans[i]&lt;l[i]||ans[i]&gt;r[i]) return puts(&quot;No&quot;),0; puts(&quot;Yes&quot;); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"[ABC304Ex] Constrained Topological Sort 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc304ex-constrained-topological-sort-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":253000,"words":791,"minutes":5},"date":"2023-06-06 13:41:17","dateFormat":"2023-06-06"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和字符集大小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 以及一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0\\sim n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">sa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">a</span></span></span></span>，求有多少个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，字符集大小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> ，从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 开始标号的字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 满足把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">a=\\{0,1,2,\\dots,n-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> 按照 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mrow><mo>[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">s_{[i,n-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> 字典序排序后满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>s</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a=sa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">a</span></span></span></span>。</p>\n<p>即生成的后缀数组是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">sa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">a</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,k\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 和字符集大小 kkk 以及一个 0∼n−10\\sim n-10∼n−1 的排列 sasasa，求有多少个长 nnn，字符集大小 kkk ，从 000 开始标号的字符串 sss 满足把 a={0,1,2,…,n−1}a=\\{0,1,2,\\dots,n-1\\}a={0,1,2,…,n−1} 按照 s[i,n−1]s_{[i,n-1]}s[i,n−1]​ 字典序排序后满足 a=saa=saa=sa。 即生成的后缀数组是 sasasa。 1≤n,k≤2×1051\\le n,k\\le 2\\times 10^51≤n,k≤2×105。 首先设 rkrkrk 为满足 sarki=isa_{rk_i}=isarki​​=i 的数组，即 s[i,n−1]s_{[i,n-1]}s[i,n−1]​ 的排名。 那么观察 saisa_isai​ 和 sai+1sa_{i+1}sai+1​，必有 ssai≤ssai+1s_{sa_i}\\le s_{sa_{i+1}}ssai​​≤ssai+1​​。考虑什么时候能取到等号，显然 rksai+1&lt;rksai+1+1rk_{sa_i+1}&lt;rk_{sa_{i+1}+1}rksai​+1​&lt;rksai+1​+1​ 时才行。 那么统计出能取等号的位置个数 cntcntcnt，则答案为 ∑i=0cnt(cnti)(kn−i)=(cnt+kn)\\sum\\limits_{i=0}^{cnt}\\binom{cnt}{i}\\binom{k}{n-i}=\\binom{cnt+k}{n}i=0∑cnt​(icnt​)(n−ik​)=(ncnt+k​)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=400005,p=998244353; int n,k,a[S],b[S]; int fra[S],inv[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;m) return 0; return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } int main() { fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[++a[i]]=i; b[n+1]=0; int cnt=0; for(int i=1;i&lt;=n-1;i++) cnt+=b[a[i]+1]&lt;b[a[i+1]+1]; printf(&quot;%d\\n&quot;,C(cnt+k,n)); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"CF1526E Oolimry and Suffix Array 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1526e-oolimry-and-suffix-array-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":157000,"words":473,"minutes":3},"date":"2023-06-01 18:19:07","dateFormat":"2023-06-01"},{"abstract":"<blockquote>\n<p>一开始黑板上有一个正奇数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mtext> </mtext><mo>(</mo><mn>3</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">x\\ (3\\le x&lt;10^6)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，每次你可以选定黑板上已有的正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>（可以相等），将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a+b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 或 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\oplus b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 写在黑板上，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⊕</mo></mrow><annotation encoding=\"application/x-tex\">\\oplus</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊕</span></span></span></span> 表示异或运算，最终目标是将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 写在黑板上。要求写数字不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span> 次且写上的数字不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">5*10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span> 。</p>\n</blockquote>\n","content":" 一开始黑板上有一个正奇数 x (3≤x&lt;106)x\\ (3\\le x&lt;10^6)x (3≤x&lt;106)，每次你可以选定黑板上已有的正整数 a,ba,ba,b（可以相等），将 a+ba+ba+b 或 a⊕ba \\oplus ba⊕b 写在黑板上，其中 ⊕\\oplus⊕ 表示异或运算，最终目标是将 111 写在黑板上。要求写数字不超过 10510^5105 次且写上的数字不超过 5∗10185*10^{18}5∗1018 。 首先设 xxx 的二进制最高位是 2y2^y2y，那么一定有 gcd⁡(2y−1x⊕x,x)=1\\gcd(2^{y-1}x\\oplus x,x)=1gcd(2y−1x⊕x,x)=1，因为 2y−1x⊕x=2y−1x+x−2y2^{y-1}x\\oplus x=2^{y-1}x+x-2^y2y−1x⊕x=2y−1x+x−2y，而： gcd⁡(2y−1x+x−2y,x)=gcd⁡((−2y)mod⁡x,x)=1\\gcd(2^{y-1}x+x-2^y,x)=\\gcd((-2^y)\\operatorname{mod} x,x)=1 gcd(2y−1x+x−2y,x)=gcd((−2y)modx,x)=1 不妨设 tx=2y−1x⊕xtx=2^{y-1}x\\oplus xtx=2y−1x⊕x，那么我的想法是用 exgcd⁡\\operatorname{exgcd}exgcd 解出 (a+ad)×x+(b+ad)×tx=ad(x+tx)+1(a+ad)\\times x+(b+ad)\\times tx=ad(x+tx)+1(a+ad)×x+(b+ad)×tx=ad(x+tx)+1 使得 0≤a+ad,b+ad0\\le a+ad,b+ad0≤a+ad,b+ad。但是 a+ada+ada+ad 和 b+adb+adb+ad 和 xxx 与 txtxtx 是一个级别的，而 txtxtx 是 101210^{12}1012 级别的，那么 (b+ad)×tx(b+ad)\\times tx(b+ad)×tx 是 102410^{24}1024 级别，超出了范围限制。 看题解后发现不需要那么麻烦，只需要找到 tx−1mod⁡xtx^{-1}\\operatorname{mod} xtx−1modx 就行了。这样构造出的解是 101810^{18}1018 级别，刚刚好。 似乎还有另一种不断消除最高位的方法： 首先设 xxx 的二进制最高位为 2hi2^{hi}2hi，那么令 y=2hi−1xy=2^{hi-1}xy=2hi−1x 即最低位与最高位对齐： x = 000111 000111 + 000111 = 001110, 001110 + 001110 = 011100 y = 011100 然后设 z=x⊕yz=x\\oplus yz=x⊕y，消掉 xxx 的最高位： 011100 ^ 000111 = 011011 z = 011011 接下来设 h=z+yh=z+yh=z+y，使得后面是 xxx，前面是 2(y−1)2(y-1)2(y−1)： 011011 + 011100 = 110111 h = 110111 然后设 w=h⊕xw=h\\oplus xw=h⊕x，取得 2(y−1)2(y-1)2(y−1)： 110111 ^ 000111 = 110000 h = 110000 接下来令 k=w⊕2yk=w\\oplus 2yk=w⊕2y，取得 2hi+12^{hi+1}2hi+1： 011100 + 011100 = 111000 111000 ^ 110000 = 001000 k = 001000 那么接下来就好办了，通过 kkk 与 yyy 取得 2hi2^{hi}2hi 即可： 011100 ^ 001000 = 010100 001000 + 001000 = 010000 010100 ^ 010000 = 000100 000111 ^ 000100 = 000011 这样就成功地消除了最高位。 代码如下：（利用互质的方法） // Problem: Xum // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1427E // Memory Limit: 250 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; struct node { int tpe; long long x,y; }ans[S]; long long x; int tot; inline void add(int tpe,long long x,long long y){ans[++tot]=(node){tpe,x,y};} inline long long calcphi(long long x) { long long px=x; for(long long i=2;i*i&lt;=x;i++) { if(x%i==0) px=px/i*(i-1); while(x%i==0) x/=i; } if(x&gt;1) px=px/x*(x-1); return px; } inline long long qpow(long long x,long long y,long long p) { x%=p; long long res=1; for(;y&gt;0;y&gt;&gt;=1,x=x*x%p) res=y&amp;1?res*x%p:res; return res; } inline void fstmul(long long a,long long b) { long long res=0; for(;b&gt;0;b&gt;&gt;=1,add(1,a,a),a+=a) res=b&amp;1?add(1,res,a),res+a:res; } int main() { scanf(&quot;%lld&quot;,&amp;x); add(2,x,x); int cnt=0; long long tx=x; while(tx&gt;0) tx&gt;&gt;=1,cnt++; fstmul(x,1&lt;&lt;cnt-1); add(2,x,x*(1&lt;&lt;cnt-1)),tx=x^(x*(1&lt;&lt;cnt-1)); long long val=qpow(tx,calcphi(x)-1,x); fstmul(tx,val),tx*=val; fstmul(x,tx/x); long long a=tx/x*x,b=tx; if(a&amp;1) add(1,a,x),a+=x,add(1,b,x),b+=x; add(2,a,b); printf(&quot;%d\\n&quot;,tot); for(int i=1;i&lt;=tot;i++) { if(ans[i].tpe==1) printf(&quot;%lld + %lld\\n&quot;,ans[i].x,ans[i].y); if(ans[i].tpe==2) printf(&quot;%lld ^ %lld\\n&quot;,ans[i].x,ans[i].y); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1427E Xum 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1427e-xum-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":318000,"words":981,"minutes":6},"date":"2023-05-28 12:15:52","dateFormat":"2023-05-28"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和两个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>。</p>\n<p>设入栈序列为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，出栈序列为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 的所有栈操作序列中，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 可能对应的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中的下标集合为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>。</p>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow></msub><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{x\\in A}x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.771711em;vertical-align:-1.021706em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.750005em;\"><span style=\"top:-2.105664em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">x</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathdefault mtight\">A</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.021706em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>。</p>\n<p>例如 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">S=100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>001</mn></mrow><annotation encoding=\"application/x-tex\">T=001</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 时答案为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span>，因为共有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 种栈操作序列满足入栈序列为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，出栈序列为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>：</p>\n<ul>\n<li>进，进，进，出，出，出，此时 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 来自 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n<li>进，进，出，进，出，出，此时 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 来自 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>所以答案为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">3+2=5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5\\times 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 和两个长 nnn 的 010101 串 SSS 与 TTT。 设入栈序列为 SSS，出栈序列为 TTT 的所有栈操作序列中，T1T_1T1​ 可能对应的 SSS 中的下标集合为 AAA。 求 ∑x∈Ax\\sum\\limits_{x\\in A}xx∈A∑​x。 例如 S=100S=100S=100，T=001T=001T=001 时答案为 555，因为共有 222 种栈操作序列满足入栈序列为 SSS，出栈序列为 TTT： 进，进，进，出，出，出，此时 T1T_1T1​ 来自 S3S_3S3​； 进，进，出，进，出，出，此时 T1T_1T1​ 来自 S2S_2S2​； 所以答案为 3+2=53+2=53+2=5。 1≤n≤5×1061\\le n\\le 5\\times 10^61≤n≤5×106。 首先有个结论，对于任意两个 000 的个数相等且 111 的个数相等的 010101 序列 AAA 与 BBB，总有合法的栈操作序列满足入栈序列为 AAA 且出栈序列为 BBB。 证明十分简单，考虑贪心，从左往右逐位考虑 AAA，设当前出栈序列已经匹配 jjj 个，则若栈顶元素 x=Bj+1x\\not=B_{j+1}x​=Bj+1​ 且 Ai=Bj+1A_i\\not=B_{j+1}Ai​​=Bj+1​ 则 AiA_iAi​ 入栈， 否则 j→j+1j\\to j+1j→j+1。这样栈中不会同时出现两种不同元素，一定可以构造出来。 考虑从 111 开始，逐个确定 SiS_iSi​ 是否有可能去到 T1T_1T1​。先不考虑 Si=T1S_i\\not= T_1Si​​=T1​ 的情况，那么若 SiS_iSi​ 去了 T1T_1T1​，则 SiS_iSi​ 出栈时 S[1,i−1]S_{[1,i-1]}S[1,i−1]​ 一定都在栈中。 所以可以找到 i≤j≤posi−1i\\le j\\le pos_{i-1}i≤j≤posi−1​ 且 S[i,j]S_{[i,j]}S[i,j]​ 中 000 的个数等于 T[1,j−i+1]T_{[1,j-i+1]}T[1,j−i+1]​ 中 000 的个数的最大的 jjj，令 posi=jpos_i=jposi​=j；找不到则 posi=−1pos_i=-1posi​=−1，求出 posipos_iposi​ 后可以这样构造： 那么显然答案即为 ∑posi=−1i\\sum\\limits_{pos_i\\not=-1}iposi​​=−1∑​i，问题变成求解 posipos_iposi​，双指针即可，时间复杂度 O(n)O(n)O(n)。 代码如下： // Problem: B. Cilantro // Contest: XXII Open Cup, Grand Prix of Korea // URL: https://codeforces.com/gym/103371/problem/B // Memory Limit: 1024 MB // Time Limit: 500 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=5000005; int n; char a[S],b[S]; int sa[S],sb[S]; int pos[S]; int main() { scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s%s&quot;,a+1,b+1); for(int i=1;i&lt;=n;i++) sa[i]=sa[i-1]+(a[i]=='Y'),sb[i]=sb[i-1]+(b[i]=='Y'); for(int i=1,r=n;i&lt;=n;i++) { while(r&gt;=i&amp;&amp;sa[r]-sa[i-1]!=sb[r-i+1]) r--; pos[i]=r; } long long ans=0; for(int i=1;i&lt;=n;i++) if(pos[i]&gt;=i&amp;&amp;a[i]==b[1]) ans+=i; printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"GYM103371B Cilantro 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/gym103371b-cilantro-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":194000,"words":664,"minutes":4},"date":"2023-05-20 14:55:34","dateFormat":"2023-05-20"},{"abstract":"<blockquote>\n<p>有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的棋盘，你要在上面放最少数量的”半皇后“，使得每个格子都能被攻击到。</p>\n<p>一个位于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> 的 ”半皇后“ 能攻击到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span> 当且仅当满足以下条件中至少一个：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">a=x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">b=y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi><mo>=</mo><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">a-b=x-y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>；</li>\n</ul>\n<p>输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个 n×nn\\times nn×n 的棋盘，你要在上面放最少数量的”半皇后“，使得每个格子都能被攻击到。 一个位于 (x,y)(x,y)(x,y) 的 ”半皇后“ 能攻击到 (a,b)(a,b)(a,b) 当且仅当满足以下条件中至少一个： a=xa=xa=x； b=yb=yb=y； a−b=x−ya-b=x-ya−b=x−y； 输出方案。 1≤n≤1051\\le n\\le 10^51≤n≤105。 设有 kkk 个”半皇后“ 就能攻击到所有格子，那么首先不考虑斜着的攻击，则横竖攻击覆盖之后还剩下 (n−k)×(n−k)(n-k)\\times (n-k)(n−k)×(n−k) 的子矩阵没有被攻击到，需要使用斜着的攻击。 考虑这个子矩阵的第一行第一列，一共有 2n−2k−12n-2k-12n−2k−1 个格子，并且每个格子所在的对角线都不同，并且只要用斜着的攻击覆盖到这些格子就能覆盖完整个子矩阵。 所以至少需要 2n−2k−12n-2k-12n−2k−1 个”半皇后“才能斜着覆盖这些格子，那么可以列出不等式 2n−2k−1≤k2n-2k-1\\le k2n−2k−1≤k，所以 k≥2n−13k\\ge \\frac{2n-1}{3}k≥32n−1​，那么 kkk 的理论下界就是 ⌈2n−13⌉\\left\\lceil \\frac{2n-1}{3}\\right\\rceil⌈32n−1​⌉。 考虑怎么构造能取到这个下界，显然若 n≡2(mod3)n\\equiv 2\\pmod 3n≡2(mod3) 则可以直接这样构造： 而若 n≡2(mod3)n\\not\\equiv 2\\pmod 3n​≡2(mod3) 就可以在左上角或者右下角放来变成 n≡2(mod3)n\\equiv 2\\pmod 3n≡2(mod3) 的情况。 代码如下： // Problem: Half Queen Cover // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1667C // Memory Limit: 250 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; int main() { scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d\\n&quot;,(n*2-1)/3+((n*2-1)%3!=0)); if(n==1) return puts(&quot;1 1&quot;),0; int f=0; if(n%3==0) printf(&quot;%d %d\\n&quot;,1,1),n--,f=1; else if(n%3==1) printf(&quot;%d %d\\n&quot;,1,1),printf(&quot;%d %d\\n&quot;,n,n),n-=2,f=1; int cnt=(n*2-1)/3; for(int i=1;i&lt;=cnt/2;i++) printf(&quot;%d %d\\n&quot;,f+n-cnt+cnt/2-i+1,f+n-cnt+i); for(int i=1;i&lt;=(cnt+1)/2;i++) printf(&quot;%d %d\\n&quot;,f+n-(cnt+1)/2+i,f+n-i+1); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1667C Half Queen Cover 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1667c-half-queen-cover/","stats":{"text":"3 min read","time":173000,"words":589,"minutes":3},"date":"2023-05-19 20:46:59","dateFormat":"2023-05-19"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，求满足以下条件的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>∈</mo><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">S\\in\\{0,1,2,\\dots,2^n-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> 的个数：</p>\n<p>对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 的非空子集 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">T\\in S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 均满足以下条件中的至少一个：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>T</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|T|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">∣</span></span></span></span> 是奇数；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 中元素的异或和非零；</li>\n</ul>\n<p>对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn，求满足以下条件的集合 S∈{0,1,2,…,2n−1}S\\in\\{0,1,2,\\dots,2^n-1\\}S∈{0,1,2,…,2n−1} 的个数： 对于所有 SSS 的非空子集 T∈ST\\in ST∈S，TTT 均满足以下条件中的至少一个： ∣T∣|T|∣T∣ 是奇数； TTT 中元素的异或和非零； 对 998244353998244353998244353 取模。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105。 不难发现只要把每个元素都加上 2n2^n2n，条件就转化为 SSS 的所有非空子集的异或和均不为 000。 考虑一个一个元素加入，假设现在 SSS 中有 iii 个元素，则这 iii 个元素任意组合出来的 2i2^i2i 个元素一定两两不同，其中有 2i−12^{i-1}2i−1 个元素第 n+1n+1n+1 位为 111，那么新插入的 xxx 就有 2n−2i−12^n-2^{i-1}2n−2i−1 种方案。 注意第一个元素有 2n2^n2n 种方案。 但是这样插入是有序的，集合是无序的，所以需要乘上 1(∣S∣)!\\frac{1}{(|S|)!}(∣S∣)!1​ 也就是说，答案为： ∑k=0n+12n∏i=1k−1(2n−2i−1)k!\\sum\\limits_{k=0}^{n+1} \\frac{2^n\\prod\\limits_{i=1}^{k-1}(2^n-2^{i-1})}{k!} k=0∑n+1​k!2ni=1∏k−1​(2n−2i−1)​ 上界是 n+1n+1n+1 是因为插入多于 nnn 个元素后集合中必然能异或出 000（线性基满了），这个东西很容易快速维护。 代码如下： // Problem: [ARC146C] Even XOR // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_arc146_c // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int p=998244353,S=200005; int n,pw2[S],prod[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); pw2[0]=1; for(int i=1;i&lt;=n+1;i++) pw2[i]=1ll*pw2[i-1]*2%p; prod[0]=pw2[n]; for(int i=1;i&lt;=n;i++) prod[i]=1ll*prod[i-1]*(pw2[n]-pw2[i-1]+p)%p; int ans=1; // k=0 for(int k=1,fra=1;k&lt;=n+1;k++) { fra=1ll*fra*k%p; ans=(ans+1ll*prod[k-1]*qpow(fra,p-2)%p)%p; } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ARC146C Even XOR 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/at_arc146_c-arc146c-even-xor-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":164000,"words":546,"minutes":3},"date":"2023-05-15 18:15:45","dateFormat":"2023-05-15"},{"abstract":"","content":"Day 0 飞机餐不好吃，辣椒酱是薄荷味的。 送了个耳机很高兴。 晚上吃了南京大排档。 Day 1 开幕式无聊。 试机前1h不知道有试机题，看到别人都在做题后遂发现桌子上的纸上的网址，然 http 打成 https 花了 15 min，刚想没多久就被老师催去吃饭了，所以没写试机题。 下午第一题看数据范围以为是 O(n)O(n)O(n) GSAM，于是跳过；第二题感觉是 Min-Max 容斥，但是推了个 O(n5)O(n^5)O(n5) 不会优化；第三题不会。 喜提 54+23+32=10954+23+32=10954+23+32=109。 赛后发现第一题直接枚举 border 长度即可，我是傻逼。 被苹果先生吊打了 /ll Day 2 讲座无聊。 讲座出来面到了 qjm 和 cxy，然后在学校里逛了一下。 T1 是傻逼 LCT 板子，但是 FHQ Treap 也能做，但是不会维护 size，于是 65pts。 T2 不会，35pts，T3 不会，25pts。 喜提 65+35+2565+35+2565+35+25。 又被苹果先生吊打了。 饭卡还剩好多钱，批发可乐，最后只剩 8 毛钱了。 晚上去看天安门广场，结果没有预约，所以去了王府井。 领略到了北京出租车司机的喜感。 Day 3 早上去圆明园随机游走，中午吃了个烤鸭，吃撑了。 飞机延期了，没有飞机餐，所以很饿。 晚上回到学校已经九点半了。 ","tags":[{"name":2023,"slug":"duHpjt30p","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/duHpjt30p/"},{"name":"PKU","slug":"Jt9rN7EEz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Jt9rN7EEz/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"}],"title":"PKUSC2023 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/pkusc2023-you-ji/","stats":{"text":"2 min read","time":86000,"words":377,"minutes":2},"date":"2023-05-06 22:02:35","dateFormat":"2023-05-06"},{"abstract":"<blockquote>\n<p>有一个边长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的立方体，你要用绳子绑紧这个立方体。绳子需要被绑成一个圈，并且不能经过立方体的顶点。绳子在绑的时候还需要被拉直，即立方体在平面上无限展开后绳子在上面的印记是若干直线。</p>\n<p>现在把立方体放到三维空间中，使得各棱与坐标轴平行。给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，你需要找到一种绑法，使得绳子的某部分平行于向量 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b,0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span>，并且绳子最短。记 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 为绳子长度，请输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>l</mi><mn>2</mn></msup><mi mathvariant=\"normal\">mod</mi><mo>⁡</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">l^2\\operatorname{mod} 10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span>，容易证明这是整数。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 组数据。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>T</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le T\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le a,b\\le 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个边长为 111 的立方体，你要用绳子绑紧这个立方体。绳子需要被绑成一个圈，并且不能经过立方体的顶点。绳子在绑的时候还需要被拉直，即立方体在平面上无限展开后绳子在上面的印记是若干直线。 现在把立方体放到三维空间中，使得各棱与坐标轴平行。给定 a,ba,ba,b，你需要找到一种绑法，使得绳子的某部分平行于向量 (a,b,0)(a,b,0)(a,b,0)，并且绳子最短。记 lll 为绳子长度，请输出 l2mod⁡109+7l^2\\operatorname{mod} 10^9+7l2mod109+7，容易证明这是整数。TTT 组数据。 1≤T≤1051\\le T\\le 10^51≤T≤105，0≤a,b≤10180\\le a,b\\le 10^{18}0≤a,b≤1018。 和之前的一道题『环』类似。 不妨先让 gcd⁡(a,b)=1\\gcd(a,b)=1gcd(a,b)=1。 考虑让正方体在平面上从 (0,0)(0,0)(0,0) 开始，沿着直线 (a,b)(a,b)(a,b) 滚动，即向上、向右滚且满足每一步底面都覆盖直线。由于 gcd⁡(a,b)=1\\gcd(a,b)=1gcd(a,b)=1 所以滚动一定是以滚过一个 a×ba\\times ba×b 的长方形为周期，那么只需要求最少滚 rrr 个周期满足滚完之后正方体每个面都是原来的面，lll 即为 r×a2+b2r\\times\\sqrt{a^2+b^2}r×a2+b2​。 考虑把正方体的每个面标号，那么滚动就可以看成置换，则只需要求出沿对角线滚过 a×ba\\times ba×b 的长方形对应的置换 ppp 即可。 考虑设向上滚的置换为 xxx，向右滚的置换为 yyy，先来考虑 8×38\\times 38×3 的长方形，显然有 p=xxxyxxxyxxy=x(xxy)x(xxy)(xxy)p=xxxyxxxyxxy=x(xxy)x(xxy)(xxy)p=xxxyxxxyxxy=x(xxy)x(xxy)(xxy)，不妨把 xxyxxyxxy 看作 y′y&#x27;y′，那么我们就成功把问题规模从 8×38\\times 38×3 缩小到了 2×32\\times 32×3。 发现这样做相当于把向右一格对应成向上两格再向右一格，类似辗转相除： 那么滚过 a×ba\\times ba×b 的长方形对应的置换 ppp 可以这样求： a=0a=0a=0 则 p=yp=yp=y，b=0b=0b=0 则 p=xp=xp=x； a≥ba\\ge ba≥b 则令 a=amod⁡ba=a\\operatorname{mod} ba=amodb，y=x⌊ab⌋yy=x^{\\lfloor\\frac{a}{b}\\rfloor}yy=x⌊ba​⌋y，递归； b&gt;ab&gt;ab&gt;a，则令 b=bmod⁡ab=b\\operatorname{mod} ab=bmoda，x=y⌊ab⌋xx=y^{\\lfloor\\frac{a}{b}\\rfloor}xx=y⌊ba​⌋x，递归； 求出 ppp 之后暴力枚举计算 rrr 即可。 代码如下： // Problem: #207. 打包 // Contest: Hydro // URL: http://oiclass.com/d/AKNOI/p/207 // Memory Limit: 256 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int p=1000000007; struct node { int a[7]; inline node(){memset(a,0,sizeof(a));} inline node(int x,int b,int c,int d,int e,int f){a[1]=x,a[2]=b,a[3]=c,a[4]=d,a[5]=e,a[6]=f;} inline int &amp;operator[](int x){return a[x];} inline node operator*(node b) { node re; for(int i=1;i&lt;=6;i++) re[i]=b[a[i]]; return re; } inline void operator=(node b){for(int i=1;i&lt;=6;i++) a[i]=b[i];} inline node operator^(long long y) { node res(1,2,3,4,5,6),x=*this; for(;y&gt;0;y&gt;&gt;=1,x=x*x) res=y&amp;1?res*x:res; return res; } inline bool operator!=(node b) { for(int i=1;i&lt;=6;i++) if(a[i]!=b[i]) return true; return false; } inline void print(){for(int i=1;i&lt;=6;i++) printf(&quot;%d &quot;,a[i]);} }; node x,y,res; inline long long gcd(long long x,long long y) { if(x==0||y==0) return x+y; long long t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } void exgcd(long long a,long long b) { if(a==0) return res=y,void(); if(b==0) return res=x,void(); if(a&gt;b) { y=(x^(a/b))*y; exgcd(a%b,b); } else { x=(y^(b/a))*x; exgcd(a,b%a); } } inline void slove() { long long a,b; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); long long g=gcd(a,b); a/=g,b/=g; x=node(6,2,5,4,1,3),y=node(2,3,4,1,5,6); exgcd(a,b); // res.print(),printf(&quot;\\n&quot;); int ans=1; node pre=res; while(pre!=node(1,2,3,4,5,6)) { pre=pre*res; ans++; } // printf(&quot;%d\\n&quot;,ans); // res.print(),printf(&quot;\\n&quot;); node tmp=res*res; // tmp.print(),printf(&quot;\\n&quot;); a%=p,b%=p; printf(&quot;%lld\\n&quot;,(a*a%p+b*b%p)%p*ans%p*ans%p); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"}],"title":"【2023NOI模拟赛21】打包 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-21-da-bao-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":333000,"words":1092,"minutes":6},"date":"2023-05-04 19:19:18","dateFormat":"2023-05-04"},{"abstract":"","content":"算法简介 Boruvka 算法是一种用来求解最小生成树的算法，它的流程如下： 刚开始每个点自己为一个连通块，接下来执行步骤 2 至 3 直到所有点在同一个连通块中； 对于每个连通块 iii，找到距离它最近，不在连通块中且与连通块有直接连边的点 toito_itoi​，记离 toito_itoi​ 最近的连通块中的点为 ouiou_ioui​； 对于每个连通块 iii，若 ouiou_ioui​ 与 toito_itoi​ 不在同一连通块中，则在生成树中新增边 (oui,toi)(ou_i,to_i)(oui​,toi​)，合并 ouiou_ioui​ 和 toito_itoi​ 所在的连通块； 这样每次合并连通块后连通块个数至少会减半，所以时间复杂度是 O((T+n)log⁡n)O((T+n)\\log n)O((T+n)logn) 的，其中 TTT 是步骤 222 的时间复杂度。 这个算法在最小生成树板子上的表现平平无奇，但是却十分擅长处理边很多的图（稠密图）的最小生成树问题。 经典例题 AT_cf17_final_j Tree MST 给定一棵 nnn 个节点的树，现有有一张完全图，两点 x,yx,yx,y 之间的边长为 wx+wy+disx,yw_x+w_y+dis_{x,y}wx​+wy​+disx,y​，其中 disdisdis 表示树上两点的距离。 求完全图的最小生成树。 n≤2×105n \\leq 2 \\times 10^5n≤2×105。 题解 直接上 Boruvka，找 ouiou_ioui​ 和 toito_itoi​ 可以做一次 up and down DP。注意到 xxx 到其它点的路径可以看作是向上走再向下走，那么跑两次 dfs。第一遍 dfs 从根把信息上推，求出每个节点距离其子树内最近和与最近点不在一个连通块的最近的点；第二遍 dfs 把信息下放，下放到 xxx 的时候就能求出距离 xxx 最近的与 xxx 不在一个连通块中的点。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： // Problem: Tree MST // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_cf17_final_j // Memory Limit: 256 MB // Time Limit: 5000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=500005; int n; long long w[S]; int esum,to[S],nxt[S],h[S]; long long c[S],dep[S]; int col[S]; int ansid[S]; long long ans[S]; struct node { int id; int id0,id1; long long mn0,mn1; inline void init() { id=id0=id1=0; mn0=mn1=1e17; } inline void operator+=(node &amp;b) { vector&lt;pair&lt;long long,int&gt;&gt; vec; vec.push_back(make_pair(mn0,id0)); vec.push_back(make_pair(mn1,id1)); vec.push_back(make_pair(b.mn0,b.id0)); vec.push_back(make_pair(b.mn1,b.id1)); sort(vec.begin(),vec.end()); id0=vec[0].second,mn0=vec[0].first; for(int i=1;i&lt;4;i++) { if(col[vec[i].second]!=col[id0]) { id1=vec[i].second,mn1=vec[i].first; break; } } } }dp[S]; inline void add(int x,int y,long long w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } void initdep(int u,int fa) { for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dep[v]=dep[u]+c[i]; initdep(v,u); } } void updfs(int u,int fa) { dp[u].init(); dp[u].id=u; dp[u].id0=u,dp[u].mn0=dep[u]+w[u]; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; updfs(v,u); dp[u]+=dp[v]; } } void dwndfs(int u,int fa) { if(fa==0) { dp[u].mn0-=dep[u]*2; dp[u].mn1-=dep[u]*2; } if(col[u]!=col[dp[u].id0]) { ansid[u]=dp[u].id0; ans[u]=dep[u]+w[u]+dp[u].mn0; } else { ansid[u]=dp[u].id1; ans[u]=dep[u]+w[u]+dp[u].mn1; } for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dp[v].mn0-=dep[v]*2; dp[v].mn1-=dep[v]*2; dp[v]+=dp[u]; dwndfs(v,u); } } int fnd(int u) { return col[u]==u?u:col[u]=fnd(col[u]); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;w[i]); for(int i=1;i&lt;=n-1;i++) { int x,y; long long w; scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;w); add(x,y,w),add(y,x,w); } initdep(1,0); for(int i=1;i&lt;=n;i++) col[i]=i; long long rss=0; while(1) { for(int i=1;i&lt;=n;i++) col[i]=fnd(i); bool f=true; for(int i=1;i&lt;=n;i++) f&amp;=col[i]==col[1]; if(f) break; updfs(1,0); dwndfs(1,0); for(int i=1;i&lt;=n;i++) { int rt=fnd(i); if(ans[i]&lt;ans[rt]) ans[rt]=ans[i],ansid[rt]=ansid[i]; } for(int i=1;i&lt;=n;i++) { int rt=fnd(i); if(rt!=fnd(ansid[rt])) { col[rt]=fnd(ansid[rt]); rss+=ans[rt]; } } } printf(&quot;%lld\\n&quot;,rss); return 0; } CF888G Xor-MST CF1550F Jumping Around CF1648E Air Reform CF1305G Kuroni and Antihype 题解 加入超级源点 000，令边 (x,y)(x,y)(x,y) 的边权为 ax+aya_x+a_yax​+ay​，那么答案即为最大生成树的边权和减去 ∑ai\\sum a_i∑ai​。 那么直接 Brouvka，每次维护子集最大值、和最大值不在同一个连通块的最大值即可。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005,LM=1&lt;&lt;18; int n,a[S]; int fa[S]; int mu[S],mv[S]; int fnd(int x){return fa[x]==x?x:fa[x]=fnd(fa[x]);} struct node { int x,y; node(){x=y=n;} inline void init(){x=y=n;} inline node operator+(node b) { node re; int res[4]={x,y,b.x,b.y}; sort(res,res+4,[&amp;](int x,int y){return a[x]&gt;a[y];}); re.x=res[0],re.y=n; for(int i=1;i&lt;4;i++) { if(fnd(res[i])!=fnd(res[0])) { re.y=res[i]; break; } } return re; } }mx[LM]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); a[++n]=0; for(int i=1;i&lt;=n;i++) fa[i]=i; long long ans=0; while(1) { for(int i=0;i&lt;LM;i++) mx[i].init(); for(int i=1;i&lt;=n;i++) mx[a[i]].x=i; for(int i=0;i&lt;LM;i++) { for(int j=0;(1&lt;&lt;j)&lt;=i;j++) { if(i&gt;&gt;j&amp;1) mx[i]=mx[i]+mx[i^(1&lt;&lt;j)]; } } for(int i=1;i&lt;=n;i++) mu[i]=mv[i]=-1; for(int u=1;u&lt;=n;u++) { int rt=fnd(u); int v=mx[a[u]^(LM-1)].x; if(fnd(v)==rt) v=mx[a[u]^(LM-1)].y; if(fnd(v)==rt) continue; if(mu[rt]==-1||a[u]+a[v]&gt;a[mu[rt]]+a[mv[rt]]) mu[rt]=u,mv[rt]=v; } bool f=true; for(int i=1;i&lt;=n;i++) { if(fa[i]==i) { int u=mu[i],v=mv[i]; if(u==-1) continue; if(fnd(u)==fnd(v)) continue; f=false; ans+=a[u]+a[v]; fa[fnd(u)]=fnd(v); } } if(f) break; } for(int i=1;i&lt;=n;i++) ans-=a[i]; printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Boruvka 算法 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/boruvka-xue-xi-bi-ji/","stats":{"text":"9 min read","time":486000,"words":1514,"minutes":9},"date":"2023-05-03 15:07:55","dateFormat":"2023-05-03"},{"abstract":"<blockquote>\n<p>给定一个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span>。求一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 的正整数倍 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 的数位累加和最小。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\le K \\le {10}^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.848448em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">0</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.848448em;\"><span style=\"top:-3.09734em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个整数 KKK。求一个 KKK 的正整数倍 SSS，使得 SSS 的数位累加和最小。 2≤K≤1052 \\le K \\le {10}^52≤K≤105。 考虑一位一位填，AB‾=A×10+B\\overline{AB}=A\\times 10+BAB=A×10+B，所以可以在 mod⁡k\\operatorname{mod} kmodk 的意义下运算，从 xxx 向 10x+bmod⁡k10x+b\\operatorname{mod} k10x+bmodk（0≤b≤90\\le b\\le 90≤b≤9）连权值为 bbb 的有向边。答案即为 1→01\\to 01→0 的最短路长度 +1+1+1。 注意到这是最短路，所以实际上从 xxx 向 10x10x10x 连权值为 000 的有向边，向 x+1x+1x+1 连权值为 111 的有向边也可以，因为最短路时个位进位一定不优，但是最长路就不能这样建边。这样建边的好处是可以 01 bfs O(n)O(n)O(n) 求解。 注意 01 bfs 每个点的最短路会更新至多两次。 代码如下： // Problem: [ABC077D] Small Multiple // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_arc084_b // Memory Limit: 256 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;deque&gt; #include &lt;cstring&gt; using namespace std; const int S=200005; int n,dis[S]; int main() { scanf(&quot;%d&quot;,&amp;n); deque&lt;int&gt; q; dis[1]=1; q.push_back(1); while(!q.empty()) { int u=q.front(); q.pop_front(); int v=u*10%n; if(dis[v]==0||dis[u]&lt;dis[v]) { dis[v]=dis[u]; q.push_front(v); } v=(u+1)%n; if(dis[v]==0||dis[u]+1&lt;dis[v]) { dis[v]=dis[u]+1; q.push_back(v); } } printf(&quot;%d\\n&quot;,dis[0]); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"AT_arc084_b [ABC077D] Small Multiple 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/at_arc084_b-abc077d-small-multiple-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":110000,"words":368,"minutes":2},"date":"2023-05-02 19:03:04","dateFormat":"2023-05-02"},{"abstract":"","content":"Part 1 前言 生成函数的变换是把一个生成函数变成另一个生成函数的一些式子，这些式子往往具有某种组合意义。 在本文中，我们讨论的是球盒模型，即统计在若干个盒子中放 nnn 个小球的方案数的问题。 Part 2 一些约定 F(x)=∑i=0∞fixiF(x)=\\sum\\limits_{i=0}^\\infin f_ix^iF(x)=i=0∑∞​fi​xi，G(x)=∑i=0∞fixii!G(x)=\\sum\\limits_{i=0}^\\infin f_i\\frac{x^i}{i!}G(x)=i=0∑∞​fi​i!xi​：参与变换的生成函数，即 fif_ifi​ 的 OGF 与 EGF，fif_ifi​ 的意义是有 fif_ifi​ 种方式把 iii 个球放进同一个盒子中； 一般认为 f0=0f_0=0f0​=0，即不能存在空盒子； [xn]H(x)[x^n]H(x)[xn]H(x)：若 H(x)H(x)H(x) 为 OGF，则代表 H(x)H(x)H(x) 中 xnx^nxn 的系数；若 H(x)H(x)H(x) 为 EGF，则代表 H(x)H(x)H(x) 中 xnn!\\frac{x^n}{n!}n!xn​ 的系数。简单的说就是我们要求的答案； Part 3 各种生成函数的变换 球无标号，盒有标号：不知道叫什么变换 最简单，根据 OGF 乘法的定义，枚举球一共占用了多少个盒子，有： ???⁡(F(x))=∑i=0∞F(x)i=11−F(x)\\begin{aligned} \\operatorname{???}(F(x))&amp;=\\sum\\limits_{i=0}^\\infin F(x)^i\\\\ &amp;=\\frac{1}{1-F(x)} \\end{aligned} ???(F(x))​=i=0∑∞​F(x)i=1−F(x)1​​ 球有标号，盒有标号：Invert⁡\\operatorname{Invert}Invert 变换 也可以叫 SEQ⁡\\operatorname{SEQ}SEQ 变换。 根据 EGF 乘法的定义，枚举球一共占用了多少个盒子，有： Invert⁡(G(x))=∑i=0∞G(x)i=11−G(x)\\begin{aligned} \\operatorname{Invert}(G(x))&amp;=\\sum\\limits_{i=0}^\\infin G(x)^i\\\\ &amp;=\\frac{1}{1-G(x)} \\end{aligned} Invert(G(x))​=i=0∑∞​G(x)i=1−G(x)1​​ 球有标号，盒无标号：Exp⁡\\operatorname{Exp}Exp 变换 根据 EGF 乘法的定义，枚举球一共占用了多少个盒子，但这样盒子是有标号的。注意到每种标号方式都会被算到恰好一次，所以要除掉盒子个数的阶乘： Exp⁡(G(x))=∑i=0∞G(x)ii!=exp⁡(G(x))\\begin{aligned} \\operatorname{Exp}(G(x))&amp;=\\sum\\limits_{i=0}^\\infin \\frac{G(x)^i}{i!}\\\\ &amp;=\\exp(G(x)) \\end{aligned} Exp(G(x))​=i=0∑∞​i!G(x)i​=exp(G(x))​ 球无标号，盒无标号：Weigh⁡&amp;Euler⁡\\operatorname{Weigh}\\&amp;\\operatorname{Euler}Weigh&amp;Euler 变换 Weigh⁡\\operatorname{Weigh}Weigh 变换 放的球一样多，放球的方式也一样的盒子只能出现一次。 类似 010101 背包，放 iii 个球的盒子有 fif_ifi​ 种，每种只能出现一次，那么有： Weigh⁡(F(x))=∏i=0∞(1+xi)fi\\operatorname{Weigh}(F(x))=\\prod\\limits_{i=0}^\\infin (1+x^i)^{f_i}\\\\ Weigh(F(x))=i=0∏∞​(1+xi)fi​ 即枚举盒子大小，然后因为有 fif_ifi​ 种这样的盒子所以要乘那么多次 1+xi1+x^i1+xi。 这个东西不好化简，考虑 ln⁡\\lnln 再 exp⁡\\expexp，要注意 ln⁡(1+x)=−∑i=1∞(−1)i(i−1)!xii!=−∑i=1∞(−x)ii\\ln(1+x)=-\\sum\\limits_{i=1}^\\infin\\frac{(-1)^{i}(i-1)!x^i}{i!}=-\\sum\\limits_{i=1}^\\infin\\frac{(-x)^i}{i}ln(1+x)=−i=1∑∞​i!(−1)i(i−1)!xi​=−i=1∑∞​i(−x)i​： ln⁡(Weigh⁡(F(x)))=∑i=0∞filn⁡(1+xi)=−∑i=0∞fi∑j=1∞(−xi)jj=−∑i=1∞(−1)ii∑j=0∞fjxij=−∑i=1∞(−1)iiF(xi)\\begin{aligned} \\ln(\\operatorname{Weigh}(F(x)))&amp;=\\sum\\limits_{i=0}^\\infin f_i\\ln(1+x^i)\\\\ &amp;=-\\sum\\limits_{i=0}^\\infin f_i\\sum\\limits_{j=1}^\\infin\\frac{(-x^i)^j}{j}\\\\ &amp;=-\\sum\\limits_{i=1}^\\infin \\frac{(-1)^i}{i}\\sum\\limits_{j=0}^\\infin f_jx^{ij}\\\\ &amp;=-\\sum\\limits_{i=1}^\\infin \\frac{(-1)^i}{i}F(x^i)\\\\ \\end{aligned} ln(Weigh(F(x)))​=i=0∑∞​fi​ln(1+xi)=−i=0∑∞​fi​j=1∑∞​j(−xi)j​=−i=1∑∞​i(−1)i​j=0∑∞​fj​xij=−i=1∑∞​i(−1)i​F(xi)​ 那么： Weigh⁡(F(x))=exp⁡(−∑i=1∞(−1)iiF(xi))\\operatorname{Weigh}(F(x))=\\exp\\left(-\\sum\\limits_{i=1}^\\infin \\frac{(-1)^i}{i}F(x^i)\\right) Weigh(F(x))=exp(−i=1∑∞​i(−1)i​F(xi)) Euler⁡\\operatorname{Euler}Euler 变换 无限制。 类似 Weigh，大小和放球方式都相同的盒子一起处理，相当于处理排序后的盒子。同种盒子允许有任意个可以通过套一层 Invert 变换来实现： E(F(x))=∏i=0∞(11−xi)fi\\mathcal{E}(F(x))=\\prod\\limits_{i=0}^\\infin \\left(\\frac{1}{1-x^i}\\right)^{f_i}\\\\ E(F(x))=i=0∏∞​(1−xi1​)fi​ 同样是 ln⁡\\lnln 再 exp⁡\\expexp： ln⁡(E(F(x)))=∑i=0∞filn⁡(11−xi)=−∑i=0∞filn⁡(1−xi)=∑i=0∞fi∑j=1∞xijj=∑i=1∞F(xi)i\\begin{aligned} \\ln(\\mathcal{E}(F(x)))&amp;=\\sum\\limits_{i=0}^\\infin f_i\\ln\\left(\\frac{1}{1-x^i}\\right)\\\\ &amp;=-\\sum\\limits_{i=0}^\\infin f_i\\ln(1-x^i)\\\\ &amp;=\\sum\\limits_{i=0}^\\infin f_i\\sum\\limits_{j=1}^\\infin\\frac{x^{ij}}{j}\\\\ &amp;=\\sum\\limits_{i=1}^\\infin \\frac{F(x^i)}{i} \\end{aligned} ln(E(F(x)))​=i=0∑∞​fi​ln(1−xi1​)=−i=0∑∞​fi​ln(1−xi)=i=0∑∞​fi​j=1∑∞​jxij​=i=1∑∞​iF(xi)​​ 所以： E(F(x))=exp⁡(∑i=1∞F(xi)i)\\mathcal{E}(F(x))=\\exp\\left(\\sum\\limits_{i=1}^\\infin \\frac{F(x^i)}{i}\\right) E(F(x))=exp(i=1∑∞​iF(xi)​) 复合变换 考虑另一个 OGF H(x)=∑i=0∞hixiH(x)=\\sum\\limits_{i=0}^\\infin h_ix^iH(x)=i=0∑∞​hi​xi，考虑复合函数 H(F(x))H(F(x))H(F(x)) 和 H(G(x))H(G(x))H(G(x)) 的意义： [xn]H(F(x))=[xn]∑i=0∞hiF(x)i[x^n]H(F(x))=[x^n]\\sum\\limits_{i=0}^\\infin h_iF(x)^i[xn]H(F(x))=[xn]i=0∑∞​hi​F(x)i：nnn 个无标号小球放入若干个有标号盒子中，每个盒子放 iii 个小球均有 [xi]F(x)[x^i]F(x)[xi]F(x) 种方案。这若干个盒子放入一个大箱子中，大箱子中放 iii 个盒子有 hih_ihi​ 种方案； [xn]H(G(x))=[xn]∑i=0∞hiG(x)i[x^n]H(G(x))=[x^n]\\sum\\limits_{i=0}^\\infin h_iG(x)^i[xn]H(G(x))=[xn]i=0∑∞​hi​G(x)i：nnn 个有标号小球放入若干个有标号盒子中，每个盒子放 iii 个小球均有 [xi]G(x)[x^i]G(x)[xi]G(x) 种方案。这若干个盒子放入一个大箱子中，大箱子中放 iii 个盒子有 hih_ihi​ 种方案； 注意 H(x)H(x)H(x) 也可以是 EGF，并且可以复合再复合。 比较经典的是有标号有根树的 EGF T(x)T(x)T(x) 复合上任意生成函数。 Part 4 各种变换的计算 ???⁡(x)\\operatorname{???}(x)???(x) 和 Invert⁡(x)\\operatorname{Invert}(x)Invert(x)：求逆即可； Exp⁡(x)\\operatorname{Exp}(x)Exp(x)：直接多项式 exp； Weigh⁡(x)\\operatorname{Weigh}(x)Weigh(x) 和 E(x)\\mathcal{E}(x)E(x)：暴力调和级数； 复合变换： 牛顿迭代。以有标号有根树的 EGF T(x)=1+∑i=1∞ii−1xii!T(x)=1+\\sum\\limits_{i=1}^\\infin i^{i-1}\\frac{x^i}{i!}T(x)=1+i=1∑∞​ii−1i!xi​ 为例，考虑另一个生成函数 H(x)H(x)H(x)（不管是 OGF 还是 EGF），求解 T(H(x))T(H(x))T(H(x))。 显然有 T(x)=xexp⁡(T(x))T(x)=x\\exp(T(x))T(x)=xexp(T(x))，那么有 T(H(x))=H(x)exp⁡(T(H(x)))T(H(x))=H(x)\\exp(T(H(x)))T(H(x))=H(x)exp(T(H(x)))。 根据牛迭式子，构造 P(A(x))=A(x)−H(x)exp⁡(A(x))P(A(x))=A(x)-H(x)\\exp(A(x))P(A(x))=A(x)−H(x)exp(A(x))。 P(A(x))P(A(x))P(A(x)) 很好算，但是求导的时候要注意实际上求的是关于 A(x)A(x)A(x) 的偏导，即把 A(x)A(x)A(x) 外的东西都看作常数，所以有：P′(A(x))=1−H(x)exp⁡(A(x))P&#x27;(A(x))=1-H(x)\\exp(A(x))P′(A(x))=1−H(x)exp(A(x))。 那么牛顿迭代求解即可。 求出来 T(H(x))T(H(x))T(H(x)) 后可以 O(n)O(n)O(n) 算出有标号无根树复合 H(x)H(x)H(x) 的结果，这样就可以算点双边双什么的了。 Part 5 拓展应用 无标号有根树计数 设无标号有根树个数的 OGF 为 T(x)T(x)T(x)，那么显然有 T(x)=xE(T(x))=xexp⁡(∑i=1∞T(xi)i)T(x)=x\\mathcal{E}(T(x))=x\\exp\\left(\\sum\\limits_{i=1}^\\infin \\frac{T(x^i)}{i}\\right)T(x)=xE(T(x))=xexp(i=1∑∞​iT(xi)​)。那么构造 P(T(x))=ln⁡(T(x)x)−∑i=1∞T(xi)iP(T(x))=\\ln\\left(\\frac{T(x)}{x}\\right)-\\sum\\limits_{i=1}^\\infin \\frac{T(x^i)}{i}P(T(x))=ln(xT(x)​)−i=1∑∞​iT(xi)​。 注意到牛迭的前提是已知 T∗(x)≡T(x)(modxn2)T_*(x)\\equiv T(x)\\pmod{x^\\frac{n}{2}}T∗​(x)≡T(x)(modx2n​)，要求 P(T∗(x))P′(T∗(x))(modxn)\\frac{P(T_*(x))}{P&#x27;(T_*(x))}\\pmod{x^n}P′(T∗​(x))P(T∗​(x))​(modxn)。那么显然 B(x)=∑i≥2∞T∗(xi)imod xnB(x)=\\sum\\limits_{i\\ge 2}^\\infin \\frac{T_*(x^i)}{i}\\mod{x^n}B(x)=i≥2∑∞​iT∗​(xi)​modxn 是已知的，则有： P(T∗(x))≡ln⁡(T∗(x)x)−T∗(x)−B(x)(modxn)P′(T∗(x))≡1T∗(x)−T∗(x)(modxn)P(T_*(x))\\equiv \\ln\\left(\\frac{T_*(x)}{x}\\right)-T_*(x)-B(x)\\pmod{x^n}\\\\ P&#x27;(T_*(x))\\equiv \\frac{1}{T_*(x)}-T_*(x)\\pmod{x^n}\\\\ P(T∗​(x))≡ln(xT∗​(x)​)−T∗​(x)−B(x)(modxn)P′(T∗​(x))≡T∗​(x)1​−T∗​(x)(modxn) 发现 [x0]T∗(x)=0[x^0]T_*(x)=0[x0]T∗​(x)=0，直接牛迭会解出 000，所以考虑用牛迭求解 A(x)=T(x)xA(x)=\\frac{T(x)}{x}A(x)=xT(x)​： P(A∗(x))≡ln⁡(A∗(x))−xA∗(x)−B(x)(modxn)P′(A∗(x))≡1A∗(x)−x(modxn)P(A_*(x))\\equiv \\ln\\left(A_*(x)\\right)-xA_*(x)-B(x)\\pmod{x^n}\\\\ P&#x27;(A_*(x))\\equiv \\frac{1}{A_*(x)}-x\\pmod{x^n}\\\\ P(A∗​(x))≡ln(A∗​(x))−xA∗​(x)−B(x)(modxn)P′(A∗​(x))≡A∗​(x)1​−x(modxn) 注意到 B(x)B(x)B(x) 可以在倍增的时候动态调和级数维护，所以 ln⁡\\lnln 加上两次求逆，再动态维护 B(x)B(x)B(x) 即可。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)，常数略大。 这个东西变成无根也很简单，只要减掉根不是重心的情况即可。 ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"生成函数变换学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/sheng-cheng-han-shu-bian-huan-xue-xi-bi-ji/","stats":{"text":"13 min read","time":734000,"words":2397,"minutes":13},"date":"2023-05-02 10:53:41","dateFormat":"2023-05-02"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，求</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&gt;</mo><mn>0</mn><mo separator=\"true\">,</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>n</mi></mrow></msub><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>F</mi><msub><mi>a</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{m&gt;0,a_i&gt;0,\\sum a_i=n}\\prod_{i=1}^m F_{a_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.020304em;vertical-align:-1.2160119999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7500050000000003em;\"><span style=\"top:-2.0589950000000004em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">m</span><span class=\"mrel mtight\">&gt;</span><span class=\"mord mtight\">0</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">&gt;</span><span class=\"mord mtight\">0</span><span class=\"mpunct mtight\">,</span><span class=\"mop op-symbol small-op mtight\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\">n</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2160119999999999em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9 + 7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>100</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^{100}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn，求 ∑m&gt;0,ai&gt;0,∑ai=n∏i=1mFai\\sum\\limits_{m&gt;0,a_i&gt;0,\\sum a_i=n}\\prod_{i=1}^m F_{a_i}m&gt;0,ai​&gt;0,∑ai​=n∑​∏i=1m​Fai​​ 对 109+710^9 + 7109+7 取模。 1≤n≤101001\\le n\\le 10^{100}1≤n≤10100。 F(x)=x2F(x)+xF(x)+xx=(1−x−x2)F(x)F(x)=x1−x−x2\\begin{aligned} F(x)&amp;=x^2F(x)+xF(x)+x\\\\ x&amp;=(1-x-x^2)F(x)\\\\ F(x)&amp;=\\frac{x}{1-x-x^2} \\end{aligned} F(x)xF(x)​=x2F(x)+xF(x)+x=(1−x−x2)F(x)=1−x−x2x​​ G(x)=G(x)F(x)+F(x)G(x)(1−F(x))=F(x)G(x)=F(x)1−F(x)G(x)=x1−x−x21−x1−x−x2G(x)=x1−x−x21−2x−x21−x−x2G(x)=x1−2x−x2\\begin{aligned} G(x)&amp;=G(x)F(x)+F(x)\\\\ G(x)(1-F(x))&amp;=F(x)\\\\ G(x)&amp;=\\frac{F(x)}{1-F(x)}\\\\ G(x)&amp;=\\frac{\\frac{x}{1-x-x^2}}{1-\\frac{x}{1-x-x^2}}\\\\ G(x)&amp;=\\frac{\\frac{x}{1-x-x^2}}{\\frac{1-2x-x^2}{1-x-x^2}}\\\\ G(x)&amp;=\\frac{x}{1-2x-x^2}\\\\ \\end{aligned} G(x)G(x)(1−F(x))G(x)G(x)G(x)G(x)​=G(x)F(x)+F(x)=F(x)=1−F(x)F(x)​=1−1−x−x2x​1−x−x2x​​=1−x−x21−2x−x2​1−x−x2x​​=1−2x−x2x​​ 设 x1−2x−x2=b1−ax+d1−cx=b−cbx+d−dax1−cx−ax+acx2=(b+d)+(−cb−da)x1+(c+a)x+acx2\\begin{aligned} \\text{设 }\\frac{x}{1-2x-x^2}&amp;=\\frac{b}{1-ax}+\\frac{d}{1-cx}\\\\ &amp;=\\frac{b-cbx+d-dax}{1-cx-ax+acx^2}\\\\ &amp;=\\frac{(b+d)+(-cb-da)x}{1+(c+a)x+acx^2}\\\\ \\end{aligned} 设 1−2x−x2x​​=1−axb​+1−cxd​=1−cx−ax+acx2b−cbx+d−dax​=1+(c+a)x+acx2(b+d)+(−cb−da)x​​ {b+d=0−cb−da=1c+a=−2ac=−1\\begin{cases} b+d=0\\\\ -cb-da=1\\\\ c+a=-2\\\\ ac=-1 \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​b+d=0−cb−da=1c+a=−2ac=−1​ 解得：（其实有两组解，但本质相同） {c=1+2a=1−2d=24b=−24\\begin{cases} c=1+\\sqrt2\\\\ a=1-\\sqrt2\\\\ d=\\frac{\\sqrt2}{4}\\\\ b=\\frac{-\\sqrt2}{4} \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​c=1+2​a=1−2​d=42​​b=4−2​​​ 所以： x1−2x−x2=b1−ax+d1−cx=−24∑i=0∞(1−2)ixi+24∑i=0∞(1+2)ixi\\begin{aligned} \\frac{x}{1-2x-x^2}&amp;=\\frac{b}{1-ax}+\\frac{d}{1-cx}\\\\ &amp;=-\\frac{\\sqrt2}{4}\\sum\\limits_{i=0}^\\infin(1-\\sqrt2)^ix^i+\\frac{\\sqrt2}{4}\\sum\\limits_{i=0}^\\infin(1+\\sqrt2)^ix^i\\\\ \\end{aligned} 1−2x−x2x​​=1−axb​+1−cxd​=−42​​i=0∑∞​(1−2​)ixi+42​​i=0∑∞​(1+2​)ixi​ 所以： gn=24((1+2)n−(1−2)n)g_n=\\frac{\\sqrt2}{4}((1+\\sqrt2)^n-(1-\\sqrt2)^n) gn​=42​​((1+2​)n−(1−2​)n) 代码如下： // Problem: P4451 [国家集训队]整数的lqp拆分 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4451 // Memory Limit: 125 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int p=1000000007,sq2=59713600; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int n; inline int read() { int s=0,c=getchar(); while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') s=(1ll*s*10+c-48)%(p-1),c=getchar(); return s; } int main() { n=read(); printf(&quot;%d\\n&quot;,1ll*sq2*qpow(4,p-2)%p*(qpow(1+sq2,n)-qpow(1-sq2+p,n)+p)%p); return 0; } ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P4451 [国家集训队]整数的lqp拆分 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p4451-guo-jia-ji-xun-dui-zheng-shu-de-lqp-chai-fen-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":269000,"words":738,"minutes":5},"date":"2023-04-24 12:50:41","dateFormat":"2023-04-24"},{"abstract":"","content":"Part 2 指数型生成函数 EGF（E\\mathtt{E}Exponential G\\mathtt{G}Generating F\\mathtt{F}Function） 指数型生成函数的特征函数是 fi(x)=xii!f_i(x)=\\frac{x^i}{i!}fi​(x)=i!xi​。 2.0 形式幂级数形式 EGF 的特征函数是 fi(x)=xii!f_i(x)=\\frac{x^i}{i!}fi​(x)=i!xi​，那么 EGF 的形式幂级数形式即为： F(x)=∑i=0∞aixii!F(x)=\\sum\\limits_{i=0}^\\infin a_i\\frac{x^i}{i!} F(x)=i=0∑∞​ai​i!xi​ 2.1 EGF 的一些运算的意义 为了方便计算，规定原序列的负数项为 000，负数的阶乘是正无穷（抛弃带有 1(−1)!\\frac{1}{(-1)!}(−1)!1​ 之类的系数的项）。 假设有两个序列 aaa，bbb 和它们的 EGF F(x)F(x)F(x)，G(x)G(x)G(x)，那么： 相加减 H(x)=F(x)±G(x)=∑i=0∞(ai±bi)xii!\\begin{aligned} H(x)&amp;=F(x)\\pm G(x)\\\\ &amp;=\\sum\\limits_{i=0}^\\infin (a_i\\pm b_i)\\frac{x^i}{i!} \\end{aligned} H(x)​=F(x)±G(x)=i=0∑∞​(ai​±bi​)i!xi​​ 相当于是 aaa 和 bbb 对应项相加减的序列 ci=ai±bic_i=a_i\\pm b_ici​=ai​±bi​ 的 EGF； 求导 F′(x)=∑i=0∞aiixi−1i!=∑i=0∞aixi−1(i−1)!=∑i=0∞ai+1xii!\\begin{aligned} F&#x27;(x)&amp;=\\sum\\limits_{i=0}^\\infin a_i\\frac{ix^{i-1}}{i!}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin a_i\\frac{x^{i-1}}{(i-1)!}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin a_{i+1}\\frac{x^i}{i!}\\\\ \\end{aligned} F′(x)​=i=0∑∞​ai​i!ixi−1​=i=0∑∞​ai​(i−1)!xi−1​=i=0∑∞​ai+1​i!xi​​ 相当于是把原序列整体左移了一位； 积分 ∫F(x)dx=∫∑i=0∞aixii!dx=C+∑i=0∞aixi+1(i+1)i!=C+∑i=0∞aixi+1(i+1)!=C+∑i=0∞ai−1xii!\\begin{aligned} \\int F(x)dx&amp;=\\int \\sum\\limits_{i=0}^\\infin a_i\\frac{x^i}{i!}dx\\\\ &amp;=C+\\sum\\limits_{i=0}^\\infin a_i\\frac{x^{i+1}}{(i+1)i!}\\\\ &amp;=C+\\sum\\limits_{i=0}^\\infin a_i\\frac{x^{i+1}}{(i+1)!}\\\\ &amp;=C+\\sum\\limits_{i=0}^\\infin a_{i-1}\\frac{x^i}{i!}\\\\ \\end{aligned} ∫F(x)dx​=∫i=0∑∞​ai​i!xi​dx=C+i=0∑∞​ai​(i+1)i!xi+1​=C+i=0∑∞​ai​(i+1)!xi+1​=C+i=0∑∞​ai−1​i!xi​​ 相当于是把原序列整体右移了一位； 相乘 F(x)G(x)=(∑i=0∞aixii!)(∑i=0∞bixii!)=∑i=0∞xi∑j=0iajbi−j1j!(i−j)!=∑i=0∞xii!∑j=0iajbi−ji!j!(i−j)!=∑i=0∞xii!∑j=0i(ij)ajbi−j\\begin{aligned} F(x)G(x)&amp;=\\left(\\sum\\limits_{i=0}^\\infin a_i\\frac{x^i}{i!}\\right)\\left(\\sum\\limits_{i=0}^\\infin b_i\\frac{x^i}{i!}\\right)\\\\ &amp;=\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^i a_jb_{i-j}\\frac{1}{j!(i-j)!}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}\\sum\\limits_{j=0}^i a_jb_{i-j}\\frac{i!}{j!(i-j)!}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}\\sum\\limits_{j=0}^i \\binom{i}{j}a_jb_{i-j}\\\\ \\end{aligned} F(x)G(x)​=(i=0∑∞​ai​i!xi​)(i=0∑∞​bi​i!xi​)=i=0∑∞​xij=0∑i​aj​bi−j​j!(i−j)!1​=i=0∑∞​i!xi​j=0∑i​aj​bi−j​j!(i−j)!i!​=i=0∑∞​i!xi​j=0∑i​(ji​)aj​bi−j​​ 相当于是 ci=∑j=0i(ij)ajbi−jc_i=\\sum\\limits_{j=0}^i\\binom{i}{j}a_jb_{i-j}ci​=j=0∑i​(ji​)aj​bi−j​ 的 EGF，组合意义如下： cic_ici​ 表示把 iii 个有标号小球放入 AAA 和 BBB 两个有标号无序集合中，其中 AAA 集合中放 iii 个球的方案数是 aia_iai​，BBB 集合中放 iii 个球的方案数是 bib_ibi​。 2.2 封闭形式 {1,1,1,… }\\{1,1,1,\\dots\\}{1,1,1,…} 的 EGF 是 F(x)=∑i=0∞xiiF(x)=\\sum\\limits_{i=0}^\\infin\\frac{x^i}{i}F(x)=i=0∑∞​ixi​，注意到这就是 exe^xex 在 x=0x=0x=0 处的泰勒展开，那么它的封闭形式即为 exe^xex。 同理，{1,p,p2,p3,… }\\{1,p,p^2,p^3,\\dots\\}{1,p,p2,p3,…} 的 EGF 的封闭形式即为 epxe^{px}epx。 由于 xii!\\frac{x^i}{i!}i!xi​ 只能利用泰勒展开化为有限的封闭形式，所以往往要先将原序列转化为多个等比数列的和。 2.3 一些常见数列的 EGF 的封闭形式 a={c,cp,cp2,cp3,… }a={1,−1,1,−1,… }a={1,0,1,0,1,… }a={0,1,0,1,0,… }ai=ni‾ 即 ai=n(n−1)(n−2)…(n−i+1)，n 是给定的常数a0=0,ai=(−1)i−1(i−1)!a0=0,ai=(i−1)!a={1,0,−1,0,1,0,−1,0,… }a={0,1,0,−1,0,1,0,−1,… }a=\\{c,cp,cp^2,cp^3,\\dots\\}\\\\ a=\\{1,-1,1,-1,\\dots\\}\\\\ a=\\{1,0,1,0,1,\\dots\\}\\\\ a=\\{0,1,0,1,0,\\dots\\}\\\\ a_i=n^{\\underline{i}}\\text{ 即 }a_i=n(n-1)(n-2)\\dots(n-i+1)\\text{，}n\\text{ 是给定的常数}\\\\ a_0=0,a_i=(-1)^{i-1}(i-1)!\\\\ a_0=0,a_i=(i-1)!\\\\ a=\\{1,0,-1,0,1,0,-1,0,\\dots\\}\\\\ a=\\{0,1,0,-1,0,1,0,-1,\\dots\\}\\\\ a={c,cp,cp2,cp3,…}a={1,−1,1,−1,…}a={1,0,1,0,1,…}a={0,1,0,1,0,…}ai​=ni​ 即 ai​=n(n−1)(n−2)…(n−i+1)，n 是给定的常数a0​=0,ai​=(−1)i−1(i−1)!a0​=0,ai​=(i−1)!a={1,0,−1,0,1,0,−1,0,…}a={0,1,0,−1,0,1,0,−1,…} 第一个： F(x)=c∑i=0∞pixii!=c∑i=0∞(px)ii!=c⋅epxF(x)=c\\sum\\limits_{i=0}^\\infin p^i\\frac{x^i}{i!}=c\\sum\\limits_{i=0}^\\infin \\frac{(px)^i}{i!}=c\\cdot e^{px} F(x)=ci=0∑∞​pii!xi​=ci=0∑∞​i!(px)i​=c⋅epx 第二个： F(x)=∑i=0∞(−1)ixii!=∑i=0∞(−x)ii!=e−xF(x)=\\sum\\limits_{i=0}^\\infin (-1)^i\\frac{x^i}{i!}=\\sum\\limits_{i=0}^\\infin\\frac{(-x)^i}{i!}=e^{-x} F(x)=i=0∑∞​(−1)ii!xi​=i=0∑∞​i!(−x)i​=e−x 第三个： ai=1+(−1)i2F(x)=∑i=0∞xii!+∑i=0∞(−x)ii!2=ex+e−x2a_i=\\frac{1+(-1)^i}{2}\\\\ F(x)=\\frac{\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}+\\sum\\limits_{i=0}^\\infin\\frac{(-x)^i}{i!}}{2}=\\frac{e^x+e^{-x}}{2} ai​=21+(−1)i​F(x)=2i=0∑∞​i!xi​+i=0∑∞​i!(−x)i​​=2ex+e−x​ 第四个： ai=1−(−1)i2F(x)=∑i=0∞xii!−∑i=0∞(−x)ii!2=ex−e−x2a_i=\\frac{1-(-1)^i}{2}\\\\ F(x)=\\frac{\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}-\\sum\\limits_{i=0}^\\infin\\frac{(-x)^i}{i!}}{2}=\\frac{e^x-e^{-x}}{2} ai​=21−(−1)i​F(x)=2i=0∑∞​i!xi​−i=0∑∞​i!(−x)i​​=2ex−e−x​ 第五个： F(x)=∑i=0nni‾xii!=∑i=0n(ni)xi=(x+1)n\\begin{aligned} F(x)&amp;=\\sum\\limits_{i=0}^n n^{\\underline i}\\frac{x^i}{i!}\\\\ &amp;=\\sum\\limits_{i=0}^n\\binom{n}{i}x^i\\\\ &amp;=(x+1)^n \\end{aligned} F(x)​=i=0∑n​ni​i!xi​=i=0∑n​(in​)xi=(x+1)n​ 第六个： 考虑 ln⁡(x+1) 在 x=0 附近的泰勒展开：ln⁡(x+1)=∑i=0∞ln⁡(i)(1)xii!=∑i=1∞(−1)i−1(i−1)!xii!所以F(x)=∑i=1∞(−1)i−1(i−1)!xii!=ln⁡(x+1)\\text{考虑 }\\ln(x+1)\\text{ 在 } x=0 \\text{ 附近的泰勒展开：}\\\\ \\begin{aligned} \\ln(x+1)&amp;=\\sum\\limits_{i=0}^{\\infin}\\ln^{(i)}(1)\\frac{x^{i}}{i!}\\\\ &amp;=\\sum\\limits_{i=1}^{\\infin}(-1)^{i-1}(i-1)!\\frac{x^{i}}{i!}\\\\ \\end{aligned}\\\\ \\text{所以}\\\\ F(x)=\\sum\\limits_{i=1}^{\\infin}(-1)^{i-1}(i-1)!\\frac{x^{i}}{i!}=\\ln(x+1) 考虑 ln(x+1) 在 x=0 附近的泰勒展开：ln(x+1)​=i=0∑∞​ln(i)(1)i!xi​=i=1∑∞​(−1)i−1(i−1)!i!xi​​所以F(x)=i=1∑∞​(−1)i−1(i−1)!i!xi​=ln(x+1) 第七个： 考虑 −ln⁡(1−x) 在 x=0 附近的泰勒展开，换元可得：−ln⁡(1−x)=∑i=1∞xii所以F(x)=∑i=1∞(i−1)!xii!=−ln⁡(1−x)\\text{考虑 }-\\ln(1-x)\\text{ 在 } x=0 \\text{ 附近的泰勒展开，换元可得：}\\\\ -\\ln(1-x)=\\sum\\limits_{i=1}^{\\infin}\\frac{x^{i}}{i}\\\\ \\text{所以}\\\\ F(x)=\\sum\\limits_{i=1}^{\\infin}(i-1)!\\frac{x^{i}}{i!}=-\\ln(1-x) 考虑 −ln(1−x) 在 x=0 附近的泰勒展开，换元可得：−ln(1−x)=i=1∑∞​ixi​所以F(x)=i=1∑∞​(i−1)!i!xi​=−ln(1−x) 第八个： 考虑 cos⁡(x) 在 x=0 处的泰勒展开：cos⁡(x)=∑i=0∞cos⁡i(0)xii!=∑i=0∞(−1)ix2i(2i)!所以F(x)=∑i=0∞aixii!=cos⁡(x)\\text{考虑 } \\cos(x) \\text{ 在 } x=0 \\text{ 处的泰勒展开：}\\\\ \\begin{aligned} \\cos(x)&amp;=\\sum\\limits_{i=0}^{\\infin} \\cos^{i}(0)\\frac{x^i}{i!}\\\\ &amp;=\\sum\\limits_{i=0}^{\\infin}(-1)^i\\frac{x^{2i}}{(2i)!}\\\\ \\end{aligned}\\\\ \\text{所以}\\\\ F(x)=\\sum\\limits_{i=0}^{\\infin}a_i\\frac{x^{i}}{i!}=\\cos(x) 考虑 cos(x) 在 x=0 处的泰勒展开：cos(x)​=i=0∑∞​cosi(0)i!xi​=i=0∑∞​(−1)i(2i)!x2i​​所以F(x)=i=0∑∞​ai​i!xi​=cos(x) 第九个： 考虑 sin⁡(x) 在 x=0 处的泰勒展开：sin⁡(x)=∑i=0∞sin⁡i(0)xii!=∑i=0∞(−1)ix2i+1(2i+1)!所以F(x)=∑i=0∞aixii!=sin⁡(x)\\text{考虑 } \\sin(x) \\text{ 在 } x=0 \\text{ 处的泰勒展开：}\\\\ \\begin{aligned} \\sin(x)&amp;=\\sum\\limits_{i=0}^{\\infin} \\sin^{i}(0)\\frac{x^i}{i!}\\\\ &amp;=\\sum\\limits_{i=0}^{\\infin}(-1)^i\\frac{x^{2i+1}}{(2i+1)!}\\\\ \\end{aligned}\\\\ \\text{所以}\\\\ F(x)=\\sum\\limits_{i=0}^{\\infin}a_i\\frac{x^{i}}{i!}=\\sin(x) 考虑 sin(x) 在 x=0 处的泰勒展开：sin(x)​=i=0∑∞​sini(0)i!xi​=i=0∑∞​(−1)i(2i+1)!x2i+1​​所以F(x)=i=0∑∞​ai​i!xi​=sin(x) 2.3.1 简单例题 POJ 3734 Blocks 有红、黄、蓝、绿四种砖块，每种都有无限块，同色的砖块是一样的。 你要选出 nnn（1≤n≤1071\\le n\\le 10^71≤n≤107）块砖砌出一堵高度为 111 的墙（一条墙），问满足以下条件的不同的墙的个数： 红色砖块只能用偶数个； 黄色砖块只能用偶数个； 对 100071000710007 取模。 由于要求排列个数且砖块内部互不区分但是不同色的砖块互相区分，所以应选用 EGF。 观察到求出各种砖块的 EGF 再卷起来即可。 蓝色和绿色砖块的 EGF 显然是 ∑i=0∞xii!=ex\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}=e^xi=0∑∞​i!xi​=ex。 红色和黄色砖块的 EGF 则是 ∑i=0∞((−1)i+1)xii!2=∑i=0∞(−x)ii!+∑i=0∞xii!2=e−x+ex2\\frac{\\sum\\limits_{i=0}^\\infin ((-1)^i+1)\\frac{x^i}{i!}}{2}=\\frac{\\sum\\limits_{i=0}^\\infin \\frac{(-x)^i}{i!}+\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}}{2}=\\frac{e^{-x}+e^x}{2}2i=0∑∞​((−1)i+1)i!xi​​=2i=0∑∞​i!(−x)i​+i=0∑∞​i!xi​​=2e−x+ex​。 全部卷起来： ANS(x)=ex×ex×e−x+ex2×e−x+ex2=e2x×e−2x+2+e2x4=1+2e2x+e4x4\\begin{aligned} ANS(x)&amp;=e^x\\times e^x\\times\\frac{e^{-x}+e^x}{2}\\times \\frac{e^{-x}+e^x}{2}\\\\ &amp;=e^{2x}\\times \\frac{e^{-2x}+2+e^{2x}}{4}\\\\ &amp;=\\frac{1+2e^{2x}+e^{4x}}{4}\\\\ \\end{aligned} ANS(x)​=ex×ex×2e−x+ex​×2e−x+ex​=e2x×4e−2x+2+e2x​=41+2e2x+e4x​​ 根据 ∑i=0∞cpixii!=cepx\\sum\\limits_{i=0}^\\infin cp^i\\frac{x^i}{i!}=ce^{px}i=0∑∞​cpii!xi​=cepx 展开： ANS(x)=1+2∑i=0∞2ixii!+∑i=0∞4ixii!4=1+2∑i=0∞2ixii!+∑i=0∞4ixii!4=14+∑i=0∞2i−14i−1xii!\\begin{aligned} ANS(x)&amp;=\\frac{1+2\\sum\\limits_{i=0}^\\infin 2^i\\frac{x^i}{i!}+\\sum\\limits_{i=0}^\\infin 4^i\\frac{x^i}{i!}}{4}\\\\ &amp;=\\frac{1+2\\sum\\limits_{i=0}^\\infin 2^i\\frac{x^i}{i!}+\\sum\\limits_{i=0}^\\infin 4^i\\frac{x^i}{i!}}{4}\\\\ &amp;=\\frac{1}{4}+\\sum\\limits_{i=0}^\\infin 2^{i-1}4^{i-1}\\frac{x^i}{i!}\\\\ \\end{aligned} ANS(x)​=41+2i=0∑∞​2ii!xi​+i=0∑∞​4ii!xi​​=41+2i=0∑∞​2ii!xi​+i=0∑∞​4ii!xi​​=41​+i=0∑∞​2i−14i−1i!xi​​ 由于 14\\frac{1}{4}41​ 是常数项，属于 x0x^0x0，而 n≥1n\\ge 1n≥1，所以不用管它，那么答案即为 2n−14n−12^{n-1}4^{n-1}2n−14n−1，直接快速幂即可。 2.4 EGF 的 EXP 的组合意义 考虑一个序列 ggg 和它的 EGF G(x)=∑i=0∞gixii!G(x)=\\sum\\limits_{i=0}^\\infin g_i\\frac{x^i}{i!}G(x)=i=0∑∞​gi​i!xi​，这里我们默认 g0=0g_0=0g0​=0，因为这是可以计算 exp⁡\\expexp 的前提条件。那么[xn]G(x)=gn[x^n]G(x)=g_n[xn]G(x)=gn​ 的组合意义如下： 把 nnn 个有标号小球放入一个无序集合内的方案数。 考虑 EGF 乘法的组合意义，那么 [xn]Gk(x)=[xn](G(x))k[x^n]G^k(x)=[x^n](G(x))^k[xn]Gk(x)=[xn](G(x))k 的组合意义如下： 把 nnn 个有标号小球放入 kkk 个有标号的非空无序集合内的方案数，每个集合中放 iii 个小球的方案数都是 gig_igi​。 那么 [xn]∑k=1∞Gk(x)[x^n]\\sum\\limits_{k=1}^\\infin G^k(x)[xn]k=1∑∞​Gk(x) 的组合意义自然是： 把 nnn 个有标号小球放入若干个有标号的非空无序集合内的方案数，每个集合中放 iii 个小球的方案数都是 gig_igi​。 考虑 [xn]Gk(x)k![x^n]\\frac{G^k(x)}{k!}[xn]k!Gk(x)​ 的组合意义，除掉的 k!k!k! 相当于去掉了集合之间的顺序： 把 nnn 个有标号小球放入 kkk 个无标号的非空无序集合内的方案数，每个集合中放 iii 个小球的方案数都是 gig_igi​。 那么 [xn]∑k=1∞Gk(x)k![x^n]\\sum\\limits_{k=1}^\\infin \\frac{G^k(x)}{k!}[xn]k=1∑∞​k!Gk(x)​ 的组合意义自然是： 把 nnn 个有标号小球放入若干个无标号的非空无序集合内的方案数，每个集合中放 iii 个小球的方案数都是 gig_igi​。 注意到这就是 exp⁡(G(x))\\exp(G(x))exp(G(x)) 的定义，所以 [xn]exp⁡(G(x))[x^n]\\exp(G(x))[xn]exp(G(x)) 的组合意义就是： 把 nnn 个有标号小球放入若干个无标号的非空无序集合内的方案数，每个集合中放 iii 个小球的方案数都是 gig_igi​。 2.5 EGF 的应用 2.5.1 圆排列计数 圆排列：排在圆上的排列，旋转之后本质相同。 设 fnf_nfn​ 表示 nnn 的排列的个数，容易发现 fn=n!f_n=n!fn​=n!。设 F(x)F(x)F(x) 为 fff 的 EGF，那么有 F(x)=∑i=0∞i!xii!=∑i=0∞xiF(x)=\\sum\\limits_{i=0}^\\infin i!\\frac{x^i}{i!}=\\sum\\limits_{i=0}^\\infin x^iF(x)=i=0∑∞​i!i!xi​=i=0∑∞​xi。 设 gng_ngn​ 表示 nnn 的圆排列的个数，那么由于环旋转之后是本质相同的，所以有 gn=n!n=(n−1)!g_n=\\frac{n!}{n}=(n-1)!gn​=nn!​=(n−1)!，特别的，g0=0g_0=0g0​=0。设 G(x)G(x)G(x) 为 ggg 的 EGF，那么有 G(x)=∑i=1∞(i−1)!xii!=∑i=1∞xiiG(x)=\\sum\\limits_{i=1}^\\infin (i-1)!\\frac{x^i}{i!}=\\sum\\limits_{i=1}^\\infin\\frac{x^i}{i}G(x)=i=1∑∞​(i−1)!i!xi​=i=1∑∞​ixi​。 观察到有 F(x)=11−xF(x)=\\frac{1}{1-x}F(x)=1−x1​，G(x)=−ln⁡(1−x)=ln⁡(11−x)G(x)=-\\ln(1-x)=\\ln(\\frac{1}{1-x})G(x)=−ln(1−x)=ln(1−x1​)，所以有 G(x)=ln⁡(F(x))G(x)=\\ln(F(x))G(x)=ln(F(x))。 组合意义上的解释是，考虑一个长度为 nnn 排列 ppp，从 iii 向 pip_ipi​ 连一条有向边，那么由于每个点的入度和出度都是 111，所以最后一定会形成若干个环，并且环的方案和排列组成双射。由于大小为 xxx 的环的方案数都是 gxg_xgx​，所以有 F(x)=exp⁡(G(x))F(x)=\\exp(G(x))F(x)=exp(G(x))。 2.5.2 错排列计数 错排列：满足 pi=ip_i\\not= ipi​​=i 的排列。 设 fnf_nfn​ 表示 nnn 的错排列的个数，gng_ngn​ 表示 nnn 的圆排列的个数，F(x)F(x)F(x)、G(x)G(x)G(x) 分别为 fff、ggg 的 EGF，根据之前的推导有 G(x)=−ln⁡(1−x)G(x)=-\\ln(1-x)G(x)=−ln(1−x)。 那么观察到错排列就相当于是变成若干个环后不存在大小为 111 的环，那么设 G∗(x)=G(x)−xG_*(x)=G(x)-xG∗​(x)=G(x)−x 即让大小为 111 的环的方案数为 000，显然有 G∗(x)=−ln⁡(1−x)−xG_*(x)=-\\ln(1-x)-xG∗​(x)=−ln(1−x)−x，F(x)=exp⁡(G∗(x))=exp⁡(−ln⁡(1−x)−x)F(x)=\\exp(G_*(x))=\\exp(-\\ln(1-x)-x)F(x)=exp(G∗​(x))=exp(−ln(1−x)−x)。 2.5.3 简单例题：不动点 求满足以下条件的 nnn 个点有向图的个数： 每个点出度为 111； 从每个点出发，走 kkk 步后到达的点和走 k−1k-1k−1 步后到达的点一样； 1≤n≤2×106,1≤k≤31\\le n\\le 2\\times 10^6,1\\le k\\le 31≤n≤2×106,1≤k≤3。 不难发现满足条件的图是一个基环树森林，并且森林中的基环树的根都是一个自环，所以实际上图是一个森林。且森林中的树的深度小于等于 kkk。 那么设 fn,mf_{n,m}fn,m​ 表示 nnn 个点的深度不超过 mmm 的有根树的个数，显然有 f1,1=1f_{1,1}=1f1,1​=1，设 Fm(x)=∑i=0∞fi,mxii!F_m(x)=\\sum\\limits_{i=0}^\\infin f_{i,m}\\frac{x^i}{i!}Fm​(x)=i=0∑∞​fi,m​i!xi​ 也就是 fff 关于 nnn 的 EGF。那么由于根的不同子树不用考虑顺序，所以有 Fm(x)=x×exp⁡(Fm−1(x))F_m(x)=x\\times \\exp(F_{m-1}(x))Fm​(x)=x×exp(Fm−1​(x)) 其中乘 xxx 是因为要算上根的 EGF x11!\\frac{x^1}{1!}1!x1​。 接下来就要把这些有根树组合起来，答案即为 [xn]exp⁡(Fk(x))[x^n]\\exp(F_k(x))[xn]exp(Fk​(x))。 经典例题 CF891E Lust 有个结论，ansansans 每次增加的量等于 ∏ai\\prod a_i∏ai​ 减少的量，那么设 aia_iai​ 减少了 bib_ibi​，那么 ansansans 即为 ∏ai−∏(ai−bi)\\prod a_i-\\prod (a_i-b_i)∏ai​−∏(ai​−bi​)。 那么设 aia_iai​ 的 EGF 为 Fi(x)=∑j=0∞(ai−j)xjj!F_i(x)=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}Fi​(x)=j=0∑∞​(ai​−j)j!xj​，则答案即为 ∏ai−[xk]∏Fi(x)nk\\prod a_i-\\frac{[x^k]\\prod F_i(x)}{n^k}∏ai​−nk[xk]∏Fi​(x)​。 分母可以 O(n)O(n)O(n) 算，所以问题的难点在于 [xk]∏Fi(x)[x^k]\\prod F_i(x)[xk]∏Fi​(x)，注意到有： Fi(x)=∑j=0∞(ai−j)xjj!=∑j=0∞aixjj!−∑j=0∞jxjj!=ai∑j=0∞xjj!−x∑j=1∞xj−1(j−1)!=(ai−x)ex\\begin{aligned} F_i(x)&amp;=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}\\\\ &amp;=\\sum\\limits_{j=0}^\\infin a_i\\frac{x^j}{j!}-\\sum\\limits_{j=0}^\\infin j\\frac{x^j}{j!}\\\\ &amp;=a_i\\sum\\limits_{j=0}^\\infin\\frac{x^j}{j!}-x\\sum\\limits_{j=1}^\\infin \\frac{x^{j-1}}{(j-1)!}\\\\ &amp;=(a_i-x)e^x \\end{aligned} Fi​(x)​=j=0∑∞​(ai​−j)j!xj​=j=0∑∞​ai​j!xj​−j=0∑∞​jj!xj​=ai​j=0∑∞​j!xj​−xj=1∑∞​(j−1)!xj−1​=(ai​−x)ex​ 那么有： [xk]∏Fi(x)=[xk](enx∏(ai−x))[x^k]\\prod F_i(x)=[x^k]\\left(e^{nx}\\prod (a_i-x)\\right) [xk]∏Fi​(x)=[xk](enx∏(ai​−x)) 由于 n≤5000n\\le 5000n≤5000，所以 ∏(ai−x)\\prod (a_i-x)∏(ai​−x) 的每一项系数 c0+c1x1+…c_0+c_1x^1+\\dotsc0​+c1​x1+… 可以 O(n2)O(n^2)O(n2) 算出来，然后根据 [xk]enx=nk[x^k]e^{nx}=n^k[xk]enx=nk，可以直接 O(n2)O(n^2)O(n2) 暴力卷积算出 [xk]∏Fi(x)[x^k]\\prod F_i(x)[xk]∏Fi​(x)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=5005,p=1000000007; int n,k,a[S]; int c[S],tmp[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;m||n&lt;0||m&lt;0) return 0; int re=1,div=1; for(int i=n;i&gt;=n-m+1;i--) re=1ll*re*i%p; for(int i=1;i&lt;=m;i++) div=1ll*div*i%p; return 1ll*re*qpow(div,p-2)%p; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); c[0]=1; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=n;j++) tmp[j]=c[j]; for(int j=0;j&lt;=n;j++) c[j]=1ll*c[j]*a[i]%p; for(int j=0;j&lt;=n-1;j++) c[j+1]=(c[j+1]-tmp[j]+p)%p; } for(int i=0,fra=1;i&lt;=n;i++) fra=1ll*fra*max(i,1)%p,c[i]=1ll*fra*c[i]%p; int prod=0; for(int i=k;i&gt;=k-n&amp;&amp;i&gt;=0;i--) prod=(prod+1ll*qpow(n,i)*c[k-i]%p*C(k,k-i)%p)%p; int mul=1; for(int i=1;i&lt;=n;i++) mul=1ll*mul*a[i]%p; int ans=(mul-1ll*prod*qpow(qpow(n,k),p-2)%p+p)%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"指数型生成函数入门","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zhi-shu-xing-sheng-cheng-han-shu-ru-men/","stats":{"text":"26 min read","time":1508000,"words":4764,"minutes":26},"date":"2023-04-20 16:39:50","dateFormat":"2023-04-20"},{"abstract":"<blockquote>\n<p>你有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\dots,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 要进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次操作，每次随机选择一个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">x \\in [1,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span>，把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 减一，并将答案增加除 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 外所有数的乘积。</p>\n<p>求最终答案的期望，答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9 + 7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 你有 nnn 个数 a1,a2,…,ana_1,a_2,\\dots,a_na1​,a2​,…,an​ 要进行 kkk 次操作，每次随机选择一个数 x∈[1,n]x \\in [1,n]x∈[1,n]，把 axa_xax​ 减一，并将答案增加除 axa_xax​ 外所有数的乘积。 求最终答案的期望，答案对 109+710^9 + 7109+7 取模。 1≤n≤50001\\le n\\le 50001≤n≤5000。 有个结论，ansansans 每次增加的量等于 ∏ai\\prod a_i∏ai​ 减少的量，那么设 aia_iai​ 减少了 bib_ibi​，那么 ansansans 即为 ∏ai−∏(ai−bi)\\prod a_i-\\prod (a_i-b_i)∏ai​−∏(ai​−bi​)。 那么设 aia_iai​ 的 EGF 为 Fi(x)=∑j=0∞(ai−j)xjj!F_i(x)=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}Fi​(x)=j=0∑∞​(ai​−j)j!xj​，则答案即为 ∏ai−[xk]∏Fi(x)nk\\prod a_i-\\frac{[x^k]\\prod F_i(x)}{n^k}∏ai​−nk[xk]∏Fi​(x)​。 分母可以 O(n)O(n)O(n) 算，所以问题的难点在于 [xk]∏Fi(x)[x^k]\\prod F_i(x)[xk]∏Fi​(x)，注意到有： Fi(x)=∑j=0∞(ai−j)xjj!=∑j=0∞aixjj!−∑j=0∞jxjj!=ai∑j=0∞xjj!−x∑j=1∞xj−1(j−1)!=(ai−x)ex\\begin{aligned} F_i(x)&amp;=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}\\\\ &amp;=\\sum\\limits_{j=0}^\\infin a_i\\frac{x^j}{j!}-\\sum\\limits_{j=0}^\\infin j\\frac{x^j}{j!}\\\\ &amp;=a_i\\sum\\limits_{j=0}^\\infin\\frac{x^j}{j!}-x\\sum\\limits_{j=1}^\\infin \\frac{x^{j-1}}{(j-1)!}\\\\ &amp;=(a_i-x)e^x \\end{aligned} Fi​(x)​=j=0∑∞​(ai​−j)j!xj​=j=0∑∞​ai​j!xj​−j=0∑∞​jj!xj​=ai​j=0∑∞​j!xj​−xj=1∑∞​(j−1)!xj−1​=(ai​−x)ex​ 那么有： [xk]∏Fi(x)=[xk](enx∏(ai−x))[x^k]\\prod F_i(x)=[x^k]\\left(e^{nx}\\prod (a_i-x)\\right) [xk]∏Fi​(x)=[xk](enx∏(ai​−x)) 由于 n≤5000n\\le 5000n≤5000，所以 ∏(ai−x)\\prod (a_i-x)∏(ai​−x) 的每一项系数 c0+c1x1+…c_0+c_1x^1+\\dotsc0​+c1​x1+… 可以 O(n2)O(n^2)O(n2) 算出来，然后根据 [xk]enx=nk[x^k]e^{nx}=n^k[xk]enx=nk，可以直接 O(n2)O(n^2)O(n2) 暴力卷积算出 [xk]∏Fi(x)[x^k]\\prod F_i(x)[xk]∏Fi​(x)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=5005,p=1000000007; int n,k,a[S]; int c[S],tmp[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;m||n&lt;0||m&lt;0) return 0; int re=1,div=1; for(int i=n;i&gt;=n-m+1;i--) re=1ll*re*i%p; for(int i=1;i&lt;=m;i++) div=1ll*div*i%p; return 1ll*re*qpow(div,p-2)%p; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); c[0]=1; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=n;j++) tmp[j]=c[j]; for(int j=0;j&lt;=n;j++) c[j]=1ll*c[j]*a[i]%p; for(int j=0;j&lt;=n-1;j++) c[j+1]=(c[j+1]-tmp[j]+p)%p; } for(int i=0,fra=1;i&lt;=n;i++) fra=1ll*fra*max(i,1)%p,c[i]=1ll*fra*c[i]%p; int prod=0; for(int i=k;i&gt;=k-n&amp;&amp;i&gt;=0;i--) prod=(prod+1ll*qpow(n,i)*c[k-i]%p*C(k,k-i)%p)%p; int mul=1; for(int i=1;i&lt;=n;i++) mul=1ll*mul*a[i]%p; int ans=(mul-1ll*prod*qpow(qpow(n,k),p-2)%p+p)%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF891E Lust 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf891e-lust-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":265000,"words":772,"minutes":5},"date":"2023-04-19 20:44:00","dateFormat":"2023-04-19"},{"abstract":"<blockquote>\n<p>给定一个长 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，定义 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的排列（任意打乱元素顺序后的数组）<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的价值为最小的操作次数使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b=a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，一次操作可以：</p>\n<ul>\n<li>选定两个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i&lt;j\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>F1：给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，构造价值最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>；</p>\n<p>F2：给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，判断 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的价值是否最大；</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长 nnn，值域 [1,n][1,n][1,n] 的数组 aaa，定义 aaa 的排列（任意打乱元素顺序后的数组）bbb 的价值为最小的操作次数使得 b=ab=ab=a，一次操作可以： 选定两个 1≤i&lt;j≤n1\\le i&lt;j\\le n1≤i&lt;j≤n，交换 bib_ibi​ 和 bjb_jbj​； F1：给定 aaa，构造价值最大的 bbb； F2：给定 aaa 和 bbb，判断 bbb 的价值是否最大； 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105。 F1 的做法很简单，先考虑 aaa 各不相同的情况。那么对于一个 bbb，设 nnn 个点的有向图 GGG 构造方法如下： 从 iii 向 bib_ibi​ 在 aaa 中的位置 jjj 连一条有向边； 那么 bbb 的价值即为 n−G 中的环个数n-G\\text{ 中的环个数}n−G 中的环个数。 考虑 aaa 会相同的情况，那么无非就是 S={i,bi=x}S=\\{i,b_i=x\\}S={i,bi​=x} 和 T={i,ai=x}T=\\{i,a_i=x\\}T={i,ai​=x} 之间的 ∣S∣|S|∣S∣ 条有向边可以任意确定，只要保证 SSS 中的每个点都有出边，TTT 中的每个点都有入边即可。 注意到若 GGG 中的两个点 x,yx,yx,y 在同一个环中且满足 bx=byb_x=b_ybx​=by​，则可以通过交换 x,yx,yx,y 的出边来把这个环分裂成两个环，这显然不花费操作次数。所以价值最大的 bbb 一定满足 bib_ibi​ 相同的 iii 不在同一个环内，那么直接乱构造就行了。 代码如下： int n,m,a[S]; vector&lt;int&gt; vec[S],cir[S]; int ans[S]; inline void slove() { read(n); for(int i=1;i&lt;=n;i++) read(a[i]); for(int i=1;i&lt;=n;i++) vec[i].clear(),cir[i].clear(); for(int i=1;i&lt;=n;i++) vec[a[i]].pb(i); m=0; for(int i=1;i&lt;=n;i++) { int id=0; for(int v:vec[i]) cir[++id].pb(v); m=max(m,id); } for(int i=1;i&lt;=m;i++) { int ct=cir[i].size(); for(int j=0;j&lt;ct;j++) { int u=cir[i][j],v=cir[i][(j+1)%ct]; ans[u]=a[v]; } } for(int i=1;i&lt;=n;i++) write(ans[i],' '); write('\\n'); } F2 其实也挺简单的，注意到合法的 bbb 对应 GGG 中环的个数一定等于 aaa 中出现次数最多的数的出现次数，那么把出现次数最多的数删掉，如果剩下的数能构成环，则 bbb 不合法。 判环直接弄个虚点 ctctct，建 (i∈S)→ct(i\\in S)\\to ct(i∈S)→ct，ct→(i∈T)ct\\to (i\\in T)ct→(i∈T)，然后拓扑判环集可。 代码如下： int n,a[S],b[S]; vector&lt;int&gt; va[S],vb[S]; int cnt[S]; vector&lt;int&gt; g[S]; int ind[S]; queue&lt;int&gt; q; inline void slove() { read(n); for(int i=1;i&lt;=n;i++) read(a[i]); for(int i=1;i&lt;=n;i++) read(b[i]); for(int i=1;i&lt;=n;i++) va[i].clear(),vb[i].clear(); for(int i=1;i&lt;=n;i++) va[a[i]].pb(i),vb[b[i]].pb(i); for(int i=1;i&lt;=n;i++) cnt[i]=0; int mx=0; for(int i=1;i&lt;=n;i++) mx=max(mx,++cnt[a[i]]); for(int i=1;i&lt;=n;i++) { if(cnt[i]==mx) { va[i].clear(),vb[i].clear(); break; } } for(int i=1;i&lt;=n+n;i++) g[i].clear(),ind[i]=0; int cnt=n; for(int i=1;i&lt;=n;i++) { cnt++; for(int id:vb[i]) g[id].pb(cnt),ind[cnt]++; for(int id:va[i]) g[cnt].pb(id),ind[id]++; } while(!q.empty()) q.pop(); for(int i=1;i&lt;=n+n;i++) if(ind[i]==0) q.push(i); while(!q.empty()) { int u=q.front(); q.pop(); for(int v:g[u]) if(--ind[v]==0) q.push(v); } for(int i=1;i&lt;=n+n;i++) if(ind[i]!=0) return puts(&quot;WA&quot;),void(); puts(&quot;AC&quot;); } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1672F2 Checker for Array Shuffling 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1672f2-checker-for-array-shuffling-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":271000,"words":894,"minutes":5},"date":"2023-04-18 20:15:36","dateFormat":"2023-04-18"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>。</p>\n<p>对于一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span>，定义其权值为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>q</mi><mn>1</mn></msub><mo>−</mo><msub><mi>p</mi><msub><mi>q</mi><mn>2</mn></msub></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>q</mi><mn>2</mn></msub><mo>−</mo><msub><mi>p</mi><msub><mi>q</mi><mn>3</mn></msub></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>q</mi><mn>3</mn></msub><mo>−</mo><msub><mi>p</mi><msub><mi>q</mi><mn>4</mn></msub></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>q</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>p</mi><msub><mi>q</mi><mi>n</mi></msub></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>q</mi><mi>n</mi></msub><mo>−</mo><msub><mi>p</mi><msub><mi>q</mi><mn>1</mn></msub></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|q_1-p_{q_2}|+|q_2-p_{q_3}|+|q_3-p_{q_4}|+\\cdots+|q_{n-1}-p_{q_n}|+|q_n-p_{q_1}|\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16454285714285719em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span></span></p>\n<p>找出 <strong>任意一个</strong> 权值最小化的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 200</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 1∼n1\\sim n1∼n 的排列 ppp。 对于一个 1∼n1\\sim n1∼n 的排列 qqq，定义其权值为： ∣q1−pq2∣+∣q2−pq3∣+∣q3−pq4∣+⋯+∣qn−1−pqn∣+∣qn−pq1∣|q_1-p_{q_2}|+|q_2-p_{q_3}|+|q_3-p_{q_4}|+\\cdots+|q_{n-1}-p_{q_n}|+|q_n-p_{q_1}| ∣q1​−pq2​​∣+∣q2​−pq3​​∣+∣q3​−pq4​​∣+⋯+∣qn−1​−pqn​​∣+∣qn​−pq1​​∣ 找出 任意一个 权值最小化的 1∼n1\\sim n1∼n 的排列 qqq。 2≤n≤2002\\le n\\le 2002≤n≤200。 设 wqimod⁡n+1=qiw_{q_{i\\operatorname{mod}n+1}}=q_iwqimodn+1​​=qi​，那么我们要最小化的东西就变成了 ∑i=1n∣wi−pi∣\\sum\\limits_{i=1}^n|w_i-p_i|i=1∑n​∣wi​−pi​∣。 一个朴素的想法是让 wi=piw_i=p_iwi​=pi​，但是注意到 i→wii\\to w_ii→wi​ 必须要形成一个大环，也就是说 www 导出的置换环只能有一个，所以 wi=piw_i=p_iwi​=pi​ 可能不合法。 那么考虑调整，找到 wiw_iwi​ 和 wjw_jwj​ 在值域上相邻且 iii 和 jjj 来自不同置换环的 (i,j)(i,j)(i,j)，注意到 ∣wi−wj∣|w_i-w_j|∣wi​−wj​∣ 一定是 111。这时交换 wiw_iwi​ 和 wjw_jwj​ 就可以以 222 的代价合并两个置换环。这样构造的答案是 2(c−1)2(c-1)2(c−1)，其中 ccc 是 www 的置换环个数。 容易证明这个是下界。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=205; int n,a[S]; int cnt,bel[S]; bool vis[S]; vector&lt;int&gt; vec[S]; pair&lt;int,int&gt; pri[S]; int b[S],nxt[S]; inline void slove() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i]; for(int i=1;i&lt;=n;i++) { cnt=0; for(int j=1;j&lt;=n;j++) vis[j]=false,vec[j].clear(); for(int j=1;j&lt;=n;j++) { if(!vis[j]) { vec[++cnt].push_back(j); bel[j]=cnt; vis[j]=true; j=a[j]; while(!vis[j]) { vec[cnt].push_back(j); bel[j]=cnt; vis[j]=true; j=a[j]; } } } for(int j=1;j&lt;=n;j++) pri[j]=make_pair(a[j],j); sort(pri+1,pri+n+1); for(int j=1;j&lt;=n-1;j++) { int x=pri[j].second,y=pri[j+1].second; if(bel[x]!=bel[y]) { swap(a[x],a[y]); swap(b[x],b[y]); break; } } } for(int i=1;i&lt;=n;i++) nxt[b[i]]=i; printf(&quot;%d &quot;,1); int u=nxt[1]; while(u!=1) { printf(&quot;%d &quot;,u); u=nxt[u]; } printf(&quot;\\n&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1685D1 Permutation Weight (Easy Version) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1685d1-permutation-weight-easy-version-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":182000,"words":569,"minutes":4},"date":"2023-04-15 16:59:41","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>你需要一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的有根树，节点编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,1,...,n-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 是根节点，且对于任何非根节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span>，它的父节点的标号 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">p(v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> 要比它的标号 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 要小。</p>\n<p>工厂里所有的树都是用竹子做的（可能不准确但不影响题意理解），这种竹子是有根的树，且每个节点只有一个子节点（除了叶子节点没有子节点），也就是说，它是直线形的。加工前，竹子的顶点可以随意标注。</p>\n<p>要加工竹子为一棵树，可以进行这样的操作：选择任意一个不是根节点且父节点也不是根节点的节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span>，将它的父节点变成原先父节点的父节点即 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>p</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">p(p(v))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，而其它节点的父节点都保持不变，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 的子树也不会改变。</p>\n<p>效率是至关重要的，所以在加工出所需要的树的前提下你应当最小化操作数。现在请你构造任何最优的操作序列以生成所需要的树</p>\n<p>注意：加工出的结果树的标签必须和所需要的树的标签一致，即根节点标签相同，其它所有具有相同标签的子节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span>，其父节点标签<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">p(v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span>也应相同。</p>\n<p>数据保证任何输入都至少有一种可行的方案，且最优操作序列最多包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span> 个操作。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 你需要一棵 nnn 个节点的有根树，节点编号为 [0,1,...,n−1][0,1,...,n-1][0,1,...,n−1]，其中 000 是根节点，且对于任何非根节点 vvv，它的父节点的标号 p(v)p(v)p(v) 要比它的标号 vvv 要小。 工厂里所有的树都是用竹子做的（可能不准确但不影响题意理解），这种竹子是有根的树，且每个节点只有一个子节点（除了叶子节点没有子节点），也就是说，它是直线形的。加工前，竹子的顶点可以随意标注。 要加工竹子为一棵树，可以进行这样的操作：选择任意一个不是根节点且父节点也不是根节点的节点 vvv，将它的父节点变成原先父节点的父节点即 p(p(v))p(p(v))p(p(v))，而其它节点的父节点都保持不变，vvv 的子树也不会改变。 效率是至关重要的，所以在加工出所需要的树的前提下你应当最小化操作数。现在请你构造任何最优的操作序列以生成所需要的树 注意：加工出的结果树的标签必须和所需要的树的标签一致，即根节点标签相同，其它所有具有相同标签的子节点 vvv，其父节点标签p(v)p(v)p(v)也应相同。 数据保证任何输入都至少有一种可行的方案，且最优操作序列最多包含 10610^6106 个操作。 2≤n≤1052\\le n\\le 10^52≤n≤105。 考虑时光倒流，把给定的树变成一条链。 显然答案下界是 n−树高n-\\text{树高}n−树高，因为每次操作最多让树高增加 111。 那么每次找到深度最浅的分叉，把最高的那个子树接到其它随便一个子树上即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=500005; int n,fat[S]; set&lt;int&gt; g[S]; int dep[S]; int tot,ans[S]; int cnt,a[S]; void dfs(int u) { dep[u]=0; for(int v:g[u]) { dfs(v); dep[u]=max(dep[u],dep[v]); } dep[u]++; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=2;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;fat[i]),fat[i]++; for(int i=2;i&lt;=n;i++) g[fat[i]].insert(i); dfs(1); int u=1; a[++cnt]=u; while(!g[u].empty()) { if(g[u].size()&gt;1) { int lst=0; for(int v:g[u]) if(dep[v]&gt;dep[lst]) lst=v; g[u].erase(lst); while(!g[u].empty()) { int v=*g[u].begin(); ans[++tot]=lst; g[u].erase(v); g[v].insert(lst); dep[v]=max(dep[v],dep[lst]+1); lst=v; } g[u].insert(lst); } u=*g[u].begin(); a[++cnt]=u; } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]-1); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;,tot); for(int i=tot;i&gt;=1;i--) printf(&quot;%d &quot;,ans[i]-1); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1225F Tree Factory 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1225f-tree-factory-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":193000,"words":721,"minutes":4},"date":"2023-04-15 16:55:51","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>有个  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的 DAG，你要加不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 条边，使得加完之后还是一个 DAG，并且 这个 DAG 的字典序最小拓扑序字典序最大。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m,k\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有个 nnn 个点 mmm 条边的 DAG，你要加不超过 kkk 条边，使得加完之后还是一个 DAG，并且 这个 DAG 的字典序最小拓扑序字典序最大。 1≤n,m,k≤1051\\le n,m,k\\le 10^51≤n,m,k≤105。 求出给定 DAG 的字典序最小拓扑序显然只需要把拓扑排序的队列换成小根堆，那么考虑贪心。 称原图拓扑排序所用的小根堆为 qqq，那么某一时刻若 qqq 中有 &gt;1&gt;1&gt;1 个点且加边的次数还没用完则可以通过加边来延后 qqq 中最小的点被删除的时间。设这个最小的点是 uuu，那么把 uuu 从 qqq 中删除，加入到一个大根堆 q2q2q2 中。注意到这样操作相当于是加了一条指向 uuu 的边。 当 qqq 中没有元素且 q2q2q2 中还有元素时，为了保证图还是 DAG 我们就不得不让 q2q2q2 中的某个点被删掉了，显然把 q2q2q2 中最大的点删掉是最优的。设这个点是 uuu，那么指向 uuu 的边一定是由当前拓扑序中最后一个点 vvv 连过来的，那么把边 v→uv\\to uv→u 加入答案序列中即可。 最后有一个细节，第一层一定要留一个点在 qqq 中，因为无法加边。以后的每一层，qqq 中还剩下一个点 uuu 时，若 q2q2q2 也非空，且最大的点为 vvv，并且还能加边，那么： u&gt;vu&gt;vu&gt;v 此时延后 uuu 被删除的时间是没有意义的，因为加入 q2q2q2 后它马上就会从 q2q2q2 中取出，所以直接顺其自然； u&lt;vu&lt;vu&lt;v 此时延后 uuu 被删除的时间显然是更优的，那么把 uuu 从 qqq 中删除，加入 q2q2q2； 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int S=100005; int n,m,k; set&lt;pair&lt;int,int&gt;&gt; st; vector&lt;int&gt; g[S]; int ind[S]; int cnt,a[S]; vector&lt;pair&lt;int,int&gt;&gt; ans; int main() { freopen(&quot;destroy.in&quot;,&quot;r&quot;,stdin); freopen(&quot;destroy.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(st.count(make_pair(x,y))) continue; st.insert(make_pair(x,y)); g[x].push_back(y); ind[y]++; } priority_queue&lt;int&gt; q,q2; for(int i=1;i&lt;=n;i++) if(ind[i]==0) q.push(-i); while(k&gt;0&amp;&amp;q.size()&gt;1) q2.push(-q.top()),q.pop(),k--; while(!q.empty()||!q2.empty()) { int u; if(!q.empty()) u=-q.top(),q.pop(); else { u=q2.top(); q2.pop(); ans.push_back(make_pair(a[cnt],u)); } a[++cnt]=u; for(int v:g[u]) { if(--ind[v]==0) q.push(-v); } while(k&gt;0&amp;&amp;q.size()&gt;1) q2.push(-q.top()),q.pop(),k--; if(k&gt;0&amp;&amp;!q.empty()&amp;&amp;!q2.empty()&amp;&amp;-q.top()&lt;q2.top()) { q2.push(-q.top()),q.pop(); k--; } } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;,ans.size()); for(pair&lt;int,int&gt; u:ans) { printf(&quot;%d %d\\n&quot;,u.first,u.second); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"【2023武汉集训模拟赛7】灭国 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023-wu-han-ji-xun-mo-ni-sai-7-mie-guo-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":220000,"words":772,"minutes":4},"date":"2023-04-15 16:54:14","dateFormat":"2023-04-15"},{"abstract":"","content":"值域树状数组求 k−thk-thk−th 这里以第 kkk 小为例。 首先不难发现一定会有 k−1k-1k−1 个数比第 kkk 小的数小，那么只需要找到最大的满足 [−inf⁡,pos][-\\inf,pos][−inf,pos] 中数的个数等于 k−1k-1k−1 的 pospospos，答案即为 pos+1pos+1pos+1。 考虑倍增求出 pospospos，显然由于树状数组维护的区间的长度是 222 的次幂，所以可以从大往小枚举 222 的次幂 2p2^p2p 并尝试加上这段区间。 具体实现 inline int kth(int k) // 这里假设值域 [1,n] { k--; int pos=0,sum=0; for(int j=20;j&gt;=0;j--) // 需要保证 2^j&gt;=n { if(pos+(1&lt;&lt;j)&lt;=n&amp;&amp;sum+tr[pos+(1&lt;&lt;j)]&lt;=k) { sum+=tr[pos+(1&lt;&lt;j)]; pos+=1&lt;&lt;j; } } if(sum!=k-1) { return -1; // 没有 } return pos+1&gt;n?-1:pos+1; // pos+1&gt;n 也是没有的情况 } 值域倍增分块 经常用于解决把所有 ai&gt;xa_i&gt; xai​&gt;x 的 aia_iai​ 减去 xxx 之类的东西。 例题：P7447 [Ynoi2007] rgxsxrs 题解 把值域分成 [2k,2k+1)[2^k,2^{k+1})[2k,2k+1) 这样的 log⁡\\loglog 个块，那么每次修改就找到 xxx 所在的块 [2y,2y+1)[2^y,2^{y+1})[2y,2y+1)： 对于所有满足 z&gt;yz&gt;yz&gt;y 的 [2z,2z+1)[2^z,2^{z+1})[2z,2z+1)：这些块将会集体减掉 xxx，那么维护每一块的最小值，暴力让该跌落的值跌落到更低的块； 对于所有满足 z&lt;yz&lt;yz&lt;y 的 [2z,2z+1)[2^z,2^{z+1})[2z,2z+1)：这些块没有任何改变； 对于 [2y,2y+1)[2^y,2^{y+1})[2y,2y+1)：这一块中所有满足 ai&gt;xa_i&gt;xai​&gt;x 的 aia_iai​ 都会跌落到更低的块，那么维护块内最大值暴力让该跌落的值跌落； 由于每个数最多只会跌落 log⁡V\\log VlogV 次，所以时间复杂度为 O(mlog⁡Vlog⁡n+nlog⁡V)O(m\\log V\\log n+n\\log V)O(mlogVlogn+nlogV)。 更多例题： CF702F T-Shirts CF1515I Phoenix and Diamonds P4587 [FJOI2016]神秘数 LOJ3527 地牢游戏 减半报警器 用于解决类似这样的问题： 维护一个数据结构，刚开始给了一些范围，每个范围有对应的权值。每次把包含一个点的范围的权值减去 xxx，维护每个范围的权值最早被减完的时刻。 例题：Codeforces GYM 102452I 有 nnn 个国家，每个国家有权值 wiw_iwi​ 和若干个（≤3\\le 3≤3）观测点。有 qqq 次操作，每次会将所有能观测到 xxx 的国家的 wiw_iwi​ 减去 yyy。你要求出每个国家的权值第一次被减完是在第几次操作。 题解 观测点个数为 111 的情况是最简单的，直接把 wiw_iwi​ 挂到观测点上即可； 观测点个数为 222 比较复杂，设这两个观测点为 xxx 和 yyy，把 ⌈wi2⌉\\lceil\\frac{w_i}{2}\\rceil⌈2wi​​⌉ 挂到 xxx 上，⌈wi2⌉\\lceil\\frac{w_i}{2}\\rceil⌈2wi​​⌉ 挂到 yyy 上。这样两边都没减完则 wiw_iwi​ 一定没被减完，有一边被减完则判一下 wiw_iwi​ 是否被减完，若没减完则重新平均分配。注意到每次 wiw_iwi​ 至少减半，所以最多重新分配 log⁡V\\log VlogV 次，均摊时间复杂度 O(nlog⁡V)O(n\\log V)O(nlogV)； 观测点个数 333 的情况和观测点个数为 222 的情况一样，只需要把 wiw_iwi​ 平均分成三份，注意到每次重新分配会让 wiw_iwi​ 变成原来的 23\\frac{2}{3}32​，那么均摊时间复杂度为 O(nlog⁡1.5V)O(n\\log_{1.5}V)O(nlog1.5​V)。 每次操作的时间复杂度为 O(log⁡n)O(\\log n)O(logn)，那么总时间复杂度即为 O(qlog⁡n+nlog⁡1.5V)O(q\\log n+n\\log_{1.5}V)O(qlogn+nlog1.5​V)。 注意挂的一定是向上取整的值，否则会出现 (1,0,0)(1,0,0)(1,0,0) 这种尴尬情况。 例题 2：Codeforces GYM 104065B 你要邀请 nnn 个人来参加会议，一个人同意参加当且仅当已经有至少 kik_iki​ 个编号在 [li,ri][l_i,r_i][li​,ri​] 内的人来参加，问最多能有多少个人参加。 也就是说你要确定一个邀请人的顺序。 题解 转换后的题意相当于给定了 mmm 个区间，第 iii 个区间的权值为 kik_iki​，你需要动态维护这样的过程： 找到 ki≤0k_i\\le 0ki​≤0 的某个区间 iii； 把它删掉，答案加一，同时将所有包含 iii 的区间的 kik_iki​ 都减去 111； 考虑所有区间都包含某个位置 ppp 的特殊情况，那么每个区间都可以被分成 [li,p][l_i,p][li​,p] 和 [p+1,ri][p+1,r_i][p+1,ri​] 两段。可以把 kik_iki​ 平均分到这两段上，每一次修改操作相当于找到左边的一个后缀或者右边的一个前缀减掉 111。 这样若一个区间的某一边被减完了则重新分配剩下的 kik_iki​，每次至少减半，均摊时间复杂度为 O(nlog⁡V)O(n\\log V)O(nlogV)。 用线段树动态维护这个东西，每次区间减，暴力找到需要重构的区间编号即可。 若所有区间没有包含共同的位置，那么可以把区间分成三类： 包含 ⌊n2⌋\\lfloor\\frac{n}{2}\\rfloor⌊2n​⌋ 的； 在 ⌊n2⌋\\lfloor\\frac{n}{2}\\rfloor⌊2n​⌋ 左边的； 在 ⌊n2⌋\\lfloor\\frac{n}{2}\\rfloor⌊2n​⌋ 右边的； 这是一个类似线段树的结构，那么分治下去，每次修改都不断往 xxx 的方向走，改一下包含当前分治中心 midmidmid 的区间。 一次修改会分治 O(log⁡n)O(\\log n)O(logn) 次，每次分治的时间复杂度为 O(log⁡n)O(\\log n)O(logn)，那么总的时间复杂度即为 O(nlog⁡2n+nlog⁡V)O(n\\log^2n+n\\log V)O(nlog2n+nlogV)。 更多例题： P7603 [THUPC2021] 鬼街 Codeforces GYM 102331F 支配 xxx 满足的条件包含 yyy 满足的条件，并且 xxx 的值比 yyy 的优，那么 yyy 就没有存在的必要了。 ——《单调队列》 关于距离的支配 序列上 CF765F Souvenirs / CF1793F Rebrending 题解 CF 自己抄自己，两道题一模一样。 先假设只有 i&lt;ji&lt;ji&lt;j 且 ai&lt;aja_i&lt;a_jai​&lt;aj​ 的 (i,j)(i,j)(i,j) 有贡献，另一种取值再跑一次即可。 注意到若 (i1,j1)(i1,j1)(i1,j1) 和 (i2,j2)(i2,j2)(i2,j2)（i1&lt;j2i1&lt;j2i1&lt;j2，i2&lt;j2i2&lt;j2i2&lt;j2）若满足 ai1−aj1≤ai2−aj2a_{i1}-a_{j1}\\le a_{i2}-a_{j2}ai1​−aj1​≤ai2​−aj2​ 且 i1≥i2i1\\ge i2i1≥i2，j1≤j2j1\\le j2j1≤j2 则(i2,j2)(i2,j2)(i2,j2) 被 (i1,j1)(i1,j1)(i1,j1) 完全包含了，即 (i1,j1)(i1,j1)(i1,j1) 支配了 (i2,j2)(i2,j2)(i2,j2)，所以只用统计 (i1,j1)(i1,j1)(i1,j1) 的贡献。 固定 iii，考虑找到所有有用的 jjj。设 Si={j∣(i,j) 未被支配}S_i=\\{j|(i,j)\\text{ 未被支配}\\}Si​={j∣(i,j) 未被支配}，考虑增量求解 SiS_iSi​，设 p=max⁡{j∣j∈Si}p=\\max\\{j|j\\in S_i\\}p=max{j∣j∈Si​}，那么 kkk（k&gt;pk&gt;pk&gt;p）想要加入 SiS_iSi​ 就必须满足： ak−ai&lt;ap−ai⇒ak&lt;apa_k-a_i&lt;a_p-a_i\\Rightarrow a_k&lt;a_pak​−ai​&lt;ap​−ai​⇒ak​&lt;ap​； ak−ai&lt;∣ap−ak∣⇒ak−ai&lt;ap−ak⇒ak&lt;ap+ai2a_k-a_i&lt;|a_p-a_k|\\Rightarrow a_k-a_i&lt;a_p-a_k\\Rightarrow a_k&lt;\\frac{a_p+a_i}{2}ak​−ai​&lt;∣ap​−ak​∣⇒ak​−ai​&lt;ap​−ak​⇒ak​&lt;2ap​+ai​​； 所以 ∣Si∣|S_i|∣Si​∣ 是 log⁡V\\log VlogV 级别的，那么未被支配的 (i,j)(i,j)(i,j) 也就只有 nlog⁡Vn\\log VnlogV 个。 接下来就变成二维数点问题了，扫描线即可，时间复杂度 O((q+nlog⁡V)log⁡n)O((q+n\\log V)\\log n)O((q+nlogV)logn)。 树上 P9058 [Ynoi2004] rpmtdq 题解 考虑点分治，对于来自分治中心 rtrtrt 不同两个子树中的两个点 x,yx,yx,y，显然有 dis⁡(x,y)=dis⁡(x,rt)+dis⁡(y,rt)\\operatorname{dis}(x,y)=\\operatorname{dis}(x,rt)+\\operatorname{dis}(y,rt)dis(x,y)=dis(x,rt)+dis(y,rt)。 那么不妨设 au=dis⁡(u,rt)a_u=\\operatorname{dis}(u,rt)au​=dis(u,rt)，显然点对 (i,j)(i,j)(i,j)（i&lt;ji&lt;ji&lt;j）未被支配当且仅当对于所有 i&lt;k&lt;ji&lt;k&lt;ji&lt;k&lt;j 都有 ai+aj&lt;ai+aka_i+a_j&lt;a_i+a_kai​+aj​&lt;ai​+ak​ 且 ai+aj&lt;ak+aja_i+a_j&lt;a_k+a_jai​+aj​&lt;ak​+aj​。稍加化简可得 ai&lt;ak,aj&lt;aka_i&lt;a_k,a_j&lt;a_kai​&lt;ak​,aj​&lt;ak​，max⁡(ai,aj)&lt;ak\\max(a_i,a_j)&lt;a_kmax(ai​,aj​)&lt;ak​，那么只有 aia_iai​ 的前驱后继会和 iii 构成支配，所以每层分治每个点只会组成 O(1)O(1)O(1) 个支配对，那么总支配对个数是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。 接下来就变成二维数点问题了，扫描线即可，时间复杂度 O((q+nlog⁡V)log⁡n)O((q+n\\log V)\\log n)O((q+nlogV)logn)。 一些特殊的支配 Mex 支配 对于一个长度为 nnn 的序列 aaa，设 bl,r=mexl≤i≤r{ai}b_{l,r}=\\text{mex}_{l\\le i\\le r}\\{a_i\\}bl,r​=mexl≤i≤r​{ai​}，有性质： bl,r≥bl+1,rb_{l,r}\\ge b_{l+1,r}bl,r​≥bl+1,r​，证明显然； b∗,r→b∗,r+1b_{*,r}\\to b_{*,r+1}b∗,r​→b∗,r+1​ 相当于把所有 bi,r=ar+1b_{i,r}=a_{r+1}bi,r​=ar+1​ 的 bi,rb_{i,r}bi,r​ 都修改为大于 ar+1a_{r+1}ar+1​ 的数，由第一个性质，需要被修改的 iii 一定是在一个区间内，所以根据颜色段均摊的经典结论，所有 rrr 造成的总修改数是 O(n)O(n)O(n) 级别的； 满足不存在 [l′,r′]⊂[l,r],bl′,r′=bl,r[l&#x27;,r&#x27;]\\subset [l,r],b_{l&#x27;,r&#x27;}=b_{l,r}[l′,r′]⊂[l,r],bl′,r′​=bl,r​ 的区间 [l,r][l,r][l,r] 个数最多有 2n2n2n 个。 证明 对于每个满足条件的 [l,r][l,r][l,r]，显然 al=ara_l\\not=a_ral​​=ar​，不妨假定 al&gt;ara_l&gt;a_ral​&gt;ar​（另一种情况对称）。 现在来证明对于每个 lll，都只有一个 rrr 满足 r&gt;l,al&gt;arr&gt;l,a_l&gt;a_rr&gt;l,al​&gt;ar​ 且 [l,r][l,r][l,r] 满足条件。 考虑反证，设存在 l&lt;r1&lt;r2l&lt;r1&lt;r2l&lt;r1&lt;r2 满足 al&gt;ar1,al&gt;ar2a_l&gt;a_{r1},a_l&gt;a_{r2}al​&gt;ar1​,al​&gt;ar2​ 且 [l,r1][l,r1][l,r1] 与 [l,r2][l,r2][l,r2] 均满足条件。显然由于 [l,r1][l,r1][l,r1] 满足条件，一定有 bl,r1&gt;alb_{l,r1}&gt;a_lbl,r1​&gt;al​。由于 al&gt;ar2a_l&gt;a_{r2}al​&gt;ar2​，所以有 bl,r1&gt;ar2b_{l,r1}&gt;a_{r2}bl,r1​&gt;ar2​，那么显然 [l,r2−1]⊂[l,r2][l,r2-1]\\sub [l,r2][l,r2−1]⊂[l,r2] 且 bl,r2=bl,r2−1b_{l,r2}=b_{l,r2-1}bl,r2​=bl,r2−1​，所以 [l,r2][l,r2][l,r2] 不满足条件，矛盾。 那么对于每个位置 iii，它作为 ala_{l}al​ 和 ara_rar​ 中最小值时最多有一个合法区间，作为最大值时也最多有一个合法区间，所以合法区间个数最多有 2n2n2n 个。 Q.E.D. 更多例题 P8528 [Ynoi2003] 铃原露露 P9060 [Ynoi2002] Goedel Machine 三维计数技巧 对于满足某些条件的有序三元组 (i,j,k)(i,j,k)(i,j,k) 且固定 kkk 和 jjj 后合法的 iii 在一段区间内时，可以考虑枚举 kkk 同时维护每个 jjj 对应的 iii 的合法区间 [lj,rj][l_j,r_j][lj​,rj​]。 例题：Nasty Donchik 题意：给定序列 a1,a2,…,ana_1,a_2,\\dots,a_na1​,a2​,…,an​，求有多少有序三元组 (i,j,k)(i,j,k)(i,j,k) 满足 i≤j&lt;ki\\le j&lt;ki≤j&lt;k 且 a[i,j]a_{[i,j]}a[i,j]​ 中出现的数集以及 a[j+1,k]a_{[j+1,k]}a[j+1,k]​ 中出现的数放入两个不可重集后两个集合相等。 题解 固定 kkk 和 jjj 后显然 iii 是在一个区间内的，考虑维护 lpl_plp​ 和 rpr_prp​ 表示 j=pj=pj=p 时 iii 的上界和下界减一，则固定 kkk 后的答案即为 ∑j=1k−1max⁡(rj−lj,0)\\sum\\limits_{j=1}^{k-1}\\max(r_j-l_j,0)j=1∑k−1​max(rj​−lj​,0)。那么设 Li=max⁡{j∣j&lt;i,aj=ai},Ri=min⁡{j∣j&gt;i,aj=ai}L_i=\\max\\{j|j&lt;i,a_j=a_i\\},R_i=\\min\\{j|j&gt;i,a_j=a_i\\}Li​=max{j∣j&lt;i,aj​=ai​},Ri​=min{j∣j&gt;i,aj​=ai​}，则有 lj=max⁡{i∣i≤j,Ri&gt;k},rj=min⁡{Li∣j&lt;i≤k}l_j=\\max\\{i|i\\le j,R_i&gt;k\\},r_j=\\min\\{L_i|j&lt;i\\le k\\}lj​=max{i∣i≤j,Ri​&gt;k},rj​=min{Li​∣j&lt;i≤k}。 考虑 k→k+1k\\to k+1k→k+1 后对 ljl_jlj​ 和 rjr_jrj​ 的影响，注意到 ljl_jlj​ 单调递增且 rjr_jrj​ 单调递增，而 k→k+1k\\to k+1k→k+1 对 ljl_jlj​ 的影响是删去了 Ri=k+1R_i=k+1Ri​=k+1 的元素，体现为后缀取 min⁡\\minmin 即区间赋值；对 rjr_jrj​ 的影响则是加入了 Lk+1L_{k+1}Lk+1​，也体现为后缀取 min⁡\\minmin 即区间赋值。注意到由于两个东西都是单调递增的，所以可以用线段树来维护。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 更多例题： GYM102900J Octasection 区间修改区间历史和线段树 考虑给线段树上每个点维护一个一次函数 f(x)=kx+bf(x)=kx+bf(x)=kx+b，f(x)f(x)f(x) 为 xxx 时的历史和。 单点修改区间查询是好做的，找到要修改的点，设在时刻 yyy 结束后要修改为 k′k&#x27;k′，那么把那个点的一次函数修改为 f(x)=k′x+y(k−k′)+bf(x)=k&#x27;x+y(k-k&#x27;)+bf(x)=k′x+y(k−k′)+b 即可。 区间修改区间查询分为两种情况： 区间加区间查询：很好做，给 kkk 和 bbb 打 tag 即可； 区间赋值区间查询： 注意到此时区间内 kkk 不同则无法一起修改，那么维护区间 kkk 最小值 mnkmnkmnk 和最大值 mxkmxkmxk。对于一个需要被修改的区间，若 mnk=mxkmnk\\not=mxkmnk​=mxk 则递归左右儿子修改，否则直接打 tag 修改。 这样做时间复杂度均摊是 O(n+qlog⁡n)O(n+q\\log n)O(n+qlogn) 的，其中 nnn 为序列长度，qqq 为操作数。因为刚开始最多有 nnn 个区间需要额外往下递归，每次修改最多会让 log⁡n\\log nlogn 个区间在以后的修改中需要额外往下递归，所以总共需要额外往下递归的区间是 O(n+qlog⁡n)O(n+q\\log n)O(n+qlogn) 的； 例题： 【2022NOI模拟赛01】漏网之鱼 CF1824D LuoTianyi and the Function 双栈 可用于 O(n)O(n)O(n) 维护滑动窗口的不可减信息。 这里以窗口长度为 kkk，维护后缀最大值的位置（比 [j+1,i][j+1,i][j+1,i] 中的所有数都大的位置）的 dp 值的最大值为例。 维护底对底的两个单调栈： 两个栈都维护每个元素到栈底之间所有元素的 dp 值的最大值。 后面的栈像普通单调栈一样正常插入删除，前面的栈若栈顶超出了窗口范围则删除栈顶。 若某一个栈空了则重构，把另一个栈的所有元素拿出来，把一半放入原来为空的栈。 这样做的时间复杂度是 O(n)O(n)O(n) 的，考虑每次重构都是某一边被删空了才会进行，设重构后左边的栈有 kkk 个元素，则本次重构时间复杂度为 O(k)O(k)O(k)，而若要进行下一次重构，则一定会执行 O(k)O(k)O(k) 次删除操作，所以重构的时间复杂度和删除的时间复杂度是一样的，均为 O(n)O(n)O(n)。 例题： 【2023成都集训模拟赛04】op set 维护连续段 颜色段均摊若用线段树维护则会把一个连续段拆成 log⁡\\loglog 个，总连续段个数变为 O(nlog⁡n)O(n\\log n)O(nlogn)。 而用 set 维护则总连续段个数是 O(n)O(n)O(n) 的，并且很好写。 代码如下： struct seg { int l,r,x; inline bool operator&lt;(const seg &amp;b)const{return l&lt;b.l;} }; typedef set&lt;seg&gt;::iterator iter; set&lt;seg&gt; st; inline iter split(int p) { iter x=st.lower_bound((seg){p,0,0}); if(x!=st.end()&amp;&amp;x-&gt;l==p) return x; x--; seg vx=*x; st.erase(x); st.insert((seg){vx.l,p-1,vx.x}); return st.insert((seg){p,vx.r,vx.x}).first; } inline void ins(int lb,int rb,int x) { split(lb); iter l,r=prev(split(rb+1)); l=st.lower_bound((seg){lb,0,0}); iter pr=l,ed=next(r); while(pr!=ed) { // a_{[pr-&gt;l,pr-&gt;r]} = x st.erase(pr++); } st.insert((seg){lb,rb,p}); } ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"一些数据结构技巧","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/yi-xie-shu-ju-jie-gou-ji-qiao/","stats":{"text":"20 min read","time":1143000,"words":4207,"minutes":20},"date":"2023-04-15 16:52:12","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人，最开始每个人手中有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 颗绿宝石，每天晚上，会随机选一个绿宝石分裂为两个。</p>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span> 个晚上后绿宝石数量最多的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个人的绿宝石数和的期望值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>d</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le n,d \\le 500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le r\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个人，最开始每个人手中有 111 颗绿宝石，每天晚上，会随机选一个绿宝石分裂为两个。 求 ddd 个晚上后绿宝石数量最多的 rrr 个人的绿宝石数和的期望值。 1≤n,d≤5001 \\le n,d \\le 5001≤n,d≤500，1≤r≤n1 \\le r\\le n1≤r≤n。 设 dpi,jdp_{i,j}dpi,j​ 表示把 jjj 划分成 iii 个有标号非负整数相加的方案数，转移考虑枚举 ≥1\\ge 1≥1 的数的个数： dpi,j=∑k=1min⁡(i,j)(ik)dpk,j−kdp_{i,j}=\\sum\\limits_{k=1}^{\\min(i,j)}\\binom{i}{k}dp_{k,j-k} dpi,j​=k=1∑min(i,j)​(ki​)dpk,j−k​ 设 pdi,jpd_{i,j}pdi,j​ 表示把 jjj 划分成 iii个有标号非负整数相加的所有方案中前 rrr 大的数的和，转移类似： pdi,j=∑k=1min⁡(i,j)(ik)(pdk,j−k+min⁡(k,r)×dpk,j−k)pd_{i,j}=\\sum\\limits_{k=1}^{\\min(i,j)}\\binom{i}{k}(pd_{k,j-k}+\\min(k,r)\\times dp_{k,j-k}) pdi,j​=k=1∑min(i,j)​(ki​)(pdk,j−k​+min(k,r)×dpk,j−k​) 最后答案即为 pdn,d+rdpn,d\\frac{pd_{n,d}+r}{dp_{n,d}}dpn,d​pdn,d​+r​，由于神秘原因，所以开 long double 即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=505; int n,d,r; long double C[S][S],dp[S][S],pd[S][S]; int main() { for(int i=0;i&lt;=S-3;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1]; } scanf(&quot;%d%d%d&quot;,&amp;n,&amp;d,&amp;r); dp[0][0]=1; for(int i=1;i&lt;=n;i++) { dp[i][0]=1; for(int j=1;j&lt;=d;j++) { for(int k=1;k&lt;=i&amp;&amp;k&lt;=j;k++) { dp[i][j]+=C[i][k]*dp[k][j-k]; pd[i][j]+=C[i][k]*(pd[k][j-k]+min(k,r)*dp[k][j-k]); } } } printf(&quot;%Lf\\n&quot;,pd[n][d]/dp[n][d]+r); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P6944 [ICPC2018 WF]Gem Island 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p6944-icpc2018-wfgem-island-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":147000,"words":460,"minutes":3},"date":"2023-04-15 16:49:30","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>有一段长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 的线段，有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个区间，左右端点在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">[0,l)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">)</span></span></span></span> 间均匀随机（可能不是整数）</p>\n<p>求期望被至少 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 段区间覆盖的长度，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取膜。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">1\\leq k \\leq n \\leq 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\leq l\\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一段长为 lll 的线段，有 nnn 个区间，左右端点在 [0,l)[0,l)[0,l) 间均匀随机（可能不是整数） 求期望被至少 kkk 段区间覆盖的长度，对 998244353998244353998244353 取膜。 1≤k≤n≤20001\\leq k \\leq n \\leq 20001≤k≤n≤2000，1≤l≤1091\\leq l\\leq 10^91≤l≤109。 首先显然问题与值域 [0,1][0,1][0,1] 是等价的，因为期望是线性的，可以乘上 lll，并且实数闭区间和开区间是等价的。 设 f(x)f(x)f(x) 为 xxx 这个位置被覆盖至少 kkk 次的概率，那么答案即为 ∫01f(x)dx\\int_0^1f(x)dx∫01​f(x)dx。 考虑一个转化，设 XXX 是一个 [0,1][0,1][0,1] 中的随机变量，那么 XXX 被覆盖至少 kkk 次的概率就是 ∫01f(x)dx1=∫01f(x)dx\\frac{\\int_0^1f(x)dx}{1}=\\int_0^1f(x)dx1∫01​f(x)dx​=∫01​f(x)dx 即答案。所以问题变成求 [0,1][0,1][0,1] 中随机一个位置被覆盖至少 kkk 次的概率。 不难发现，由于是实数，所以我们并不关心 XXX 和区间端点的具体取值，只关心它们的相对位置。那么把这 2n+12n+12n+1 个位置拉出来，区间左端点看作左括号，区间右端点看作右括号，设 dpi,j,0/1dp_{i,j,0/1}dpi,j,0/1​ 表示考虑完前 iii 个位置，有 jjj 个左括号未匹配，没放/放 XXX 的方案数。那么有转移： {dpi,j,f→dpi+1,j+1,fj×dpi,j,f→dpi+1,j−1,fj&gt;0dpi,j,f→dpi+1,j,1j≥k,f=0\\begin{cases}dp_{i,j,f}\\to dp_{i+1,j+1,f}\\\\j\\times dp_{i,j,f}\\to dp_{i+1,j-1,f}&amp;j&gt;0\\\\ dp_{i,j,f}\\to dp_{i+1,j,1}&amp;j\\ge k,f=0\\end{cases} ⎩⎪⎨⎪⎧​dpi,j,f​→dpi+1,j+1,f​j×dpi,j,f​→dpi+1,j−1,f​dpi,j,f​→dpi+1,j,1​​j&gt;0j≥k,f=0​ dp2n+1,0,1dp_{2n+1,0,1}dp2n+1,0,1​ 除掉总的方案数即为要求的 ∫01f(x)dx\\int_0^1f(x)dx∫01​f(x)dx，这个东西乘上 lll 就是答案。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int S=2005,p=998244353; int n,k,l; int dp[2][S*2][2],pd[2][S*2]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;l); dp[0][0][0]=pd[0][0]=1; for(int i=0;i&lt;=n*2;i++) { int u=i&amp;1,v=i+1&amp;1; memset(dp[v],0,sizeof(dp[v])); memset(pd[v],0,sizeof(pd[v])); for(int j=0;j&lt;=i;j++) { for(int f=0;f&lt;=1;f++) { if(dp[u][j][f]==0) continue; add(dp[v][j+1][f],dp[u][j][f]); if(j&gt;0) add(dp[v][j-1][f],1ll*dp[u][j][f]*j%p); if(j&gt;=k&amp;&amp;f==0) add(dp[v][j][1],dp[u][j][f]); } add(pd[v][j+1],pd[u][j]); if(j&gt;0) add(pd[v][j-1],1ll*pd[u][j]*j%p); } } // printf(&quot;%d / %d\\n&quot;,dp[n*2+1&amp;1][0][1],1ll*pd[n*2&amp;1][0]*(n*2+1)%p); printf(&quot;%d\\n&quot;,1ll*dp[n*2+1&amp;1][0][1]*qpow(1ll*pd[n*2&amp;1][0]*(n*2+1)%p,p-2)%p*l%p); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1153F Serval and Bonus Problem 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1153f-serval-and-bonus-problem-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":257000,"words":820,"minutes":5},"date":"2023-04-15 16:45:52","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给两个包含 <code>A</code>,<code>B</code>,<code>?</code> 的串，<code>?</code> 可以填 <code>A</code> 或 <code>B</code>，求所有情况下下面这个东西的和，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模：</p>\n<ul>\n<li>统计有多少对长度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(S,T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span> 使得把所有 <code>A</code> 换成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，<code>B</code> 换成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 后两个串相等；</li>\n</ul>\n<p>两个串的长度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。<br>\n为了方便，设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∣</mi><mi>b</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">|a|=n,|b|=m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">a</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">b</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，原来的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 设为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n</blockquote>\n","content":" 给两个包含 A,B,? 的串，? 可以填 A 或 B，求所有情况下下面这个东西的和，对 109+710^9+7109+7 取模： 统计有多少对长度 ≤n\\le n≤n 的 010101 串 (S,T)(S,T)(S,T) 使得把所有 A 换成 SSS，B 换成 TTT 后两个串相等； 两个串的长度 ≤3×105\\le 3\\times 10^5≤3×105。 为了方便，设 ∣a∣=n,∣b∣=m|a|=n,|b|=m∣a∣=n,∣b∣=m，原来的 nnn 设为 kkk。 首先有： 那么 sss 和 ttt 一定是由一个小串 ccc 不断重复得到的，其中 ∣c∣=gcd⁡(∣s∣,∣t∣)|c|=\\gcd(|s|,|t|)∣c∣=gcd(∣s∣,∣t∣)。 先不管问号，设 aaa 中的 A 比 bbb 中的 A 多 xxx 个，bbb 中的 B 比 aaa 中的 B 多 yyy 个，那么显然有限制 x×∣s∣=y×∣t∣x\\times |s|=y\\times |t|x×∣s∣=y×∣t∣。显然若 xxx 和 yyy 异号则无解，否则可以让 xxx 和 yyy 都取绝对值。接下来分类讨论： x=y=0x=y=0x=y=0： 此时 ∣s∣|s|∣s∣ 和 ∣t∣|t|∣t∣ 可以取任意值，那么答案为： ∑i=1k∑j=1k2gcd⁡(i,j)=∑d=1k2d∑i=1⌊kd⌋∑j=1⌊kd⌋[gcd⁡(i,j)=1]=∑d=1k2d∑i=1⌊kd⌋μ(i)(⌊kdi⌋)2\\begin{aligned} &amp;\\sum\\limits_{i=1}^k\\sum\\limits_{j=1}^k2^{\\gcd(i,j)}\\\\ &amp;=\\sum\\limits_{d=1}^{k}2^d\\sum\\limits_{i=1}^{\\lfloor\\frac{k}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{k}{d}\\rfloor}[\\gcd(i,j)=1]\\\\ &amp;=\\sum\\limits_{d=1}^{k}2^d\\sum\\limits_{i=1}^{\\lfloor\\frac{k}{d}\\rfloor}\\mu(i)\\left(\\left\\lfloor\\frac{k}{di}\\right\\rfloor\\right)^2 \\end{aligned} ​i=1∑k​j=1∑k​2gcd(i,j)=d=1∑k​2di=1∑⌊dk​⌋​j=1∑⌊dk​⌋​[gcd(i,j)=1]=d=1∑k​2di=1∑⌊dk​⌋​μ(i)(⌊dik​⌋)2​ 直接整除分块，时间复杂度 O(k)O(k)O(k)。 x=0x=0x=0 且 y=0y\\not=0y​=0 或 x=0x\\not=0x​=0 且 y=0y=0y=0：方程无解。 x&gt;0,y&gt;0x&gt;0,y&gt;0x&gt;0,y&gt;0： 若 xxx 和 yyy 不互质则可以同时除掉 gcd⁡(x,y)\\gcd(x,y)gcd(x,y)，方程显然仍然成立，所以下面默认 xxx 和 yyy 互质。 因为 xxx 和 yyy 互质，所以有 ∣s∣=y×w,∣t∣=x×w|s|=y\\times w,|t|=x\\times w∣s∣=y×w,∣t∣=x×w，www 的取值范围是 [1,⌊ky⌋]∩[1,⌊kx⌋]=[1,⌊kmax⁡(x,y)⌋][1,\\lfloor\\frac{k}{y}\\rfloor]\\cap[1,\\lfloor\\frac{k}{x}\\rfloor]=[1,\\lfloor\\frac{k}{\\max(x,y)}\\rfloor][1,⌊yk​⌋]∩[1,⌊xk​⌋]=[1,⌊max(x,y)k​⌋]，答案即为 ∑i=1⌊kmax⁡(x,y)⌋2i\\sum\\limits_{i=1}^{\\lfloor\\frac{k}{\\max(x,y)}\\rfloor}2^ii=1∑⌊max(x,y)k​⌋​2i。 现在考虑有问号的情况，先设 x,yx,yx,y 的答案为 f(x,y)f(x,y)f(x,y)，设 aaa 原来有 aaaaaa 个 A，ababab 个 B，aqaqaq 个 ?，bbb 原来有 bababa 个 A，bbbbbb 个 B，bqbqbq 个 ? 那么有： ans=∑i=0aq∑j=0bq(aqi)(bqj)f(aa+i−ba−j,bb+bq−j−ab−aq+i)=∑i=−bqaqf(aa−ba+i,m−ba−n+aa+i)∑j=0bq(bqj)(aqi+j)=∑i=−bqaqf(aa−ba+i,m−ba−n+aa+i)∑j=0bq(bqj)(aqaq−i−j)=∑i=−bqaqf(aa−ba+i,m−ba−n+aa+i)(bq+aqaq−i)\\begin{aligned} ans&amp;=\\sum\\limits_{i=0}^{aq}\\sum\\limits_{j=0}^{bq}\\binom{aq}{i}\\binom{bq}{j}f(aa+i-ba-j,bb+bq-j-ab-aq+i)\\\\ &amp;=\\sum\\limits_{i=-bq}^{aq}f(aa-ba+i,m-ba-n+aa+i)\\sum\\limits_{j=0}^{bq}\\binom{bq}{j}\\binom{aq}{i+j}\\\\ &amp;=\\sum\\limits_{i=-bq}^{aq}f(aa-ba+i,m-ba-n+aa+i)\\sum\\limits_{j=0}^{bq}\\binom{bq}{j}\\binom{aq}{aq-i-j}\\\\ &amp;=\\sum\\limits_{i=-bq}^{aq}f(aa-ba+i,m-ba-n+aa+i)\\binom{bq+aq}{aq-i}\\\\ \\end{aligned} ans​=i=0∑aq​j=0∑bq​(iaq​)(jbq​)f(aa+i−ba−j,bb+bq−j−ab−aq+i)=i=−bq∑aq​f(aa−ba+i,m−ba−n+aa+i)j=0∑bq​(jbq​)(i+jaq​)=i=−bq∑aq​f(aa−ba+i,m−ba−n+aa+i)j=0∑bq​(jbq​)(aq−i−jaq​)=i=−bq∑aq​f(aa−ba+i,m−ba−n+aa+i)(aq−ibq+aq​)​ f(0,0)f(0,0)f(0,0) 单独算一下，其他的 fff 均可 O(1)O(1)O(1) 算出，那么时间复杂度 O(n)O(n)O(n)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int S=2000005,p=1000000007; int n,m,k; char a[S],b[S]; int aa,ab,aq,ba,bb,bq; bool nop[S]; int tot,prime[S]; int mu[S],sum[S]; int fra[S],inv[S]; int _2sum[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } inline int gcd(int x,int y) { int t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } inline int g(int n) { int res=0; for(int l=1;l&lt;=n;l++) { int r=min(n,n/(n/l)); int val=((long long)sum[r]-sum[l-1]+p)%p; res=(res+1ll*val*(n/l)%p*(n/l)%p)%p; l=r; } return res; } inline int f(int x,int y) { if(x==0&amp;&amp;y==0) { int res=0; for(int l=1;l&lt;=k;l++) { int r=min(k,k/(k/l)); int val=((long long)_2sum[r]-_2sum[l-1]+p)%p; res=(res+1ll*val*g(k/l)%p)%p; l=r; } return res; } else { int g=gcd(x,y); x/=g,y/=g; return ((long long)_2sum[k/max(x,y)]-_2sum[0]+p)%p; } } int main() { scanf(&quot;%s%s%d&quot;,a+1,b+1,&amp;k); n=strlen(a+1),m=strlen(b+1); for(int i=1;i&lt;=n;i++) { aa+=a[i]=='A'; ab+=a[i]=='B'; aq+=a[i]=='?'; } for(int i=1;i&lt;=m;i++) { ba+=b[i]=='A'; bb+=b[i]=='B'; bq+=b[i]=='?'; } nop[0]=nop[1]=true; mu[1]=1; for(int i=2;i&lt;=S-3;i++) { if(!nop[i]) { prime[++tot]=i; mu[i]=-1; } for(int j=1;j&lt;=tot;j++) { if(i*prime[j]&gt;S-3) break; nop[i*prime[j]]=true; mu[i*prime[j]]=mu[i]*mu[prime[j]]; if(i%prime[j]==0) { mu[i*prime[j]]=0; break; } } } for(int i=1;i&lt;=S-3;i++) sum[i]=((long long)sum[i-1]+mu[i]+p)%p; fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; _2sum[0]=1; for(int i=1,tmp=1;i&lt;=S-3;i++) { tmp=2ll*tmp%p; _2sum[i]=(_2sum[i-1]+tmp)%p; } int ans=0; for(int i=-bq;i&lt;=aq;i++) { int x=aa-ba+i,y=m-ba-n+aa+i; if((x&lt;0&amp;&amp;y&gt;0)||(x&gt;0&amp;&amp;y&lt;0)) continue; x=abs(x),y=abs(y); if((x==0||y==0)&amp;&amp;x+y&gt;0) continue; // printf(&quot;%d %d %d\\n&quot;,x,y,f(x,y)); ans=(ans+1ll*f(x,y)*C(bq+aq,aq-i)%p)%p; } bool fl=n==m; for(int i=1;i&lt;=n;i++) fl&amp;=a[i]==b[i]||a[i]=='?'||b[i]=='?'; if(fl) { int cnt=0; for(int i=1;i&lt;=n;i++) cnt+=a[i]=='?'&amp;&amp;b[i]=='?'; ans=((long long)ans-1ll*f(0,0)*qpow(2,cnt)%p+p)%p; int val=((long long)_2sum[k]-_2sum[0]+p)%p; ans=(ans+1ll*val*val%p*qpow(2,cnt)%p)%p; } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"CF794G Replace All 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf794g-replace-all-zuo-ti-ji-lu/","stats":{"text":"10 min read","time":552000,"words":1604,"minutes":10},"date":"2023-04-15 16:39:48","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给你两个可重集 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A, B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A, B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 的元素个数都为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，它们中每个元素的大小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">x\\in [1,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span>。请你分别找出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 的一个子集和 B$ 的一个子集，使得它们中的元素之和相等。输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\leq 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给你两个可重集 A,BA, BA,B，A,BA, BA,B 的元素个数都为 nnn，它们中每个元素的大小 x∈[1,n]x\\in [1,n]x∈[1,n]。请你分别找出 AAA 的一个子集和 B$ 的一个子集，使得它们中的元素之和相等。输出方案。 1≤n≤1061\\le n\\leq 10^61≤n≤106。 直接考虑子序列是做不了的，那么不妨加强限制，考虑子段。 发现值域是序列的长度 nnn，这启发我们想到抽屉原理。设 sasasa 和 sbsbsb 是两个序列的前缀和，不妨假设 san≤sbnsa_n\\le sb_nsan​≤sbn​，设 posipos_iposi​ 表示最大的满足 sbx≤saisb_x\\le sa_isbx​≤sai​ 的 xxx，那么总有 posi=npos_i=nposi​=n 或者 sbposi+1−sai&gt;0sb_{pos_i+1}-sa_i&gt;0sbposi​+1​−sai​&gt;0。后者移项得 sai−sbposi&lt;bposi+1sa_i-sb_{pos_i}&lt;b_{pos_i+1}sai​−sbposi​​&lt;bposi​+1​，而 posi=npos_i=nposi​=n 的情况则由于 san&lt;sbnsa_n&lt;sb_nsan​&lt;sbn​ 所以有 sai−sbposi=0sa_i-sb_{pos_i}=0sai​−sbposi​​=0。由于 bposi+1b_{pos_i+1}bposi​+1​ 的最大值为 nnn，所以总有 sai−sbposi&lt;nsa_i-sb_{pos_i}&lt;nsai​−sbposi​​&lt;n。 注意到只要找到一个四元组 (l1,r1,l2,r2)(l1,r1,l2,r2)(l1,r1,l2,r2)，满足 0≤l1&lt;r1≤n,0≤l2&lt;r2≤n0\\le l1&lt;r1\\le n,0\\le l2&lt;r2\\le n0≤l1&lt;r1≤n,0≤l2&lt;r2≤n 且 al1−bl2=ar1−br2a_{l1}-b_{l2}=a_{r1}-b_{r2}al1​−bl2​=ar1​−br2​ 则 [l1+1,r1][l1+1,r1][l1+1,r1] 和 [l2+1,r2][l2+1,r2][l2+1,r2] 就是一个合法的解。而 sai−sbposisa_i-sb_{pos_i}sai​−sbposi​​ 共有 nnn 种取值，iii 却有 n+1n+1n+1 种取值，所以总能找到两对相等的 sai−sbposisa_i-sb_{pos_i}sai​−sbposi​​。并且由于 saisa_isai​ 互不相同，所以这两对的 posipos_iposi​ 也互不相同，所以找出来的是合法的解。 那么用个桶记录每个 sai−sbposisa_i-sb_{pos_i}sai​−sbposi​​ 对应的 iii 即可，时间复杂度 O(n)O(n)O(n)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005; int n; bool flg; int a[S],b[S]; long long sa[S],sb[S]; int pos[S],val[S]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) { sa[i]=sa[i-1]+a[i]; sb[i]=sb[i-1]+b[i]; } if(sa[n]&gt;sb[n]) { flg=true; swap(a,b); swap(sa,sb); } for(int i=0;i&lt;=n;i++) { if(i&gt;0) pos[i]=pos[i-1]; while(pos[i]&lt;n&amp;&amp;sb[pos[i]+1]&lt;=sa[i]) pos[i]++; val[i]=-1; } int l1=-1,r1=-1,l2=-1,r2=-1; for(int i=0;i&lt;=n;i++) { int pre=sa[i]-sb[pos[i]]; if(val[pre]!=-1) { if(!flg) { l1=val[pre],r1=i; l2=pos[val[pre]],r2=pos[i]; } else { l1=pos[val[pre]],r1=pos[i]; l2=val[pre],r2=i; } } else val[pre]=i; } if(l1&gt;r1) swap(l1,r1); if(l2&gt;r2) swap(l2,r2); l1++,l2++; printf(&quot;%d\\n&quot;,r1-l1+1); for(int i=l1;i&lt;=r1;i++) printf(&quot;%d &quot;,i); printf(&quot;\\n%d\\n&quot;,r2-l2+1); for(int i=l2;i&lt;=r2;i++) printf(&quot;%d &quot;,i); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF618F Double Knapsack 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf618f-double-knapsack-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":236000,"words":750,"minutes":4},"date":"2023-04-15 16:36:05","dateFormat":"2023-04-15"},{"abstract":"","content":"Part 1 公共部分 1.1 定义 补图： 无向图 GGG 的补图中存在一条边 (x,y)(x,y)(x,y) 当且仅当 GGG 中不存在边 (x,y)(x,y)(x,y) 有向图 GGG 的补图中存在一条边 x→yx\\to yx→y 当且仅当 GGG 中不存在边 x→yx\\to yx→y； 子图：图中某些点和它们之间的边构成的新图； 链覆盖：把图划分为若干条链的方案； 反链：满足点两两之间不能互相到达的点集； 1.2 定理 最小链覆盖等于最长反链 证明 考虑不得不用两条链覆盖的结构，即一个分叉，显然不同分支上的点不能相互到达，那么最长反链中的每个点都可以代表一条链。 Q.E.D. 最小链覆盖等于点数减去拆点二分图的最大匹配 证明 二分图每匹配一对点，就相当于合并了两条链。 Q.E.D. Part 2 无向图 2.1 定义 点的邻点：无向图中，vvv 为点 uuu 的邻点当且仅当它们有边直接相连，N(u)N(u)N(u) 为 uuu 的邻点集； 团：无向图中满足点两两之间都有连边的点集； 独立集：无向图中满足点两两之间没有连边的点集； 直径：无向图中所有点对的最短路的最大值； 点覆盖：无向图中所有边两端的点都至少有一个在其中的点集； 2.2 定理 最大团等于补图的最大独立集 证明 原图的一个团内的点显然在补图上两两没有连边，所以原图的最大团在补图上一定是独立集。 反过来即可证明补图的最大独立集在原图上一定是团。 Q.E.D. 无向图中 111 到其它点最短路的最大值 disdisdis 和图的直径 ddd 满足 ⌈d2⌉≤dis≤d\\lceil\\frac{d}{2}\\rceil\\le dis \\le d⌈2d​⌉≤dis≤d 证明 dis≤ddis\\le ddis≤d 显然，⌈d2⌉≤dis\\lceil\\frac{d}{2}\\rceil\\le dis⌈2d​⌉≤dis​ 则是因为要先走到直径上，再走到直径的两个端点。 Q.E.D. 2.3 二分图 2.3.1 定义 二分图：无向图，满足可以分成左部点集 SSS 和右部点集 TTT 使得对于所有边 (u,v)(u,v)(u,v) 都有 u∈S,v∈Tu\\in S,v\\in Tu∈S,v∈T 或 u∈T,v∈Su\\in T,v\\in Su∈T,v∈S； 拆点二分图：把每个点拆成入点和出点，对于一条边 x→yx\\to yx→y，在二分图中连一条从 xxx 的出点到 yyy 的入点的边； k−k-k−正则二分图：所有点的度数都为 kkk 的二分图，易知 k−k-k−正则二分图中 ∣S∣=∣T∣|S|=|T|∣S∣=∣T∣； 匹配：二分图中满足每个点度数都是 111 的子图； 完美匹配：某一部中的点都在其中的匹配； 2.3.2 定理 二分图最小点覆盖等于最大匹配： 证明 网络流，源点向每个左部点连流量为 111 的边，左部点向原图中有连边的右部点连流量为 ∞\\infin∞ 的边，右部点向汇点连流量为 111​ 的边，最小割等于最大流。 Q.E.D. 二分图最大独立集等于点数减去最小点覆盖： 证明 每条边都至少有一个端点在最小点覆盖中，那么把最小点覆盖中的点删掉后就是最大独立集了。 Q.E.D. k−k-k−正则二分图可以被拆解为 kkk 组完美匹配 证明 归纳： 1−1-1−正则二分图显然满足； k−k-k−正则二分图满足 Hall 定理：∀A⊆S\\forall A\\subseteq S∀A⊆S，AAA 连出去的边集 EAEAEA 是 N(A)N(A)N(A) 连出去的边集 EBEBEB 的子集，所以 ∣EA∣≤∣EB∣|EA|\\le |EB|∣EA∣≤∣EB∣，那么显然 k∣A∣≤k∣N(A)∣k|A|\\le k|N(A)|k∣A∣≤k∣N(A)∣，∣A∣≤∣N(A)∣|A|\\le |N(A)|∣A∣≤∣N(A)∣； 由于 k−k-k−二分图满足 ∣S∣=∣T∣|S|=|T|∣S∣=∣T∣，所以找到 k−k-k−二分图的一组完美后去掉它可以转化为 (k−1)−(k-1)-(k−1)−正则二分图； Q.E.D. 2.3.3 Hall 定理 2.3.3.1 基本形式 对于左部点集为 SSS，右部点集为 TTT 的二分图 GGG，其存在大小为 ∣S∣|S|∣S∣ 的匹配的充要条件为： ∀A⊆S,∣∪u∈AN(u)∣≥∣A∣\\forall A\\subseteq S,|\\cup_{u\\in A}N(u)|\\ge|A|∀A⊆S,∣∪u∈A​N(u)∣≥∣A∣。 证明 必要性显然，充分性考虑反证。 若满足了基本 Hall 定理但是不存在大小为 ∣S∣|S|∣S∣ 的匹配，则一定存在一个 u∈Su\\in Su∈S 满足 uuu 不在最大匹配中，那么 ∀v∈N(u)\\forall v\\in N(u)∀v∈N(u)，vvv 一定在最大匹配中。 考虑匈牙利算法，对于每一个 vvv，都不断找到它匹配的点 bvb_vbv​，把 bvb_vbv​ 当作 uuu 继续进行这个过程。设遍历过的 uuu 的集合为 BBB（包含刚开始的那个 uuu），则若 ∀u∈B\\forall u\\in B∀u∈B，N(u)N(u)N(u) 中都不存在未被匹配的点，那么一定有 ∣N(B)∣=∣B∣−1|N(B)|=|B|-1∣N(B)∣=∣B∣−1，即只有刚开始的那个 uuu 找不到和它匹配的点。与定理相悖。 Q.E.D. 2.3.3.2 拓展形式 对于类似这样的二分网络流图，即源点向左边第 iii 个点连一条流量 aia_iai​ 的边，左边第 iii 个点向右边第 jjj 个点连一条流量 ci,jc_{i,j}ci,j​ 的边，右边第 iii 个点向汇点连一条流量 bib_{i}bi​ 的边： 它左边的所有点能满流（经过左边第 iii 个点的流量为 aia_iai​）当且仅当以下条件成立： 设左边点集合为 SSS，则 ∀T⊆S,∑u∈Tau≤∑u∈N(T)min⁡(bu,∑v∈Tcv,u)\\forall T\\subseteq S,\\sum\\limits_{u\\in T}a_u\\le\\sum\\limits_{u\\in N(T)}\\min\\left(b_u,\\sum\\limits_{v\\in T} c_{v,u}\\right)∀T⊆S,u∈T∑​au​≤u∈N(T)∑​min(bu​,v∈T∑​cv,u​)； 即与 TTT 相连的右边点集能承受的总流量要至少为 TTT 中点输出的总流量。 证明 把基本形式证明中的匈牙利换成 EK（每次暴力找一条增广路）即可。 2.3.3.3 点和区间匹配形 数轴上有 nnn 个点和 nnn 个区间，一个点能匹配一个区间当且仅当这个点被这个区间包含。 存在大小为 nnn 的匹配当且仅当： 把值域离散化到 [1,n][1,n][1,n] 后，对于所有区间 [l,r][l,r][l,r]，被 [l,r][l,r][l,r] 完全包含的区间个数 ≤r−l+1\\le r-l+1≤r−l+1； 证明 考虑反证。 对于区间集合 SSS，若 ∣S∣&gt;∣∪u∈S[lu,ru]∣|S|&gt;|\\cup_{u\\in S} [l_u,r_u]|∣S∣&gt;∣∪u∈S​[lu​,ru​]∣ 且 ∪u∈S[lu,ru]\\cup_{u\\in S} [l_u,r_u]∪u∈S​[lu​,ru​] 可以分成若干个极长的不交且不相邻区间 [lb1,rb1],[lb2,rb2],…,[lbk,rbk][lb_1,rb_1],[lb_2,rb_2],\\dots,[lb_k,rb_k][lb1​,rb1​],[lb2​,rb2​],…,[lbk​,rbk​]，则设 Ai={x∣x∈S,[lx,rx]⊆[lbi,rbi]}A_i=\\{x|x\\in S,[l_x,r_x]\\subseteq [lb_i,rb_i]\\}Ai​={x∣x∈S,[lx​,rx​]⊆[lbi​,rbi​]}。 注意到对于任意不同的 i,ji,ji,j，必然有 Ai∩Aj=∅A_i\\cap A_j=\\emptysetAi​∩Aj​=∅，也就是说，对于任意不同的 i,ji,ji,j，Ai∩Aj=∅A_i\\cap A_j=\\emptysetAi​∩Aj​=∅ 且 (∪u∈Ai[lu,ru])∩(∪u∈Aj[lu,ru])=∅(\\cup_{u\\in A_i} [l_u,r_u])\\cap(\\cup_{u\\in A_j} [l_u,r_u])=\\emptyset(∪u∈Ai​​[lu​,ru​])∩(∪u∈Aj​​[lu​,ru​])=∅。 所以对于任意不同的 i,ji,ji,j，AiA_iAi​ 和 AjA_jAj​ 独立。 那么必然存在某个 iii 满足 ∣Ai∣&gt;∣∪u∈Ai[lu,ru]∣|A_i|&gt;|\\cup_{u\\in A_i} [l_u,r_u]|∣Ai​∣&gt;∣∪u∈Ai​​[lu​,ru​]∣，此时区间 ∪u∈Ai[lu,ru]\\cup_{u\\in A_i} [l_u,r_u]∪u∈Ai​​[lu​,ru​] 不合法。 Q.E.D. 2.3.3.4 例题 CF1519F Chests and Keys | 题解 P6519 [CEOI2010 day1] bodyguards CF1718D Permutation for Burenka | 题解 2.4 生成树 2.4.1 定义 生成树：无向图 GGG 的一个边集，满足所有点都可以通过该边集联通且该边集的边数最小； 最小生成树：边权和最小的生成树； dfs 树：所有非树边两端的节点都互为祖孙关系的生成树； 本源环：dfs 树中只有一条非树边的环； 2.4.2 定理 所有最小生成树中每种边权的边的条数对应相等： 证明 考虑 Kruskal 算法的过程，显然边权小的边会选尽量多条。 Q.E.D. 例题： P4208 [JSOI2008] 最小生成树计数 所有简单环都可以由任意生成树中的若干本源环异或得出： 证明 每个简单环都等价于环中非树边对应的本源环异或起来。 Q.E.D. 例题： P4151 [WC2011] 最大XOR和路径 CF19E Fairy | 题解 Part3 有向图 3.1 定义 强连通子图：有向图的满足所有点对都能互相到达的子图； SCC：有向图的极大强连通子图（即加入任意节点都不强连通的强连通子图）； 3.2 偏序图 3.2.1 定义 偏序图：有向图，满足若存在边 x→yx\\to yx→y 和边 y→zy\\to zy→z 则存在边 x→zx\\to zx→z； 3.2.2 定理 偏序图上的独立集和反链等价 证明 考虑反证，设独立集中有两个点 x,yx,yx,y 满足 xxx 能到达 yyy，由于偏序图满足 xxx 能到达 yyy 则存在边 x→yx\\to yx→y，所以 x,yx,yx,y​ 不能同时存在于独立集中。 Q.E.D. 3.3 竞赛图 3.3.1 定义 竞赛图：有向图，满足可以由点数相同的完全图定向得到； 3.3.2 定理 竞赛图缩点（把每个 SCC 都缩成一个大点）后，满足拓扑序唯一且每个大点向它拓扑序中后面的所有大点都有连边 把竞赛图中的点按出度从小到大排序后，每个 SCC 对应一个区间 证明 竞赛图缩点后，满足拓扑序唯一且每个大点向它拓扑序中后面的所有大点都有连边。 也就是说对于每个 SCC，设拓扑序在它后面的 SCC 共有 mmm 个点，则这个 SCC 中的每个点都会向这 mmm 个点连一条边。 而一个大小为 kkk 的 SCC 中的点向这个 SCC 内部的其它点最多连 k−1k-1k−1 条边。 所以把所有点按出度从小到大排序相当于把 SCC 按照拓扑序从后往前排序，每个 SCC 对应一个区间。 Q.E.D. 竞赛图中的 SCC 个数即为其中的点按出度 dud_udu​ 从小到大排序后满足 ∑j=1idj=(i2)\\sum\\limits_{j=1}^id_j=\\binom{i}{2}j=1∑i​dj​=(2i​) 的 iii 的个数 证明 根据上一条定理的证明，把所有点按出度从小到大排序后相当于把 SCC 按照拓扑序从后往前排序，每个 SCC 对应一个区间。 那么 ∑j=1idj=(i2)\\sum\\limits_{j=1}^id_j=\\binom{i}{2}j=1∑i​dj​=(2i​) 的区间 [1,i][1,i][1,i] 与拓扑序的后缀构成双射。 Q.E.D. 题外话：不难发现 Sum of SCC 那题的结论和这个本质相同。 例题： [ARC163D] Sum of SCC | 题解 CF1779E Anya's Simultaneous Exhibition QOJ5407 基础图论练习题 ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"一些图论的定理","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/yi-xie-tu-lun-de-ding-li/","stats":{"text":"12 min read","time":712000,"words":2856,"minutes":12},"date":"2023-04-15 16:35:15","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>有一个长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，刚开始 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">a_i=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>。还有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的无向图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>，刚开始 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中没有边。</p>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个操作，每一次给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le x&lt;n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中连一条 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{x+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">x</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 之间的边，然后交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{x+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">x</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中的最大团的大小。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个长为 nnn 的序列 aaa，刚开始 ai=ia_i=iai​=i。还有一个 nnn 个点的无向图 GGG，刚开始 GGG 中没有边。 有 mmm 个操作，每一次给定一个 1≤x&lt;n1\\le x&lt;n1≤x&lt;n 的 xxx，在 GGG 中连一条 axa_xax​ 和 ax+1a_{x+1}ax+1​ 之间的边，然后交换 axa_xax​ 和 ax+1a_{x+1}ax+1​。 求 GGG 中的最大团的大小。 1≤n,m≤2×1051\\le n,m\\le 2\\times 10^51≤n,m≤2×105。 由于最大团等于补图的最大独立集，所以考虑补图。 不妨先给补图 HHH 重定向，强制让编号小的连向编号大的，那么注意到 HHH 中若有 x→yx\\to yx→y，y→zy\\to zy→z 这两条边那么也一定有 x→zx\\to zx→z 这条边，即 HHH 是一个偏序关系图。注意到偏序关系图的最大独立集等于最长反链，最长反链等于最小链覆盖，最小链覆盖可以通过把 uuu 拆成入点和出点跑二分图最大匹配做，那么问题就转化为求 HHH 的拆点二分图最大匹配。 考虑先贪心匹配，注意到若当前匹配了 kkk 对点，那么所有度数 &gt;k&gt;k&gt;k 且未匹配的左部点一定能匹配。这一部分可以用 set 简单维护，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 最后停下来时有 n−kn-kn−k 个左部点，它们的度数一定都 ≤k\\le k≤k，由于度数 ≤k\\le k≤k 的点最多只有 ⌊mn−k⌋\\lfloor\\frac{m}{n-k}\\rfloor⌊n−km​⌋ 个，所以有 n−k≤mn-k\\le \\sqrt mn−k≤m​ 即未匹配的点是 O(m)O(\\sqrt m)O(m​) 的。那么用并查集维护一下匈牙利找边的过程即可。 时间复杂度 O(nlog⁡n+nm)O(n\\log n+n\\sqrt m)O(nlogn+nm​)。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; const int S=200005,mod=1145143; int n,m; int a[S]; vector&lt;int&gt; to[S]; set&lt;int&gt; st; int tp,sta[S]; bool flg[S]; int blg[S],fa[S]; inline int read() { int s=0,c=getchar(); while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') s=s*10+c-48,c=getchar(); return s; } int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } bool dfs(int u) { for(int v=fnd(u+1),i=-1;v&lt;=n;v=fnd(v+1)) { while(i+1&lt;to[u].size()&amp;&amp;to[u][i+1]&lt;=v) i++; if(i==-1||v!=to[u][i]) { int tmp=blg[v]; blg[v]=u; fa[fnd(v)]=fnd(v+1); if(tmp==0||dfs(tmp)) return true; blg[v]=tmp; } } return false; } int main() { freopen(&quot;sugar.in&quot;,&quot;r&quot;,stdin); freopen(&quot;sugar.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=i; for(int i=1;i&lt;=m;i++) { int ix=read(); int x=a[ix],y=a[ix+1]; to[x].push_back(y),to[y].push_back(x); swap(a[ix],a[ix+1]); } for(int i=1;i&lt;=n;i++) { sort(to[i].begin(),to[i].end()); to[i].erase(unique(to[i].begin(),to[i].end()),to[i].end()); vector&lt;int&gt; tmp; for(int j:to[i]) if(j&gt;i) tmp.push_back(j); to[i]=tmp; } int ans=n; for(int i=1;i&lt;=n;i++) st.insert(i); for(int i=1;i&lt;=n;i++) { if(st.count(i)) st.erase(i); for(int v:to[i]) if(st.count(v)) st.erase(v),sta[++tp]=v; if(!st.empty()) { blg[*st.begin()]=i,flg[i]=true,ans--; st.erase(st.begin()); } while(tp&gt;0) st.insert(sta[tp--]); } for(int i=1;i&lt;=n;i++) { if(!flg[i]) { for(int j=1;j&lt;=n+1;j++) fa[j]=j; ans-=dfs(i); } } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"【2023武汉集训模拟赛03】嘉心糖 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023-wu-han-ji-xun-mo-ni-sai-03-jia-xin-tang-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":267000,"words":871,"minutes":5},"date":"2023-04-15 16:33:52","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给出数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> ,你可以改变每个数的正负，求逆序对数最少是多少。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">|a_i|\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给出数组 aaa ,你可以改变每个数的正负，求逆序对数最少是多少。 1≤n≤20001\\le n\\le 20001≤n≤2000，∣ai∣≤105|a_i|\\le 10^5∣ai​∣≤105。 考虑一对 (i,j)(i,j)(i,j)（i&lt;ji&lt;ji&lt;j）对逆序对个数的贡献： ∣ai∣&gt;∣aj∣|a_i|&gt;|a_j|∣ai​∣&gt;∣aj​∣：有贡献当且仅当 aia_iai​ 取 ∣ai∣|a_i|∣ai​∣； ∣ai∣&lt;∣aj∣|a_i|&lt;|a_j|∣ai​∣&lt;∣aj​∣：有贡献当且仅当 aja_jaj​ 取 −∣aj∣-|a_j|−∣aj​∣； ∣ai∣=∣aj∣|a_i|=|a_j|∣ai​∣=∣aj​∣：有贡献当且仅当 aia_iai​ 取 ∣ai∣|a_i|∣ai​∣，aja_jaj​ 取 −∣aj∣-|a_j|−∣aj​∣ 且 ai=0,aj=0a_i\\not=0,a_j\\not=0ai​​=0,aj​​=0； 暂时先不考虑第三种情况，不难发现 (i,j)(i,j)(i,j) 的贡献和 aia_iai​、aja_jaj​ 中绝对值最大的那个的取值直接挂钩，那么 axa_xax​ 对逆序对个数的贡献为： ax=∣ax∣a_x=|a_x|ax​=∣ax​∣ 时：i&lt;xi&lt;xi&lt;x 且 ∣ai∣&lt;∣ax∣|a_i|&lt;|a_x|∣ai​∣&lt;∣ax​∣ 的 iii 的个数； ax=−∣ax∣a_x=-|a_x|ax​=−∣ax​∣ 时：i&gt;xi&gt;xi&gt;x 且 ∣ai∣&lt;∣ax∣|a_i|&lt;|a_x|∣ai​∣&lt;∣ax​∣ 的 iii 的个数； 所以有一个显然的贪心：每个 xxx 都从这两个值中取最小的累加进答案。容易发现如果不存在 ∣ai∣=∣aj∣|a_i|=|a_j|∣ai​∣=∣aj​∣ 的 (i,j)(i,j)(i,j) 则这个贪心一定是正确的，因为每个 xxx 的贡献是独立的。 若存在 ∣ai∣=∣aj∣|a_i|=|a_j|∣ai​∣=∣aj​∣ 的 (i,j)(i,j)(i,j)，这个贪心其实也是对的。因为对于所有 ∣ai∣=w|a_i|=w∣ai​∣=w，在原序列中一定存在一个分界点 kkk，满足 i≤ki\\le ki≤k 的 aia_iai​ 是负数，i&gt;ki&gt;ki&gt;k 的 aia_iai​ 是正数。因为 axa_xax​ 贡献的取值一定是单调的。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; int n,a[S],id[S]; int tr[S]; inline void add(int pos,int val) { for(int i=pos;i&lt;=n;i+=i&amp;-i) tr[i]+=val; } inline int que(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=tr[i]; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),a[i]=abs(a[i]),id[i]=i; sort(id+1,id+n+1,[&amp;](int x,int y){return a[x]&lt;a[y];}); long long ans=0; for(int i=1,j=0;i&lt;=n;i++) { while(j&lt;i&amp;&amp;a[id[j+1]]!=a[id[i]]) add(id[++j],1); ans+=min(que(id[i]),j-que(id[i])); } printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF351E Jeff and Permutation 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf351e-jeff-and-permutation-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":181000,"words":599,"minutes":4},"date":"2023-04-15 16:32:45","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>场上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">2N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个整数， Alice，Bob 轮流取数， Alice 先手，如果最终 Alice 取出数的和取模 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 和 Bob 取出来数的和相等，那么 Bob 获胜，否则 Alice 获胜。</p>\n<p>两个人绝对聪明，求哪个人会获胜。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq N \\leq 2 \\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\leq M \\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>A</mi><mi>i</mi></msub><mo>≤</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\leq A_i \\leq M - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n</ul>\n</blockquote>\n","content":" 场上 2N2N2N 个整数， Alice，Bob 轮流取数， Alice 先手，如果最终 Alice 取出数的和取模 MMM 和 Bob 取出来数的和相等，那么 Bob 获胜，否则 Alice 获胜。 两个人绝对聪明，求哪个人会获胜。 1≤N≤2×1051 \\leq N \\leq 2 \\times 10^51≤N≤2×105 2≤M≤1092 \\leq M \\leq 10^92≤M≤109 0≤Ai≤M−10 \\leq A_i \\leq M - 10≤Ai​≤M−1 考虑最后剩下两个数 a,ba,ba,b 且的情况，显然此时 Alice 先手。设此时两人的数的和分别为 xxx 和 yyy，那么 Bob 胜当且仅当 x+a≡y+b(modM)x+a\\equiv y+b\\pmod Mx+a≡y+b(modM) 且 x+b≡y+a(modM)x+b\\equiv y+a\\pmod Mx+b≡y+a(modM)，两式相加减可以把条件转化为 2x≡2y(modM)2x\\equiv 2y\\pmod M2x≡2y(modM) 且 x−y≡y−x(modM)x-y\\equiv y-x\\pmod Mx−y≡y−x(modM) 且 2a≡2b(modM)2a\\equiv 2b\\pmod M2a≡2b(modM) 且 a−b≡b−a(modM)a-b\\equiv b-a\\pmod Ma−b≡b−a(modM)。观察到只有以下几种情况满足条件： x≡y(modM)x\\equiv y\\pmod Mx≡y(modM) 且 a≡b(modM)a\\equiv b\\pmod Ma≡b(modM)； MMM 为偶数且 x+M2≡y(modM)x+\\frac{M}{2}\\equiv y\\pmod Mx+2M​≡y(modM) 且 a+M2≡b(modM)a+\\frac{M}{2}\\equiv b\\pmod Ma+2M​≡b(modM)； 那么不难发现若能把 AiA_iAi​ 分成若干组 x≡y(modM)x\\equiv y\\pmod Mx≡y(modM) 和偶数组 x+M2≡y(modM)x+\\frac{M}{2}\\equiv y\\pmod Mx+2M​≡y(modM)（MMM 是偶数时）则 Bob 必胜，因为可以取和 Alice 取的那个数组成一组的那个数。 考虑证明这个条件是充要的，即证明其他情况 Alice 必胜。其实很好证明，只要让 Alice 模仿 Bob 操作，Bob 取能组成一组的她就取这一组中的另一个，Bob 取零散的 Alice 也取零散的，这样最后剩下的两个数字一定不能组成一组，并且零散的数字互相组成 MMM 来消掉的情况 Alice 也可以通过一些微调来避免，所以这时 Alice 必胜。 代码如下： // Problem: [ARC148D] mod M Game // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_arc148_d // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=400005; int n,m,a[S]; set&lt;int&gt; st; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n*2;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n*2;i++) { if(st.count(a[i])) st.erase(a[i]); else st.insert(a[i]); } int cnt=0; for(int x:st) { if(m&amp;1) return puts(&quot;Alice&quot;),0; if(!st.count((x+m/2)%m)) return puts(&quot;Alice&quot;),0; cnt++; } cnt/=2; puts((cnt&amp;1)?&quot;Alice&quot;:&quot;Bob&quot;); return 0; } ","tags":[{"name":"博弈论","slug":"6A-_b3w3J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/6A-_b3w3J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"AT_arc148_d [ARC148D] mod M Game 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/at_arc148_d-arc148d-mod-m-game-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":202000,"words":677,"minutes":4},"date":"2023-04-15 16:25:46","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>定义⼀个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 是连续的，当且仅当序列中最大值和最小值的差为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>m</mi><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">−</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">|m|−1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">m</span><span class=\"mord\">∣</span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>有⼀个⻓度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，按照以下规则⽣成数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><mi>L</mi><mi mathvariant=\"normal\">∣</mi><mo>[</mo><msub><mi>p</mi><mi>i</mi></msub><mi mathvariant=\"normal\">−</mi><mi>L</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><msub><mi>p</mi><mi>i</mi></msub><mi mathvariant=\"normal\">−</mi><mi>L</mi><mo>+</mo><mn>2</mn><mo>…</mo><msub><mi>p</mi><mi>i</mi></msub><mo>]</mo><mtext> 连续</mtext><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">T_i=\\max\\{L|[p_i−L+1,p_i−L+2\\dots p_i]\\text{ 连续}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">L</span><span class=\"mord\">∣</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">−</span><span class=\"mord mathdefault\">L</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">−</span><span class=\"mord mathdefault\">L</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">连续</span></span><span class=\"mclose\">}</span></span></span></span>，也就是以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为右端点的最长连续子串长度，显然 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">T_i\\ge1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>现在给你 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 数组，你需要知道有多少 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 可以生成指定的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>。对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span> 组数据。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5\\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>Q</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">1\\le Q\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 定义⼀个序列 mmm 是连续的，当且仅当序列中最大值和最小值的差为 ∣m∣−1|m|−1∣m∣−1。 有⼀个⻓度为 nnn 的排列 ppp，按照以下规则⽣成数组 TTT，其中 Ti=max⁡{L∣[pi−L+1,pi−L+2…pi] 连续}T_i=\\max\\{L|[p_i−L+1,p_i−L+2\\dots p_i]\\text{ 连续}\\}Ti​=max{L∣[pi​−L+1,pi​−L+2…pi​] 连续}，也就是以 iii 为右端点的最长连续子串长度，显然 Ti≥1T_i\\ge1Ti​≥1。 现在给你 TTT 数组，你需要知道有多少 ppp 可以生成指定的数组 TTT。对 998244353998244353998244353 取模。 有 QQQ 组数据。 1≤n≤5×1041\\le n\\le 5\\times 10^41≤n≤5×104，1≤Q≤1001\\le Q\\le 1001≤Q≤100。 不难发现若两个集合 AAA、BBB 连续且 A∩B=∅A\\cap B\\not=\\varnothingA∩B​=∅，那么 A∪BA\\cup BA∪B 一定连续，所以两个极长连续区间要么没有交集要么互相包含。那么首先判掉区间关系不合法的情况（注意 Tn=nT_n\\not=nTn​​=n 也不行），然后按照包含关系建出树，设 dpudp_udpu​ 为 uuu 的子树的答案，那么有转移： dpu=f∣sonu∣+1∏v∈sonudpvdp_u=f_{|son_u|+1}\\prod\\limits_{v\\in son_u}dp_v dpu​=f∣sonu​∣+1​v∈sonu​∏​dpv​ 其中 fnf_nfn​ 表示长度为 nnn 的形如 {1,1,1,1,…,1,n}\\{1,1,1,1,\\dots,1,n\\}{1,1,1,1,…,1,n} 的 TTT 的答案，总的答案即为 dpndp_ndpn​。 这样转移相当于把儿子代表的区间看作一个点，因为这一段在序列和值域上都是独立的。 那么求出 fff 即可求出答案，但是直接在 ppp 上面 dp 不好做。 这里有个神奇的转化，考虑 ppp 的逆排列 p′p&#x27;p′ 即满足 ppi′=ip&#x27;_{p_i}=ippi​′​=i 的排列，那么 ppp 上的一段连续的区间 [l,r][l,r][l,r] 对应的 p′p&#x27;p′ 上的区间 [min⁡{pl,pl+1,…,pr},max⁡{pl,pl+1,…,pr}][\\min\\{p_l,p_{l+1},\\dots,p_r\\},\\max\\{p_l,p_{l+1},\\dots,p_r\\}][min{pl​,pl+1​,…,pr​},max{pl​,pl+1​,…,pr​}] 也是连续的， 且这段区间中的最大值是 rrr，最小值是 lll。不难发现 ppp 和 p′p&#x27;p′ 是双射的，那么 fnf_nfn​ 就相当于 p′p&#x27;p′ 中所有连续区间都包含最大值 nnn 的排列 p′p&#x27;p′ 的数量。 容易发现 f1=1,f2=2,f3=2f_1=1,f_2=2,f_3=2f1​=1,f2​=2,f3​=2。接下来考虑 fn→fn+1f_n\\to f_{n+1}fn​→fn+1​ 的转移（n≥3n\\ge 3n≥3），考虑新插入一个最小值 000： 插入之前 p′p&#x27;p′ 已经合法：此时唯一的要求是 000 不能和 111 相邻，则 (n−1)×fn→fn(n-1)\\times f_{n}\\to f_n(n−1)×fn​→fn​； 插入之前 p′p&#x27;p′ 不合法：那么要让插入之后的 p′p&#x27;p′ 合法，由于只能插入一个 000，所以插入之前只能有一个极长的不合法连续区间，设它的长度为 xxx，那么要求这个区间中没有 111 且没有 nnn，所以区间的取值共有 n−x−1n-x-1n−x−1 种，并且插入 000 后要让这个区间的子连续段要么长度为 111 要么经过 000，所以区间内部的方案数为 (n−x−1)×fx+1(n-x-1)\\times f_{x+1}(n−x−1)×fx+1​。插入完之后要把这个区间放回去，把它看作一个点，那么外部的方案数即为 fn−x+1f_{n-x+1}fn−x+1​，所以有转移 ∑x=2n−2(n−x−1)fx+1fn−x+1→fn+1\\sum\\limits_{x=2}^{n-2}(n-x-1)f_{x+1}f_{n-x+1}\\to f_{n+1}x=2∑n−2​(n−x−1)fx+1​fn−x+1​→fn+1​； 接下来开始推式子： fn+1=(n−1)×fn+∑x=2n−2(n−x−1)fx+1fn−x+1=(n−1)×fn+∑x=3n−1fx(n−x)fn−x+2=(n−1)×fn+∑x=3nfx(n−x)fn−x+2设 gx=xfx+2 , hx={0x&lt;3fxx≥3=(n−1)×fn+∑i=0nhign−i\\begin{aligned} f_{n+1}&amp;=(n-1)\\times f_n+\\sum\\limits_{x=2}^{n-2} (n-x-1)f_{x+1}f_{n-x+1}\\\\ &amp;=(n-1)\\times f_n+\\sum\\limits_{x=3}^{n-1} f_{x}(n-x)f_{n-x+2}\\\\ &amp;=(n-1)\\times f_n+\\sum\\limits_{x=3}^{n} f_{x}(n-x)f_{n-x+2}\\\\ \\text{设 }g_x=xf_{x+2}\\text{ , }h_x=\\begin{cases}0&amp;x&lt;3\\\\f_x&amp;x\\ge3\\end{cases}\\\\ &amp;=(n-1)\\times f_n+\\sum\\limits_{i=0}^{n} h_ig_{n-i}\\\\ \\end{aligned} fn+1​设 gx​=xfx+2​ , hx​={0fx​​x&lt;3x≥3​​=(n−1)×fn​+x=2∑n−2​(n−x−1)fx+1​fn−x+1​=(n−1)×fn​+x=3∑n−1​fx​(n−x)fn−x+2​=(n−1)×fn​+x=3∑n​fx​(n−x)fn−x+2​=(n−1)×fn​+i=0∑n​hi​gn−i​​ 那么直接分治 NTT O(nlog⁡2n)O(n\\log ^2n)O(nlog2n) 维护，[l,mid][l,mid][l,mid] 贡献到 [mid+1,r][mid+1,r][mid+1,r] 的时候要注意算上 i∈[l,mid]i\\in[l,mid]i∈[l,mid] 的 fif_ifi​ 和 gig_igi​ 的贡献，并且注意边界。 代码如下： // Problem: #187. count // Contest: Hydro // URL: http://oiclass.com/d/AKNOI/p/187 // Memory Limit: 512 MB // Time Limit: 3000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int MS=50005,S=500005; const int p=998244353,ginv=332748118; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int getlen(int n) { int res=1; while(res&lt;n) res&lt;&lt;=1; return res; } int lst_n,lst_rev[S]; inline void NTT(int n,int a[],int tpe) { if(lst_n!=n) { lst_n=n; for(int i=0;i&lt;n;i++) lst_rev[i]=(lst_rev[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1)*(n&gt;&gt;1); } for(int i=0;i&lt;n;i++) if(lst_rev[i]&lt;i) swap(a[i],a[lst_rev[i]]); int g=tpe==1?3:ginv; for(int mid=1;mid&lt;n;mid&lt;&lt;=1) { int len=mid&lt;&lt;1,Wn=qpow(g,(p-1)/len); for(int l=0;l&lt;n-len+1;l+=len) { for(int k=0,Wk=1;k&lt;mid;k++,Wk=1ll*Wk*Wn%p) { int x=a[l+k],y=1ll*a[l+mid+k]*Wk%p; a[l+k]=(x+y)%p,a[l+mid+k]=(x-y+p)%p; } } } } inline void DFT(int n,int a[]){NTT(n,a,1);} inline void IDFT(int n,int a[]) { NTT(n,a,-1); int inv=qpow(n,p-2); for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*inv%p; } int f[S]; int h[S],g[S]; int q,n,a[MS]; void calc(int l,int r) { if(r&lt;=3||l&gt;r) return; if(l==r) return f[l]=(f[l]+1ll*(l-2)*f[l-1]%p)%p,void(); int mid=l+r&gt;&gt;1; calc(l,mid); // printf(&quot;calc([%d %d] -&gt; %d):\\n&quot;,l,r,mid); for(int i=l;i&lt;=mid;i++) h[i-l]=i&lt;3?0:f[i]; for(int i=0;i&lt;=r-l-1;i++) g[i]=1ll*i*f[i+2]%p; int lh=mid-l,lg=r-l-1; // for(int i=0;i&lt;=lh;i++) printf(&quot;%d &quot;,h[i]); // printf(&quot;\\n&quot;); // for(int i=0;i&lt;=lg;i++) printf(&quot;%d &quot;,g[i]); // printf(&quot;\\n&quot;); int rl=getlen(lh+lg+1); for(int i=lh+1;i&lt;rl;i++) h[i]=0; for(int i=lg+1;i&lt;rl;i++) g[i]=0; DFT(rl,h),DFT(rl,g); for(int i=0;i&lt;rl;i++) g[i]=1ll*h[i]*g[i]%p; IDFT(rl,g); for(int i=mid+1;i&lt;=r;i++) f[i]=(f[i]+g[i-l-1])%p; // printf(&quot;res: &quot;); // for(int i=mid+1;i&lt;=r;i++) printf(&quot;%d:%d &quot;,i-l-1,g[i-l-1]); // printf(&quot;\\n\\n&quot;); for(int i=l-2;i&lt;=mid-2;i++) h[i-l+2]=1ll*i*f[i+2]%p; for(int i=0;i&lt;=r-l+1;i++) g[i]=i&lt;3||i&gt;=l?0:f[i]; lh=mid-l,lg=r-l+1; // for(int i=0;i&lt;=lh;i++) printf(&quot;%d &quot;,h[i]); // printf(&quot;\\n&quot;); // for(int i=0;i&lt;=lg;i++) printf(&quot;%d &quot;,g[i]); // printf(&quot;\\n&quot;); rl=getlen(lh+lg+1); for(int i=lh+1;i&lt;rl;i++) h[i]=0; for(int i=lg+1;i&lt;rl;i++) g[i]=0; DFT(rl,h),DFT(rl,g); for(int i=0;i&lt;rl;i++) g[i]=1ll*h[i]*g[i]%p; IDFT(rl,g); for(int i=mid+1;i&lt;=r;i++) f[i]=(f[i]+g[i-l+1])%p; // printf(&quot;res: &quot;); // for(int i=mid+1;i&lt;=r;i++) printf(&quot;%d &quot;,g[i-l+1]); // printf(&quot;\\n***************\\n&quot;); calc(mid+1,r); } int dfs(int r) { int l=r-a[r]+1,res=1; int cnt=0; for(int i=r-1;i&gt;=l;i--) { if(i-a[i]+1&lt;l) return 0; res=1ll*res*dfs(i)%p; cnt++; i=i-a[i]+1; } res=1ll*res*f[cnt+1]%p; return res; } int main() { freopen(&quot;count.in&quot;,&quot;r&quot;,stdin); freopen(&quot;count.out&quot;,&quot;w&quot;,stdout); f[1]=1,f[2]=2,f[3]=2; // for(int i=4;i&lt;=100;i++) // { // f[i]=1ll*(i-2)*f[i-1]%p; // for(int j=0;j&lt;=i-1;j++) // { // h[j]=j&lt;3?0:f[j]; // g[j]=1ll*j*f[j+2]%p; // } // for(int j=0;j&lt;=i-1;j++) // { // f[i]=(f[i]+1ll*h[j]*g[i-1-j]%p)%p; // } // } calc(1,MS-3); // for(int i=1;i&lt;=20;i++) printf(&quot;%d &quot;,f[i]); // printf(&quot;\\n&quot;); scanf(&quot;%d%d&quot;,&amp;q,&amp;n); while(q--) { for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); if(a[n]!=n) puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,dfs(n)); } return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛13】count 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-13-count-zuo-ti-ji-lu/","stats":{"text":"12 min read","time":698000,"words":2140,"minutes":12},"date":"2023-04-15 16:18:28","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>你有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">1,2,\\dots N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>。</p>\n<p>你可以进行<strong>一次</strong>如下操作：选择一个<strong>非负</strong>整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，以及 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个不交的区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>l</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>r</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>l</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>r</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>l</mi><mi>k</mi></msub><mo>&lt;</mo><msub><mi>r</mi><mi>k</mi></msub><mo>≤</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">1\\le l_1&lt;r_1&lt;l_2&lt;r_2&lt;\\dots&lt;l_k&lt;r_k\\le N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，然后对每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>P</mi><msub><mi>l</mi><mi>i</mi></msub></msub><mo separator=\"true\">,</mo><msub><mi>P</mi><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>P</mi><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>+</mo><mn>2</mn></mrow></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>P</mi><msub><mi>r</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">P_{l_i},P_{l_i+1},P_{l_i+2},\\dots,P_{r_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> 替换为它们的升序排列。</p>\n<p>你想知道 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> 在操作完后可能有多少种不同的情况。由于情况数可能很多，所以你只想得到其对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模后的结果。请你帮帮你自己求出答案！</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le N\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 你有一个 1,2,…N1,2,\\dots N1,2,…N 的排列 PPP。 你可以进行一次如下操作：选择一个非负整数 kkk，以及 kkk 个不交的区间 1≤l1&lt;r1&lt;l2&lt;r2&lt;⋯&lt;lk&lt;rk≤N1\\le l_1&lt;r_1&lt;l_2&lt;r_2&lt;\\dots&lt;l_k&lt;r_k\\le N1≤l1​&lt;r1​&lt;l2​&lt;r2​&lt;⋯&lt;lk​&lt;rk​≤N，然后对每个 1≤i≤k1\\le i\\le k1≤i≤k 的 iii，将 Pli,Pli+1,Pli+2,…,PriP_{l_i},P_{l_i+1},P_{l_i+2},\\dots,P_{r_i}Pli​​,Pli​+1​,Pli​+2​,…,Pri​​ 替换为它们的升序排列。 你想知道 PPP 在操作完后可能有多少种不同的情况。由于情况数可能很多，所以你只想得到其对 998244353998244353998244353 取模后的结果。请你帮帮你自己求出答案！ 1≤N≤2×1051\\le N\\le 2\\times 10^51≤N≤2×105。 考虑设 dpidp_{i}dpi​ 表示 P[1,i]P_{[1,i]}P[1,i]​ 在操作之后有多少种不同的情况，考虑转移。一个区间 [l,r][l,r][l,r] 只能通过操作 [l,r][l,r][l,r] 来排序当且仅当不存在 kkk 满足 l≤k≤r−1l\\le k\\le r-1l≤k≤r−1 且排序 [l,k][l,k][l,k] 再排序 [k+1,r][k+1,r][k+1,r] 得到的序列和排序 [l,r][l,r][l,r] 相同。不妨称满足条件的区间是 ”好的“ 那么设 SiS_iSi​ 表示所有满足 [j,i][j,i][j,i] 是好的的 jjj 的集合，那么有转移 dpi=∑j∈Sidpj−1dp_i=\\sum\\limits_{j\\in S_i}dp_{j-1}dpi​=j∈Si​∑​dpj−1​，初始状态 dp0=1dp_0=1dp0​=1。 考虑求解 SiS_iSi​，显然有一个 O(n2)O(n^2)O(n2) 的算法： 对于每个 iii，从 iii 开始往前遍历，并维护当前 SiS_iSi​ 中最长的区间 [l,i][l,i][l,i] 和其中的最小值 valvalval。刚开始 Si={i},l=i,val=aiS_i=\\{i\\},l=i,val=a_iSi​={i},l=i,val=ai​，每遍历到一个位置 jjj： 若 Pj&lt;valP_j&lt;valPj​&lt;val，什么也不做； 若 Pj&gt;valP_j&gt;valPj​&gt;val，表明排序 [j,i][j,i][j,i] 之后会有一些 [l,i][l,i][l,i] 中的元素跑到 PjP_jPj​ 前面，由于 [l,i][l,i][l,i] 已经是好的了，所以这是排序 [j,x][j,x][j,x] 再排序 [x+1,i][x+1,i][x+1,i] 所做不到的，那么更新 l=jl=jl=j，并把 jjj 加入 SiS_iSi​，更新 valvalval； 观察到许多 SiS_iSi​ 是有大量重复的，考虑利用这种高重复性优化时间复杂度。设 xxx 为满足 Px&lt;PiP_x&lt;P_iPx​&lt;Pi​ 且 x&lt;ix&lt;ix&lt;i 的最大的 xxx，yyy 为满足 Py&gt;PiP_y&gt;P_iPy​&gt;Pi​ 且 y&lt;xy&lt;xy&lt;x 的最大的 yyy。那么有 [x+1,i]∈Si[x+1,i]\\in S_i[x+1,i]∈Si​ 且 [y+1,x]∉Si[y+1,x]\\notin S_i[y+1,x]∈/​Si​。 更进一步，设 zzz 为 [y+1,x][y+1,x][y+1,x] 中最小值的位置，由于 Py&gt;Pi,Pi&gt;Px,Px≥PzP_y&gt;P_i,P_i&gt;P_x,P_x\\ge P_zPy​&gt;Pi​,Pi​&gt;Px​,Px​≥Pz​，所以有 Pz&lt;PyP_z&lt;P_yPz​&lt;Py​，那么有 [y+1,z]∈Sz[y+1,z]\\in S_z[y+1,z]∈Sz​。并且观察到从 iii 和从 zzz 开始遍历到 yyy 时都有 l=y,val=Pzl=y,val=P_zl=y,val=Pz​，所以 Sz−[y+1,z]+[x+1,i]=SiS_z-[y+1,z]+[x+1,i]=S_iSz​−[y+1,z]+[x+1,i]=Si​。 那么二分 + ST 表找到 x,y,zx,y,zx,y,z，拿个前缀和维护转移即可。时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005,BS=20; const int p=998244353; int n,a[S]; int tot,sta[S],premn[S]; int mlog[S],mn[S][BS+5],mx[S][BS+5]; int sum[S],dp[S]; inline int quemn(int l,int r) { int k=mlog[r-l+1]; int x=mn[l][k],y=mn[r-(1&lt;&lt;k)+1][k]; return a[x]&lt;a[y]?x:y; } inline int quemx(int l,int r) { int k=mlog[r-l+1]; int x=mx[l][k],y=mx[r-(1&lt;&lt;k)+1][k]; return a[x]&gt;a[y]?x:y; } inline int fnd(int x,int val) { int l=1,r=x,res=0; while(l&lt;=r) { int mid=l+r&gt;&gt;1; if(a[quemx(mid,x)]&gt;val) res=mid,l=mid+1; else r=mid-1; } return res; } inline int quesm(int l,int r) { return (sum[r]-(l==0?0:sum[l-1])+p)%p; } int main() { freopen(&quot;bai.in&quot;,&quot;r&quot;,stdin); freopen(&quot;bai.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sta[tot=0]=0; for(int i=1;i&lt;=n;i++) { while(tot&gt;0&amp;&amp;a[sta[tot]]&gt;a[i]) tot--; premn[i]=sta[tot]; sta[++tot]=i; } mlog[0]=-1; for(int i=1;i&lt;=n;i++) mlog[i]=mlog[i&gt;&gt;1]+1,mn[i][0]=mx[i][0]=i; for(int j=1;j&lt;=mlog[n];j++) { for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++) { int x=mn[i][j-1],y=mn[i+(1&lt;&lt;j-1)][j-1]; mn[i][j]=a[x]&lt;a[y]?x:y; x=mx[i][j-1],y=mx[i+(1&lt;&lt;j-1)][j-1]; mx[i][j]=a[x]&gt;a[y]?x:y; } } sum[0]=dp[0]=1; for(int i=1;i&lt;=n;i++) { int x=premn[i],y=fnd(x,a[i]); if(y==0) dp[i]=quesm(x,i-1); else { int z=quemn(y+1,x); dp[i]=((dp[z]-quesm(y,z-1)+p)%p+quesm(x,i-1))%p; } sum[i]=(sum[i-1]+dp[i])%p; } printf(&quot;%d\\n&quot;,dp[n]); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛11】白 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-11-bai-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":409000,"words":1293,"minutes":7},"date":"2023-04-15 16:13:03","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>你在打游戏。在这个游戏中你有一个怒气值，其初始为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>，你的目标是通过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 次操作将其变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>。这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 次操作决定了你在一次游戏中的得分，这个得分初始为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，每次操作你可以：</p>\n<ul>\n<li>发怒，这会使你怒气值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span><span class=\"mord\">1</span></span></span></span>，然后将得分乘上当前怒气值。</li>\n<li>冷静，这会使你怒气值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">−</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">−1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>，而不改变得分。</li>\n</ul>\n<p>你想知道如果你使用所有能够达成目标的操作序列都各进行一次游戏，你的得分总和会是多少。特别地，如果无论如何都无法达成目标，则总和为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。由于这个总和可能很大，所以你只想得到其对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模后的结果。请你帮帮你自己求出答案！</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le N,A,B\\le 2\\times 10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 你在打游戏。在这个游戏中你有一个怒气值，其初始为 AAA，你的目标是通过 NNN 次操作将其变为 BBB。这 NNN 次操作决定了你在一次游戏中的得分，这个得分初始为 111，每次操作你可以： 发怒，这会使你怒气值 +1+1+1，然后将得分乘上当前怒气值。 冷静，这会使你怒气值 −1−1−1，而不改变得分。 你想知道如果你使用所有能够达成目标的操作序列都各进行一次游戏，你的得分总和会是多少。特别地，如果无论如何都无法达成目标，则总和为 000。由于这个总和可能很大，所以你只想得到其对 998244353998244353998244353 取模后的结果。请你帮帮你自己求出答案！ 0≤N,A,B≤2×1070\\le N,A,B\\le 2\\times 10^70≤N,A,B≤2×107。 首先 N+A+BN+A+BN+A+B 若不为偶数就不存在可以达成目标的操作序列，直接输出 000。 观察到由于 0≤A,B0\\le A,B0≤A,B，所以若怒气值降到负数则之后一定升到 000，让得分为 000。所以若把发怒看作 (，冷静看作 )，那么在操作序列对应的括号序列前面加上 AAA 个 (，后面加上 BBB 个 ) 则这个括号序列一定合法。 考虑 A=B=0A=B=0A=B=0 的情况，发现答案为 1×3×5×...×(N−1)=(N−1)!!1\\times 3\\times 5\\times...\\times (N-1)=(N-1)!!1×3×5×...×(N−1)=(N−1)!!。这个东西有个组合意义：NNN 个互不相同的东西分成 N2\\frac{N}{2}2N​ 个互不区分的无序二元组的方案数。那么考虑构建双射，对于一种分组方案，在这一组中小的那个位置填上 (，大的那个位置填 )，则这样填出来的一定是合法括号序列。 考虑一个括号序列有多少种分组方案与之对应。可以从右向左考虑，遇到 ) 就先加入一个集合 SSS，遇到 ( 就随便从 SSS 中选一个位置和它组成一个二元组。设某一次遇到 ( 的位置为 iii，所以 ∣S∣|S|∣S∣ 就是 iii 之后 ) 的个数 cnt)[i+1,n]cnt)_{[i+1,n]}cnt)[i+1,n]​ 减掉 iii 之后 ( 的个数 cnt([i+1,n]cnt(_{[i+1,n]}cnt([i+1,n]​；那么由于 A=B=0A=B=0A=B=0，所以 cnt([1,i]−cnt)[1,i]=cnt)[i+1,n]−cnt([i+1,n]=∣S∣cnt(_{[1,i]}-cnt)_{[1,i]}=cnt)_{[i+1,n]}-cnt(_{[i+1,n]}=|S|cnt([1,i]​−cnt)[1,i]​=cnt)[i+1,n]​−cnt([i+1,n]​=∣S∣。因为一个括号序列的分组方案数是 ∏∣S∣\\prod|S|∏∣S∣，所以一个括号序列对应的分组方案就是它的分数！ 加上 AAA 和 BBB 的条件，问题就变成了： 有 A+N+BA+N+BA+N+B 个元素，现在要把它们两两配对成 A+N+B2\\frac{A+N+B}{2}2A+N+B​ 个互不区分的无序二元组，求满足以下条件的配对方案个数： AAA 中的元素不能两两配对； BBB 中的元素不能两两配对； 如果只有 BBB 中元素不能两两配对的限制那么很好做，答案即为 (N+A)B‾(N+A−B−1)!!(N+A)^{\\underline{B}}(N+A-B-1)!!(N+A)B​(N+A−B−1)!!，即最后 BBB 个元素的配对方案乘上剩下 N+A−BN+A-BN+A−B 个元素的配对方案。若考虑上 AAA 的限制其实也很简单，只需要枚举有多少个二元组是 AAA 中元素互相配对的就行了： 1A!∑i=0⌊A2⌋(−1)i(A2i)(2i−1)!!(N+A−2i)B‾(N+A−2i−B−1)!!\\frac{1}{A!}\\sum\\limits_{i=0}^{\\lfloor\\frac{A}{2}\\rfloor}(-1)^i\\binom{A}{2i}(2i-1)!!(N+A-2i)^{\\underline{B}}(N+A-2i-B-1)!! A!1​i=0∑⌊2A​⌋​(−1)i(2iA​)(2i−1)!!(N+A−2i)B​(N+A−2i−B−1)!! 乘上 1A!\\frac{1}{A!}A!1​ 是为了去掉在括号前面添加的那 AAA 个 ( 的贡献。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=40000005; const int p=998244353; int n,a,b; int fra[S],inv[S],fra2[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } int main() { freopen(&quot;fa.in&quot;,&quot;r&quot;,stdin); freopen(&quot;fa.out&quot;,&quot;w&quot;,stdout); fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; fra2[0]=fra2[1]=1; for(int i=2;i&lt;=S-3;i++) fra2[i]=1ll*fra2[i-2]*i%p; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b); if(n+a+b&amp;1) return puts(&quot;0&quot;),0; int ans=0; for(int i=0;i*2&lt;=a&amp;&amp;n+a-i*2&gt;=b;i++) { int val=1ll*C(a,i*2)*(i==0?1:fra2[i*2-1])%p; val=1ll*val*fra[n+a-i*2]%p*inv[n+a-i*2-b]%p; val=1ll*val*(n+a-i*2-b==0?1:fra2[n+a-i*2-b-1])%p; if(i&amp;1) ans=(ans-val+p)%p; else ans=(ans+val)%p; } ans=1ll*ans*inv[a]%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛11】發 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-11-fa-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":371000,"words":1319,"minutes":7},"date":"2023-04-15 16:11:56","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>鸽子的老家是一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的树，节点编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。这是鸽子三年来第一次回老家，鸽子发现树的边受了些损伤。设损伤的边集为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span> 表示节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 之间简单路径的边集，鸽子用下面这个函数表示树的受损程度：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>a</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>a</mi><mi>m</mi></msub><mo>≤</mo><mi>n</mi></mrow></munder><mrow><mo fence=\"true\">[</mo><mrow><mo fence=\"true\">(</mo><munder><mo>∏</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow></munder><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo>)</mo><mo>∩</mo><mi>S</mi><mi mathvariant=\"normal\">∣</mi><mo fence=\"true\">)</mo></mrow><mo>≥</mo><mn>1.24280373</mn><msup><mn>9</mn><mrow><mo>(</mo><mi>m</mi><mi mathvariant=\"normal\">−</mi><mn>1</mn><mo>)</mo><mo>(</mo><mi>m</mi><mi mathvariant=\"normal\">−</mi><mn>2</mn><mo>)</mo></mrow></msup><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">f(S)=\\sum\\limits_{1\\le a_1&lt;a_2&lt;⋯&lt;a_m\\le n}\\left[\\left(\\prod\\limits_{1\\le i,j\\le m}|P(a_i,a_j)\\cap S|\\right)\\ge 1.242803739^{(m−1)(m−2)}\\right]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.163777em;vertical-align:-1.413777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.050005em;\"><span style=\"top:-1.882887em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">≤</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">&lt;</span><span class=\"minner mtight\">⋯</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16454285714285719em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\">n</span></span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.367213em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">[</span></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">(</span></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.050005em;\"><span style=\"top:-1.8723309999999997em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathdefault mtight\">m</span></span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∏</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.413777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">)</span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">2</span><span class=\"mord\">8</span><span class=\"mord\">0</span><span class=\"mord\">3</span><span class=\"mord\">7</span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord\">9</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.938em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">m</span><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">m</span><span class=\"mord mtight\">−</span><span class=\"mord mtight\">2</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">]</span></span></span></span></span></span></span></p>\n</blockquote>\n<blockquote>\n<p>鸽子会告诉你树边 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>e</mi><mrow><mi>n</mi><mi mathvariant=\"normal\">−</mi><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">e_1,e_2,\\dots,e_{n−1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>你需要依次求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>}</mo><mo>)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><mo>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo>}</mo><mo>)</mo><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><mo>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>e</mi><mrow><mi>n</mi><mi mathvariant=\"normal\">−</mi><mn>1</mn></mrow></msub><mo>}</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(\\{e_1\\}),f(\\{e_1,e_2\\}),\\dots,f(\\{e_1,e_2,\\dots,e_{n−1}\\})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mclose\">)</span></span></span></span>，答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1914270647</mn></mrow><annotation encoding=\"application/x-tex\">1914270647</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">9</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mord\">2</span><span class=\"mord\">7</span><span class=\"mord\">0</span><span class=\"mord\">6</span><span class=\"mord\">4</span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 鸽子的老家是一棵 nnn 个节点的树，节点编号为 1∼n1\\sim n1∼n。这是鸽子三年来第一次回老家，鸽子发现树的边受了些损伤。设损伤的边集为 SSS，P(a,b)P(a,b)P(a,b) 表示节点 aaa 和 bbb 之间简单路径的边集，鸽子用下面这个函数表示树的受损程度： f(S)=∑1≤a1&lt;a2&lt;⋯&lt;am≤n[(∏1≤i,j≤m∣P(ai,aj)∩S∣)≥1.242803739(m−1)(m−2)]f(S)=\\sum\\limits_{1\\le a_1&lt;a_2&lt;⋯&lt;a_m\\le n}\\left[\\left(\\prod\\limits_{1\\le i,j\\le m}|P(a_i,a_j)\\cap S|\\right)\\ge 1.242803739^{(m−1)(m−2)}\\right] f(S)=1≤a1​&lt;a2​&lt;⋯&lt;am​≤n∑​[(1≤i,j≤m∏​∣P(ai​,aj​)∩S∣)≥1.242803739(m−1)(m−2)] 鸽子会告诉你树边 e1,e2,…,en−1e_1,e_2,\\dots,e_{n−1}e1​,e2​,…,en−1​。 你需要依次求出 f({e1}),f({e1,e2}),…,f({e1,e2,…,en−1})f(\\{e_1\\}),f(\\{e_1,e_2\\}),\\dots,f(\\{e_1,e_2,\\dots,e_{n−1}\\})f({e1​}),f({e1​,e2​}),…,f({e1​,e2​,…,en−1​})，答案对 191427064719142706471914270647 取模。 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤m≤101\\le m\\le 101≤m≤10。 诈骗题。 首先考虑依照没坏的边把原图分成多个连通块，这些连通块之间通过坏掉的边形成一棵树。那么选出的 mmm 个点一定不能在同一个连通块中，否则会有某个 ∣P(ai,aj)∩S∣|P(a_i,a_j)\\cap S|∣P(ai​,aj​)∩S∣ 为 000。 观察到这样的 (i,j)(i,j)(i,j) 一共有 (m2)=m(m−1)2\\binom{m}{2}=\\frac{m(m-1)}{2}(2m​)=2m(m−1)​ 对，由于 mmm 个点组成的是一个树形结构，最多有 m−1m-1m−1 对点的 ∣P(ai,aj)∩S∣|P(a_i,a_j)\\cap S|∣P(ai​,aj​)∩S∣ 是 111。并且由于 1.2428037392&lt;21.242803739^2&lt;21.2428037392&lt;2，那么有： 2(m2)−(m−1)=2m(m−1)2−(m−1)=2(m−1)(m−2)2≥2(m−1)(m−2)2≥(1.2428037392)(m−1)(m−2)2≥1.242803739(m−1)(m−2)2^{\\binom{m}{2}-(m-1)}=2^{\\frac{m(m-1)}{2}-(m-1)}=2^{\\frac{(m-1)(m-2)}{2}}\\ge 2^{\\frac{(m-1)(m-2)}{2}}\\ge (1.242803739^2)^{\\frac{(m-1)(m-2)}{2}}\\ge 1.242803739^{(m-1)(m-2)} 2(2m​)−(m−1)=22m(m−1)​−(m−1)=22(m−1)(m−2)​≥22(m−1)(m−2)​≥(1.2428037392)2(m−1)(m−2)​≥1.242803739(m−1)(m−2) 所以只要选出的 mmm 个点不属于一个连通块就行了，1.2428037391.2428037391.242803739 就是诈骗的。 考虑怎么求出 f({e1}),f({e1,e2}),…,f({e1,e2,…,en−1})f(\\{e_1\\}),f(\\{e_1,e_2\\}),\\dots,f(\\{e_1,e_2,\\dots,e_{n−1}\\})f({e1​}),f({e1​,e2​}),…,f({e1​,e2​,…,en−1​})，显然可以倒过来变成加边，然后用退背包退掉合并前连通块的贡献。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005,MS=15; const long long p=1914270647; int n,m; int xs[S],ys[S]; int fa[S],siz[S]; long long dp[MS],pd[MS]; long long ans[S]; int fnd(int u) { return fa[u]==u?u:fa[u]=fnd(fa[u]); } inline void meg(int x,int y) { int rx=fnd(x),ry=fnd(y); fa[rx]=ry; siz[ry]+=siz[rx]; } inline void add(long long &amp;x,long long y) { x+=y; if(x&gt;=p) x-=p; } int main() { freopen(&quot;hometown.in&quot;,&quot;r&quot;,stdin); freopen(&quot;hometown.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) scanf(&quot;%d%d&quot;,&amp;xs[i],&amp;ys[i]); for(int i=1;i&lt;=n;i++) fa[i]=i,siz[i]=1; dp[0]=1; for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=1;j--) add(dp[j],dp[j-1]); for(int i=n-1;i&gt;=1;i--) { ans[i]=dp[m]; int x=xs[i],y=ys[i]; int sx=siz[fnd(x)],sy=siz[fnd(y)]; for(int j=0;j&lt;=m;j++) { pd[j]=dp[j]; if(j&gt;=1) add(pd[j],p-pd[j-1]*sx%p); } for(int j=0;j&lt;=m;j++) dp[j]=pd[j]; for(int j=0;j&lt;=m;j++) { pd[j]=dp[j]; if(j&gt;=1) add(pd[j],p-pd[j-1]*sy%p); } for(int j=0;j&lt;=m;j++) dp[j]=pd[j]; for(int j=m;j&gt;=1;j--) add(dp[j],dp[j-1]*(sx+sy)%p); meg(x,y); } for(int i=1;i&lt;=n-1;i++) printf(&quot;%lld\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛10】鸽子的老家 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-10-ge-zi-de-lao-jia-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":322000,"words":985,"minutes":6},"date":"2023-04-15 16:09:36","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>有⼀个⻓度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>，每⼀位为 <code>*</code> 或 <code>+</code>，你需要选择⼀个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 的⼦序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span>，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mspace></mspace><mspace width=\"0.6666666666666666em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">f(t) \\mod 2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">t</span><span class=\"mclose\">)</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> 最⼤。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">t</span><span class=\"mclose\">)</span></span></span></span> 表示依次遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> 中元素后的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 值：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 开始，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为 <code>*</code> 则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 乘 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> ，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为 <code>+</code> 则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 加 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> ，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 初始为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<p>注意：⼀个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 的⼦序列，当且仅当 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> 可以通过删除 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 中⼀些位置的元素得到。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,k\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有⼀个⻓度为 nnn 的序列 sss，每⼀位为 * 或 +，你需要选择⼀个 sss 的⼦序列 ttt，使得 f(t)mod 2kf(t) \\mod 2^kf(t)mod2k 最⼤。 f(t)f(t)f(t) 表示依次遍历 ttt 中元素后的 xxx 值：iii 从 111 开始，如果 tit_iti​ 为 * 则 xxx 乘 222 ，如果 tit_iti​ 为 + 则 xxx 加 111 ，xxx 初始为 000。 注意：⼀个序列 ttt 为 sss 的⼦序列，当且仅当 ttt 可以通过删除 sss 中⼀些位置的元素得到。 1≤n,k≤1061\\le n,k\\le 10^61≤n,k≤106。 先维护出一个数组 aaa，求出每个 + 后面 * 的个数 xxx，即这个 + 最多可以贡献到 2x2^x2x，然后让 ax→ax+1a_x\\to a_x+1ax​→ax​+1。 接下来贪心的进位，按 iii 从小到大遍历 aaa，若 ai≥3a_i\\ge 3ai​≥3 则让 ai+1→ai+1+1a_{i+1}\\to a_{i+1}+1ai+1​→ai+1​+1，ai→ai−2a_i\\to a_i-2ai​→ai​−2，注意到这样可以让来自相邻两个 * 的 + 在 aaa 上留下连续的一段 111 或者 222，并且可以避免进了不需要进的位的情况。 然后就可以求出答案了，从高位往低位贪心，设当前是第 iii 位，那么： 存在 j≥ij\\ge ij≥i 满足 aj=0a_j\\not=0aj​​=0：那么直接让这一位的 111 贡献给第 iii 位，ansi=1ans_i=1ansi​=1，并且让 aj=0a_j=0aj​=0。注意到由于来自相邻两个 * 的 + 在 aaa 上留下连续的一段 111 或者 222，这些 + 会在答案中留下连续的一段 111，所以这样”强扯“过来是可行的，相当于把最后一个 * 从子序列中删去； 不存在 j≥ij\\ge ij≥i 满足 aj=0a_j\\not=0aj​​=0：那么要么 ansi=0ans_i=0ansi​=0，要么找到 111111211111121111112 这样的一段 aaa 进位到 aia_iai​，由于进位之后这些位置都会变成 000，所以直接暴力找即可； 由于高位为 111 一定更优，所以这样贪心是对的，时间复杂度 O(n)O(n)O(n)。 代码如下： // Problem: #A. sequence // Contest: Hydro // URL: http://oiclass.com/d/AKNOI/p/185?tid=63fd6c6355e89e02d91afefd // Memory Limit: 512 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005; int n,k; char str[S]; int sum[S],a[S*2]; int ans[S]; int main() { freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin); freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); k--; scanf(&quot;%s&quot;,str+1); sum[n]=str[n]=='*'; for(int i=n-1;i&gt;=1;i--) sum[i]=sum[i+1]+(str[i]=='*'); for(int i=1;i&lt;=n;i++) if(str[i]=='+') a[sum[i]]++; for(int i=0;i&lt;=n*2;i++) { if(a[i]&gt;=3) { a[i+1]+=a[i]/2-(a[i]&amp;1^1); a[i]=1+(a[i]&amp;1^1); } } for(int i=k,j=n*2;i&gt;=0;i--) { while(j&gt;=i&amp;&amp;a[j]==0) j--; if(j&gt;=i) a[j]=0,ans[i]=1; else { int res=-1; for(int l=i-1;l&gt;=0;l--) { if(a[l]==0) break; if(a[l]==2) { res=l; break; } } if(res!=-1) { for(int l=res;l&lt;=i-1;l++) a[l]=0; ans[i]=1; } } } bool flg=false; for(int i=k;i&gt;=0;i--) { if(ans[i]==1) flg=true; if(flg) printf(&quot;%d&quot;,ans[i]); } if(!flg) puts(&quot;0&quot;); else printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛13】sequence 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-13-sequence-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":227000,"words":772,"minutes":4},"date":"2023-04-15 16:06:31","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>小L初学的时候学到了如下的点分治算法:</p>\n<ul>\n<li>初始时当前连通块是整棵树。</li>\n<li>首先，在当前连通块中找到任意一个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 作为该次的分治中心（不必是重心）。</li>\n<li>其次，把点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 在当前连通块中删去，可以得到若干个连通块。对于每个连通块再递归进行这样的操作。</li>\n</ul>\n<p>不难发现，这个点分治在最坏情况下递归层数可以达到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> 层。现在，好奇的小 L 想要知道，对于一棵给定的包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的树，他有多少种不同的点分治方案呢？因为答案可能很大，你只需要输出它对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模的值即可。</p>\n<p>两种点分治方案不同当且仅当某一个连通块所选的点分治中心不同。</p>\n<p>为了避免因为大家所学算法的具体细节不同出现歧义，我们还提供了一份暴力代码来具体描述这个算法。</p>\n<pre><code class=\"language-cpp\">const int mod=1e9+7;\nconst int maxn=5005;\nbool vis[maxn];\nvector&lt;int&gt; e[maxn];\nint n;\ninline void view_all(vector&lt;int&gt; &amp;cur,int x,int fa)\n{\n\tcur.push_back(x);\n\tfor(int p: e[x])\n\t{\n\t\tif (vis[p]) continue;\n\t\tif (p == fa) continue;\n\t\tview_all(cur, p, x);\n\t}\n}\ninline int calc(int x)\n{\n\tvector&lt;int&gt; cur;\n\tint ans = 0;\n\tview_all(cur, x, -1);\n\tfor(auto = w : cur)\n\t{\n\t\tint res = 1;\n\t\tvis[w] = 1;\n\t\tfor(auto p: e[w])\n\t\t{\n\t\t\tif (vis[p]) continue;\n\t\t\tres = 1ll * res * calc(p) % mod;\n\t\t}\n\t\tvis[w] = 0;\n\t\tans = (ans + res) % mod;\n\t}\n\treturn ans;\n}\ninline int get_ans()\n{\n\treturn calc(1);\n}\n</code></pre>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 小L初学的时候学到了如下的点分治算法: 初始时当前连通块是整棵树。 首先，在当前连通块中找到任意一个点 uuu 作为该次的分治中心（不必是重心）。 其次，把点 uuu 在当前连通块中删去，可以得到若干个连通块。对于每个连通块再递归进行这样的操作。 不难发现，这个点分治在最坏情况下递归层数可以达到 O(n)O(n)O(n) 层。现在，好奇的小 L 想要知道，对于一棵给定的包含 nnn 个节点的树，他有多少种不同的点分治方案呢？因为答案可能很大，你只需要输出它对 109+710^9+7109+7 取模的值即可。 两种点分治方案不同当且仅当某一个连通块所选的点分治中心不同。 为了避免因为大家所学算法的具体细节不同出现歧义，我们还提供了一份暴力代码来具体描述这个算法。 const int mod=1e9+7; const int maxn=5005; bool vis[maxn]; vector&lt;int&gt; e[maxn]; int n; inline void view_all(vector&lt;int&gt; &amp;cur,int x,int fa) { cur.push_back(x); for(int p: e[x]) { if (vis[p]) continue; if (p == fa) continue; view_all(cur, p, x); } } inline int calc(int x) { vector&lt;int&gt; cur; int ans = 0; view_all(cur, x, -1); for(auto = w : cur) { int res = 1; vis[w] = 1; for(auto p: e[w]) { if (vis[p]) continue; res = 1ll * res * calc(p) % mod; } vis[w] = 0; ans = (ans + res) % mod; } return ans; } inline int get_ans() { return calc(1); } 1≤n≤50001\\le n\\le 50001≤n≤5000。 考虑原树上的一条边 (u,v)(u,v)(u,v)： 考虑断掉 (u,v)(u,v)(u,v) 后对点分树的影响，设断掉 (u,v)(u,v)(u,v) 后 uuu 子树中的点为绿点，vvv 子树中的点为红点，那么由于所有红点和所有绿点只有一条边相连，所以断边前的点分树一定只有一条极长链是既包含绿点又包含红点的： 那么假设这条链是这样的： 断边之后为了保证祖先-后代关系，就一定要这样连： 即每个点的新父亲都是它所有祖先中最深的和它颜色一样的点。 注意到由于保证了祖先-后代关系，所以同一个点分树断不同的边得到的结果是互不相同的，同一个点分树断相同的边得到的结果是相同的。 考虑把这个操作倒过来，合并两棵子树。观察到这个操作对 uuu 和 vvv 这两个点在对应点分树中的子孙都没有影响，所以把 uuu、vvv 到它的子树的点分树的根的链画出来： 那么为了保证不同的两棵小点分树合并出来的点分树不同，相同两棵小点分树合并出来的点分树相同，同样需要保证合并后的祖先-后代关系一致，那么类似归并排序，只要保证这两条链的相对顺序就行了。设绿色链的长度为 xxx，红色链的长度为 yyy，那么合并的方案数即为 (x+yx)\\binom{x+y}{x}(xx+y​)。 考虑用树上背包维护合并的过程，设 dpu,xdp_{u,x}dpu,x​ 表示 uuu 的子树合并完毕，uuu 在点分树中到根的链长度为 xxx 的点分树个数，那么对于每个 uuu 的儿子 vvv，有转移： ∑i=1x∑j=x−isizvdpv,j(x−1i−1)→dpu,x\\sum\\limits_{i=1}^{x}\\sum\\limits_{j=x-i}^{siz_v}dp_{v,j}\\binom{x-1}{i-1}\\to dp_{u,x} i=1∑x​j=x−i∑sizv​​dpv,j​(i−1x−1​)→dpu,x​ 即枚举 uuu 的祖先中有多少个属于 vvv 的点分树的点。注意到这样时间复杂度是 O(n3)O(n^3)O(n3) 的，注意到组合数与 jjj 无关，所以可以做后缀和，这样就可以优化到 O(n2)O(n^2)O(n2)，足以通过本题。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=5005,p=1000000007; int C[S][S]; int n; int esum,to[S*2],nxt[S*2],h[S]; int siz[S],dp[S][S],pd[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } inline void addd(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } void dfs(int u,int fa) { siz[u]=1,dp[u][1]=1; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); for(int j=1;j&lt;=siz[u];j++) { for(int k=0;k&lt;=siz[v];k++) { addd(pd[j+k],1ll*dp[u][j]*dp[v][k]%p*C[j+k-1][j-1]%p); } } siz[u]+=siz[v]; for(int j=1;j&lt;=siz[u];j++) dp[u][j]=pd[j],pd[j]=0; } for(int i=siz[u]-1;i&gt;=0;i--) addd(dp[u][i],dp[u][i+1]); } int main() { freopen(&quot;dianfen.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dianfen.out&quot;,&quot;w&quot;,stdout); for(int i=0;i&lt;=S-3;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } dfs(1,0); printf(&quot;%d\\n&quot;,dp[1][1]); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛09】点分治 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-09-dian-fen-zhi-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":349000,"words":1285,"minutes":6},"date":"2023-04-15 14:48:38","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>罗曼诺夫统一了全世界，开创了人类的新纪元。</p>\n<p>为了让子民们和罗曼诺夫一样卷，罗曼诺夫决定把一年设为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 天，当中只有一天放假，也就是罗曼诺夫的生日。</p>\n<p>然而，罗曼诺夫飞升之后，他的继承人却误解了罗曼诺夫的意思，没能继承罗曼诺夫的卷志。每一个继承人登基时都会把自己的生日设为假日，并且如果存在一天，它前后都是假日，那么这天也会被自动设为假日。 <strong>把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 天看做一个环，也就是说第一天和第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 天相邻</strong>。</p>\n<p>我们假设每年会换一个继承人，所有人的生日都独立在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 天中随机。</p>\n<p>工作日逐渐减少，人民无所事事。当一年之中只剩下小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 天工作日的时候，国家终于崩溃了。</p>\n<p>天上的罗曼诺夫预料到了这一切。请你帮他算一下，在亡国之前，每一年的<strong>权值</strong>之和的期望。</p>\n<p>定义一年的权值为这一年中假期的总天数的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> 次方。</p>\n<p>更加严谨的描述：从初始全都不是假日开始，令计数器 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">cnt=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> ，一直执行以下操作：</p>\n<ul>\n<li>在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 天中均匀随机一天，把它设为假日。</li>\n<li>把两边都是假日的日期也变成假日。</li>\n<li>设此时假日的个数为 <em>s</em> 。如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi><mi mathvariant=\"normal\">−</mi><mi>s</mi><mo>≤</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">D−s\\le K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord\">−</span><span class=\"mord mathdefault\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 那么退出循环，否则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><msup><mo>←</mo><mo>+</mo></msup><msup><mi>s</mi><mi>t</mi></msup></mrow><annotation encoding=\"application/x-tex\">cnt\\leftarrow^+ s^t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">←</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7935559999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7935559999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">t</span></span></span></span></span></span></span></span></span></span></span> 并返回第一步。</li>\n</ul>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">cnt</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span></span></span></span> 的期望，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>K</mi><mo>&lt;</mo><mi>D</mi><mo>≤</mo><mn>2000</mn><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>t</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le K&lt;D\\le 2000,0\\le t\\le 10^8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 罗曼诺夫统一了全世界，开创了人类的新纪元。 为了让子民们和罗曼诺夫一样卷，罗曼诺夫决定把一年设为 DDD 天，当中只有一天放假，也就是罗曼诺夫的生日。 然而，罗曼诺夫飞升之后，他的继承人却误解了罗曼诺夫的意思，没能继承罗曼诺夫的卷志。每一个继承人登基时都会把自己的生日设为假日，并且如果存在一天，它前后都是假日，那么这天也会被自动设为假日。 把 DDD 天看做一个环，也就是说第一天和第 DDD 天相邻。 我们假设每年会换一个继承人，所有人的生日都独立在 DDD 天中随机。 工作日逐渐减少，人民无所事事。当一年之中只剩下小于等于 KKK 天工作日的时候，国家终于崩溃了。 天上的罗曼诺夫预料到了这一切。请你帮他算一下，在亡国之前，每一年的权值之和的期望。 定义一年的权值为这一年中假期的总天数的 ttt 次方。 更加严谨的描述：从初始全都不是假日开始，令计数器 cnt=0cnt=0cnt=0 ，一直执行以下操作： 在 DDD 天中均匀随机一天，把它设为假日。 把两边都是假日的日期也变成假日。 设此时假日的个数为 s 。如果 D−s≤KD−s\\le KD−s≤K 那么退出循环，否则 cnt←+stcnt\\leftarrow^+ s^tcnt←+st 并返回第一步。 求 cntcntcnt 的期望，对 998244353998244353998244353 取模。 0≤K&lt;D≤2000,0≤t≤1080\\le K&lt;D\\le 2000,0\\le t\\le 10^80≤K&lt;D≤2000,0≤t≤108。 注意到共有 iii 天假日时有 jjj 段独立的连续假日段所有情况的概率都是一样的，所以可以设 dpi,jdp_{i,j}dpi,j​ 表示共有 iii 天假日时，有 jjj 段独立的连续假日段的所有情况的总概率，并且暂时先不考虑选择的假日之前被选过的情况。 设 calc⁡(i,j)\\operatorname{calc}(i,j)calc(i,j) 表示有 iii 天假日，分成 jjj 段独立的连续假日段的方案数，即 dpi,jdp_{i,j}dpi,j​ 中共有多少种情况，显然可以用插板法快速求出，那么每种情况的概率即为 ech=dpi,jcalc⁡(i,j)ech=\\frac{dp_{i,j}}{\\operatorname{calc}(i,j)}ech=calc(i,j)dpi,j​​。 转移考虑下一次选择作为假日的是哪一天，首先所有转移的方案数和为 all=(D−i)×calc⁡(i,j)all=(D-i)\\times \\operatorname{calc}(i,j)all=(D−i)×calc(i,j)，接下来分类讨论： 若下一次选择的日期把两个连续段连了起来： 消去长度为 333 的工作日段的方案数为 de3=j×calc⁡(i+3,j−1)de3=j\\times\\operatorname{calc}(i+3,j-1)de3=j×calc(i+3,j−1)，有转移 echD−i×de3→dpi+3,j−1\\frac{ech}{D-i}\\times de3\\to dp_{i+3,j-1} D−iech​×de3→dpi+3,j−1​ 消去长度为 222 的工作日段的方案数为 de2=2×j×calc⁡(i+2,j−1)de2=2\\times j\\times\\operatorname{calc}(i+2,j-1)de2=2×j×calc(i+2,j−1)，有转移 echD−i×de2→dpi+2,j−1\\frac{ech}{D-i}\\times de2\\to dp_{i+2,j-1} D−iech​×de2→dpi+2,j−1​ 若下一次选择的日期并入了某个连续段： 紧挨着之前的连续段的方案数为 wi1=2×j×calc⁡(i+1,j)wi1=2\\times j\\times \\operatorname{calc}(i+1,j)wi1=2×j×calc(i+1,j)，有转移 echD−i×wi1→dpi+1,j\\frac{ech}{D-i}\\times wi1\\to dp_{i+1,j} D−iech​×wi1→dpi+1,j​ 和之前某个连续段之间只间隔一天的方案数为 wi2=2×j×calc⁡(i+2,j)wi2=2\\times j\\times \\operatorname{calc}(i+2,j)wi2=2×j×calc(i+2,j)，有转移 echD−i×wi2→dpi+2,j\\frac{ech}{D-i}\\times wi2\\to dp_{i+2,j} D−iech​×wi2→dpi+2,j​ 下一次选择的日期单独开一个连续段的方案数即为 lft=all−de3−de2−wi1−wi2lft=all-de3-de2-wi1-wi2lft=all−de3−de2−wi1−wi2，有转移 echD−i×lft→dpi+1,j+1\\frac{ech}{D-i}\\times lft\\to dp_{i+1,j+1} D−iech​×lft→dpi+1,j+1​ 最后计算答案考虑期望在有 iii 天假期时停留多少轮即可，利用等比数列求和公式推导，有： ans=∑i=1D−K−1∑j=1idpi,j×it×∑k=0∞(iD)k=∑i=1D−K−1∑j=1idpi,j×it×11−iD\\begin{aligned} ans&amp;=\\sum\\limits_{i=1}^{D-K-1}\\sum\\limits_{j=1}^{i} dp_{i,j}\\times i^t\\times\\sum\\limits_{k=0}^{\\infin}\\left(\\frac{i}{D}\\right)^k\\\\ &amp;=\\sum\\limits_{i=1}^{D-K-1}\\sum\\limits_{j=1}^{i} dp_{i,j}\\times i^t\\times\\frac{1}{1-\\frac{i}{D}}\\\\ \\end{aligned} ans​=i=1∑D−K−1​j=1∑i​dpi,j​×it×k=0∑∞​(Di​)k=i=1∑D−K−1​j=1∑i​dpi,j​×it×1−Di​1​​ 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=2005; const int p=998244353; int D,K,t; int C[S][S],dp[S][S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int inv(int x) { return qpow(x,p-2); } inline int calc(int n,int m) { int val=D-n; if(val==0&amp;&amp;m==0) return 1; if(val-m&lt;=0||m&lt;=0) return 0; return C[val-m-1][m-1]; } int main() { freopen(&quot;holiday.in&quot;,&quot;r&quot;,stdin); freopen(&quot;holiday.out&quot;,&quot;w&quot;,stdout); C[0][0]=1; for(int i=1;i&lt;=S-3;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } scanf(&quot;%d%d%d&quot;,&amp;D,&amp;K,&amp;t); dp[1][1]=1; for(int i=1;i&lt;=D-K-2;i++) { for(int j=1;j&lt;=i;j++) { if(dp[i][j]==0) continue; int all=1ll*(D-i)*calc(i,j)%p; int ech=1ll*dp[i][j]*inv(calc(i,j))%p; int de3=1ll*j*calc(i+3,j-1)%p; int de2=1ll*2*j*calc(i+2,j-1)%p; int wi1=1ll*2*j*calc(i+1,j)%p; int wi2=1ll*2*j*calc(i+2,j)%p; int lft=(((long long)all-de3-de2-wi1-wi2)%p+p)%p; add(dp[i+3][j-1],1ll*ech*inv(D-i)%p*de3%p); add(dp[i+2][j-1],1ll*ech*inv(D-i)%p*de2%p); add(dp[i+1][j],1ll*ech*inv(D-i)%p*wi1%p); add(dp[i+2][j],1ll*ech*inv(D-i)%p*wi2%p); add(dp[i+1][j+1],1ll*ech*inv(D-i)%p*lft%p); } } int ans=0; for(int i=1;i&lt;=D-K-1;i++) { int sum=0; for(int j=1;j&lt;=i;j++) add(sum,dp[i][j]); add(ans,1ll*sum*qpow(i,t)%p*inv((1-1ll*i*inv(D)%p+p)%p)%p); } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛08】节日 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-08-jie-ri-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":484000,"words":1636,"minutes":9},"date":"2023-04-15 14:46:48","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>罗曼诺夫跑去打炉石，发现对面很菜，所以想要计算自己一发能干掉几个。</p>\n<p>对方有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个随从，生命值分别是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,a_3,\\dots,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 。罗曼诺夫发动一次技能，会连续攻击 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 次，每次在当前生命值为正的随从中随机选择一个，使得它的生命值减 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。当一个随从的生命值降到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 时它就死掉了。</p>\n<p>问期望能干掉几个随从，答案模 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 输出。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>15</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>200</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 15,1\\le m,a_i\\le 200,m\\le \\sum a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 罗曼诺夫跑去打炉石，发现对面很菜，所以想要计算自己一发能干掉几个。 对方有 nnn 个随从，生命值分别是 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 。罗曼诺夫发动一次技能，会连续攻击 mmm 次，每次在当前生命值为正的随从中随机选择一个，使得它的生命值减 111。当一个随从的生命值降到 000 时它就死掉了。 问期望能干掉几个随从，答案模 998244353998244353998244353 输出。 1≤n≤15,1≤m,ai≤200,m≤∑ai1\\le n\\le 15,1\\le m,a_i\\le 200,m\\le \\sum a_i1≤n≤15,1≤m,ai​≤200,m≤∑ai​。 考虑按时间 dp，设 fi,stf_{i,st}fi,st​ 表示进行了 iii 次操作，死掉的怪物集合是 ststst 概率。fi,stf_{i,st}fi,st​ 一定是形如 ABnx(n−1)y(n−2)z…\\frac{AB}{n^{x}(n-1)^{y}(n-2)^{z}\\dots}nx(n−1)y(n−2)z…AB​ 这样的，其中 AAA 是 u∈stu\\in stu∈st 的部分的方案数，BBB 是 u∈stu\\not\\in stu​∈st 的部分的方案数。注意到 BBB 不好计算，那么先不管它，让 fi,stf_{i,st}fi,st​ 只计算 Anx(n−1)y(n−2)z…\\frac{A}{n^{x}(n-1)^{y}(n-2)^{z}\\dots}nx(n−1)y(n−2)z…A​。 那么有 f0,0=1f_{0,0}=1f0,0​=1，转移枚举第 iii 次操作伤害了哪个小怪： 伤害了 u∉stu\\notin stu∈/​st，那么这部分的贡献属于 BBB，不管： fi,st→fi+1,stf_{i,st}\\to f_{i+1,st} fi,st​→fi+1,st​ 伤害了 u∈stu\\in stu∈st，那么这部分的贡献属于 AAA，有： fi,st×(i−∣st∣aj−1)(n−∣st∣)i+1×(n−∣st∣−1)i+1→fi+1,st+{j}\\frac{f_{i,st}\\times \\binom{i-|st|}{a_j-1}}{(n-|st|)^{i+1}}\\times (n-|st|-1)^{i+1}\\to f_{i+1,st+\\{j\\}} (n−∣st∣)i+1fi,st​×(aj​−1i−∣st∣​)​×(n−∣st∣−1)i+1→fi+1,st+{j}​ 乘的神秘次幂是为了方便计算 1nx(n−1)y(n−2)z…\\frac{1}{n^{x}(n-1)^{y}(n-2)^{z}\\dots}nx(n−1)y(n−2)z…1​，注意到最后 fm,stf_{m,st}fm,st​ 会多乘 (n−∣st∣)m(n-|st|)^m(n−∣st∣)m，那么进行完转移后需要让 fm,st→fm,st(n−∣st∣)mf_{m,st}\\to \\frac{f_{m,st}}{(n-|st|)^m}fm,st​→(n−∣st∣)mfm,st​​。 最后需要考虑计算 BBB，可以设 dpi,jdp_{i,j}dpi,j​ 表示 u∈iu\\in iu∈i 的怪物都没死，剩下的不管的方案数，背包转移即可。注意到这样的时间复杂度是 O(nm2n)O(nm2^n)O(nm2n) 的，过不了，但是注意到可以 meet-in-middle 把时间复杂度变成 O(nm2⌈n2⌉)O(nm2^{\\lceil\\frac{n}{2}\\rceil})O(nm2⌈2n​⌉)，这样就能过了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N=20,M=205,BS=1&lt;&lt;15; const int p=998244353; int n,m,a[N]; int C[M][M],cnt[BS],sum[BS],mylog[BS]; int pw[M][M],qw[M][M]; int f[M][BS],dp[BS][M],pd[BS][M]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); C[0][0]=1; for(int i=1;i&lt;=m;i++) { C[i][0]=1; for(int j=1;j&lt;=m;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++) { for(int j=1;j&lt;=n;j++) { if(i&gt;&gt;j-1&amp;1) { cnt[i]++; sum[i]+=a[j]; } } } mylog[0]=-1; for(int i=1;i&lt;=(1&lt;&lt;n)-1;i++) mylog[i]=mylog[i&gt;&gt;1]+1; pw[0][0]=qw[0][0]=1; for(int i=1;i&lt;=m;i++) { pw[0][i]=qw[0][i]=1; pw[i][0]=1,qw[i][0]=1; int tp=qpow(i,p-2); for(int j=1;j&lt;=m;j++) { pw[i][j]=1ll*pw[i][j-1]*i%p; qw[i][j]=1ll*qw[i][j-1]*tp%p; } } f[0][0]=1; for(int i=0;i&lt;=m-1;i++) { for(int j=0;j&lt;=(1&lt;&lt;n)-1;j++) { if(f[i][j]==0||sum[j]&gt;i) continue; add(f[i+1][j],f[i][j]); for(int k=1;k&lt;=n;k++) { if((j&gt;&gt;k-1&amp;1^1)&amp;&amp;sum[j]+a[k]&lt;=i+1) { add(f[i+1][j|(1&lt;&lt;k-1)], 1ll*f[i][j]*C[i-sum[j]][a[k]-1]%p *qw[n-cnt[j]][i+1]%p*pw[n-cnt[j]-1][i+1]%p ); } } } } for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++) { f[m][i]=1ll*f[m][i]*qw[n-cnt[i]][m]%p; // 除掉算多的次幂 } int lim=n/2; dp[0][0]=1; for(int i=1;i&lt;=(1&lt;&lt;lim)-1;i++) { int id=mylog[i&amp;-i]+1; for(int j=0;j&lt;=m;j++) { for(int k=0;k&lt;=j&amp;&amp;k&lt;a[id];k++) { add(dp[i][j],1ll*dp[i^(i&amp;-i)][j-k]*C[j][k]%p); } } } pd[0][0]=1; for(int i=1;i&lt;=(1&lt;&lt;n-lim)-1;i++) { int id=mylog[i&amp;-i]+lim+1; for(int j=0;j&lt;=m;j++) { for(int k=0;k&lt;=j&amp;&amp;k&lt;a[id];k++) { add(pd[i][j],1ll*pd[i^(i&amp;-i)][j-k]*C[j][k]%p); } } } int ans=0; for(int i=1;i&lt;=(1&lt;&lt;n)-1;i++) { if(sum[i]&gt;m) continue; int stdp=(i^((1&lt;&lt;n)-1))&amp;((1&lt;&lt;lim)-1); int stpd=(i^((1&lt;&lt;n)-1))&gt;&gt;lim; for(int j=0;j&lt;=m-sum[i];j++) { int pre=1ll*dp[stdp][j]*pd[stpd][m-sum[i]-j]%p *C[m-sum[i]][j]%p *f[m][i]%p; add(ans,1ll*cnt[i]*pre%p); } } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023NOI模拟赛08】游戏 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-08-you-xi-zuo-ti-ji-lu/","stats":{"text":"8 min read","time":435000,"words":1324,"minutes":8},"date":"2023-04-15 14:44:58","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>罗曼诺夫发明了一种新的排序方法，所以决定用它来出道题。给定一个排列，这个排序算法会执行以下步骤：</p>\n<ol>\n<li>从排列的开头开始，判断每一对相邻的数是否大小关系正确；</li>\n<li>如果存在相邻的一对数大小关系不正确：\n<ol>\n<li>把较小的那个数丢到排列开头；</li>\n<li>回到步骤一；</li>\n</ol>\n</li>\n<li>排列有序了，结束；</li>\n</ol>\n<p>比如一个排序过程是</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo>→</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4,1,3,2\\to1,4,3,2\\to3,1,4,2\\to1,3,4,2\\to2,1,3,4\\to1,2,3,4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>→</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo>→</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4,1,3,2\\to1,4,3,2\\to3,1,4,2\\to1,3,4,2\\to2,1,3,4\\to1,2,3,4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span></span></span></span></p>\n<p>对于排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> ，设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">F(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span></span></span></span> 表示把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 排序会需要进行多少次步骤二。比如 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mo>(</mo><mo>{</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>}</mo><mo>)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">F(\\{4,1,3,2\\})=5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mopen\">{</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span>。</p>\n<p>类似字符串，可以定义两个排列（允许长度不同）的字典序比较。</p>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> ，求字典序最小的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>p</mi><mo>)</mo><mo>=</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">F(p)=K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">p</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 。可以证明解必定存在。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le K\\le 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 罗曼诺夫发明了一种新的排序方法，所以决定用它来出道题。给定一个排列，这个排序算法会执行以下步骤： 从排列的开头开始，判断每一对相邻的数是否大小关系正确； 如果存在相邻的一对数大小关系不正确： 把较小的那个数丢到排列开头； 回到步骤一； 排列有序了，结束； 比如一个排序过程是 4,1,3,2→1,4,3,2→3,1,4,2→1,3,4,2→2,1,3,4→1,2,3,44,1,3,2\\to1,4,3,2\\to3,1,4,2\\to1,3,4,2\\to2,1,3,4\\to1,2,3,44,1,3,2→1,4,3,2→3,1,4,2→1,3,4,2→2,1,3,4→1,2,3,4 4,1,3,2→1,4,3,2→3,1,4,2→1,3,4,2→2,1,3,4→1,2,3,44,1,3,2\\to1,4,3,2\\to3,1,4,2\\to1,3,4,2\\to2,1,3,4\\to1,2,3,44,1,3,2→1,4,3,2→3,1,4,2→1,3,4,2→2,1,3,4→1,2,3,4 对于排列 ppp ，设 F(p)F(p)F(p) 表示把 ppp 排序会需要进行多少次步骤二。比如 F({4,1,3,2})=5F(\\{4,1,3,2\\})=5F({4,1,3,2})=5。 类似字符串，可以定义两个排列（允许长度不同）的字典序比较。 给定 KKK ，求字典序最小的排列 ppp，使得 F(p)=KF(p)=KF(p)=K 。可以证明解必定存在。 1≤K≤10181\\le K\\le 10^{18}1≤K≤1018。 不难发现排序的过程是从前往后依次把每一个前缀排序，那么每个前缀都可以归纳为这样的形式： 1 2 3 4 5 6 7 ... n+1 n 设这样的序列的操作次数为 f(n)f(n)f(n)，那么有： {f(1)=1f(n)=1+∑i=2n−1f(i−1)\\begin{cases} f(1)=1\\\\ f(n)=1+\\sum\\limits_{i=2}^{n-1}f(i-1) \\end{cases} ⎩⎨⎧​f(1)=1f(n)=1+i=2∑n−1​f(i−1)​ 易得 f(n)=2n−1f(n)=2^{n-1}f(n)=2n−1。 接下来开个栈构造即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1005,BS=62; int ta,tb,a[S],b[S]; int main() { freopen(&quot;sorting.in&quot;,&quot;r&quot;,stdin); freopen(&quot;sorting.out&quot;,&quot;w&quot;,stdout); long long n; scanf(&quot;%lld&quot;,&amp;n); int id=0; long long m=n; for(int i=0;m&gt;0;i++) { if(n&gt;&gt;i&amp;1) { b[++tb]=++id; a[++ta]=++id; m-=1ll&lt;&lt;i; } else { while(tb&gt;0&amp;&amp;ta&lt;=i) a[++ta]=b[tb--]; if(tb==0&amp;&amp;ta&lt;=i) a[++ta]=++id; } } for(int i=1;i&lt;=ta;i++) printf(&quot;%d &quot;,a[i]); for(int i=tb;i&gt;=1;i--) printf(&quot;%d &quot;,b[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛08】排序 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-08-pai-xu-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":201000,"words":660,"minutes":4},"date":"2023-04-15 14:30:59","dateFormat":"2023-04-15"},{"abstract":"","content":"Part 1 普通型生成函数 OGF（O\\mathtt{O}Ordinary G\\mathtt{G}Generating F\\mathtt{F}Function） 普通型生成函数的特征函数是 fi(x)=xif_i(x)=x^ifi​(x)=xi。 1.0 形式幂级数形式 回到生成函数的定义： F(x)=∑i=0∞aifi(x)F(x)=\\sum\\limits_{i=0}^\\infin a_if_i(x) F(x)=i=0∑∞​ai​fi​(x) OGF 的特征函数是 fi(x)=xif_i(x)=x^ifi​(x)=xi，也就是说，OGF 总是可以写成这样的形式： F(x)=∑i=0∞aixiF(x)=\\sum\\limits_{i=0}^\\infin a_ix^i F(x)=i=0∑∞​ai​xi 由于 xxx 是无关紧要的，只是一个形式，并且这种写法带次幂，所以它被叫做形式幂级数形式。 注意到这种形式可以很方便地将生成函数还原回序列，所以从生成函数还原到序列之前往往要先化为形式幂级数形式。 1.1 OGF 的一些运算的意义 为了方便运算，所以生成函数往往规定原序列的负数项为 000。 假设有两个序列 aaa，bbb 和它们的 OGF F(x)F(x)F(x)，G(x)G(x)G(x)，那么： 相加 H(x)=F(x)+G(x)=∑i=0∞(ai+bi)xi\\begin{aligned} H(x)&amp;=F(x)+G(x)\\\\ &amp;=\\sum\\limits_{i=0}^\\infin (a_i+b_i)x^i \\end{aligned} H(x)​=F(x)+G(x)=i=0∑∞​(ai​+bi​)xi​ 相当于是 aaa 和 bbb 对应项相加的序列 ci=ai+bic_i=a_i+b_ici​=ai​+bi​ 的 OGF； 相减 H(x)=F(x)−G(x)=∑i=0∞(ai−bi)xi\\begin{aligned} H(x)&amp;=F(x)-G(x)\\\\ &amp;=\\sum\\limits_{i=0}^\\infin (a_i-b_i)x^i \\end{aligned} H(x)​=F(x)−G(x)=i=0∑∞​(ai​−bi​)xi​ 相当于是 aaa 和 bbb 对应项相减的序列 ci=ai−bic_i=a_i-b_ici​=ai​−bi​ 的 OGF； 乘 xxx xF(x)=∑i=0∞aixi+1=∑i=0∞ai−1xi\\begin{aligned} xF(x)&amp;=\\sum\\limits_{i=0}^\\infin a_ix^{i+1}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin a_{i-1}x^{i} \\end{aligned} xF(x)​=i=0∑∞​ai​xi+1=i=0∑∞​ai−1​xi​ 相当于把原序列整体右移一位； 相乘 H(x)=F(x)G(x)=(∑i=0∞aixi)(∑i=0∞bixi)=∑i=0∞xi∑j=0iajbi−j\\begin{aligned} H(x)&amp;=F(x)G(x)\\\\ &amp;=\\left(\\sum\\limits_{i=0}^\\infin a_ix^i\\right)\\left(\\sum\\limits_{i=0}^\\infin b_ix^i\\right)\\\\ &amp;=\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^ia_jb_{i-j} \\end{aligned} H(x)​=F(x)G(x)=(i=0∑∞​ai​xi)(i=0∑∞​bi​xi)=i=0∑∞​xij=0∑i​aj​bi−j​​ 相当于是 ci=∑j=0iajbi−jc_i=\\sum\\limits_{j=0}^ia_jb_{i-j}ci​=j=0∑i​aj​bi−j​ 的 OGF。组合意义如下： cic_ici​ 表示把 iii 个无标号小球放入 AAA 和 BBB 两个有标号无序集合中，其中 AAA 集合中放 iii 个球的方案数是 aia_iai​，BBB 集合中放 iii 个球的方案数是 bib_ibi​。 1.2 封闭形式 a={1,1,… }a=\\{1,1,\\dots\\}a={1,1,…} 这个数列的 OGF 的形式幂级数形式是 F(x)=∑i=0∞xiF(x)=\\sum\\limits_{i=0}^\\infin x^iF(x)=i=0∑∞​xi，考虑用更简洁的方法表示 F(x)F(x)F(x)： 令 Gn(x)=∑i=0nxiGn+1(x)−Gn(x)=xn+1=1+xGn(x)−Gn(x)=1+(x−1)Gn(x)所以1+(x−1)Gn(x)=xn+1Gn(x)=xn+1−1x−1代入 n=∞,−1&lt;x&lt;1F(x)=G∞(x)=−1x−1=11−x\\text{令 } G_n(x)=\\sum\\limits_{i=0}^nx^i\\\\ \\begin{aligned} &amp;G_{n+1}(x)-G_n(x)\\\\ &amp;=x^{n+1}\\\\ &amp;=1+xG_n(x)-G_n(x)\\\\ &amp;=1+(x-1)G_n(x) \\end{aligned}\\\\ \\text{所以}\\\\ 1+(x-1)G_n(x)=x^{n+1}\\\\ G_n(x)=\\frac{x^{n+1}-1}{x-1}\\\\ \\text{代入 }n=\\infin,-1&lt;x&lt;1\\\\ F(x)=G_{\\infin}(x)=\\frac{-1}{x-1}=\\frac{1}{1-x}\\\\ 令 Gn​(x)=i=0∑n​xi​Gn+1​(x)−Gn​(x)=xn+1=1+xGn​(x)−Gn​(x)=1+(x−1)Gn​(x)​所以1+(x−1)Gn​(x)=xn+1Gn​(x)=x−1xn+1−1​代入 n=∞,−1&lt;x&lt;1F(x)=G∞​(x)=x−1−1​=1−x1​ 也就是说，当 −1&lt;x&lt;1-1&lt;x&lt;1−1&lt;x&lt;1 时，F(x)=11−xF(x)=\\frac{1}{1-x}F(x)=1−x1​，这种**“最简形式”被定义为生成函数的封闭形式**。由于我们并不关心 xxx 的取值，所以可以认为 F(x)=1x−1F(x)=\\frac{1}{x-1}F(x)=x−11​。注意到封闭形式有利于对生成函数进行各种运算，所以往往要把生成函数化为封闭形式再进行各种推导。 总结一下，利用生成函数来对数列进行各种推导主要分成以下几步： 确定特征函数，写出数列对应的生成函数的形式幂级数形式； 根据生成函数的形式幂级数形式求出它的封闭形式； 对所有要参加推导的数列都重复前两步以确定它们的生成函数的封闭形式； 根据题目的需要，对这些封闭形式进行各种运算； 将运算的结果还原回形式幂级数形式，获得答案序列； 1.3 一些常见数列的 OGF 的封闭形式 a={y,yp,yp2,yp3,yp4,… }a={0,1,1,1,1,… }a={0,1,0,1,0,… }a={1,2,3,4,5,… }ai=(ni)n 是给定的常数ai=(n+in)n 是给定的常数ai=ai−1+ai−2,a0=1,a1=1并推导出通项公式ai=∑j=0i−1ajai−j−1,a0=1a=\\{y,yp,yp^2,yp^3,yp^4,\\dots\\}\\\\ a=\\{0,1,1,1,1,\\dots\\}\\\\ a=\\{0,1,0,1,0,\\dots\\}\\\\ a=\\{1,2,3,4,5,\\dots\\}\\\\ a_i=\\binom{n}{i}\\qquad n\\text{ 是给定的常数}\\\\ a_i=\\binom{n+i}{n}\\qquad n\\text{ 是给定的常数}\\\\ a_i=a_{i-1}+a_{i-2},a_0=1,a_1=1\\qquad\\text{并推导出通项公式}\\\\ a_i=\\sum\\limits_{j=0}^{i-1}a_{j}a_{i-j-1},a_0=1 a={y,yp,yp2,yp3,yp4,…}a={0,1,1,1,1,…}a={0,1,0,1,0,…}a={1,2,3,4,5,…}ai​=(in​)n 是给定的常数ai​=(nn+i​)n 是给定的常数ai​=ai−1​+ai−2​,a0​=1,a1​=1并推导出通项公式ai​=j=0∑i−1​aj​ai−j−1​,a0​=1 第一个： F(x)=y∑i=0∞pixi=y(1+xpF(x))=y1−xp\\begin{aligned} F(x)&amp;=y\\sum\\limits_{i=0}^\\infin p^ix^i\\\\ &amp;=y(1+xpF(x))\\\\ &amp;=\\frac{y}{1-xp} \\end{aligned} F(x)​=yi=0∑∞​pixi=y(1+xpF(x))=1−xpy​​ 第二个： F(x)=∑i=1∞xi=x∑i=0∞xi=x1−x\\begin{aligned} F(x)&amp;=\\sum\\limits_{i=1}^{\\infin}x^i\\\\ &amp;=x\\sum\\limits_{i=0}^{\\infin}x^i\\\\ &amp;=\\frac{x}{1-x}\\\\ \\end{aligned} F(x)​=i=1∑∞​xi=xi=0∑∞​xi=1−xx​​ 第三个： F(x)=∑i=0∞[i=2j+1]xi=∑i=0∞x2i+1=x∑i=0∞(x2)i=x1−x2\\begin{aligned} F(x)&amp;=\\sum\\limits_{i=0}^{\\infin}[i=2j+1]x^i\\\\ &amp;=\\sum\\limits_{i=0}^{\\infin}x^{2i+1}\\\\ &amp;=x\\sum\\limits_{i=0}^{\\infin}(x^2)^i\\\\ &amp;=\\frac{x}{1-x^2}\\\\ \\end{aligned} F(x)​=i=0∑∞​[i=2j+1]xi=i=0∑∞​x2i+1=xi=0∑∞​(x2)i=1−x2x​​ 第四个： F(x)=∑i=0∞(i+1)xi=∑i=0∞ixi+∑i=0∞xi=xF(x)+11−x(1−x)F(x)=11−xF(x)=1(1−x)2\\, \\begin{aligned} F(x)&amp;=\\sum\\limits_{i=0}^{\\infin}(i+1)x^i\\\\ &amp;=\\sum\\limits_{i=0}^{\\infin}ix^i+\\sum\\limits_{i=0}^{\\infin}x^i\\\\ &amp;=xF(x)+\\frac{1}{1-x} \\end{aligned}\\\\ (1-x)F(x)=\\frac{1}{1-x}\\\\ F(x)=\\frac{1}{(1-x)^2} F(x)​=i=0∑∞​(i+1)xi=i=0∑∞​ixi+i=0∑∞​xi=xF(x)+1−x1​​(1−x)F(x)=1−x1​F(x)=(1−x)21​ 第五个： F(x)=∑i=0n(ni)xi=(1+x)i\\begin{aligned} F(x)&amp;=\\sum\\limits_{i=0}^{n}\\binom{n}{i}x^i\\\\ &amp;=(1+x)^i\\\\ \\end{aligned} F(x)​=i=0∑n​(in​)xi=(1+x)i​ 第六个： 考虑组合意义，(n+in)\\binom{n+i}{n}(nn+i​) 相当于把 n+i+1n+i+1n+i+1 个相同的小球放进 n+1n+1n+1 个不同的盒子里的方案数，相当于 x1+x2+⋯+xn+1=ix_1+x_2+\\dots+x_{n+1}=ix1​+x2​+⋯+xn+1​=i 的不同非负整数解的个数，相当于 n+1n+1n+1 个 F(x)=∑i=0∞xiF(x)=\\sum\\limits_{i=0}^{\\infin}x^iF(x)=i=0∑∞​xi 乘起来即 (∑i=0∞xi)n+1\\left(\\sum\\limits_{i=0}^{\\infin}x^i\\right)^{n+1}(i=0∑∞​xi)n+1，写成封闭形式即为 (11−x)n+1=1(1−x)n+1(\\frac{1}{1-x})^{n+1}=\\frac{1}{(1-x)^{n+1}}(1−x1​)n+1=(1−x)n+11​。 所以 F(x)=1(1−x)n+1F(x)=\\frac{1}{(1-x)^{n+1}}F(x)=(1−x)n+11​。 第七个： aia_iai​ 就是斐波那契数列的第 iii 项。 显然有 F(x)=xF(x)+x2F(x)−xa0+a0+xa1=1+xF(x)+x2F(x)F(x)=xF(x)+x^2F(x)-xa_0+a_0+xa_1=1+xF(x)+x^2F(x)F(x)=xF(x)+x2F(x)−xa0​+a0​+xa1​=1+xF(x)+x2F(x)，解得 F(x)=11−x−x2F(x)=\\frac{1}{1-x-x^2}F(x)=1−x−x21​。 进一步的，我们可以推导出 aia_iai​ 的通项公式： F(x)=11−x−x2=∑i=0∞(x+x2)i=∑i=0∞∑j=0i(ij)xi+j=∑i=0∞xi∑j=0i(i−jj)\\begin{aligned} F(x)&amp;=\\frac{1}{1-x-x^2}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin (x+x^2)^i\\\\ &amp;=\\sum\\limits_{i=0}^\\infin \\sum\\limits_{j=0}^i \\binom{i}{j}x^{i+j}\\\\ &amp;=\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^i \\binom{i-j}{j}\\\\ \\end{aligned} F(x)​=1−x−x21​=i=0∑∞​(x+x2)i=i=0∑∞​j=0∑i​(ji​)xi+j=i=0∑∞​xij=0∑i​(ji−j​)​ 即 ai=∑j=0i(i−jj)a_i=\\sum\\limits_{j=0}^i \\binom{i-j}{j}ai​=j=0∑i​(ji−j​)。 但是这个式子是 O(n)O(n)O(n) 的，并不是我们熟悉的带 5\\sqrt 55​ 的神秘 O(1)O(1)O(1) 通项。 下面将用另一种方式推出 O(1)O(1)O(1) 的通项，考虑一类我们熟悉的 OGF —— yF(x)=∑i=0∞piyxi=y1−xpyF(x)=\\sum\\limits_{i=0}^\\infin p^iyx^i=\\frac{y}{1-xp}yF(x)=i=0∑∞​piyxi=1−xpy​，由于斐波那契数列的生成函数的封闭形式是 11−x−x2\\frac{1}{1-x-x^2}1−x−x21​，所以需要至少两个这样的 OGF 加起来通分之后才能出现最高次项，那么设： 11−x−x2=A1−ax+B1−bx=A(1−bx)+B(1−ax)(1−ax)(1−bx)=A+B−(aB+Ab)x1−(a+b)x+abx2\\begin{aligned} \\frac{1}{1-x-x^2}&amp;=\\frac{A}{1-ax}+\\frac{B}{1-bx}\\\\ &amp;=\\frac{A(1-bx)+B(1-ax)}{(1-ax)(1-bx)}\\\\ &amp;=\\frac{A+B-(aB+Ab)x}{1-(a+b)x+abx^2}\\\\ \\end{aligned} 1−x−x21​​=1−axA​+1−bxB​=(1−ax)(1−bx)A(1−bx)+B(1−ax)​=1−(a+b)x+abx2A+B−(aB+Ab)x​​ 所以有： {aB+Ab=0A+B=1a+b=1ab=−1\\begin{cases} aB+Ab=0\\\\ A+B=1\\\\ a+b=1\\\\ ab=-1 \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​aB+Ab=0A+B=1a+b=1ab=−1​ 解得： {a=1−52b=1+52A=12−510B=12+510\\begin{cases} a=\\frac{1-\\sqrt 5}{2}\\\\ b=\\frac{1+\\sqrt 5}{2}\\\\ A=\\frac{1}{2}-\\frac{\\sqrt 5}{10}\\\\ B=\\frac{1}{2}+\\frac{\\sqrt 5}{10} \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​a=21−5​​b=21+5​​A=21​−105​​B=21​+105​​​ 所以有 F(x)=∑i=0∞((12−510)(1−52)i+(12+510)(1+52)i)xi=∑i=0∞((1−55)(1−52)i+(1+55)(1+52)i2)xi\\begin{aligned} F(x)&amp;=\\sum\\limits_{i=0}^\\infin \\left((\\frac{1}{2}-\\frac{\\sqrt 5}{10})(\\frac{1-\\sqrt 5}{2})^i+(\\frac{1}{2}+\\frac{\\sqrt 5}{10})(\\frac{1+\\sqrt 5}{2})^i\\right)x^i\\\\ &amp;=\\sum\\limits_{i=0}^\\infin \\left(\\frac{(1-\\frac{\\sqrt 5}{5})(\\frac{1-\\sqrt 5}{2})^i+(1+\\frac{\\sqrt 5}{5})(\\frac{1+\\sqrt 5}{2})^i}{2}\\right)x^i\\\\ \\end{aligned} F(x)​=i=0∑∞​((21​−105​​)(21−5​​)i+(21​+105​​)(21+5​​)i)xi=i=0∑∞​(2(1−55​​)(21−5​​)i+(1+55​​)(21+5​​)i​)xi​ 第八个： aia_iai​ 就是卡特兰数的第 iii 项。 发现这个递推式很像卷积，所以考虑用卷积构造它的生成函数。 设 F(x)=∑i=0∞aixiF(x)=\\sum\\limits_{i=0}^\\infin a_ix^iF(x)=i=0∑∞​ai​xi，则有： F(x)=1+∑i=1∞xi∑j=0i−1ajai−j−1=1+x∑i=0∞xi∑j=0iajai−j=1+xF2(x)=1±1+4x2x\\begin{aligned} F(x)&amp;=1+\\sum\\limits_{i=1}^\\infin x^i\\sum\\limits_{j=0}^{i-1}a^ja^{i-j-1}\\\\ &amp;=1+x\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^ia^ja^{i-j}\\\\ &amp;=1+xF^2(x)\\\\ &amp;=\\frac{1\\pm\\sqrt{1+4x}}{2x} \\end{aligned} F(x)​=1+i=1∑∞​xij=0∑i−1​ajai−j−1=1+xi=0∑∞​xij=0∑i​ajai−j=1+xF2(x)=2x1±1+4x​​​ 现在的问题是取哪个根，我们将其分子有理化： F(x)=21±1+4xF(x)=\\frac{2}{1\\pm\\sqrt{1+4x}} F(x)=1±1+4x​2​ 代入 x=0x=0x=0，这样 F(x)=a0=1F(x)=a_0=1F(x)=a0​=1，显然若分母应取 1+1+4x=21+\\sqrt{1+4x}=21+1+4x​=2，所以 FFF 的封闭形式为 F(x)=1−1+4x2xF(x)=\\frac{1-\\sqrt{1+4x}}{2x}F(x)=2x1−1+4x​​。 1.4 应用 1.4.0 BZOJ3028 食物 在许多不同种类的食物中选出 nnn 个，每种食物的限制如下： 承德汉堡：偶数个 可乐：000 个或 111 个 鸡腿：000 个，111 个或 222 个 蜜桃多：奇数个 鸡块：444 的倍数个 包子：000 个，111 个，222 个或 333 个 土豆片炒肉：不超过一个。 面包：333 的倍数个 每种食物都是以“个”为单位，只要总数加起来是 nnn 就算一种方案。对于给出的 nnn 你需要计算出方案数，对 100071000710007（质数）取模。 考虑对每种食物构造多项式，由于两种食物选出 nnn 个的方案数的生成函数就是它们的生成函数的卷积，所以多种食物总共选出 nnn 个的方案数的生成函数就是他们的生成函数全部卷到一起的结果。 接下来问题就变为求出每种食物的生成函数的封闭形式然后乘起来，最后还原回形式幂级数形式，得到答案。 这里给出每种食物的生成函数的封闭形式： 11−x2\\frac{1}{1-x^2}1−x21​ 1+x1+x1+x 1+x+x2=1−x31−x1+x+x^2=\\frac{1-x^3}{1-x}1+x+x2=1−x1−x3​ x1−x2\\frac{x}{1-x^2}1−x2x​ 11−x4\\frac{1}{1-x^4}1−x41​ 1+x+x2+x3=1−x41−x1+x+x^2+x^3=\\frac{1-x^4}{1-x}1+x+x2+x3=1−x1−x4​ 1+x1+x1+x 11−x3\\frac{1}{1-x^3}1−x31​ 接下来要把它们乘起来： (1+x)(1−x3)x(1−x4)(1+x)(1−x2)(1−x)(1−x2)(1−x4)(1−x)(1−x3)=(1+x)x(1+x)(1−x2)(1−x)(1−x2)(1−x)=(1+x)x(1+x)(1−x)(1+x)(1−x)(1−x)(1+x)(1−x)=x(1−x)(1−x)(1−x)(1−x)=x(1−x)4\\begin{aligned} &amp;\\frac{(1+x)(1-x^3)x(1-x^4)(1+x)}{(1-x^2)(1-x)(1-x^2)(1-x^4)(1-x)(1-x^3)}\\\\ &amp;=\\frac{(1+x)x(1+x)}{(1-x^2)(1-x)(1-x^2)(1-x)}\\\\ &amp;=\\frac{(1+x)x(1+x)}{(1-x)(1+x)(1-x)(1-x)(1+x)(1-x)}\\\\ &amp;=\\frac{x}{(1-x)(1-x)(1-x)(1-x)}\\\\ &amp;=\\frac{x}{(1-x)^4}\\\\ \\end{aligned} ​(1−x2)(1−x)(1−x2)(1−x4)(1−x)(1−x3)(1+x)(1−x3)x(1−x4)(1+x)​=(1−x2)(1−x)(1−x2)(1−x)(1+x)x(1+x)​=(1−x)(1+x)(1−x)(1−x)(1+x)(1−x)(1+x)x(1+x)​=(1−x)(1−x)(1−x)(1−x)x​=(1−x)4x​​ 考虑到 x(1−x)4=x(11−x)4\\frac{x}{(1-x)^4}=x(\\frac{1}{1-x})^4(1−x)4x​=x(1−x1​)4，相当于四个 {1,1,1,1,1,… }\\{1,1,1,1,1,\\dots\\}{1,1,1,1,1,…} 的生成函数乘起来再让系数整体右移一位，也就是 x∑i=0∞(i+33)xi=∑i=0∞(i+23)xix\\sum\\limits_{i=0}^\\infin\\binom{i+3}{3}x^i=\\sum\\limits_{i=0}^\\infin\\binom{i+2}{3}x^ixi=0∑∞​(3i+3​)xi=i=0∑∞​(3i+2​)xi，那么答案即为 (n+23)\\binom{n+2}{3}(3n+2​)。 1.4.1 [P6078 [CEOI2004] Sweets](https://www.luogu.com.cn/problem/P6078) 第 iii 种糖果的生成函数显然是 1−xmi+11−x\\frac{1-x^{m_i+1}}{1-x}1−x1−xmi​+1​，答案的生成函数就是 ∏i=1n1−xmi+1(1−x)n\\frac{\\prod\\limits_{i=1}^n 1-x^{m_i+1}}{(1-x)^n}(1−x)ni=1∏n​1−xmi​+1​。 考虑暴力展开，显然由于 ai=(n+in)a_i=\\binom{n+i}{n}ai​=(nn+i​) 的生成函数的封闭形式就是 1(1−x)n+1\\frac{1}{(1-x)^{n+1}}(1−x)n+11​，所以答案的生成函数可以化为： (∏i=1n1−xmi+1)∑i=0∞(n+i−1i)xi\\left(\\prod\\limits_{i=1}^n 1-x^{m_i+1}\\right)\\sum\\limits_{i=0}^\\infin \\binom{n+i-1}{i}x^i (i=1∏n​1−xmi​+1)i=0∑∞​(in+i−1​)xi 前面的部分可以 O(2n)O(2^n)O(2n) 暴力求出 xxx 的所有指数对应的系数 yixkiy_ix^{k_i}yi​xki​，那么对于所有二元组 (yi,ki)(y_i,k_i)(yi​,ki​)，它对答案的贡献即为： yi∑j=a−ib−ki(n+j−1j)=yi(∑j=0b−ki(n−1+jj)−∑j=0a−ki−1(n−1+jj))=yi((n−1+b−ki+1b−ki)−(n−1+a−ki−1+1a−ki−1))=yi((n+b−kib−ki)−(n+a−ki−1a−ki−1))=yi((n+b−kin)−(n+a−ki−1n))\\begin{aligned} &amp;y_i\\sum\\limits_{j=a-i}^{b-k_i} \\binom{n+j-1}{j}\\\\ &amp;=y_i\\left(\\sum\\limits_{j=0}^{b-k_i} \\binom{n-1+j}{j}-\\sum\\limits_{j=0}^{a-k_i-1} \\binom{n-1+j}{j}\\right)\\\\ &amp;=y_i\\left(\\binom{n-1+b-k_i+1}{b-k_i}-\\binom{n-1+a-k_i-1+1}{a-k_i-1}\\right)\\\\ &amp;=y_i\\left(\\binom{n+b-k_i}{b-k_i}-\\binom{n+a-k_i-1}{a-k_i-1}\\right)\\\\ &amp;=y_i\\left(\\binom{n+b-k_i}{n}-\\binom{n+a-k_i-1}{n}\\right)\\\\ \\end{aligned} ​yi​j=a−i∑b−ki​​(jn+j−1​)=yi​(j=0∑b−ki​​(jn−1+j​)−j=0∑a−ki​−1​(jn−1+j​))=yi​((b−ki​n−1+b−ki​+1​)−(a−ki​−1n−1+a−ki​−1+1​))=yi​((b−ki​n+b−ki​​)−(a−ki​−1n+a−ki​−1​))=yi​((nn+b−ki​​)−(nn+a−ki​−1​))​ 注意到组合数可以直接暴力 O(n)O(n)O(n) 计算（(nm)=n!m!(n−m)!\\binom{n}{m}=\\frac{n!}{m!(n-m)!}(mn​)=m!(n−m)!n!​，由于 m!m!m! 很小，所以可以暴力计算 n×(n−1)×(n−2)×⋯×(n−m+1)mod 2004m!n\\times (n-1)\\times(n-2)\\times\\dots\\times(n-m+1)\\mod 2004m!n×(n−1)×(n−2)×⋯×(n−m+1)mod2004m! 然后除以 m!m!m! 再模 200420042004），时间复杂度即为 O(n2n)O(n2^n)O(n2n)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=15,p=2004; int n,a,b; int m[S]; inline int C(int n,int m) { if(n&lt;0||m&lt;0||m&gt;n) return 0; long long mod=p; long long r1=1,r2=1; for(int i=1;i&lt;=m;i++) r1*=i,mod*=i; for(int i=n;i&gt;=n-m+1;i--) r2=r2*i%mod; // printf(&quot;C(%d %d)=%d\\n&quot;,n,m,r2/r1); return r2/r1%p; } int dfs(int i,int y,int k) { if(i==n+1) return (y*(C(n+b-k,n)-C(n+a-k-1,n))+p)%p; return (dfs(i+1,y,k)+dfs(i+1,-y,k+m[i]+1))%p; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;m[i]); printf(&quot;%d\\n&quot;,dfs(1,1,0)); return 0; } ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"普通型生成函数入门","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/pu-tong-xing-sheng-cheng-han-shu-ru-men/","stats":{"text":"24 min read","time":1411000,"words":4411,"minutes":24},"date":"2023-04-15 14:29:26","dateFormat":"2023-04-15"},{"abstract":"","content":"前言 A：你知道当 nnn 很大的时候怎么快速求 (n0)−(n1)+(n2)−⋯+(−1)n(nn)\\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}-\\dots+(-1)^n\\binom{n}{n}(0n​)−(1n​)+(2n​)−⋯+(−1)n(nn​) 吗？ B：这不是二项式定理的逆运用吗？(1−1)n=∑i=0n(−1)i(ni)=(n0)−(n1)+(n2)−⋯+(−1)n(nn)(1-1)^n=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}=\\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}-\\dots+(-1)^n\\binom{n}{n}(1−1)n=i=0∑n​(−1)i(in​)=(0n​)−(1n​)+(2n​)−⋯+(−1)n(nn​)，所以原式为 000。 上面这种情景其实是经常出现的，很多时候一些数列的操作往往可以被“压缩”成一些简洁式子的运算。 也就是说，可以用函数来表示数列，然后把数列上奇奇怪怪的操作转化为我们熟知的各种运算，最后从运算后的函数还原回数列，求出想要的答案。具体的，可以随便选一些“特征函数”fi(x)f_i(x)fi​(x)，然后定义： F(x)=∑i=0∞aifi(x)F(x)=\\sum\\limits_{i=0}^\\infin a_if_i(x) F(x)=i=0∑∞​ai​fi​(x) 为数列 aaa 的“生成函数”（也可以叫做母函数）。 虽然但是，fi(x)f_i(x)fi​(x) 并不是怎么指定都可以让 F(x)F(x)F(x) 有足以解出题目的性质的，所以生成函数也根据 fi(x)f_i(x)fi​(x) 分为几种。 需要注意的是，F(x)F(x)F(x) 的参数 xxx 是无关紧要的，xxx 取何值并不影响从生成函数还原到数列的过程。所以通常为了令生成函数收敛都会取 −1&lt;x&lt;1-1&lt;x&lt;1−1&lt;x&lt;1。 Part 1 普通型生成函数 OGF（O\\mathtt{O}Ordinary G\\mathtt{G}Generating F\\mathtt{F}Function） 链接。 Part 2 指数型生成函数 EGF（E\\mathtt{E}Exponential G\\mathtt{G}Generating F\\mathtt{F}Function） 链接。 Part 3 生成函数变换 链接。 Part 4 一些练习 4.1 有标号无向简单连通图计数 P4841 [集训队作业2013]城市规划 设 fif_ifi​ 为 iii 个点的有标号无向简单连通图的数量， gig_igi​ 为 iii 个点的有标号无向简单图的数量，F(x)F(x)F(x)、G(x)G(x)G(x) 为这两个数列的 EGF，那么有： G(x)=exp⁡(F(x))G(x)=\\exp(F(x)) G(x)=exp(F(x)) 因为所有无向简单图都可以被分成若干互不区分的连通块。 fif_ifi​ 很好求，有 fi=2(i2)f_i=2^{\\binom{i}{2}}fi​=2(2i​)，那么由于有 ln⁡(G(x))=F(x)\\ln(G(x))=F(x)ln(G(x))=F(x) 所以直接上多项式 ln⁡\\lnln 即可。 4.2 有标号二分图计数 P7364 有标号二分图计数 设 fif_ifi​ 为 iii 个点的有标号二分图数量， gig_igi​ 为 iii 个点的有标号连通二分图，F(x)F(x)F(x)、G(x)G(x)G(x) 为这两个数列的 EGF，那么有： F(x)=exp⁡(G(x))F(x)=\\exp(G(x)) F(x)=exp(G(x)) 设 hih_ihi​ 为 iii 个点的有标号黑白染色图数量，H(x)H(x)H(x) 为它的 EGF，显然有： hi=∑j=0i(ij)2j(i−j)h_i=\\sum\\limits_{j=0}^i \\binom{i}{j}2^{j(i-j)} hi​=j=0∑i​(ji​)2j(i−j) 容易发现，一个有标号连通二分图只有两种染色方案，那么有： H(x)=exp⁡(2G(x))H(x)=\\exp(2G(x))\\\\ H(x)=exp(2G(x)) 由于 F(x)=exp⁡(G(x))F(x)=\\exp(G(x))F(x)=exp(G(x))，所以 F(x)=H(x)F(x)=\\sqrt{H(x)}F(x)=H(x)​。注意到 xy=(x+y2)−(x2)−(y2)xy=\\binom{x+y}{2}-\\binom{x}{2}-\\binom{y}{2}xy=(2x+y​)−(2x​)−(2y​) 所以 H(x)H(x)H(x) 可以卷积求，多项式开根是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，那么总的时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 4.3 有标号毛毛虫计数 毛毛虫：一种特殊的树，满足存在一条路径，使得任何一个点到路径的距离不超过 111。 考虑一节一节”组装“毛毛虫，显然单独一节毛毛虫是一个菊花，其 EGF 为 G(x)=∑i=1∞ixii!G(x)=\\sum\\limits_{i=1}^\\infin i\\frac{x^i}{i!}G(x)=i=1∑∞​ii!xi​ 但是头和尾要特殊考虑，因为端点节只有一个点时会被端点前面那一节连出来很多点的情况算上。 那么不妨强制钦定端点节至少由两个点组成，那么端点节的 EGF 为 B(x)=∑i=2∞ixii!B(x)=\\sum\\limits_{i=2}^\\infin i\\frac{x^i}{i!}B(x)=i=2∑∞​ii!xi​。 那么答案的 EGF 即为： F(x)=B(x)212∑i=0∞Ai(x)=B(x)212∑i=0∞Ai(x)=B(x)22(1−A(x))\\begin{aligned} F(x)&amp;=B(x)^2\\frac{1}{2}\\sum\\limits_{i=0}^{\\infin}A^i(x)\\\\ &amp;=B(x)^2\\frac{1}{2}\\sum\\limits_{i=0}^{\\infin}A^i(x)\\\\ &amp;=\\frac{B(x)^2}{2(1-A(x))}\\\\ \\end{aligned} F(x)​=B(x)221​i=0∑∞​Ai(x)=B(x)221​i=0∑∞​Ai(x)=2(1−A(x))B(x)2​​ 注意菊花和 n≤2n\\le 2n≤2 的情况要特判。 4.4 有标号 DAG 计数 DAG：有向无环图。 P6295 有标号 DAG 计数 考虑不断加入入度为 000 的点集，设 fnf_nfn​ 为 nnn 个点的 DAG 个数，那么有： fn=∑i=1n(ni)2i(n−i)fn−if_n=\\sum\\limits_{i=1}^{n}\\binom{n}{i}2^{i(n-i)}f_{n-i} fn​=i=1∑n​(in​)2i(n−i)fn−i​ 但是这样 G={1→3,2→3}G=\\{1\\to 3,2\\to 3\\}G={1→3,2→3} 会被算重，发现一个点集 SSS 的所有子集 T⊆ST\\subseteq ST⊆S 都会把 SSS 算一次，那么根据： (1−1)n=∑i=0n(−1)i(ni)=[n=0]∑i=1n(−1)i−1(ni)=[n=0](1-1)^n=\\sum\\limits_{i=0}^n (-1)^i\\binom{n}{i}=[n=0]\\\\ \\sum\\limits_{i=1}^n (-1)^{i-1}\\binom{n}{i}=[n\\not=0]\\\\ (1−1)n=i=0∑n​(−1)i(in​)=[n=0]i=1∑n​(−1)i−1(in​)=[n​=0] 所以有容斥： fn=∑i=1n(−1)i−1(ni)2i(n−i)fn−if_n=\\sum\\limits_{i=1}^{n}(-1)^{i-1}\\binom{n}{i}2^{i(n-i)}f_{n-i} fn​=i=1∑n​(−1)i−1(in​)2i(n−i)fn−i​ 由于 xy=(x+y2)−(x2)−(y2)xy=\\binom{x+y}{2}-\\binom{x}{2}-\\binom{y}{2}xy=(2x+y​)−(2x​)−(2y​)，所以这个东西可以直接分治 NTT。 考虑设 F(x)=∑i=0∞fii!2(i2)xiF(x)=\\sum\\limits_{i=0}^\\infin \\frac{f_i}{i!2^{\\binom{i}{2}}}x^iF(x)=i=0∑∞​i!2(2i​)fi​​xi，G(x)=∑i=1∞(−1)i−1i!2(i2)xiG(x)=\\sum\\limits_{i=1}^\\infin\\frac{(-1)^{i-1}}{i!2^{\\binom{i}{2}}}x^iG(x)=i=1∑∞​i!2(2i​)(−1)i−1​xi，那么有： F(x)≡F(x)G(x)+1(modxn)F(x)≡11−G(x)(modxn)\\begin{aligned} F(x)&amp;\\equiv F(x)G(x)+1\\pmod{x^n}\\\\ F(x)&amp;\\equiv \\frac{1}{1-G(x)}\\pmod{x^n} \\end{aligned} F(x)F(x)​≡F(x)G(x)+1(modxn)≡1−G(x)1​(modxn)​ 那么求逆就行了，优化掉了一个 log⁡\\loglog。 但是洛谷上的题要求图必须弱联通，所以需要再 ln⁡\\lnln 一下。 ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"生成函数入门","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/sheng-cheng-han-shu-ru-men/","stats":{"text":"9 min read","time":496000,"words":1699,"minutes":9},"date":"2023-04-15 14:28:39","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2,3,\\ldots,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 和两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>。</p>\n<p>将这些数分成恰好 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 组使得每组的异或和都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>。具体地，每个数都必须出现在恰好一组内。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n\\le 2\\cdot 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le x\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 个数 [1,2,3,…,n][1,2,3,\\ldots,n][1,2,3,…,n] 和两个正整数 kkk 和 xxx。 将这些数分成恰好 kkk 组使得每组的异或和都是 xxx。具体地，每个数都必须出现在恰好一组内。 1≤k≤n≤2⋅1051\\le k\\le n\\le 2\\cdot 10^51≤k≤n≤2⋅105，1≤x≤1091\\le x\\le 10^91≤x≤109。 首先考虑无解情况，显然若 1⊕2⊕3⊕⋯⊕n=[kmod⁡2=1]x1\\oplus2\\oplus 3\\oplus\\dots\\oplus n\\not=[k\\operatorname{mod}2=1]x1⊕2⊕3⊕⋯⊕n​=[kmod2=1]x 则无解，还有一个不那么显然的是若 1,2,3,…n1,2,3,\\dots n1,2,3,…n 中 xxx 的最高位为 111 的数的个数比 kkk 小也无解。 接下来考虑构造解，显然由于 x⊕x⊕x=xx\\oplus x\\oplus x=xx⊕x⊕x=x 且 1⊕2⊕3⊕⋯⊕n=[kmod⁡2=1]x1\\oplus2\\oplus 3\\oplus\\dots\\oplus n=[k\\operatorname{mod}2=1]x1⊕2⊕3⊕⋯⊕n=[kmod2=1]x，所以只要最大化分的组数就行了。 首先若 1≤x≤n1\\le x\\le n1≤x≤n 则显然 xxx 单独分一组最优。 接下来设 xxx 的最高位为 2k2^k2k，那么每一组中都至少要有一个数二进制第 kkk 位为 111，不妨设二进制第 kkk 位为 111 且不是 xxx 的数的集合为 SSS，那么对于所有 y∈Sy\\in Sy∈S，都有 x⊕y&lt;yx\\oplus y&lt;yx⊕y&lt;y，且对于任意两个不同的 a∈S,b∈Sa\\in S,b\\in Sa∈S,b∈S，x⊕ax\\oplus ax⊕a 和 x⊕bx\\oplus bx⊕b 都不同，所以每个 a∈Sa\\in Sa∈S 都可以找到一个唯一对应的数 b=x⊕ab=x\\oplus ab=x⊕a 组成一组 {a,b}\\{a,b\\}{a,b}。 这样分组之后显然所有二进制第 kkk 位为 111 的数都单独在一个组，没被分组的数中一定没有二进制第 kkk 位为 111 的了，所以这样分组是最优的，并且剩下的所有数异或起来为 000。所以剩下的数可以一起并入任意一组。 设当前分的组数为 mmm，那么有 m≡k(mod2)m\\equiv k\\pmod 2m≡k(mod2)，所以可以不断利用 x⊕x⊕x=xx\\oplus x\\oplus x=xx⊕x⊕x=x 来合并多余的组，最终一定能得到 kkk 组。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005; int n,k,x; bool vis[S]; inline void slove() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;x); int sum=0; for(int i=1;i&lt;=n;i++) sum^=i; if(sum!=(k&amp;1)*x) return puts(&quot;NO&quot;),void(); int higbit=-1,tmp=x; while(tmp&gt;0) tmp&gt;&gt;=1,higbit++; int cnt=0; for(int i=1;i&lt;=n;i++) if(i&gt;&gt;higbit&amp;1) cnt++; if(cnt&lt;k) return puts(&quot;NO&quot;),void(); for(int i=1;i&lt;=n;i++) vis[i]=false; puts(&quot;YES&quot;); int tot=0; if(tot==k-1) { cnt=0; for(int i=1;i&lt;=n;i++) if(!vis[i]) cnt++; printf(&quot;%d &quot;,cnt); for(int i=1;i&lt;=n;i++) if(!vis[i]) printf(&quot;%d &quot;,i); printf(&quot;\\n&quot;); return; } if(x&lt;=n) vis[x]=true,printf(&quot;1 %d\\n&quot;,x),tot++; for(int i=1;i&lt;=n;i++) { if(tot==k-1) { cnt=0; for(int i=1;i&lt;=n;i++) if(!vis[i]) cnt++; printf(&quot;%d &quot;,cnt); for(int i=1;i&lt;=n;i++) if(!vis[i]) printf(&quot;%d &quot;,i); printf(&quot;\\n&quot;); return; } if(!vis[i]&amp;&amp;(i&gt;&gt;higbit&amp;1)) { vis[i]=vis[x^i]=true; printf(&quot;2 %d %d\\n&quot;,i,x^i); tot++; } } } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1787E The Harmonization of XOR 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1787e-the-harmonization-of-xor-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":259000,"words":851,"minutes":5},"date":"2023-04-15 14:27:03","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>有一个初始为空的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，你可以通过如下方式生成一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，刚开始 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 为空。</p>\n<p>接下来进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 次操作，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 次可选的操作如下：</p>\n<ul>\n<li>把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 放入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的开头；</li>\n<li>把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 放入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的末尾；</li>\n</ul>\n<p>接下来再进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 次操作，每次操作可以是下面两种中的一种：</p>\n<ul>\n<li>把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 开头元素从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中删除，并将其放入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的最后；</li>\n<li>把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 末尾元素从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中删除，并将其放入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的最后；</li>\n</ul>\n<p>对于给定的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">n,k,p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，请求出所有不同的可以由以上过程生成的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 中有多少个满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">b_k=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>（质数）取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>≤</mo><mi>p</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^8\\le p\\le 2\\times 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个初始为空的序列 aaa，你可以通过如下方式生成一个序列 bbb，刚开始 bbb 为空。 接下来进行 nnn 次操作，第 iii 次可选的操作如下： 把 iii 放入 aaa 的开头； 把 iii 放入 aaa 的末尾； 接下来再进行 nnn 次操作，每次操作可以是下面两种中的一种： 把 aaa 开头元素从 aaa 中删除，并将其放入 bbb 的最后； 把 aaa 末尾元素从 aaa 中删除，并将其放入 bbb 的最后； 对于给定的 n,k,pn,k,pn,k,p，请求出所有不同的可以由以上过程生成的序列 bbb 中有多少个满足 bk=1b_k=1bk​=1，对 ppp（质数）取模。 1≤k≤n≤5×1051\\le k\\le n\\le 5\\times 10^51≤k≤n≤5×105，108≤p≤2×10910^8\\le p\\le 2\\times 10^9108≤p≤2×109。 注意到进行完 111 和 222 操作之后的序列 aaa 一定是长这样的： 不难发现 333 和 444 操作一定是先取完某一边，取的时候穿插着取另一边，然后取 111，最后剩下的随便取。观察到以 111 为中心的左边和右边的序列是本质相同的，所以可以假设取完的是左边。 不难发现，这样序列 bbb 就会分成两部分，1∼k1\\sim k1∼k 是一部分，k+1∼nk+1\\sim nk+1∼n 是另一部分。前一部分的要求是能划分为两个单调下降的子序列，后一部分可以乱取，方案数为 2n−k−12^{n-k-1}2n−k−1。设第一部分中属于左边的子序列为 AAA，属于右边的子序列为 BBB，那么两部分唯一的限制即为第二部分中属于右边的最后一个元素要小于 BBB 的最后一个元素： 考虑计算第一部分的方案数，为了防止记重，对于一个 b[1,k]b_{[1,k]}b[1,k]​ 的合法方案，不妨从左往右依次考虑，若 bib_ibi​ 可以接到 AAA 的后面则直接接上去，否则再接到 BBB 的后面。容易证明若 b[1,k]b_{[1,k]}b[1,k]​ 合法则 AAA 和 BBB 则可以分完 b[1,k]b_{[1,k]}b[1,k]​，那么考虑设 dpi,jdp_{i,j}dpi,j​ 表示序列长度为 iii，序列中的数两两不同，BBB 的最后一个数是第 jjj 小的方案数。那么考虑 i+1i+1i+1 是在值域中哪里插入的，分为两种情况： 在值域的末尾（比当前最小值小）：此时一定要接在 AAA 的最后，所以转移到 dpi+1,j+1dp_{i+1,j+1}dpi+1,j+1​； 不在值域的末尾，但比当前第 jjj 小数要小：此时一定要接在 BBB 的最后，所以转移到 dpi+1,2≤k≤jdp_{i+1,2\\le k\\le j}dpi+1,2≤k≤j​； 注意到这两种转移很像，所以可以合并为 dpi,jdp_{i,j}dpi,j​ 转移到 dpi+1,2≤k≤j+1dp_{i+1,2\\le k\\le j+1}dpi+1,2≤k≤j+1​。 考虑 dpi,jdp_{i,j}dpi,j​ 可以从哪里转移到： 如图所示，所以有新的转移 dpi,j=dpi,j+1+dpi−1,j−1dp_{i,j}=dp_{i,j+1}+dp_{i-1,j-1}dpi,j​=dpi,j+1​+dpi−1,j−1​，边界条件 dp1,2=1dp_{1,2}=1dp1,2​=1（BBB 为空默认它里面最小的是第 i+1i+1i+1 小的），那么 dpi,jdp_{i,j}dpi,j​ 相当于从 (1,2)(1,2)(1,2) 开始，只能往下和往右上走，不越过直线 y=x+1y=x+1y=x+1，走到 (i,j)(i,j)(i,j) 的方案数。又发现 dp∗,1dp_{*,1}dp∗,1​ 一定是 000，所以可以令 dpi,j′=dpi,j−1dp&#x27;_{i,j}=dp_{i,j-1}dpi,j′​=dpi,j−1​ 即往下移，那么 dpi,jdp_{i,j}dpi,j​ 就相当于是 (1,1)(1,1)(1,1) 往下往右上走，不越过直线 y=xy=xy=x 走到 (i,j−1)(i,j-1)(i,j−1) 的方案数： 发现这样很丑，不好计算，那么计算 dpa,b′dp&#x27;_{a,b}dpa,b′​ 的时候令 pdi,j=dpi,a−j+1′pd_{i,j}=dp&#x27;_{i,a-j+1}pdi,j​=dpi,a−j+1′​ 即把整体”反过来“，dpa,b′=pda,a−b+1dp&#x27;_{a,b}=pd_{a,a-b+1}dpa,b′​=pda,a−b+1​ 就相当于从 (1,a)(1,a)(1,a) 往下往右走，不越过直线 y=a−x+1y=a-x+1y=a−x+1 走到 (a,b)(a,b)(a,b) 的方案数： 再重新对 pdi,jpd_{i,j}pdi,j​ 建系，dpa,b′dp&#x27;_{a,b}dpa,b′​ 就相当于从 (1,1)(1,1)(1,1) 往上往右走，不越过直线 y=xy=xy=x 走到 (a,a−b+1)(a,a-b+1)(a,a−b+1) 的方案数： 遇到格路计数问题，先设 calc⁡(x,y)\\operatorname{calc}(x,y)calc(x,y) 为从 (1,1)(1,1)(1,1) 向右向上走到 (x,y)(x,y)(x,y) 的方案数，即 (x+y−2x−1)\\binom{x+y-2}{x-1}(x−1x+y−2​)。 这是个经典问题，考虑容斥，用所有方案数减去越过直线 y=xy=xy=x 的方案。所有方案数即为 calc⁡(a,a−b+1)\\operatorname{calc}(a,a-b+1)calc(a,a−b+1)，而越过直线的方案数可以考虑以 y=x+1y=x+1y=x+1 为对称轴把 (a,a−b+1)(a,a-b+1)(a,a−b+1) ”翻折“到 (a−b,a+1)(a-b,a+1)(a−b,a+1)： 这样由于第一次越过直线 y=xy=xy=x 的位置 (x0,y0)(x_0,y_0)(x0​,y0​) 一定在直线 y=x+1y=x+1y=x+1 上，所以把 (x0,y0)(x_0,y_0)(x0​,y0​) 之后的路径翻折就可以到达 (a−b,a+1)(a-b,a+1)(a−b,a+1)，而且每个不同的 (x0,y0)(x_0,y_0)(x0​,y0​) 对应的路径都不一样，翻折后当然也不一样： 所以每种越过直线 y=xy=xy=x 的路径都可以转换为从 (1,1)(1,1)(1,1) 向上向右走到 (a−b,a+1)(a-b,a+1)(a−b,a+1) 的路径，方案数为 calc⁡(a−b,a+1)\\operatorname{calc}(a-b,a+1)calc(a−b,a+1)，那么从 (1,1)(1,1)(1,1) 向上向右走到 (a,a−b+1)(a,a-b+1)(a,a−b+1) 且不越过直线 y=xy=xy=x 的方案数即为 calc⁡(a,a−b+1)−calc⁡(a−b,a+1)\\operatorname{calc}(a,a-b+1)-\\operatorname{calc}(a-b,a+1)calc(a,a−b+1)−calc(a−b,a+1)。 这样我们就可以 O(1)O(1)O(1) 计算 dpi,jdp_{i,j}dpi,j​ 了，dpi,jdp_{i,j}dpi,j​ 即为 calc⁡(i,i−j+2)−calc⁡(i−j+1,i+1)\\operatorname{calc}(i,i-j+2)-\\operatorname{calc}(i-j+1,i+1)calc(i,i−j+2)−calc(i−j+1,i+1)。 那么可以枚举 jjj，答案即为 2n−k−1∑i=2k(i−1+n−ki−1)(calc⁡(k−1,k−i+1)−calc⁡(k−i,k))2^{n-k-1}\\sum\\limits_{i=2}^{k}\\binom{i-1+n-k}{i-1}\\left(\\operatorname{calc}(k-1,k-i+1)-\\operatorname{calc}(k-i,k)\\right)2n−k−1i=2∑k​(i−1i−1+n−k​)(calc(k−1,k−i+1)−calc(k−i,k))。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;deque&gt; #include &lt;set&gt; using namespace std; typedef long long ll; const int S=1000005; int n,m; ll p,fra[S],inv[S]; inline ll qpow(ll x,ll y) { ll res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?res*x%p:res; return res; } inline ll C(int n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return fra[n]*inv[n-m]%p*inv[m]%p; } inline void add(ll &amp;x,ll y) { x+=y; if(x&gt;=p) x-=p; } inline ll calc(int x,int y) { if(x&lt;1||y&lt;1) return 0; return C(x+y-2,x-1); } inline ll calcpd(int i,int j) { return (calc(i,i-j+1)-calc(i-j,i+1)+p)%p; } int main() { scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;m,&amp;p); if(m==1) return printf(&quot;%d\\n&quot;,qpow(2,n-2)),0; fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=inv[i]*i%p; ll ans=0; for(int i=2;i&lt;=m;i++) { ll prex=C(i-1+n-m,i-1)*calcpd(m-1,i-1)%p; add(ans,prex); } printf(&quot;%lld\\n&quot;,ans*qpow(2,n-m-1)%p); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2023 NOI 模拟赛 04】小 F 与游戏 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023-noi-mo-ni-sai-04-xiao-f-yu-you-xi-zuo-ti-ji-lu/","stats":{"text":"10 min read","time":585000,"words":2011,"minutes":10},"date":"2023-04-15 14:22:54","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 层的金字塔，你能进行两种操作。</p>\n<p>给某个点染色，代价是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span>。给某一个底边是金字塔的底边的子三角形染色，，代价是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>点数</mtext><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\text{点数}+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">点数</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>。</p>\n<p>现在有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个黑点，求出把所有黑点染色所需的最小代价。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 一个 nnn 层的金字塔，你能进行两种操作。 给某个点染色，代价是 333。给某一个底边是金字塔的底边的子三角形染色，，代价是 点数+2\\text{点数}+2点数+2。 现在有 mmm 个黑点，求出把所有黑点染色所需的最小代价。 1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105。 模拟赛的时候读错题了…… 首先可以把金字塔向左对齐，并且把行数从下到上重新编号（x→n−x+1x\\to n-x+1x→n−x+1），这样问题就变成了选一个点染色或者选一个“到底”的直角三角形染色。 从左向右一列一列考虑，假设考虑到 iii，显然左上角在 iii 这一列前面的所有直角三角形都处理完了，并且这些直角三角形会在当前列即以后留下一个“小尖”： 那么有一个显然的 dp，设 dpi,jdp_{i,j}dpi,j​ 表示处理完前 iii 列，所有直角三角形在第 iii 列的左上角最高为 jjj（即“小尖”和在第 iii 列选的直角三角形覆盖了第 iii 列 jjj 以下的所有点）需要的最少花费。 转移枚举当前列选的直角三角形即可，前缀最小值加上后缀和可以优化到 O(n2)O(n^2)O(n2)。 不难发现，答案上界是 3m3m3m，也就是说选择的直角三角形的左上角的高度 xxx 不会大于 6m≈774\\sqrt{6m}\\approx 7746m​≈774，所以时间复杂度可以优化到 O(774n)O(774n)O(774n)，加上滚动数组优化即可通过本题。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int S=100005,MS=785; int n,m,lim; vector&lt;int&gt; pos[S]; int dp[2][MS]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); lim=min(n,MS-3); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); pos[y].push_back(n-x+1); } for(int i=1;i&lt;=n;i++) sort(pos[i].begin(),pos[i].end()); memset(dp,127,sizeof(dp)); dp[0][0]=0; for(int i=1;i&lt;=n;i++) { int u=i&amp;1,v=i-1&amp;1; memset(dp[u],127,sizeof(dp[u])); int k=0,siz=pos[i].size(); dp[u][0]=dp[v][0]+(siz-k)*3; for(int j=0,k=0;j+1&lt;=lim&amp;&amp;j&lt;=n-i+1;j++) { while(k&lt;pos[i].size()&amp;&amp;pos[i][k]&lt;=j) k++; dp[u][j]=min(dp[u][j],dp[v][j+1]+(siz-k)*3); } k=0; int mn=min(dp[v][0],dp[v][1]); for(int j=1;j&lt;=lim&amp;&amp;j&lt;=n-i+1;j++) { while(k&lt;pos[i].size()&amp;&amp;pos[i][k]&lt;=j) k++; if(j+1&lt;=lim) mn=min(mn,dp[v][j+1]); dp[u][j]=min(dp[u][j],mn+j*(j+1)/2+2+(siz-k)*3); } } printf(&quot;%d\\n&quot;,min(dp[n&amp;1][0],dp[n&amp;1][1])); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF354D Transferring Pyramid 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf354d-transferring-pyramid-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":203000,"words":709,"minutes":4},"date":"2023-04-15 14:20:23","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给出长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <code>01</code> 序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{1\\sim n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">∼</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，<strong>序列中有偶数个 <code>1</code></strong>。NIT 和 TIN 轮流做以下操作，NIT 先手：</p>\n<ul>\n<li>选择位置 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mtext> </mtext><mo>(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">i\\ (1\\le i\\le n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>，满足区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span></span></span></span> 中有奇数个 <code>1</code>。再选择位置 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mtext> </mtext><mo>(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">j\\ (i&lt;j\\le n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>。将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i,a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 都取反（即，<code>0</code> 变 <code>1</code>，<code>1</code> 变 <code>0</code>）</li>\n</ul>\n<p>当整个序列中的所有元素都变为 <code>0</code> 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都<em>绝顶</em>聪明，谁会赢？可以证明，游戏总会结束。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 可能很大，但序列中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的个数不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p><code>01</code> 序列的输入方式是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个<strong>递增</strong>的正整数，描述这些 <code>1</code> 的下标，下标从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 开始。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\le m\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。保证 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 是偶数，保证为 <code>1</code> 的下标是递增顺序给出的。</p>\n</blockquote>\n","content":" 给出长度为 nnn 的 01 序列 a1∼na_{1\\sim n}a1∼n​，序列中有偶数个 1。NIT 和 TIN 轮流做以下操作，NIT 先手： 选择位置 i (1≤i≤n)i\\ (1\\le i\\le n)i (1≤i≤n)，满足区间 [1,i][1,i][1,i] 中有奇数个 1。再选择位置 j (i&lt;j≤n)j\\ (i&lt;j\\le n)j (i&lt;j≤n)。将 ai,aja_i,a_jai​,aj​ 都取反（即，0 变 1，1 变 0） 当整个序列中的所有元素都变为 0 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都绝顶聪明，谁会赢？可以证明，游戏总会结束。 nnn 可能很大，但序列中 111 的个数不超过 2×1052\\times 10^52×105。 01 序列的输入方式是 mmm 个递增的正整数，描述这些 1 的下标，下标从 111 开始。 1≤n≤10181\\le n\\le 10^{18}1≤n≤1018，2≤m≤1062 \\le m\\le 10^62≤m≤106。保证 mmm 是偶数，保证为 1 的下标是递增顺序给出的。 妙妙题。 不难发现，操作相当于移动 111。不妨设 bi=n−aib_i=n-a_ibi​=n−ai​，游戏即转化为所有 bib_ibi​ 均为 000 时无法操作。 ai=1a_i=1ai​=1 的情况： aj=0a_j=0aj​=0，相当于让 bi→bi−(j−i)b_i\\to b_i-(j-i)bi​→bi​−(j−i)； aj=1a_j=1aj​=1，相当于让 bi→0b_i\\to 0bi​→0，bj→0b_j\\to 0bj​→0； ai=0a_i=0ai​=0 的情况： aj=0a_j=0aj​=0，相当于新建两个 bm+1=n−ib_{m+1}=n-ibm+1​=n−i 和 bm+2=n−jb_{m+2}=n-jbm+2​=n−j； aj=1a_j=1aj​=1，相当于让 bj→bj+(j−i)b_j\\to b_j+(j-i)bj​→bj​+(j−i)； 下面将证明这个游戏等价于 Nim 游戏，即先手必胜当且仅当 ⊕ibi=0\\oplus_ib_i\\not=0⊕i​bi​​=0。 设当前异或和为 xxx，则： 1.1 相当于 Nim 游戏的正常操作； 1.2 相当于让 bi→bi−(j−i)b_i\\to b_i-(j-i)bi​→bi​−(j−i)，由于存在 bj=bi−(j−i)b_j=b_i-(j-i)bj​=bi​−(j−i)，所以这两个在异或和中抵消了，相当于都变成了 000； 并且不难发现 “[1,i][1,i][1,i] 区间有奇数个 111” 这个限制是没有任何用的，因为 Nim 游戏中从 x=0x\\not=0x​=0 转移到 x=0x=0x=0 的操作方法是找到一个二进制最高位和 xxx 的最高位相同的 bkb_kbk​，并让它减去 bk−(x⊕bk)b_k-(x\\oplus b_k)bk​−(x⊕bk​)。设最大的满足条件的 kkk 为 ppp，则满足 bi&gt;bpb_i&gt;b_pbi​&gt;bp​ 的 iii 一定有偶数个，那么此时操作 bpb_pbp​ 即可。 那么注意到 ai=1a_i=1ai​=1 的情况已经涵盖了 Nim 游戏的所有合法操作，下面来证明 ai=0a_i=0ai​=0 的情况不会出现。不难发现 ai=0a_i=0ai​=0 的操作出现的目的一定是停在 x=0x=0x=0 的情况，那么只需要考虑操作产生的贡献有没有可能是 000 即可： 2.1 中 n−in-in−i 一定不等于 n−jn-jn−j，贡献一定不为 000； 2.2 中 贡献还是一定不为 000； 所以 ai=0a_i=0ai​=0 的操作一定不会出现。 综上，证毕。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005; int n,m; int a[S]; inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]); int ans=0; for(int i=1;i&lt;=m;i++) ans^=n-a[i]; puts(ans==0?&quot;TIN&quot;:&quot;NIT&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"博弈论","slug":"6A-_b3w3J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/6A-_b3w3J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P9003 [RC-07] Game Theory 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p9003-rc-07-game-theory-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":246000,"words":887,"minutes":5},"date":"2023-04-15 14:06:44","dateFormat":"2023-04-15"},{"abstract":"","content":"本文的时间复杂度证明比我能在网上找到的其它文章的更为完善。 后缀树（数据结构）和本文中的后缀树其实不是一个东西，更规范的叫法应该是 parent 树，但是由于 SSS 的后缀树就是其反串的 parent 树，所以并没有加以区分。 前言 SAM（后缀自动机） 是一种强大的数据结构，在应用上可以完全包含 SA（后缀数组），往往比 SA 好写好调且时间复杂度更优。 本文借鉴了 后缀自动机(SAM)奶妈式教程 - 一铭君一 - 博客园 (cnblogs.com)（算法思想、实现、技巧）和 后缀自动机 - star_road_xyz - 博客园 (cnblogs.com)（状态个数、转移个数证明）。 为了表述方便，这里为本文规定一些记号： ∣S∣|S|∣S∣：字符串 SSS 的长度； VVV：字符集大小； 基本定义 SAM 是一个 DAG，它的节点被称作“状态”，边被称作“转移”； SAM 有一个初始状态 rtrtrt（代表空串），所有其它状态都能通过转移从 rtrtrt 到达； 每个转移会被标记上字符集中的一个字符（类似边权），从一个状态出发的所有转移的字符互不相同； 存在至少一个终止状态，从 rtrtrt 出发到终止状态的每一条路径上的所有转移依次拼接得到的字符串都是原串的后缀，也就是说原串的每个后缀都能表示成从 rtrtrt 到终止状态的路径； SAM 是满足上述条件中状态数最少的 DAG； 一些记号 SSS：要被建 SAM 的原串； rtrtrt：SAM 的初始状态（空串对应状态）； tou,chto_{u,ch}tou,ch​ 从状态 uuu 出发的，被标记上字符 chchch 的转移； SAM 的优势 不难发现，从 rtrtrt 到SAM 上的每个状态路径上的字符拼接起来都是原串某个后缀的一个前缀，这意味着原串的每个子串都能表示成从 rtrtrt 到某个状态的路径。 虽然大多数 SAM 能做的操作 SA 也能做，但是线性 SA 的 DC3 算法常数巨大，并且 SA 性质较少，应用时通常需要一些较为复杂的数据结构辅助，这些数据结构相应也会提高时间复杂度。但建立字符串 SSS 对应的 SAM 的时空复杂度仅为 O(∣S∣)O(|S|)O(∣S∣)，并且 SAM 有着更好的性质。 综上，SAM 不失为一种十分优秀的字符串算法。 endpos⁡\\operatorname{endpos}endpos 和 endpos⁡\\operatorname{endpos}endpos 等价类 使用 endpos⁡\\operatorname{endpos}endpos 等价类压缩时空就是 SAM 保持优秀时间复杂度的原因。 记 endpos⁡(s)\\operatorname{endpos}(s)endpos(s) 表示 sss 在 SSS 中每次出现的结尾位置的集合（下标从 111 开始），例如： S: abab s: a b,ab ba,aba bab,abab endpos(s): {1,3} {2,4} {3} {4} 不难发现，某些字符串的 endpos⁡\\operatorname{endpos}endpos 是相同的，例如例子中的 b 和 ab。那么不妨将所有 endpos⁡(s)=A\\operatorname{endpos}(s)=Aendpos(s)=A 的归到同一个等价类中，记 endpos′⁡(A)={s∣endpos(s)=A⁡}\\operatorname{endpos&#x27;}(A)=\\{s|\\operatorname{endpos(s)=A}\\}endpos′(A)={s∣endpos(s)=A}。 在 SAM 中，一个状态表示的并不是具体的某个字符串，而是一个等价类。 一些记号： endpos⁡(s)\\operatorname{endpos}(s)endpos(s)：sss 在 SSS 中每次出现的结尾位置的集合（下标从 111 开始）； endpos′⁡(A)\\operatorname{endpos&#x27;}(A)endpos′(A)：{s∣endpos(s)=A⁡}\\{s|\\operatorname{endpos(s)=A}\\}{s∣endpos(s)=A} 即 endpos⁡(s)=A\\operatorname{endpos}(s)=Aendpos(s)=A 的 sss 构成的集合； E(u)E(u)E(u)：状态 uuu 代表的等价类； sta⁡(s)\\operatorname{sta}(s)sta(s)：字符串 sss 所属的等价类对应的状态； endpos⁡\\operatorname{endpos}endpos 等价类的一些性质 引理 1 考虑两个非空字符串 s1,s2s1,s2s1,s2，满足 ∣s1∣≥∣s2∣|s1|\\ge|s2|∣s1∣≥∣s2∣。 若 endpos⁡(s1)=endpos⁡(s2)\\operatorname{endpos}(s1)=\\operatorname{endpos}(s2)endpos(s1)=endpos(s2)，则 s2s2s2 是 s1s1s1 的后缀，且 s2s2s2 在且仅在 s1s1s1 在 SSS 中出现时作为它的后缀出现； 若 s2s2s2 是 s1s1s1 的后缀，且 s2s2s2 在且仅在 s1s1s1 在 SSS 中出现时作为它的后缀出现，那么 endpos⁡(s1)=endpos⁡(s2)\\operatorname{endpos}(s1)=\\operatorname{endpos}(s2)endpos(s1)=endpos(s2)； 证明是显然的。 引理 2 考虑两个非空字符串 s1,s2s1,s2s1,s2，满足 ∣s1∣≥∣s2∣|s1|\\ge|s2|∣s1∣≥∣s2∣。 若 s2s2s2 是 s1s1s1 的后缀，那么 endpos⁡(s1)⊆endpos⁡(s2)\\operatorname{endpos}(s1)\\subseteq\\operatorname{endpos}(s2)endpos(s1)⊆endpos(s2)； 若 s2s2s2 不是 s1s1s1 的后缀，那么 endpos⁡(s2)∩endpos⁡(s1)=∅\\operatorname{endpos}(s2)\\cap\\operatorname{endpos}(s1)=\\varnothingendpos(s2)∩endpos(s1)=∅； 第一条是因为 s1s1s1 每次出现 s2s2s2 都必然会出现。 第二条是因为若 s2s2s2 是 s1s1s1 的子串且存在 ppp 满足 p∈endpos⁡(s1)p\\in \\operatorname{endpos}(s1)p∈endpos(s1) 且 p∈endpos⁡(s2)p\\in \\operatorname{endpos}(s2)p∈endpos(s2) 则 s1s1s1 和 s2s2s2 都一定会在 ppp 处结束，s2s2s2 必定是 s1s1s1 的子串，和假设矛盾，得证。 引理 3 考虑一个 endpos⁡\\operatorname{endpos}endpos 等价类 A=endpos⁡′(E)A=\\operatorname{endpos}&#x27;(E)A=endpos′(E)。 AAA 中不包含两个长度相同但本质不同的字符串； 对于 AAA 中任意两个字符串，短的那个一定是长的那个的真后缀，也就是说 AAA 中所有字符串都是最长的那个的后缀； 设 l,rl,rl,r 分别为 AAA 中最短和最长的字符串的长度，则 {∣s∣,s∈A}=[l,r]∩N+\\{|s|,s\\in A\\}=[l,r]\\cap \\mathbb{N}^+{∣s∣,s∈A}=[l,r]∩N+，即 l,rl,rl,r 之间的每种长度的串都会出现恰好一次； 第一条可以由引理 1 推出，第二条可以由引理 2 推出，考虑第三条的证明。 不难发现只有可能是等号右边的集合的某个元素没在等号左边的集合中出现。那么设 d∈([l,r]∩N+)d\\in ([l,r]\\cap \\mathbb{N}^+)d∈([l,r]∩N+) 且 d∉{∣s∣,s∈A}d\\notin\\{|s|,s\\in A\\}d∈/​{∣s∣,s∈A}。由于第二条，所以可以设长度为 ddd 的字符串为 sds^dsd，则由于引理 2，有 A⊆endpos⁡(sd)A\\subseteq\\operatorname{endpos}(s^d)A⊆endpos(sd)。 此时若 A⊂endpos⁡(sd)A\\subset \\operatorname{endpos}(s^d)A⊂endpos(sd)，则 sds^dsd 的所有子串的 endpos⁡\\operatorname{endpos}endpos 都会不等于 AAA。由于第二条，t∈([l,d]∩N+)t\\in ([l,d]\\cap\\mathbb{N^+})t∈([l,d]∩N+) 的所有 ttt 均满足 A⊂endpos(st)⁡A\\subset \\operatorname{endpos(s^t)}A⊂endpos(st)，那么 lll 将会等于 d+1d+1d+1，和 d∈([l,r]∩N+)d\\in ([l,r]\\cap \\mathbb{N}^+)d∈([l,r]∩N+) 矛盾，得证。 一些记号： long⁡(u)\\operatorname{long}(u)long(u)：endpos⁡′(E⁡(u))\\operatorname{endpos}&#x27;(\\operatorname{E}(u))endpos′(E(u)) 中最长的字符串； len(u)⁡\\operatorname{len(u)}len(u)：∣long⁡(E⁡(u))∣|\\operatorname{long}(\\operatorname{E}(u))|∣long(E(u))∣ 即 endpos⁡′(E⁡(u))\\operatorname{endpos}&#x27;(\\operatorname{E}(u))endpos′(E(u)) 中最长的字符串的长度； short⁡(u)\\operatorname{short}(u)short(u)：endpos⁡′(E⁡(u))\\operatorname{endpos}&#x27;(\\operatorname{E}(u))endpos′(E(u)) 中最短的字符串； slen(u)⁡\\operatorname{slen(u)}slen(u)：∣short⁡(E⁡(u))∣|\\operatorname{short}(\\operatorname{E}(u))|∣short(E(u))∣ 即 endpos⁡′(E⁡(u))\\operatorname{endpos}&#x27;(\\operatorname{E}(u))endpos′(E(u)) 中最短的字符串的长度； 后缀指针 link⁡\\operatorname{link}link 和后缀树 设 A=E(u)A=E(u)A=E(u) 即状态 uuu 代表的等价类，www 为 long⁡(u)\\operatorname{long}(u)long(u) 最长的满足 w∉Aw\\notin Aw∈/​A 的一个后缀，vvv 为 sta⁡(w)\\operatorname{sta}(w)sta(w) 即 www 所属等价类对应的状态（由 SAM 的定义可知这个状态一定存在），link⁡(u)\\operatorname{link}(u)link(u) 即为 vvv。特别的，rtrtrt 没有 link⁡\\operatorname{link}link 指针。 根据引理 3，从状态 uuu 出发不断跳 link⁡\\operatorname{link}link 到 rtrtrt 路径上所有状态的等价类并起来就是 long⁡(u)\\operatorname{long}(u)long(u) 的所有后缀，所以 link⁡\\operatorname{link}link 也叫后缀指针。 引理 5 对于一个状态 uuu，设 link⁡(u)=v\\operatorname{link}(u)=vlink(u)=v。 long⁡(v)\\operatorname{long}(v)long(v) 是 short⁡(u)\\operatorname{short}(u)short(u) 的长度为 slen⁡(u)−1\\operatorname{slen}(u)-1slen(u)−1 的后缀； E⁡(u)⊊E⁡(v)\\operatorname{E}(u)\\subsetneq \\operatorname{E}(v)E(u)⊊E(v)； 第一条可以由引理 3 得出，第二条可以由引理 2 和 link⁡\\operatorname{link}link 指针的定义得出。 需要注意的是，利用这个引理，SAM 中的每个状态便只需要记录等价类中的最长串。 引理 6 把状态看作节点，则所有有向边 u→link(u)⁡u\\to\\operatorname{link(u)}u→link(u) 构成一棵以 rtrtrt 为根的内向树（后缀树）。 首先由于所有状态不断跳 link⁡\\operatorname{link}link 总能跳回 rtrtrt（空串是所有字符串的后缀），所以“后缀图”一定连通。 然后由于只有 rtrtrt 没有 link⁡\\operatorname{link}link 指针，所以“后缀图”的边数恰好等于点数减 111，所以“后缀图”是一棵树。 一些记号： link⁡(u)\\operatorname{link}(u)link(u)：设 A=E(u)A=E(u)A=E(u) 即状态 uuu 代表的等价类，www 为 long⁡(A)\\operatorname{long}(A)long(A) 最长的满足 w∉Aw\\notin Aw∈/​A 的一个后缀，vvv 为 sta⁡(w)\\operatorname{sta}(w)sta(w) 即 www 所属等价类对应的状态（由 SAM 的定义可知这个状态一定存在），link⁡(u)\\operatorname{link}(u)link(u) 即为 vvv。特别的，rtrtrt 没有 link⁡\\operatorname{link}link 指针； 小结 在开始介绍如何构造 SAM 前，我们先小结一下： 原串 SSS 的每一个子串可以根据 endpos⁡\\operatorname{endpos}endpos 来划分为若干个等价类，每个等价类对应一个状态； 对于每个状态 uuu，E⁡(u)\\operatorname{E}(u)E(u) 中包含了 long(u)⁡\\operatorname{long(u)}long(u) 长度从 slen⁡(u)\\operatorname{slen}(u)slen(u) 到 len⁡(u)\\operatorname{len}(u)len(u) 的所有后缀（引理 3）； 从状态 uuu 出发不断跳 link⁡\\operatorname{link}link 到 rtrtrt 路径上所有状态的等价类并起来就是 long⁡(u)\\operatorname{long}(u)long(u) 的所有后缀（引理 3 推出）； 设 A=E(u)A=E(u)A=E(u) 即状态 uuu 代表的等价类，www 为 long⁡(A)\\operatorname{long}(A)long(A) 最长的满足 w∉Aw\\notin Aw∈/​A 的一个后缀，vvv 为 sta⁡(w)\\operatorname{sta}(w)sta(w) 即 www 所属等价类对应的状态（由 SAM 的定义可知这个状态一定存在），则 link⁡(u)\\operatorname{link}(u)link(u) 即为 vvv。特别的，rtrtrt 没有 link⁡\\operatorname{link}link 指针。所有 link⁡\\operatorname{link}link 指针构成一棵以 rtrtrt 为根的内向树，称之为后缀树（引理 6）； SAM 的构造 构造 SAM 的算法是一个动态的算法。一开始 SAM 中只存在一个代表空串的状态 rtrtrt，没有任何转移。通过依次插入原串 SSS 中的每一个字符来动态维护 SAM。 这里将给出算法流程、解释、时空复杂度分析和 C++ 代码。 算法流程 一开始 SAM 中只存在一个编号为 000 的状态 rtrtrt。为了方便，我们钦定 long⁡(rt)=0\\operatorname{long}(rt)=0long(rt)=0，link⁡(rt)=−1\\operatorname{link}(rt)=-1link(rt)=−1。 现在任务是给 SAM 维护的字符串的末尾新加入一个字符 ccc，流程如下： 设上一次加入字符后整个整个字符串 SSS 对应的状态为 lstlstlst，即 long⁡(lst)=S\\operatorname{long}(lst)=Slong(lst)=S； 创建一个新的状态 preprepre，并且令 len⁡(pre)=len⁡(lst)+1\\operatorname{len}(pre)=\\operatorname{len}(lst)+1len(pre)=len(lst)+1； 从 lstlstlst 开始不断跳 link⁡\\operatorname{link}link，如果当前状态 uuu 没有标记 ccc 的转移，那么令 tou,c=preto_{u,c}=pretou,c​=pre； 如果跳到了 rtrtrt 并且 rtrtrt 也没有标记 ccc 的转移，那么令 tort,c=preto_{rt,c}=pretort,c​=pre，link⁡(pre)=0\\operatorname{link}(pre)=0link(pre)=0（指向状态 rtrtrt），转到 8； 否则停止跳 link⁡\\operatorname{link}link，并设当前跳到的状态为 ppp，top,c=qto_{p,c}=qtop,c​=q； 若 len(q)⁡=len⁡(p)+1\\operatorname{len(q)}=\\operatorname{len}(p)+1len(q)=len(p)+1，令 link⁡(pre)=q\\operatorname{link}(pre)=qlink(pre)=q； 否则： 复制 qqq 到一个新的状态 cpycpycpy（只复制 link⁡\\operatorname{link}link 以及 toq,∗to_{q,*}toq,∗​）； 令 len⁡(cpy)=len⁡(p)+1,link⁡(pre)=cpy\\operatorname{len}(cpy)=\\operatorname{len}(p)+1,\\operatorname{link}(pre)=cpylen(cpy)=len(p)+1,link(pre)=cpy； 从 ppp 开始不断跳 link⁡\\operatorname{link}link，设当前跳到的状态为 uuu，则： 若 u=−1u=-1u=−1 或 tou,c=qto_{u,c}\\not=qtou,c​​=q，停止跳 link⁡\\operatorname{link}link； 否则令 tou,c=cpyto_{u,c}=cpytou,c​=cpy； 令 link⁡(q)=cpy\\operatorname{link}(q)=cpylink(q)=cpy，转到 8； 令 lst=prelst=prelst=pre，插入操作完成； 算法解释 为了表述方便，设 S1S1S1 为插入 ccc 之前的 SSS，S2S2S2 为插入 ccc 之后的 SSS 即 S1+cS1+cS1+c。 为之后的操作做准备； 插入字符 ccc 后，endpos⁡(S2)={∣S1∣+1}\\operatorname{endpos}(S2)=\\{|S1|+1\\}endpos(S2)={∣S1∣+1} 一定会成为一个新的等价类，所以需要分配新的状态 preprepre 来代表它。而 len⁡(pre)\\operatorname{len}(pre)len(pre) 一定是 ∣S1∣+1|S1|+1∣S1∣+1，lstlstlst 中最长的字符串显然就是 S1S1S1，所以令 len⁡(pre)=len⁡(lst)+1\\operatorname{len}(pre)=\\operatorname{len}(lst)+1len(pre)=len(lst)+1； 考虑新建转移到 preprepre，不断枚举 S1S1S1 的后缀，如果还没有标记为 ccc 的转移就可以新建标记为 ccc 的转移到 preprepre； 跳到 rtrtrt 还没结束代表字符 ccc 是第一次出现，因为 rtrtrt 没有到 ccc 的转移表明 S1S1S1 不存在 ccc 这个子串，那么 link⁡(pre)\\operatorname{link}(pre)link(pre) 自然要指向状态 rtrtrt，因为 S2S2S2 不存在非空真后缀； 为之后的操作做准备，注意此时所有到 preprepre 的转移已处理完成，接下来的所有步骤都是在处理 link⁡(pre)\\operatorname{link}(pre)link(pre)； 若 E(q)E(q)E(q) 中最长的那个就是 long⁡(p)+c\\operatorname{long}(p)+clong(p)+c 即 S1S1S1 的某个后缀加上字符 ccc，那么 long⁡(q)\\operatorname{long}(q)long(q) 就一定是 S2S2S2 最长的真后缀，所以可以让 link⁡(pre)\\operatorname{link}(pre)link(pre) 指向 qqq； 否则一定有 len⁡(q)&gt;len⁡(p)\\operatorname{len}(q)&gt;\\operatorname{len}(p)len(q)&gt;len(p)。发现所有 A={s∣s∈E(q),∣s∣≤len⁡(p)+1}A=\\{s|s\\in E(q),|s|\\le \\operatorname{len}(p)+1\\}A={s∣s∈E(q),∣s∣≤len(p)+1} 中的字符串一定是 S1S1S1 的某个后缀加上字符 ccc，而 B=E(q)/AB=E(q)/AB=E(q)/A 中的一定不是。那么 AAA 中的字符串的 endpos⁡\\operatorname{endpos}endpos 集合一定会加入元素 ∣S2∣|S2|∣S2∣，BBB 中的则一定不会，所以 AAA 和 BBB 不再属于同一个等价类。 此时就需要分裂 qqq 代表的等价类。具体的，创建一个新的状态 cpycpycpy，把 qqq 的所有“出边”都复制过去。 接下来的工作就是让 cpycpycpy 表示 AAA，原来的 qqq 表示 BBB。 首先 AAA 中最长的字符串的长度显然是 len⁡(p)+1\\operatorname{len}(p)+1len(p)+1，那么令 len⁡(cpy)=len⁡(p)+1\\operatorname{len}(cpy)=\\operatorname{len}(p)+1len(cpy)=len(p)+1，而 BBB 中最长的字符串没有改变，所以无需对 len⁡(q)\\operatorname{len}(q)len(q) 进行任何操作。 接下来不难发现 long⁡(cpy)\\operatorname{long}(cpy)long(cpy) 一定是 S2S2S2 的最长的真后缀，所以令 link⁡(pre)\\operatorname{link}(pre)link(pre) 指向 cpycpycpy。 然后遍历 ppp 所有的后缀的状态 uuu。因为 len⁡(u)≤len⁡(p)\\operatorname{len}(u)\\le \\operatorname{len}(p)len(u)≤len(p)，所以若 uuu 有标记 ccc 的转移到 qqq，那么转移得到的字符串一定属于 AAA，所以让 tou,c=cpyto_{u,c}=cpytou,c​=cpy；否则 U=endpos⁡(s+c∣s∈E⁡(u))U=\\operatorname{endpos}(s+c|s\\in \\operatorname{E}(u))U=endpos(s+c∣s∈E(u)) 一定包含且不等于 Q=endpos⁡(s∈E(q))Q=\\operatorname{endpos}(s\\in E(q))Q=endpos(s∈E(q))，那么 long⁡(u)\\operatorname{long}(u)long(u) 的后缀的 endpos⁡\\operatorname{endpos}endpos 集合更不可能满足要求，所以可以停止跳 link⁡\\operatorname{link}link。 最后由于 long⁡(cpy)\\operatorname{long}(cpy)long(cpy) 一定是 long⁡(q)\\operatorname{long}(q)long(q) 的最长真后缀，所以令 link⁡(q)\\operatorname{link}(q)link(q) 指向 cpycpycpy； 更新 lstlstlst，为之后的插入做准备； 复杂度分析 记 n=∣S∣n=|S|n=∣S∣。 状态数和转移数 不难发现，除第一次之外每次插入最多会新建两个状态，所以状态数上限为 2n−12n-12n−1。 而转移会分为两种： link⁡\\operatorname{link}link：由于构成内向树，所以上限为 2n−22n-22n−2； tototo：考虑转移 v=tou,cv=to_{u,c}v=tou,c​，设 s1s1s1 为 rtrtrt 到 uuu 的最长路径构成的字符串，s2s2s2 为 vvv 到任意一个终止状态的最长的路径构成的字符串，那么对于不同的 (u,c)(u,c)(u,c)，s1+c+s2s1+c+s2s1+c+s2 一定两两不同并且是 SSS 的后缀，所以 tototo 转移的上限是 nnn； 那么转移数的上限为 3n−23n-23n−2。实际上还达不到这个数量，真实上限大概是 3n−43n-43n−4。 空间复杂度 由于状态数上限为 2n−12n-12n−1，转移数上限为 3n−23n-23n−2，所以空间复杂度为 O(n)O(n)O(n)。 特别的，若字符集较小，那么往往采用数组存储 tototo，此时空间复杂度为 O(nV)O(nV)O(nV)。 若字符集较大，往往采用哈希表来存储 tototo，此时空间复杂度为 O(n)O(n)O(n)。 时间复杂度 较难证明的部分是两个跳 link⁡\\operatorname{link}link 的步骤。不难发现，步骤 3 跳的总次数和转移数相当，所以是 O(n)O(n)O(n) 的。 而步骤 7 就有点复杂了，考虑一次因为插入字符 ccc 引起的分裂，显然它只会影响标记为 ccc 的转移，而分裂完成后 link⁡(pre)\\operatorname{link}(pre)link(pre) 会指向 cpycpycpy。 只有满足 tou,c=cpyto_{u,c}=cpytou,c​=cpy 且 E⁡(u)\\operatorname{E}(u)E(u) 中的字符串都是插入 ccc 后的 SSS 的后缀的 uuu 的 tou,cto_{u,c}tou,c​ 才有可能在之后的分裂中被重定向。而满足条件的 uuu 若存在，则 long⁡(u)+c\\operatorname{long}(u)+clong(u)+c 一定是形如 cccccc…ccccccc\\dots ccccccc…c 这样的字符串，那么必有 len⁡(u)+1=slen⁡(cpy)\\operatorname{len}(u)+1=\\operatorname{slen}(cpy)len(u)+1=slen(cpy) 也就是说这样的 uuu 最多只有一个，且必为 link⁡(cpy)\\operatorname{link}(cpy)link(cpy)。 所以 cpycpycpy 以后因为插入字符 ccc 造成的分裂最多只会重定向一条边，所以步骤 7 中这个循环总共只会执行 O(n)O(n)O(n) 次。 综上，构建 SAM 的时间复杂度为 O(nk)O(nk)O(nk)（其中 kkk 是访问和修改 tototo 的时间复杂度，若使用数组或哈希表则为 O(1)O(1)O(1)，使用 map 为 O(log⁡V)O(\\log V)O(logV)）。 代码 const int S=1000005,V=26; // 字符串最大长度，字符集大小 struct SAM { int tot,lst; int len[S*2],to[S*2][V],link[S*2]; // 记得开两倍 inline void init() // 初始化 { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=0; memset(to[i],0,sizeof(to[i])); } tot=lst=0; link[0]=-1; // 记得让 link(rt)=-1 } inline void ins(int c) // 在末尾插入一个字符 { // 新建状态（第 1、2 步） int pre=++tot; len[pre]=len[lst]+1; // 处理到 pre 的转移（第 3 步） int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; // 第 4 步 else { int q=to[p][c]; // 第 5 步 if(len[q]==len[p]+1) link[pre]=q; // 无需分裂（第 6 步） else // 分裂状态 q（第 7 步） { // 复制 q 到新状态 cpy，令 link(pre)=cpy（7.1、7.2） int cpy=++tot; len[cpy]=len[p]+1; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; // 处理到 cpy 的转移（7.3） while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; // 令 link(q)=cpy（7.4） } } lst=pre; // 第 8 步 } }; 一些额外信息的求解 值得注意的是，这些信息的求解的时间复杂度均为 O(n)O(n)O(n)。 结束标记 只需要在构建完 SAM 后，从 lstlstlst 出发不断跳 link⁡\\operatorname{link}link，把经过的状态全都打上标记即可。 建立后缀树 只需要在构建完 SAM 后，对于所有 1≤u1\\le u1≤u 的 uuu，在 link⁡(u)\\operatorname{link}(u)link(u) 的儿子列表中加入 uuu 即可。 两个子串的最长公共后缀 找到这两个子串所属的状态 x,yx,yx,y，它们的最长公共后缀所属的状态 zzz 即为 x,yx,yx,y 在后缀树上的 LCA⁡\\operatorname{LCA}LCA。 ∣E⁡(u)∣|\\operatorname{E}(u)|∣E(u)∣（每个节点对应的等价类中的字符串个数） 由于引理 3，∣E⁡(u)∣|\\operatorname{E}(u)|∣E(u)∣ 即为 len⁡(u)−len⁡(link⁡(u))\\operatorname{len}(u)-\\operatorname{len}(\\operatorname{link}(u))len(u)−len(link(u))。 sizu=∣endpos⁡(s)∣,s∈E⁡(u)siz_u=|\\operatorname{endpos}(s)|,s\\in\\operatorname{E}(u)sizu​=∣endpos(s)∣,s∈E(u)（每个节点对应的等价类中的字符串出现的次数） 构建 SAM 时让 sizpre=1siz_{pre}=1sizpre​=1，注意到这样标记的实际上是 SSS 的每个前缀，一个子串的出现次数等于它是多少个前缀的后缀，所以构建完成后只需要在后缀树上求一次子树 sizsizsiz 和即可。 注意复制节点的时候无需复制 sizsizsiz，因为一个等价类中最长的那个字符串才有可能是 SSS 的前缀，而这个最长的字符串一定在分裂之后的 E(q)E(q)E(q) 中。 代码 const int S=1000005,V=26; struct SAM { int tot,lst; int len[S*2],to[S*2][V],link[S*2]; vector&lt;int&gt; son[S*2]; // 后缀树中每个状态的儿子 int siz[S*2]; // 每个状态代表的等价类中每个字符串出现了几次 inline void init() // 初始化 { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=siz[i]=0; memset(to[i],0,sizeof(to[i])); son[i].clear(); } tot=lst=0; link[0]=-1; } inline void ins(int c) // 在末尾插入一个字符 { int pre=++tot; len[pre]=len[lst]+1; siz[pre]=1; // 标记 int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } inline void build() // 建后缀树 { for(int i=1;i&lt;=tot;i++) son[link[i]].push_back(i); } void getsiz(int u=0) // dfs 求子树和 { for(int v:son[u]) { getsiz(v); siz[u]+=siz[v]; } } }; mnru=min⁡v∈endpos⁡(s),s∈E⁡(u)vmnr_u=\\min\\limits_{v\\in \\operatorname{endpos}(s),s\\in\\operatorname{E}(u)} vmnru​=v∈endpos(s),s∈E(u)min​v（每个节点对应的等价类中的字符串的最早出现的右端点） 和 sizusiz_usizu​ 一样，构建时每个前缀的 mnrmnrmnr 就是这个前缀的长度，构建完后在后缀树上求子树 min⁡\\minmin 即可。 经典例题 P3804 【模板】后缀自动机 (SAM) 注意到状态 uuu 下的所有字符串出现次数均为 sizusiz_usizu​，显然选最长的最优，那么求出 sizsizsiz 后对所有 sizu&gt;1siz_u&gt;1sizu​&gt;1 的 uuu 的 lenu×sizulen_u\\times siz_ulenu​×sizu​ 取 max⁡\\maxmax 即可。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int S=1000005,V=26; struct SAM { int tot,lst; int len[S*2],to[S*2][V],link[S*2]; vector&lt;int&gt; son[S*2]; int siz[S*2]; inline void init() { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=siz[i]=0; memset(to[i],0,sizeof(to[i])); son[i].clear(); } tot=lst=0; link[0]=-1; } inline void ins(int c) { int pre=++tot; len[pre]=len[lst]+1; siz[pre]=1; int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } inline void build() { for(int i=1;i&lt;=tot;i++) son[link[i]].push_back(i); } void getsiz(int u=0) { for(int v:son[u]) { getsiz(v); siz[u]+=siz[v]; } } }; int n; char a[S]; SAM sam; int main() { scanf(&quot;%s&quot;,a+1); n=strlen(a+1); sam.init(); for(int i=1;i&lt;=n;i++) sam.ins(a[i]-'a'); sam.build(); sam.getsiz(); long long ans=0; for(int i=0;i&lt;=sam.tot;i++) if(sam.siz[i]&gt;1) ans=max(ans,1ll*sam.len[i]*sam.siz[i]); printf(&quot;%lld\\n&quot;,ans); return 0; } P4070 [SDOI2016]生成魔咒 考虑新加入的字符会产生多少个新的非空子串，设加入新字符之前的长度为 lstlenlstlenlstlen，那么只有 endpos⁡′({lstlen+1})\\operatorname{endpos}&#x27;(\\{lstlen+1\\})endpos′({lstlen+1}) 中的字符串是新的非空子串。 考虑哪个状态代表的等价类是 endpos⁡′({lstlen+1})\\operatorname{endpos}&#x27;(\\{lstlen+1\\})endpos′({lstlen+1})，显然只有新加入的状态 preprepre 是。preprepre 中的字符串个数很好求，即为 len⁡(pre)−len⁡(link⁡(pre))\\operatorname{len}(pre)-\\operatorname{len}(\\operatorname{link}(pre))len(pre)−len(link(pre))。 那么每次让答案累加上 len⁡(pre)−len⁡(link⁡(pre))\\operatorname{len}(pre)-\\operatorname{len}(\\operatorname{link}(pre))len(pre)−len(link(pre)) 即可。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;map&gt; using namespace std; const int S=100005; struct SAM { int tot,len[S*2],link[S*2]; map&lt;int,int&gt; to[S*2]; int lst; inline void init() { for(int i=0;i&lt;=tot;i++) len[i]=link[i]=0,to[i].clear(); link[0]=-1; } inline void ins(int c) { int pre=++tot; len[pre]=len[lst]+1; int p=lst; while(p!=-1&amp;&amp;to[p].find(c)==to[p].end()) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; to[cpy]=to[q],link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } }; SAM sam; int main() { int n; scanf(&quot;%d&quot;,&amp;n); sam.init(); long long ans=0; for(int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); sam.ins(x); ans+=sam.len[sam.lst]-sam.len[sam.link[sam.lst]]; printf(&quot;%lld\\n&quot;,ans); } } P3975 [TJOI2015]弦论 双倍经验：SP7258 SUBLEX - Lexicographical Substring Search 原串 SSS 的每个子串都能表示为从 rtrtrt 到某个状态的路径，那么在 SAM 的反 DAG 上跑一边 bfs，求出每个状态出发有多少个子串，然后逐位确定即可。 如果 k=1k=1k=1 每个状态的权值就是 sizusiz_usizu​，否则就是 111。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int S=500005,V=26; struct SAM { int tot; int len[S*2],to[S*2][V],link[S*2]; vector&lt;int&gt; son[S*2]; int siz[S*2]; int lst; inline void init() { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=siz[i]=0; memset(to[i],0,sizeof(to[i])); son[i].clear(); } tot=lst=0; link[0]=-1; } inline void ins(int c) { int pre=++tot; len[pre]=len[lst]+1; siz[pre]=1; int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } inline void build() { for(int i=1;i&lt;=tot;i++) son[link[i]].push_back(i); } void getsiz(int u=0) { for(int v:son[u]) { getsiz(v); siz[u]+=siz[v]; } } }; int n,t; long long k; char a[S]; SAM sam; vector&lt;int&gt; to[S*2]; int ind[S*2]; long long cnt[S*2]; int main() { scanf(&quot;%s&quot;,a+1); n=strlen(a+1); scanf(&quot;%d%lld&quot;,&amp;t,&amp;k); sam.init(); for(int i=1;i&lt;=n;i++) sam.ins(a[i]-'a'); sam.build(); sam.getsiz(); for(int i=0;i&lt;=sam.tot;i++) { for(int j=0;j&lt;V;j++) { int v=sam.to[i][j]; if(v!=0) to[v].push_back(i),ind[i]++; } } queue&lt;int&gt; q; for(int i=0;i&lt;=sam.tot;i++) { cnt[i]=t?sam.siz[i]:1; if(ind[i]==0) q.push(i); } cnt[0]=0; while(!q.empty()) { int u=q.front(); q.pop(); for(int v:to[u]) { cnt[v]+=cnt[u]; if(--ind[v]==0) q.push(v); } } if(k&gt;cnt[0]) return puts(&quot;-1&quot;),0; int u=0; while(k&gt;0) { for(int i=0;i&lt;V;i++) { int v=sam.to[u][i]; if(v==0) continue; if(cnt[v]&lt;k) k-=cnt[v]; else { k-=t?sam.siz[v]:1; printf(&quot;%c&quot;,'a'+i); u=v; break; } } } printf(&quot;\\n&quot;); return 0; } P4248 [AHOI2013]差异 建反串的 SAM，在后缀树上 dp 即可。 SP1811 LCS - Longest Common Substring 对于这种多个字符串的问题，通常是要用广义 SAM 来做，但是这里介绍一种“伪广义 SAM”。 考虑把输入的两个字符串 AAA 和 BBB 在中间加入一个分隔符 # 后拼接起来加入 SAM，即 A+#+BA+\\#+BA+#+B 这样。加入的过程中若当前字符属于 AAA 则给加入后 SSS 对应的状态打上 AAA 标记，否则打上 BBB 标记，最后在后缀树上让每个点的标记都贡献到它的祖先上。 这样一来所有同时被打上 AAA 和 BBB 标记的状态中的字符串都是 AAA 和 BBB 的公共子串，那么统计这些状态的 len⁡\\operatorname{len}len 的最大值即可。 SP1812 LCS2 - Longest Common Substring II 这题也类似，不过要注意分隔符要两两不同，要不然带分隔符的子串可能也会被打上标记。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int S=500005,V=27; struct SAM { int tot; int len[S*2],to[S*2][V],link[S*2]; vector&lt;int&gt; son[S*2]; bool app[2][S*2]; int lst; inline void init() { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=0; memset(to[i],0,sizeof(to[i])); app[0][i]=app[1][i]=false; son[i].clear(); } tot=lst=0; link[0]=-1; } inline void ins(int c,int tpe) { int pre=++tot; len[pre]=len[lst]+1; app[tpe][pre]=true; int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } inline void build() { for(int i=1;i&lt;=tot;i++) son[link[i]].push_back(i); } inline void calctag(int u=0) { for(int v:son[u]) { calctag(v); for(int i=0;i&lt;=1;i++) app[i][u]|=app[i][v]; } } }; int n,m; char a[S],b[S]; SAM sam; int main() { scanf(&quot;%s%s&quot;,a+1,b+1); n=strlen(a+1),m=strlen(b+1); sam.init(); for(int i=1;i&lt;=n;i++) sam.ins(a[i]-'a',0); sam.ins(26,1); for(int i=1;i&lt;=m;i++) sam.ins(b[i]-'a',1); sam.build(); sam.calctag(); int ans=0; for(int i=0;i&lt;=sam.tot;i++) if(sam.app[0][i]&amp;&amp;sam.app[1][i]) ans=max(ans,sam.len[i]); printf(&quot;%d\\n&quot;,ans); return 0; } P3649 [APIO2014] 回文串 有两种做法。 Manacher + SAM 前置知识：Manacher。 由于 SSS 的本质不同回文子串个数上限是 ∣S∣|S|∣S∣，所以可以建出 SAM 之后跑 Manacher 找到每个本质不同回文子串 S[li,ri]S_{[l_i,r_i]}S[li​,ri​]​，再从 S[1,ri]S_{[1,r_i]}S[1,ri​]​ 这个前缀对应的状态开始倍增跳 link⁡\\operatorname{link}link 找到 S[li,ri]S_{[l_i,r_i]}S[li​,ri​]​ 对应的等价类并统计答案。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 SAM 建 SAM 时维护每个状态中的字符串的最后出现位置 mxumx_umxu​，建完 SAM 后在 SAM 上跑反串 S′S&#x27;S′ 和 SSS 的所有子串的匹配。假设跑到 S[1,n−l+1]′S&#x27;_{[1,n-l+1]}S[1,n−l+1]′​ 时匹配到了状态 uuu，匹配长度为 lenlenlen。那么若 mxu∈[l,l+len−1]mx_u\\in[l,l+len-1]mxu​∈[l,l+len−1]： 此时绿色部分 S[l,mxu]S_{[l,mx_u]}S[l,mxu​]​ 一定是回文串，并且它的出现次数一定是 sizusiz_usizu​ 即状态 uuu 中的每个字符串出现的次数。 只统计 S[l,mxu]S_{[l,mx_u]}S[l,mxu​]​ 是不够全面的，还需要不断跳 uuu 的 link⁡\\operatorname{link}link 直到 mxu∉[l,l+len−1]mx_u\\notin [l,l+len-1]mxu​∈/​[l,l+len−1] 或 len⁡(u)&lt;mxu−l+1\\operatorname{len}(u)&lt; mx_u-l+1len(u)&lt;mxu​−l+1，因为这些状态中的字符串 S[l,mxu]S_{[l,mx_u]}S[l,mxu​]​ 也是回文串。 注意到 mxmxmx 一样的 uuu 只有 len⁡(u)\\operatorname{len}(u)len(u) 最小的才会有贡献，所以可以用倍增跳 link⁡\\operatorname{link}link。 不难发现一个子串只会被统计一次，所以时间复杂度即为 O(nlog⁡n)O(n\\log n)O(nlogn)。 另外似乎还有一种做法即跳 link⁡\\operatorname{link}link 时给跳过的状态打上标记，下一次不跳。这种做法时间复杂度是 O(n)O(n)O(n) 的，但是正确性不是很显然。 虽然第二种做法很难写，但是可以增加对 SAM 的理解。所以我写了第二种做法，然后 BZOJ 过了洛谷一直 MLE…… 代码（第二种做法） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include &lt;map&gt; using namespace std; const int S=300001,V=26,BS=20; struct SAM { int tot; int len[S*2],link[S*2]; map&lt;char,int&gt; to[S*2]; vector&lt;int&gt; son[S*2]; int siz[S*2],mx[S*2]; vector&lt;int&gt; fa[S*2]; int lst; inline void init() { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=siz[i]=mx[i]=0; to[i].clear(); son[i].clear(); fa[i].clear(); } link[0]=-1; tot=lst=0; } inline void ins(int c,int pp) { int pre=++tot; len[pre]=len[lst]+1; siz[pre]=1,mx[pre]=pp; int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; to[cpy]=to[q]; link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } inline void build() { for(int i=1;i&lt;=tot;i++) son[link[i]].push_back(i); } void dfs(int u=0) { if(u!=0) { fa[u].push_back(link[u]); for(int i=1;i&lt;=BS;i++) { if(fa[u][i-1]==-1) break; else { int fat=fa[u][i-1]; if(fa[fat].size()&lt;=i-1) break; else fa[u][i]=fa[fat][i-1]; } } } for(int v:son[u]) { dfs(v); siz[u]+=siz[v],mx[u]=max(mx[u],mx[v]); } vector&lt;int&gt;().swap(son[u]); // 释放 vector 空间 } }; int n; char a[S]; SAM sam; int main() { scanf(&quot;%s&quot;,a); n=strlen(a); sam.init(); for(int i=0;i&lt;n;i++) sam.ins(a[i]-'a',i); sam.build(); sam.dfs(); int u=0,len=0; long long ans=0; for(int i=n-1;i&gt;=0;i--) { while(u!=-1&amp;&amp;sam.to[u][a[i]-'a']==0) { u=sam.link[u]; if(u!=-1) len=sam.len[u]; } if(u==-1) u=0,len=0; else u=sam.to[u][a[i]-'a'],len++; int r=i+len-1,v=u; while(sam.mx[v]&lt;=r&amp;&amp;sam.len[v]&gt;=sam.mx[v]-i+1) { for(int j=BS;j&gt;=0;j--) { if(sam.fa[v].size()&gt;j&amp;&amp;sam.mx[sam.fa[v][j]]==sam.mx[v]&amp;&amp;sam.len[sam.fa[v][j]]&gt;=sam.mx[v]-i+1) v=sam.fa[v][j]; } if(sam.mx[v]&gt;=i) ans=max(ans,1ll*(sam.mx[v]-i+1)*sam.siz[v]); if(sam.fa[v].size()&gt;0) v=sam.fa[v][0]; else break; } } printf(&quot;%lld\\n&quot;,ans); return 0; } P5685 [JSOI2013]快乐的 JYY 双倍经验：P5555 秩序魔咒 和上一题差不多，建完“伪广义” SAM 之后跑 manacher+哈希求出 AAA 的所有本质不同的回文子串 [l,r][l,r][l,r]，然后找到 A[1,r]A_{[1,r]}A[1,r]​ 即前缀 rrr 对应的 SAM 上的状态，倍增找到 A[l,r]A_{[l,r]}A[l,r]​ 所在的状态，然后统计答案即可。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; const int S=100005,V=27,BS=25,bse=31,p1=998244353,p2=1000000007; struct SAM { int tot; int len[S*4],to[S*4][V],link[S*4]; vector&lt;int&gt; suf,son[S*4]; int siz[2][S*4]; int fa[S*4][BS+1]; int lst; inline void init() { for(int i=0;i&lt;=tot;i++) { len[i]=link[i]=siz[0][i]=siz[1][i]=0; memset(to[i],0,sizeof(to[i])); vector&lt;int&gt;().swap(son[i]); } vector&lt;int&gt;().swap(suf); tot=lst=0; link[0]=-1; suf.push_back(0); } inline void ins(int c,int tpe) { int pre=++tot; len[pre]=len[lst]+1; suf.push_back(pre); siz[tpe][pre]=1; int p=lst; while(p!=-1&amp;&amp;to[p][c]==0) to[p][c]=pre,p=link[p]; if(p==-1) link[pre]=0; else { int q=to[p][c]; if(len[q]==len[p]+1) link[pre]=q; else { int cpy=++tot; len[cpy]=len[p]+1; memcpy(to[cpy],to[q],sizeof(to[q])); link[cpy]=link[q]; link[pre]=cpy; while(p!=-1&amp;&amp;to[p][c]==q) to[p][c]=cpy,p=link[p]; link[q]=cpy; } } lst=pre; } inline void build() { for(int i=1;i&lt;=tot;i++) son[link[i]].push_back(i); } void calctag(int u=0) { fa[u][0]=link[u]; for(int i=1;i&lt;=BS;i++) { int tp=fa[u][i-1]; if(tp==-1) fa[u][i]=-1; else fa[u][i]=fa[tp][i-1]; } for(int v:son[u]) { calctag(v); for(int j=0;j&lt;=1;j++) siz[j][u]+=siz[j][v]; } } }; int n,m; char a[S],b[S]; SAM sam; char str[S*2]; int ext[S*2]; int pw1[S],pw2[S]; int s1[S],s2[S]; set&lt;pair&lt;int,int&gt;&gt; st; inline pair&lt;int,int&gt; calchash(int l,int r) { return make_pair( (s1[r]-1ll*s1[l-1]*pw1[r-l+1]%p1+p1)%p1, (s2[r]-1ll*s2[l-1]*pw2[r-l+1]%p2+p2)%p2); } int main() { scanf(&quot;%s%s&quot;,a+1,b+1); sam.init(); n=strlen(a+1),m=strlen(b+1); for(int i=1;i&lt;=n;i++) sam.ins(a[i]-'A',0); sam.ins(26,1); for(int i=1;i&lt;=m;i++) sam.ins(b[i]-'A',1); sam.build(); sam.calctag(); pw1[0]=1,pw2[0]=1; for(int i=1;i&lt;=n;i++) { pw1[i]=1ll*pw1[i-1]*bse%p1; pw2[i]=1ll*pw2[i-1]*bse%p2; s1[i]=(1ll*s1[i-1]*bse%p1+a[i]-'A'+1)%p1; s2[i]=(1ll*s2[i-1]*bse%p2+a[i]-'A'+1)%p2; } for(int i=1;i&lt;=n;i++) str[i*2]=a[i]; n=n*2+1; for(int i=1;i&lt;=n;i+=2) str[i]='#'; str[0]='@',str[n+1]='$'; long long ans=0; for(int i=1,pos=0;i&lt;=n;i++) { if(pos+ext[pos]&gt;i) ext[i]=min(pos+ext[pos]-i,ext[pos-(i-pos)]); while(str[i-ext[i]]==str[i+ext[i]]) { ext[i]++; if(str[i-ext[i]+1]=='#'&amp;&amp;ext[i]&gt;1) { int len=ext[i]-1; int rb=i/2+len/2; pair&lt;int,int&gt; pir=calchash(rb-len+1,rb); if(st.count(pir)==0) { st.insert(pir); int u=sam.suf[rb]; if(sam.len[sam.link[u]]+1&gt;len) { for(int j=BS;j&gt;=0;j--) { int to=sam.fa[u][j]; if(to!=-1&amp;&amp;sam.link[to]!=-1&amp;&amp;sam.len[sam.link[to]]+1&gt;len) u=to; } u=sam.fa[u][0]; } ans+=1ll*sam.siz[0][u]*sam.siz[1][u]; // for(int j=rb-len+1;j&lt;=rb;j++) printf(&quot;%c&quot;,a[j]); // printf(&quot; : %d * %d\\n&quot;,sam.siz[0][u],sam.siz[1][u]); } } } if(i+ext[i]&gt;pos+ext[pos]) pos=i; } printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"SAM（后缀自动机）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/samhou-zhui-zi-dong-ji-xue-xi-bi-ji/","stats":{"text":"47 min read","time":2780000,"words":9462,"minutes":47},"date":"2023-04-15 12:04:09","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>题目链接：<a href=\"https://vjudge.csgrandeur.cn/problem/UniversalOJ-228\">UniversalOJ 228 基础数据结构练习题</a></p>\n<p>你需要维护一个数据结构，支持以下三种操作：</p>\n<ul>\n<li><code>1 l r k</code> 给 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">i\\in[l,r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 的所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>；</li>\n<li><code>2 l r</code> 对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">i\\in[l,r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 的所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，令其变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌊</mo><msub><msqrt><mi>a</mi></msqrt><mi>i</mi></msub><mo>⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor\\sqrt a_i\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0897000000000001em;vertical-align:-0.28942em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8002800000000001em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathdefault\" style=\"padding-left:0.833em;\">a</span></span><span style=\"top:-2.76028em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,\n-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,\n-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,\n35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,\n-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467\ns-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422\ns-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.23972em;\"><span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17224399999999995em;\"><span style=\"top:-2.4105800000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.28942em;\"><span></span></span></span></span></span></span><span class=\"mclose\">⌋</span></span></span></span>；</li>\n<li><code>3 l r</code> 查询 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mi>r</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{i=l}^r a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.35351em;vertical-align:-1.002113em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.351397em;\"><span style=\"top:-2.097887em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span style=\"top:-3.000005em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.002113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>；</li>\n</ul>\n<p>序列长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，操作次数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span>，值域为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,q\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>V</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le V\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 题目链接：UniversalOJ 228 基础数据结构练习题 你需要维护一个数据结构，支持以下三种操作： 1 l r k 给 i∈[l,r]i\\in[l,r]i∈[l,r] 的所有 aia_iai​ 加上 kkk； 2 l r 对于 i∈[l,r]i\\in[l,r]i∈[l,r] 的所有 aia_iai​，令其变为 ⌊ai⌋\\lfloor\\sqrt a_i\\rfloor⌊a​i​⌋； 3 l r 查询 ∑i=lrai\\sum\\limits_{i=l}^r a_ii=l∑r​ai​； 序列长度为 nnn，操作次数为 qqq，值域为 VVV。 1≤n,q≤1051\\le n,q\\le 10^51≤n,q≤105，1≤V≤1091\\le V\\le 10^91≤V≤109。 不难发现，⌊⌊⌊⌊⌊109⌋⌋⌋⌋⌋=1\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{10^9}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor=1⎣⎢⎢⎢​⎣⎢⎢⎢​⌊⌊⌊109​⌋​⌋​⌋​⎦⎥⎥⎥​​⎦⎥⎥⎥​=1，也就是说，值域内一个数变为 111 所需的开根次数可以看作是一个很小的常数。这样若没有区间加操作，我们就可以每次暴力找到区间内非 111 的数，暴力地一个一个处理，这就是 P4145 上帝造题的七分钟 2 / 花神游历各国 的做法。 但是本题有了区间加操作，这使得直接暴力找的时间复杂度退化为 O(qn)O(qn)O(qn)。但是考虑到因为 a−b=(a−b)(a+b)a-b=(\\sqrt a - \\sqrt b)(\\sqrt a+\\sqrt b)a−b=(a​−b​)(a​+b​)，所以开一次根至少会让区间极差变为之前的一半，而当开根退化为区间减的时候就可以快速维护了。 考虑一次区间加对时间复杂度的贡献，由于 [l,r][l,r][l,r] 操作只会影响到包含 lll 和包含 rrr 的 O(log⁡n)O(\\log n)O(logn) 个区间，每个区间至多增加 O(log⁡V)O(\\log V)O(logV)，所以时间复杂度为 O(qlog⁡nlog⁡V)O(q\\log n\\log V)O(qlognlogV)，足以通过本题。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; const int S=100005; int n,m; long long a[S]; long long mn[S&lt;&lt;2],mx[S&lt;&lt;2],sm[S&lt;&lt;2],tg[S&lt;&lt;2]; inline void upd(int u) { mn[u]=min(mn[u&lt;&lt;1],mn[u&lt;&lt;1|1]); mx[u]=max(mx[u&lt;&lt;1],mx[u&lt;&lt;1|1]); sm[u]=sm[u&lt;&lt;1]+sm[u&lt;&lt;1|1]; } inline void adtg(int u,int l,int r,long long val) { mn[u]+=val; mx[u]+=val; sm[u]+=val*(r-l+1); tg[u]+=val; } inline void dwtg(int u,int l,int r) { int mid=l+r&gt;&gt;1; adtg(u&lt;&lt;1,l,mid,tg[u]),adtg(u&lt;&lt;1|1,mid+1,r,tg[u]); tg[u]=0; } void built(int u,int l,int r) { tg[u]=0; if(l==r) return mn[u]=mx[u]=sm[u]=a[l],void(); int mid=l+r&gt;&gt;1; built(u&lt;&lt;1,l,mid),built(u&lt;&lt;1|1,mid+1,r); upd(u); } void add(int u,int l,int r,int L,int R,long long val) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) return adtg(u,l,r,val); dwtg(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid) add(u&lt;&lt;1,l,mid,L,R,val); if(R&gt;=mid+1) add(u&lt;&lt;1|1,mid+1,r,L,R,val); upd(u); } void updat(int u,int l,int r,int L,int R) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) { long long mnd=mn[u]-(long long)sqrt(mn[u]),mxd=mx[u]-(long long)sqrt(mx[u]); if(mnd==mxd) adtg(u,l,r,-mnd); else { dwtg(u,l,r); int mid=l+r&gt;&gt;1; updat(u&lt;&lt;1,l,mid,L,R),updat(u&lt;&lt;1|1,mid+1,r,L,R); upd(u); } return; } dwtg(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid) updat(u&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1) updat(u&lt;&lt;1|1,mid+1,r,L,R); upd(u); } long long que(int u,int l,int r,int L,int R) { if(l&gt;R||r&lt;L) return 0; if(l&gt;=L&amp;&amp;r&lt;=R) return sm[u]; dwtg(u,l,r); int mid=l+r&gt;&gt;1; long long res=0; if(L&lt;=mid) res+=que(u&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1) res+=que(u&lt;&lt;1|1,mid+1,r,L,R); return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); built(1,1,n); while(m--) { int op,l,r; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) { long long v; scanf(&quot;%lld&quot;,&amp;v); add(1,1,n,l,r,v); } else if(op==2) updat(1,1,n,l,r); else printf(&quot;%lld\\n&quot;,que(1,1,n,l,r)); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"UniversalOJ 228 基础数据结构练习题 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/universaloj-228-ji-chu-shu-ju-jie-gou-lian-xi-ti-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":348000,"words":1065,"minutes":6},"date":"2023-04-15 12:02:52","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>Alice 和 Bob 在一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的树上玩游戏，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个节点上有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 个石子，每轮可以选择一个深度至少为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的节点并移动任意多石子到其 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 级祖先处，对每个结点询问如果将其作为根谁会赢。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mn>20</mn><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">n\\le 10^5 , k\\le 20 , a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" Alice 和 Bob 在一棵 nnn 个点的树上玩游戏，第 iii 个节点上有 aia_iai​ 个石子，每轮可以选择一个深度至少为 kkk 的节点并移动任意多石子到其 kkk 级祖先处，对每个结点询问如果将其作为根谁会赢。 n≤105,k≤20,ai≤109n\\le 10^5 , k\\le 20 , a_i\\le 10^9n≤105,k≤20,ai​≤109。 首先不难发现 k&gt;1k&gt;1k&gt;1 相当于拆成了多棵树，那么考虑 k=1k=1k=1 时一些特殊情况下先手必胜的条件： 菊花：此时是经典的 Nim 游戏，先手必胜当且仅当 ⊕u=rootau=0\\oplus_{u\\not=root}a_u\\not=0⊕u​=root​au​​=0； 链（其实就是阶梯 Nim 游戏）：把节点按照深度的奇偶性分成两类（根节点深度为 000），深度为奇数的叫奇节点，深度为偶数的叫偶节点。那么对偶节点进行操作是没用的，因为后手可以模仿先手的操作，把先手移去奇节点的石子都往前移到下一个偶节点，最后移到无法移动的根节点，先手还是先手。所以可以把在奇节点上的操作看作是丢掉了一些石子，那么先手必胜当且仅当 ⊕depu≡1(mod2)au=0\\oplus_{dep_u\\equiv 1\\pmod 2}a_u\\not=0⊕depu​≡1(mod2)​au​​=0； 考虑将链的情况推广一下，不难发现，对于任意一棵树，链情况的结论都成立。所以 k=1k=1k=1 时先手必胜当且仅当 ⊕depu≡1(mod2)au=0\\oplus_{dep_u\\equiv 1\\pmod 2}a_u\\not=0⊕depu​≡1(mod2)​au​​=0。 对于 k&gt;1k&gt;1k&gt;1 的情况，拆成多棵 k=1k=1k=1 的树做，先手必胜当且仅当 ⊕i∈tree⊕depi,u≡1(mod2)ai,u=0\\oplus_{i\\in tree}\\oplus_{dep_{i,u}\\equiv 1\\pmod 2}a_{i,u}\\not=0⊕i∈tree​⊕depi,u​≡1(mod2)​ai,u​​=0。 简单换根 dp 即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005; int n,k; int a[S]; int esum,to[S],nxt[S],h[S]; int dp[S][25][2],pd[S][25][2],ans[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs1(int u,int fa) { dp[u][0][1]=a[u]; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs1(v,u); dp[u][0][0]^=dp[v][k-1][1]; dp[u][0][1]^=dp[v][k-1][0]; for(int j=1;j&lt;k;j++) { dp[u][j][0]^=dp[v][j-1][0]; dp[u][j][1]^=dp[v][j-1][1]; } } } void dfs2(int u,int fa) { if(u==1) { for(int i=0;i&lt;k;i++) pd[u][i][0]=dp[u][i][0],pd[u][i][1]=dp[u][i][1]; } else { pd[u][0][0]=pd[fa][k-1][1]^dp[u][(k-2+k)%k][k==1?0:1]; pd[u][0][1]=pd[fa][k-1][0]^dp[u][(k-2+k)%k][k==1?1:0]; for(int i=1;i&lt;k;i++) { pd[u][i][0]^=pd[fa][i-1][0]^dp[u][(i-2+k)%k][i==1?1:0]; pd[u][i][1]^=pd[fa][i-1][1]^dp[u][(i-2+k)%k][i==1?0:1]; } for(int i=0;i&lt;k;i++) pd[u][i][0]^=dp[u][i][0],pd[u][i][1]^=dp[u][i][1]; } for(int i=0;i&lt;k;i++) ans[u]^=pd[u][i][0]; // printf(&quot;%d %d\\n&quot;,pd[u][0][0],pd[u][0][1]); for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs2(v,u); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs1(1,0),dfs2(1,0); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]==0?0:1); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"博弈论","slug":"6A-_b3w3J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/6A-_b3w3J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1498F Christmas Game 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1498f-christmas-game-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":274000,"words":892,"minutes":5},"date":"2023-04-15 11:58:46","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的正整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,… ,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>x</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><msub><mi>a</mi><mi>n</mi></msub><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>x</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>x</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,n)= x\\ mod\\ a_n,f(x, i) =(x\\ mod\\ a_i)+ f(x\\ mod\\ a_i,i+ 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 为非负整数时，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的最大值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>13</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^{13}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长度为 nnn 的正整数序列 a1,a2,…,ana_1,a_2,… ,a_na1​,a2​,…,an​，令 f(x,n)=x mod an,f(x,i)=(x mod ai)+f(x mod ai,i+1)f(x,n)= x\\ mod\\ a_n,f(x, i) =(x\\ mod\\ a_i)+ f(x\\ mod\\ a_i,i+ 1)f(x,n)=x mod an​,f(x,i)=(x mod ai​)+f(x mod ai​,i+1)。 求 xxx 为非负整数时，f(x,1)f(x,1)f(x,1) 的最大值。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤ai≤10131\\le a_i\\le 10^{13}1≤ai​≤1013。 记 xi=xmod a1mod a2mod …mod aix_i=x\\mod a_1\\mod a_2\\mod\\dots\\mod a_ixi​=xmoda1​moda2​mod…modai​，ansi=f(x)−f(xi,i+1)ans_i=f(x)-f(x_i,i+1)ansi​=f(x)−f(xi​,i+1) 也就是前缀和。 设状态 (i,r,S)(i,r,S)(i,r,S) 表示考虑了 a[1,i]a_{[1,i]}a[1,i]​，xi∈[0,r]x_i\\in[0,r]xi​∈[0,r] 且 ansi=ixi+Sans_i=ix_i+Sansi​=ixi​+S，那么显然这个状态下最大的 ansians_iansi​ 为 ir+Sir+Sir+S。 这是图解，最大的 ansians_iansi​ 即为 iii 前面那个楼梯的面积： 考虑转移，有两种情况： r≤ai+1r\\le a_{i+1}r≤ai+1​：无事发生，转移到 (i+1,r,S)(i+1,r,S)(i+1,r,S)； r&gt;ai+1r&gt;a_{i+1}r&gt;ai+1​：需要取模，分成两种子情况： xi≤r−(rmod ai+1)x_i\\le r-(r\\mod a_{i+1})xi​≤r−(rmodai+1​)：蓝色部分，转移到 (i+1,ai+1−1,S+i(r−(rmod ai+1)−ai+1)(i+1,a_{i+1}-1,S+i(r-(r\\mod a_{i+1})-a_{i+1})(i+1,ai+1​−1,S+i(r−(rmodai+1​)−ai+1​)； xi&gt;r−(rmod ai+1)x_i&gt; r-(r\\mod a_{i+1})xi​&gt;r−(rmodai+1​)：红色部分，转移到 (i+1,rmod ai+1,S+i(r−(rmod ai+1))(i+1,r\\mod a_{i+1},S+i(r-(r\\mod a_{i+1}))(i+1,rmodai+1​,S+i(r−(rmodai+1​))； 图解（绿色是第一种转移 SSS 增加的部分，黄色是第二种）: 不难发现，第二种转移的 rrr 是固定的，那么只需要将 SSS 取 max⁡\\maxmax 即可，所以每个 iii 最多只会贡献一种新状态，并且由于最多取模 log⁡V\\log VlogV 次（VVV 是值域），所以状态数是 nlog⁡Vn\\log VnlogV 的，用 set 优化转移可以做到 O(nlog⁡V+nlog⁡(nlog⁡V))O(n\\log V+n\\log(n\\log V))O(nlogV+nlog(nlogV)) 的时间复杂度。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=200005; inline void fio(string name) { freopen((name+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin); freopen((name+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout); } struct node { long long r,s; inline bool operator&lt;(node b) const { return r==b.r?s&gt;b.s:r&gt;b.r; } }; int n,m; long long a[S]; set&lt;node&gt; dp; int main() { fio(&quot;mod&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); dp.insert((node){a[1]-1,0}); for(int i=2;i&lt;=n;i++) { long long mx=-114; for(node u:dp) { if(u.r&lt;a[i]) break; dp.insert((node){u.r%a[i],u.s+(i-1)*(u.r-u.r%a[i])}); mx=max(mx,u.s+(i-1)*(u.r-u.r%a[i]-a[i])); } while((*dp.begin()).r&gt;=a[i]) dp.erase(dp.begin()); if(mx!=-114) dp.insert((node){a[i]-1,mx}); } long long ans=0; for(node u:dp) ans=max(ans,n*u.r+u.s); printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023 NOI 模拟赛 01】膜 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023-noi-mo-ni-sai-01-mo-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":258000,"words":786,"minutes":5},"date":"2023-04-15 11:54:58","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给定长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的颜色序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，每次你可以选择任意长度的<strong>连续且颜色相同</strong>的一段位置，将其全部变成任意同一种颜色，问你最少总共需要多少次操作才能使得整个序列颜色相同。</p>\n<p><strong>限制：</strong> 每一种颜色初始时在序列中最多只有20个位置（是该种颜色）。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>3000</mn></mrow><annotation encoding=\"application/x-tex\">n\\le 3000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">a_i \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><mi>n</mi><mo>≤</mo><mn>3000</mn></mrow><annotation encoding=\"application/x-tex\">\\sum n \\le 3000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定长度为 nnn 的颜色序列 aia_iai​，每次你可以选择任意长度的连续且颜色相同的一段位置，将其全部变成任意同一种颜色，问你最少总共需要多少次操作才能使得整个序列颜色相同。 限制： 每一种颜色初始时在序列中最多只有20个位置（是该种颜色）。 n≤3000n\\le 3000n≤3000，ai≤na_i \\le nai​≤n，∑n≤3000\\sum n \\le 3000∑n≤3000。 首先不难发现连续一段相同的颜色的格子可以缩成一个格子，那么不妨先缩到相邻的两个格子颜色不同。 考虑某一段格子 [l,r][l,r][l,r] 最后被涂成的颜色，显然若 [l,r−1][l,r-1][l,r−1] 涂的颜色和 ara_rar​ 不同则需要花费一次操作把 [l,r−1][l,r-1][l,r−1] 涂成 ara_rar​，或者把 rrr 涂成 [l,r−1][l,r-1][l,r−1] 的颜色。那么不妨钦定让 [l,r−1][l,r-1][l,r−1] 涂成 ara_rar​，则可以设 dpl,rdp_{l,r}dpl,r​ 表示 [l,r][l,r][l,r] 这一段全部涂成 ara_rar​ 所需的最小操作次数，那么有转移： dpl,r=min⁡{dpl,r−1+1dpl,k+dpk+1,rak=ardp_{l,r}=\\min\\begin{cases}dp_{l,r-1}+1\\\\dp_{l,k}+dp_{k+1,r}&amp;a_k=a_r\\end{cases} dpl,r​=min{dpl,r−1​+1dpl,k​+dpk+1,r​​ak​=ar​​ 由于每种颜色出现次数最多只有 202020，所以可以预处理出每个位置前面最后一个与它颜色相同的位置来转移，时间复杂度 O(20n2)O(20n^2)O(20n2)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=3005; int n,a[S]; int m,b[S],dp[S][S]; int pos[S],pre[S]; inline void slove() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); m=0; for(int i=1;i&lt;=n;i++) if(a[i]!=a[i-1]) b[++m]=a[i]; for(int i=1;i&lt;=n;i++) pos[i]=0; for(int i=1;i&lt;=m;i++) { pre[i]=pos[b[i]]; pos[b[i]]=i; } for(int i=1;i&lt;=m;i++) for(int j=i;j&lt;=m;j++) dp[i][j]=1e8; for(int i=1;i&lt;=m;i++) dp[i][i]=0; for(int len=2;len&lt;=m;len++) { for(int l=1;l&lt;=m-len+1;l++) { int r=l+len-1; dp[l][r]=dp[l][r-1]+1; for(int k=pre[r];k&gt;=l;k=pre[k]) { dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]); } } } printf(&quot;%d\\n&quot;,dp[1][m]); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1572C Paint 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1572c-paint-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":186000,"words":627,"minutes":4},"date":"2023-04-15 11:52:16","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给你 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span></span></span></span>，且总价值最大，并输出最大的总价值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n \\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>W</mi><mo separator=\"true\">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≤</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le W,w_i,v_i \\le 2^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p>保证每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 能写成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>×</mo><msup><mn>2</mn><mi>b</mi></msup><mtext> </mtext><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a \\times 2^b\\space (a,b \\in \\mathbb N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">b</span></span></span></span></span></span></span></span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mclose\">)</span></span></span></span> 的形式，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">a \\leq 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span> , <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding=\"application/x-tex\">b \\leq 30</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span></span></span></span>，且答案不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给你 nnn 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 WWW，且总价值最大，并输出最大的总价值。 1≤n≤1001\\le n \\le 1001≤n≤100，1≤W,wi,vi≤2301\\le W,w_i,v_i \\le 2^{30}1≤W,wi​,vi​≤230。 保证每个 wiw_iwi​ 能写成 a×2b (a,b∈N)a \\times 2^b\\space (a,b \\in \\mathbb N)a×2b (a,b∈N) 的形式，a≤10a \\leq 10a≤10 , b≤30b \\leq 30b≤30，且答案不超过 2302^{30}230。 不难发现，虽然数据范围很大，但是由于 wi=a×2bw_i=a\\times 2^bwi​=a×2b，1≤a≤101\\le a\\le 101≤a≤10。所以 bbb 相同的 www 同时除掉 2b2^b2b 之后的和很小，只有 10n10n10n。那么不难想到按照 bbb 分组，每组物品单独做背包，最后合并。 那么设 fi,jf_{i,j}fi,j​ 表示所有 b=ib=ib=i 的物品，背包容量为 j×2ij\\times 2^ij×2i 时的最大收益。这部分可以在 O(300n)O(300n)O(300n) 的时间之内预处理完。 考虑如何合并，设 totitot_itoti​ 表示 b=ib=ib=i 的物品数量，用类似数位 dp 的思路，设 gi,jg_{i,j}gi,j​ 表示前 iii 个 bbb，背包容量为 (m&amp;((1&lt;&lt;i)−1))+j×2i(m\\&amp;((1&lt;&lt;i)-1))+j\\times 2^i(m&amp;((1&lt;&lt;i)−1))+j×2i（也就是 mmm 的前 i−1i-1i−1 位加上额外的 jjj 个 2i2^i2i）时的最大收益。这样设计状态的好处在于可以处理低位向高位借 111 的情况，那么转移即为 gi,j+k=max⁡(gi,j+k,fj+gi−1,min⁡(10∑l=0i−1totl,2k+((m&gt;&gt;(i−1))&amp;1)))g_{i,j+k}=\\max(g_{i,j+k},f_j+g_{i-1,\\min(10\\sum\\limits_{l=0}^{i-1}tot_l,2k+((m&gt;&gt;(i-1))\\&amp;1))}) gi,j+k​=max(gi,j+k​,fj​+gi−1,min(10l=0∑i−1​totl​,2k+((m&gt;&gt;(i−1))&amp;1))​) 即枚举有多少个 2i2^i2i 被上一位借了。 这部分的时间复杂度为 O(3000n)O(3000n)O(3000n)，总时间复杂度 O(4000n)O(4000n)O(4000n) 左右。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int S=105,BS=30,MS=1005; int n,m; int tot[BS+5],vw[BS+5][S],vv[BS+5][S]; int f[BS+5][MS],g[BS+5][MS]; void slove() { for(int i=0;i&lt;=BS;i++) tot[i]=false; memset(f,0,sizeof(f)),memset(g,0,sizeof(g)); for(int i=1;i&lt;=n;i++) { int w,v; scanf(&quot;%d%d&quot;,&amp;w,&amp;v); int a=w,b=0; while(a&amp;1^1) a&gt;&gt;=1,b++; // printf(&quot;&gt;&gt; %d %d %d\\n&quot;,a,b,v); vw[b][++tot[b]]=a; vv[b][tot[b]]=v; } for(int i=0;i&lt;=BS;i++) { for(int j=1;j&lt;=tot[i];j++) { int w=vw[i][j],v=vv[i][j]; for(int k=tot[i]*10;k&gt;=w;k--) f[i][k]=max(f[i][k],f[i][k-w]+v); } } // for(int i=0;i&lt;=10;i++) // { // for(int j=0;j&lt;=20;j++) printf(&quot;%d &quot;,f[i][j]); // printf(&quot;\\n&quot;); // } for(int i=0;i&lt;=tot[0]*10;i++) g[0][i]=f[0][i]; int sm=tot[0]; for(int i=1;i&lt;=BS;i++) { sm+=tot[i]; for(int j=0;j&lt;=sm*10;j++) { for(int k=0;k&lt;=j;k++) { g[i][j]=max(g[i][j],f[i][j-k]+g[i-1][min((sm-tot[i])*10,k*2+((m&gt;&gt;i-1)&amp;1))]); } } } printf(&quot;%d\\n&quot;,g[BS][m&gt;&gt;BS&amp;1]); } int main() { while(1) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n==-1&amp;&amp;m==-1) break; slove(); } return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P3188 [HNOI2007]梦幻岛宝珠 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p3188-hnoi2007meng-huan-dao-bao-zhu-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":268000,"words":846,"minutes":5},"date":"2023-04-15 11:48:33","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>维护一个字符串集合，支持三种操作：</p>\n<ol>\n<li>加字符串</li>\n<li>删字符串</li>\n<li>查询集合中的所有字符串在给出的模板串中出现的次数</li>\n</ol>\n<p>操作数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">m \\leq 3 \\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，输入字符串总长度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>s</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\sum |s_i| \\leq 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p><strong>本题强制在线，应该在每次输出后调用<code>fflush(stdout)</code>。你只有在输出上一个询问的答案后才能读入下一组询问。</strong></p>\n</blockquote>\n","content":" 维护一个字符串集合，支持三种操作： 加字符串 删字符串 查询集合中的所有字符串在给出的模板串中出现的次数 操作数 m≤3×105m \\leq 3 \\times 10^5m≤3×105，输入字符串总长度 ∑∣si∣≤3×105\\sum |s_i| \\leq 3\\times 10^5∑∣si​∣≤3×105。 本题强制在线，应该在每次输出后调用fflush(stdout)。你只有在输出上一个询问的答案后才能读入下一组询问。 为了叙述方便，设 len=∑∣si∣len=\\sum|s_i|len=∑∣si​∣。 首先容易想到字符串哈希，开桶存某个哈希值有多少个，然后暴力枚举子串判断。这样时间复杂度是 O(len2)O(len^2)O(len2) 的。 考虑优化，一个显然的做法是记录下集合内的串的长度，只枚举长度合法的字串。由于 1+2+3+⋯+n=n(n+1)21+2+3+\\dots+n=\\frac{n(n+1)}21+2+3+⋯+n=2n(n+1)​，所以不同的长度最多只会有 len\\sqrt lenl​en 个，时间复杂度为 lenlenlen\\sqrt{len}lenlen​。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;set&gt; #include &lt;map&gt; using namespace std; const int S=300005,bse=31,p1=998244353,p2=1000000007; int n; char a[S]; int p1p[S],p2p[S]; int cntlen[S]; set&lt;int&gt; lens; map&lt;pair&lt;int,int&gt;,int&gt; cnt; int pre1[S],pre2[S]; int main() { p1p[0]=p2p[0]=1; for(int i=1;i&lt;=S-3;i++) p1p[i]=1ll*p1p[i-1]*bse%p1,p2p[i]=1ll*p2p[i-1]*bse%p2; scanf(&quot;%d&quot;,&amp;n); while(n--&gt;0) { int tpe; scanf(&quot;%d%s&quot;,&amp;tpe,a+1); if(tpe==1) { int x=0,y=0; int len=strlen(a+1); cntlen[len]++; if(cntlen[len]==1) lens.insert(len); for(int i=1;i&lt;=len;i++) { x=(1ll*x*bse%p1+a[i]-'a'+1)%p1; y=(1ll*y*bse%p2+a[i]-'a'+1)%p2; } // printf(&quot;+ %d %d\\n&quot;,x,y); cnt[make_pair(x,y)]++; } if(tpe==2) { int x=0,y=0; int len=strlen(a+1); cntlen[len]--; if(cntlen[len]==0) lens.erase(len); for(int i=1;i&lt;=len;i++) { x=(1ll*x*bse%p1+a[i]-'a'+1)%p1; y=(1ll*y*bse%p2+a[i]-'a'+1)%p2; } // printf(&quot;- %d %d\\n&quot;,x,y); cnt[make_pair(x,y)]--; } if(tpe==3) { long long ans=0; int m=strlen(a+1); for(int i=1;i&lt;=m;i++) { pre1[i]=(1ll*pre1[i-1]*bse%p1+a[i]-'a'+1)%p1; pre2[i]=(1ll*pre2[i-1]*bse%p2+a[i]-'a'+1)%p2; } for(int len:lens) { for(int i=len;i&lt;=m;i++) { int x=(pre1[i]-1ll*pre1[i-len]*p1p[len]%p1+p1)%p1; int y=(pre2[i]-1ll*pre2[i-len]*p2p[len]%p2+p2)%p2; ans+=cnt[make_pair(x,y)]; } } printf(&quot;%lld\\n&quot;,ans); fflush(stdout); } } return 0; } ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"CF710F String Set Queries 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf710f-string-set-queries-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":197000,"words":621,"minutes":4},"date":"2023-04-15 11:39:37","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的简单无向图，求其三元环个数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le m \\le 2 \\times {10}^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.848448em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">0</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.848448em;\"><span style=\"top:-3.09734em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的简单无向图，点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 有点权 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，求其所有本质不同的四元环中所有点的点权和，模 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 个点 mmm 条边的简单无向图，求其三元环个数。 1≤n≤1051 \\le n \\le 10^51≤n≤105，1≤m≤2×1051 \\le m \\le 2 \\times {10}^51≤m≤2×105。 给定一个 nnn 个点 mmm 条边的简单无向图，点 iii 有点权 aia_iai​，求其所有本质不同的四元环中所有点的点权和，模 109+710^9+7109+7。 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤m≤2×1051\\le m\\le 2\\times 10^51≤m≤2×105，1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109。 三元环 三元环等价于 (x,y)(x,y)(x,y)，(y,z)(y,z)(y,z)，(x,z)(x,z)(x,z)。 考虑给原图定向，让度数大的连向度数小的，度数一样按编号。 这样定向后的图一定是 DAG。 有一个很暴力的想法是直接枚举 xxx，然后： 开一个桶 bbb； 枚举 xxx 出边指向的点 yyy，枚举 yyy 出边指向的点 zzz，bz→bz+1b_z\\to b_z+1bz​→bz​+1； 枚举 xxx 出边指向的点 yyy，ans→ans+byans\\to ans+b_yans→ans+by​； 这样做的时间复杂度是 O(mm)O(m\\sqrt m)O(mm​) 的。 证明 设 dud_udu​ 为点 uuu 在原图中的度数。 一条边 x→yx\\to yx→y 对时间复杂度的贡献显然为 outyout_youty​ 即 yyy 的出度。 dy≤md_y\\le \\sqrt mdy​≤m​：由于新的图是原图定向得来的，所以 outy≤dy≤mout_y\\le d_y\\le \\sqrt mouty​≤dy​≤m​； dy&gt;md_y&gt;\\sqrt mdy​&gt;m​：这样的点只有 m\\sqrt mm​ 个； 综上，时间复杂度为 mmm\\sqrt mmm​。 Q.E.D. 闲话 事实上，定向时由度数小的连向度数大的点在三元环计数中也可行。 证明 设 dud_udu​ 为点 uuu 在原图中的度数。 一条边 x→yx\\to yx→y 对时间复杂度的贡献显然为 outyout_youty​ 即 yyy 的出度。 dy≤md_y\\le \\sqrt mdy​≤m​：由于新的图是原图定向得来的，所以 outy≤dy≤mout_y\\le d_y\\le \\sqrt mouty​≤dy​≤m​； dy&gt;md_y&gt;\\sqrt mdy​&gt;m​：yyy 在新图上的出边连向的点 zzz 一定满足 dz&gt;md_z&gt;\\sqrt mdz​&gt;m​，这样的点最多只有 m\\sqrt mm​ 个，所以 outy≤mout_y\\le \\sqrt mouty​≤m​； 综上，时间复杂度为 mmm\\sqrt mmm​。 Q.E.D. #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=100005; int n,m,a[S]; vector&lt;int&gt; g[S],g2[S]; int id[S],rk[S]; int cnt[S]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(y),g[y].push_back(x); } for(int i=1;i&lt;=n;i++) id[i]=i; sort(id+1,id+n+1,[&amp;](int x,int y){return g[x].size()&lt;g[y].size();}); for(int i=1;i&lt;=n;i++) rk[id[i]]=i; for(int u=1;u&lt;=n;u++) for(int v:g[u]) if(rk[v]&lt;rk[u]) g2[u].push_back(v); long long ans=0; for(int x=1;x&lt;=n;x++) { for(int y:g2[x]) for(int z:g2[y]) cnt[z]++; for(int y:g2[x]) ans+=cnt[y]; for(int y:g2[x]) for(int z:g2[y]) cnt[z]=0; } printf(&quot;%d\\n&quot;,ans); return 0; } 四元环 四元环等价于 (x,y),(y,z)(x,y),(y,z)(x,y),(y,z) 和 (x,w),(w,z)(x,w),(w,z)(x,w),(w,z)。 按照三元环的方式给图定向，即度数大的连向度数小的。记新图为 G′G&#x27;G′，原图为 GGG。 G′G&#x27;G′ 显然是 DAG，随意取它的一个拓扑序，设 uuu 的排名为 rkurk_urku​。 直接枚举 xxx，然后： 开两个桶 cntcntcnt 和 sumsumsum； 在 G’G’G’ 中枚举 xxx 出边指向的点 yyy，在 GGG 中枚举 yyy 出边指向的点 zzz： ans→ans+sumz+cntz×ayans\\to ans+sum_z+cnt_z\\times a_yans→ans+sumz​+cntz​×ay​； 若 rkz&lt;rkxrk_z&lt;rk_xrkz​&lt;rkx​ 则 cntz→cntz+1cnt_z\\to cnt_z+1cntz​→cntz​+1，sumz→sumz+ax+ay+azsum_z\\to sum_z+a_x+a_y+a_zsumz​→sumz​+ax​+ay​+az​； 清空两个桶； 可以看成是每次删除 rkxrk_xrkx​ 最大的点 xxx 并统计答案，这样做的时间复杂度是 O(mm)O(m\\sqrt m)O(mm​) 的。 证明和三元环的第一个证明是一样的。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=100005,p=1000000007; int n,m,a[S]; vector&lt;int&gt; g[S],g2[S]; int id[S],rk[S]; int cnt[S],bu[S]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(y),g[y].push_back(x); } for(int i=1;i&lt;=n;i++) id[i]=i; sort(id+1,id+n+1,[&amp;](int x,int y){return g[x].size()&lt;g[y].size();}); for(int i=1;i&lt;=n;i++) rk[id[i]]=i; for(int u=1;u&lt;=n;u++) for(int v:g[u]) if(rk[v]&lt;rk[u]) g2[u].push_back(v); int ans=0; for(int x=1;x&lt;=n;x++) { for(int y:g2[x]) { for(int z:g[y]) { if(rk[z]&gt;=rk[x]) continue; ans=(0ll+ans+bu[z]+1ll*cnt[z]*a[y]%p)%p; cnt[z]++; bu[z]=(0ll+bu[z]+a[x]+a[y]+a[z])%p; } } for(int y:g2[x]) for(int z:g[y]) cnt[z]=bu[z]=0; } printf(&quot;%d\\n&quot;,ans); return 0; } 闲话 三元环和四元环计数的本质都是找有 333 个点的简单链，那么 nnn 个点 mmm 条边的无向图中有 kkk 个点的本质不同的简单链个数的级别是怎么样的呢？ k=1k=1k=1：O(n)O(n)O(n)； k=2k=2k=2：O(m)O(m)O(m)； k=3k=3k=3：O(mm)O(m\\sqrt m)O(mm​)； 能否得出一个结论：k≥2k\\ge 2k≥2 时级别是 O((m)k)O((\\sqrt m)^k)O((m​)k) 的？ ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"无向图三元环 & 四元环计数 小结","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p1989-wu-xiang-tu-san-yuan-huan-ji-shu-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":415000,"words":1363,"minutes":7},"date":"2023-04-15 11:21:28","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>九条可怜是一个喜欢树的女孩子，她想生成两棵均有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的树。</p>\n<p>第一棵树的生成方式是：</p>\n<ol>\n<li>节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 作为树的根。</li>\n<li>对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>2</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">i \\in [2, n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span>，从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1, i - 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中选取一个节点作为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的父亲。</li>\n</ol>\n<p>第二棵树的生成方式是：</p>\n<ol>\n<li>节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 作为树的根。</li>\n<li>对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">i \\in [1, n - 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[i + 1, n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 中选取一个节点作为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的父亲。</li>\n</ol>\n<p>九条可怜希望对于任意 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">i \\in [1, n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span>，若第一棵树中的节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为叶子，那么第二棵树中的节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为非叶子；若第一棵树中的节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为非叶子，那么第二棵树中的节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为叶子。一个节点被称为叶子当且仅当没有节点的父亲是它。</p>\n<p>九条可怜希望你统计生成两棵树的方案数是多少。具体地，你需要对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>∈</mo><mo>[</mo><mn>2</mn><mo separator=\"true\">,</mo><mi>N</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n \\in [2, N]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span> 都计算方案数。两种方案不同当且仅当存在一棵树中的一个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，两种方案中它的父亲不同。因为答案可能很大，你只需要输出答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 取模后的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">2 \\le N \\le 500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>10</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">10 \\le M \\le 2^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 九条可怜是一个喜欢树的女孩子，她想生成两棵均有 nnn 个节点的树。 第一棵树的生成方式是： 节点 111 作为树的根。 对于 i∈[2,n]i \\in [2, n]i∈[2,n]，从 [1,i−1][1, i - 1][1,i−1] 中选取一个节点作为 iii 的父亲。 第二棵树的生成方式是： 节点 nnn 作为树的根。 对于 i∈[1,n−1]i \\in [1, n - 1]i∈[1,n−1]，从 [i+1,n][i + 1, n][i+1,n] 中选取一个节点作为 iii 的父亲。 九条可怜希望对于任意 i∈[1,n]i \\in [1, n]i∈[1,n]，若第一棵树中的节点 iii 为叶子，那么第二棵树中的节点 iii 为非叶子；若第一棵树中的节点 iii 为非叶子，那么第二棵树中的节点 iii 为叶子。一个节点被称为叶子当且仅当没有节点的父亲是它。 九条可怜希望你统计生成两棵树的方案数是多少。具体地，你需要对于所有 n∈[2,N]n \\in [2, N]n∈[2,N] 都计算方案数。两种方案不同当且仅当存在一棵树中的一个节点 iii，两种方案中它的父亲不同。因为答案可能很大，你只需要输出答案对 MMM 取模后的结果。 2≤N≤5002 \\le N \\le 5002≤N≤500，10≤M≤23010 \\le M \\le 2^{30}10≤M≤230。 设 f(S)f(S)f(S) 表示叶子节点集合为 SSS 时第一棵树的方案数，g(T)g(T)g(T) 表示叶子节点集合为 TTT 时第二棵树的方案数，那么有 ans=∑S∩T=∅,S∪T={1,2,3,…,n}f(S)g(T)ans=\\sum\\limits_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,3,\\dots,n\\}}f(S)g(T) ans=S∩T=∅,S∪T={1,2,3,…,n}∑​f(S)g(T) 发现非叶子节点非常难处理，所以不妨设 f′(S)f&#x27;(S)f′(S) 表示非叶子节点集合为 SSS 是第一棵树的方案树，设 g’(T)g’(T)g’(T) 表示非叶子节点集合为 TTT 时第二棵树的方案数，那么有 ans=∑S∩T=∅,S∪T={1,2,3,…,n}f(S)g(T)=∑S∩T=∅,S∪T={1,2,3,…,n}∑S′∈S,T′∈Tf′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣=∑S′∩T′=∅f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣2n−∣S′∣−∣T′∣ （S′ 和 T′ 之外的节点可以出现在 S 或 T 中）=∑S′∩T′=∅f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣\\begin{aligned} ans&amp;=\\sum\\limits_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,3,\\dots,n\\}}f(S)g(T)\\\\ &amp;=\\sum\\limits_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,3,\\dots,n\\}}\\sum\\limits_{S&#x27;\\in S,T&#x27;\\in T}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{n-|S&#x27;|-|T&#x27;|}\\\\ &amp;=\\sum\\limits_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-1)^{n-|S&#x27;|-|T&#x27;|}2^{n-|S&#x27;|-|T&#x27;|}\\,\\,\\,\\text{（}S&#x27;\\text{ 和 }T&#x27;\\text{ 之外的节点可以出现在 }S\\text{ 或 }T\\text{ 中）}\\\\ &amp;=\\sum\\limits_{S&#x27;\\cap T&#x27;=\\varnothing}f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-2)^{n-|S&#x27;|-|T&#x27;|} \\end{aligned} ans​=S∩T=∅,S∪T={1,2,3,…,n}∑​f(S)g(T)=S∩T=∅,S∪T={1,2,3,…,n}∑​S′∈S,T′∈T∑​f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣=S′∩T′=∅∑​f′(S′)g′(T′)(−1)n−∣S′∣−∣T′∣2n−∣S′∣−∣T′∣（S′ 和 T′ 之外的节点可以出现在 S 或 T 中）=S′∩T′=∅∑​f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣​ 那么设 dpi,j,kdp_{i,j,k}dpi,j,k​ 表示处理到 iii，∣S′∩{1,2,3,…,i}∣=j,∣T′∩{i+1,i+2,i+3,…,n}∣=k|S&#x27;\\cap\\{1,2,3,\\dots,i\\}|=j,|T&#x27;\\cap\\{i+1,i+2,i+3,\\dots,n\\}|=k∣S′∩{1,2,3,…,i}∣=j,∣T′∩{i+1,i+2,i+3,…,n}∣=k 时的 f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣f&#x27;(S&#x27;)g&#x27;(T&#x27;)(-2)^{n-|S&#x27;|-|T&#x27;|}f′(S′)g′(T′)(−2)n−∣S′∣−∣T′∣，有转移： j×k×dpi,j,k→dpi+1,j+1,kj\\times k\\times dp_{i,j,k}\\to dp_{i+1,j+1,k}j×k×dpi,j,k​→dpi+1,j+1,k​ j×k×dpi,j,k→dpi+1,j,k−1j\\times k\\times dp_{i,j,k}\\to dp_{i+1,j,k-1}j×k×dpi,j,k​→dpi+1,j,k−1​ −2×j×k×dpi,j,k→dpi+1,j,k-2\\times j\\times k\\times dp_{i,j,k}\\to dp_{i+1,j,k}−2×j×k×dpi,j,k​→dpi+1,j,k​ 边界条件 dp1,1,k=1,1≤k≤n−1dp_{1,1,k}=1,1\\le k\\le n-1dp1,1,k​=1,1≤k≤n−1。 答案为 ∑i=1n−1dpn−1,i,1×i\\sum\\limits_{i=1}^{n-1}dp_{n-1,i,1}\\times ii=1∑n−1​dpn−1,i,1​×i。 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=505; int n,p; int dp[S][S][S]; inline void addd(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;p); for(int i=1;i&lt;=n-1;i++) dp[1][1][i]=1; for(int i=1;i&lt;=n-1;i++) { for(int j=1;j&lt;=i;j++) { for(int k=1;k&lt;=n-i;k++) { addd(dp[i+1][j+1][k],1ll*j*k%p*dp[i][j][k]%p); addd(dp[i+1][j][k-1],1ll*j*k%p*dp[i][j][k]%p); addd(dp[i+1][j][k],p-2ll*j*k%p*dp[i][j][k]%p); } } } for(int i=2;i&lt;=n;i++) { int ans=0; for(int j=1;j&lt;=n-1;j++) addd(ans,1ll*dp[i-1][j][1]*j%p); printf(&quot;%d\\n&quot;,ans); } return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P8329 [ZJOI2022] 树 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p8329-zjoi2022-shu-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":398000,"words":1260,"minutes":7},"date":"2023-04-15 11:18:28","dateFormat":"2023-04-15"},{"abstract":"<blockquote>\n<p>为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？</p>\n<p>判断两棵树是否同构的伪代码如下：</p>\n<figure data-type=\"image\" tabindex=\"1\"><img src=\"/../post-images/1681474508176.webp\" alt=\"\" loading=\"lazy\"></figure>\n<p>对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>100</mn><mi mathvariant=\"normal\">%</mi></mrow><annotation encoding=\"application/x-tex\">100\\%</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">%</span></span></span></span> 的数据，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 nnn 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？ 判断两棵树是否同构的伪代码如下： 对于 100%100\\%100% 的数据，1≤n≤1091 \\le n \\le 10^91≤n≤109。 对于每棵 nnn 个点的二叉树，设它有 kkk 个叶子，那么把这 kkk 个叶子分别删去就能得到 kkk 棵 n−1n-1n−1 个点的二叉树。 由于每一颗 n−1n-1n−1 个点的二叉树都能悬挂 nnn 个新的叶子，所以每一棵 n−1n-1n−1 个点的二叉树都会被上面的过程得到 nnn 次。 由于 nnn 个点的有根二叉树有 (2nn)n+1\\frac{\\binom{2n}{n}}{n+1}n+1(n2n​)​ 种，所以 nnn 个点的所有二叉树总共有 (2n−2n−1)\\binom{2n-2}{n-1}(n−12n−2​) 个叶子，期望有 (2n−21n−1)(2nn)n+1=(n+1)(2n−2)!(n−1)!2(2n)!n!2=(n+1)n22n(2n−1)=n(n+1)2(2n−1)\\frac{\\binom{2n-2}{1n-1}}{\\frac{\\binom{2n}{n}}{n+1}}=\\frac{(n+1)\\frac{(2n-2)!}{(n-1)!^2}}{\\frac{(2n)!}{n!^2}}=\\frac{(n+1)n^2}{2n(2n-1)}=\\frac{n(n+1)}{2(2n-1)}n+1(n2n​)​(1n−12n−2​)​=n!2(2n)!​(n+1)(n−1)!2(2n−2)!​​=2n(2n−1)(n+1)n2​=2(2n−1)n(n+1)​ 个叶子。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; int main() { scanf(&quot;%d&quot;,&amp;n); printf(&quot;%.9Lf\\n&quot;,n*(n+1)/(long double)(2*(2*n-1))); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P3978 [TJOI2015]概率论 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p3978-tjoi2015gai-lu-lun-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":113000,"words":401,"minutes":2},"date":"2023-04-14 20:14:40","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>小 Z 正在自学量子计算机相关知识，最近他在研究量子通信章节，并遇到了一个有趣的问题。在该问题中，Alice 和 Bob 正在进行量子通信，它们的通信语言是一个大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的字典 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，在该字典中，每一个单词 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le i \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>）都可以用一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"bold-italic\">256</mn></mrow><annotation encoding=\"application/x-tex\">\\boldsymbol{256}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">2</span><span class=\"mord mathbf\">5</span><span class=\"mord mathbf\">6</span></span></span></span></span></span> <strong>位的</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"bold-italic\">01</mn></mrow><annotation encoding=\"application/x-tex\">\\boldsymbol{01}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">0</span><span class=\"mord mathbf\">1</span></span></span></span></span></span> <strong>串</strong>来表示。在本题中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 可以通过调用函数 <code>gen</code> 来生成，选手可以在题目目录下的 <code>gen.cpp</code> 中查看，该函数的参数 <code>n</code>、<code>a1</code>、<code>a2</code> 将由输入数据给出。</p>\n<p>Alice 和 Bob 接下来要进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 次通信，每次通信由 Alice 向 Bob 传输<strong>恰好一个</strong>字典中的单词。然而，两人使用的通信信道并不可靠，会受到噪音的干扰。更具体地，对于第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 次传输，记 Alice 传输的原单词为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，该 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串会受噪音干扰而<strong>翻转最多</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"bold-italic\">k</mi><mi mathvariant=\"bold-italic\">i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\boldsymbol{k_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord boldsymbol\" style=\"margin-right:0.01852em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33528199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01852em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord boldsymbol mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></span> <strong>位</strong>。换句话说，记 Bob 这次收到的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">y_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，它与 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 相比，可能有最多 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">k_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 位是不同的，并且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">y_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 可能不在字典 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中出现。</p>\n<p>与此同时，Bob 得知坏人 Eve 也潜入了两人的通信信道，并准备干扰两人的通信。他的干扰方式是将 Bob 收到的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串变为任意的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding=\"application/x-tex\">256</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mord\">6</span></span></span></span> 位 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串，并且这个串可能不在字典 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中出现。Eve 非常狡猾，他<strong>不一定</strong>会对每次通信都进行干扰。</p>\n<p>现在 Bob 找来了你帮忙，对于接下来的每次通信，你需要根据 Bob 最终收到的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串以及这次通信的噪音干扰阈值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">k_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le k_i \\le 15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span>），判断这次通信是否有可能没有受到 Eve 的干扰（即 Bob 收到的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串可以由字典中的某个单词翻转至多 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">k_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 位后得到）。本次通信如果有可能没受到 Eve 干扰，请你输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，否则输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。Bob 很信任你的能力，所以你需要<strong>在线地回答结果，具体要求见输入格式</strong>。</p>\n<p>为了降低读入用时， Bob 收到的串将用<strong>长度为</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"bold-italic\">64</mn></mrow><annotation encoding=\"application/x-tex\">\\boldsymbol{64}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">6</span><span class=\"mord mathbf\">4</span></span></span></span></span></span> <strong>的</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"bold-italic\">16</mn></mrow><annotation encoding=\"application/x-tex\">\\boldsymbol{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">1</span><span class=\"mord mathbf\">6</span></span></span></span></span></span> <strong>进制串</strong>给出，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span></span></span></span> 进制串中包含数字字符 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext mathvariant=\"monospace\">0</mtext><mo>∼</mo><mtext mathvariant=\"monospace\">9</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{0} \\sim \\texttt{9}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">0</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">9</span></span></span></span></span> 与大写英文字母 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext mathvariant=\"monospace\">A</mtext><mo>∼</mo><mtext mathvariant=\"monospace\">F</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{A} \\sim \\texttt{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">A</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">F</span></span></span></span></span>，其中字符 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext mathvariant=\"monospace\">A</mtext><mo>∼</mo><mtext mathvariant=\"monospace\">F</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{A} \\sim \\texttt{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">A</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">F</span></span></span></span></span> 依次表示数值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>10</mn><mo>∼</mo><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">10 \\sim 15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span></span></span></span> 进制串可以逐位转化为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串，例如：<code>5</code> 对应 <code>0101</code>，<code>A</code> 对应 <code>1010</code>，<code>C</code> 对应 <code>1100</code>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>4</mn><mo>×</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 4 \\times {10}^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.848448em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">0</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.848448em;\"><span style=\"top:-3.09734em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1.2</mn><mo>×</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le m \\le 1.2 \\times {10}^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.848448em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">0</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.848448em;\"><span style=\"top:-3.09734em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le k_i \\le 15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0, 2^{64} - 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">6</span><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 之间均匀随机生成。</p>\n</blockquote>\n","content":" 小 Z 正在自学量子计算机相关知识，最近他在研究量子通信章节，并遇到了一个有趣的问题。在该问题中，Alice 和 Bob 正在进行量子通信，它们的通信语言是一个大小为 nnn 的字典 SSS，在该字典中，每一个单词 sis_isi​（1≤i≤n1 \\le i \\le n1≤i≤n）都可以用一个 256\\boldsymbol{256}256 位的 01\\boldsymbol{01}01 串来表示。在本题中 sis_isi​ 可以通过调用函数 gen 来生成，选手可以在题目目录下的 gen.cpp 中查看，该函数的参数 n、a1、a2 将由输入数据给出。 Alice 和 Bob 接下来要进行 mmm 次通信，每次通信由 Alice 向 Bob 传输恰好一个字典中的单词。然而，两人使用的通信信道并不可靠，会受到噪音的干扰。更具体地，对于第 iii 次传输，记 Alice 传输的原单词为 xix_ixi​，该 010101 串会受噪音干扰而翻转最多 ki\\boldsymbol{k_i}ki​ 位。换句话说，记 Bob 这次收到的 010101 串为 yiy_iyi​，它与 xix_ixi​ 相比，可能有最多 kik_iki​ 位是不同的，并且 yiy_iyi​ 可能不在字典 SSS 中出现。 与此同时，Bob 得知坏人 Eve 也潜入了两人的通信信道，并准备干扰两人的通信。他的干扰方式是将 Bob 收到的 010101 串变为任意的 256256256 位 010101 串，并且这个串可能不在字典 SSS 中出现。Eve 非常狡猾，他不一定会对每次通信都进行干扰。 现在 Bob 找来了你帮忙，对于接下来的每次通信，你需要根据 Bob 最终收到的 010101 串以及这次通信的噪音干扰阈值 kik_iki​（0≤ki≤150 \\le k_i \\le 150≤ki​≤15），判断这次通信是否有可能没有受到 Eve 的干扰（即 Bob 收到的 010101 串可以由字典中的某个单词翻转至多 kik_iki​ 位后得到）。本次通信如果有可能没受到 Eve 干扰，请你输出 111，否则输出 000。Bob 很信任你的能力，所以你需要在线地回答结果，具体要求见输入格式。 为了降低读入用时， Bob 收到的串将用长度为 64\\boldsymbol{64}64 的 16\\boldsymbol{16}16 进制串给出，161616 进制串中包含数字字符 0∼9\\texttt{0} \\sim \\texttt{9}0∼9 与大写英文字母 A∼F\\texttt{A} \\sim \\texttt{F}A∼F，其中字符 A∼F\\texttt{A} \\sim \\texttt{F}A∼F 依次表示数值 10∼1510 \\sim 1510∼15。 161616 进制串可以逐位转化为 010101 串，例如：5 对应 0101，A 对应 1010，C 对应 1100。 1≤n≤4×1051 \\le n \\le 4 \\times {10}^51≤n≤4×105，1≤m≤1.2×1051 \\le m \\le 1.2 \\times {10}^51≤m≤1.2×105，0≤ki≤150 \\le k_i \\le 150≤ki​≤15，a1a_1a1​ 和 a2a_2a2​ 在 [0,264−1][0, 2^{64} - 1][0,264−1] 之间均匀随机生成。 观察到由于最多只会翻转 151515 位，所以可以把每个 010101 串都分成 161616 段，这样若没被那个人干扰则总会有一段和字典中的完全一样。 由于数据随机，字典中合法的串的个数大概只有 400000÷216×16400000\\div2^{16}\\times16400000÷216×16 个，这个数字大概是 100100100，所以能过。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P7738 [NOI2021] 量子通信 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p7738-noi2021-liang-zi-tong-xin-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":197000,"words":820,"minutes":4},"date":"2023-04-14 20:03:11","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>B 君在玩一个游戏，这个游戏由 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个灯和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个开关组成，给定这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个灯的初始状态，下标为从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的正整数。</p>\n<p>每个灯有两个状态亮和灭，我们用 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 来表示这个灯是亮的，用 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。</p>\n<p>但是当操作第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个开关时，所有编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的约数（包括 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。</p>\n<p>B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。</p>\n<p>这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 步）操作这些开关。</p>\n<p>B 君想知道按照这个策略（也就是先随机操作，最后小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 步，使用操作次数最小的操作方法）的操作次数的期望。</p>\n<p>这个期望可能很大，但是 B 君发现这个期望乘以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的阶乘一定是整数，所以他只需要知道这个整数对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>100003</mn></mrow><annotation encoding=\"application/x-tex\">100003</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">3</span></span></span></span> 取模之后的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\leq n \\leq 100000, 0 \\leq k \\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" B 君在玩一个游戏，这个游戏由 nnn 个灯和 nnn 个开关组成，给定这 nnn 个灯的初始状态，下标为从 111 到 nnn 的正整数。 每个灯有两个状态亮和灭，我们用 111 来表示这个灯是亮的，用 000 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。 但是当操作第 iii 个开关时，所有编号为 iii 的约数（包括 111 和 iii）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。 B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。 这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 kkk 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 kkk 步）操作这些开关。 B 君想知道按照这个策略（也就是先随机操作，最后小于等于 kkk 步，使用操作次数最小的操作方法）的操作次数的期望。 这个期望可能很大，但是 B 君发现这个期望乘以 nnn 的阶乘一定是整数，所以他只需要知道这个整数对 100003100003100003 取模之后的结果。 1≤n≤100000,0≤k≤n1 \\leq n \\leq 100000, 0 \\leq k \\leq n1≤n≤100000,0≤k≤n。 不难发现按下同一个灯的开关两次相当于没按，并且一定有解，因为可以倒着跑，遇到亮着的灯直接关掉。然后不难发现这是唯一解。 所以可以设 dpidp_idpi​ 表示从 还有 iii 个灯的 开关按下状态 和解不同转移到有 i−1i-1i−1 个不同的期望次数，那么有： dpi=in+n−in(1+dpi+1+dpi)ndpi=i+(n−i)(1+dpi+1+dpi)idpi=i+(n−i)(1+dpi+1)dpi=i+(n−i)(1+dpi+1)idp_i=\\frac{i}{n}+\\frac{n-i}{n}(1+dp_{i+1}+dp_{i})\\\\ ndp_i=i+(n-i)(1+dp_{i+1}+dp_i)\\\\ idp_i=i+(n-i)(1+dp_{i+1})\\\\ dp_i=\\frac{i+(n-i)(1+dp_{i+1})}{i} dpi​=ni​+nn−i​(1+dpi+1​+dpi​)ndpi​=i+(n−i)(1+dpi+1​+dpi​)idpi​=i+(n−i)(1+dpi+1​)dpi​=ii+(n−i)(1+dpi+1​)​ 并且有 dpn=1dp_{n}=1dpn​=1。 那么设当前还有 cntcntcnt 个灯的开关按下状态和解不同，答案即为 n!(k+∑i=k+1cntdpi)n!(k+\\sum\\limits_{i=k+1}^{cnt}dp_i)n!(k+i=k+1∑cnt​dpi​)。 注意特判刚开始就满足的情况。 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005,p=100003; int n,k; int a[S]; int cnt,dp[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=n;i&gt;=1;i--) { if(a[i]) { cnt++; for(int j=1;j*j&lt;=i;j++) { if(i%j==0) { a[j]^=1; if(j*j!=i) a[i/j]^=1; } } } } // printf(&quot;%d\\n&quot;,cnt); if(cnt&lt;=k) { for(int i=1;i&lt;=n;i++) cnt=1ll*cnt*i%p; printf(&quot;%d\\n&quot;,cnt); return 0; } dp[n]=1; for(int i=n-1;i&gt;=1;i--) dp[i]=1ll*(i+1ll*(n-i)*(1+dp[i+1])%p)*qpow(i,p-2)%p; int ans=k; for(int i=k+1;i&lt;=cnt;i++) ans=(ans+dp[i])%p; for(int i=1;i&lt;=n;i++) ans=1ll*ans*i%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P3750 [六省联考 2017] 分手是祝愿 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p3750-liu-sheng-lian-kao-2017-fen-shou-shi-zhu-yuan-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":245000,"words":881,"minutes":5},"date":"2023-04-14 19:54:14","dateFormat":"2023-04-14"},{"abstract":"","content":" 设 fxf_xfx​ 表示达到状态 xxx 的期望，答案即为 fneedf_{need}fneed​； 设 fx,yf_{x,y}fx,y​ 表示从状态 xxx 转到状态 yyy 的期望，求答案的时候加起来； 遇到求 ()x()^x()x 的时候直接二项式定理设多个 dp 数组，或者考虑 xxx 个人同时进行一样的操作； 考虑折线图/笛卡尔树； 箭头 dp： 设 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个元素，有 jjj 段。转移考虑新建段、加入某段的左边/右边、合并两段。 例题： P5999 [CEOI2016] kangaroo CF704B Ant Man LOJ2743 「JOI Open 2016」摩天大楼 【2023NOI模拟赛08】节日 ABC313Ex Group Photo 非负整数划分 dp： 非负整数 nnn 划分成 mmm 个带标号非负整数的方案数。 设 fi,jf_{i,j}fi,j​ 表示 jjj 划分成 iii 个带标号非负整数的方案数，那么有 f∗,0=1f_{*,0}=1f∗,0​=1。转移考虑有多少个 ≥1\\ge 1≥1 的数： fi,j=∑k=1min⁡(i,j)(ik)fk,j−kf_{i,j}=\\sum\\limits_{k=1}^{\\min(i,j)}\\binom{i}{k}f_{k,j-k} fi,j​=k=1∑min(i,j)​(ki​)fk,j−k​ 折线优化： 考虑某些形如 fi,j=max⁡(fi−1,j+x+w1,fi−1,j+y+w2)f_{i,j}=\\max(f_{i-1,j+x}+w_1,f_{i-1,j+y}+w_2)fi,j​=max(fi−1,j+x​+w1​,fi−1,j+y​+w2​) 这样的只和上一列有关的 dp，可以猜想并且经常有： 存在某个 kkk 满足 fi,j={fi−1,j+x+w1j≤kfi−1,j+y+w2j&gt;kf_{i,j}=\\begin{cases}f_{i-1,j+x}+w_1&amp;j\\le k\\\\f_{i-1,j+y}+w_2&amp;j&gt;k\\end{cases}fi,j​={fi−1,j+x​+w1​fi−1,j+y​+w2​​j≤kj&gt;k​ 例题： CF573E Bear and Bowling P4331 [BalticOI 2004] Sequence 数字序列 P7294 [USACO21JAN] Minimum Cost Paths P ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"一些 dp 状态 & 技巧","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/yi-xie-qi-guai-de-dp-zhuang-tai/","stats":{"text":"3 min read","time":123000,"words":432,"minutes":3},"date":"2023-04-14 19:49:29","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给定两个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A,B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，满足：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo separator=\"true\">,</mo><msub><mi>A</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\forall 1\\le i&lt;n,A_i \\ge A_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub><mo>≥</mo><msubsup><mi>min</mi><mo>⁡</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>(</mo><msub><mi>B</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">A_n\\ge \\min\\limits_{i=1}^n(B_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.9969160000000001em;vertical-align:-0.727664em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2692520000000003em;\"><span style=\"top:-2.072336em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-2.7em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span><span class=\"mop\">min</span></span></span><span style=\"top:-3.5678600000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.727664em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> 是一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列，定义价值函数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>π</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(\\pi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mclose\">)</span></span></span></span>：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>π</mi><mo>)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>min</mi><mo>⁡</mo><mo>(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>B</mi><mrow><mi>π</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(\\pi)=\\prod_{i=1}^n\\min(A_i,B_{\\pi(i)})\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.929066em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∏</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>每种排列出现的概率相等，求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>π</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(\\pi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mclose\">)</span></span></span></span> 的期望对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模的结果。</p>\n<p>即求:</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">(</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><munder><mo>∑</mo><mi>π</mi></munder><mi>f</mi><mo>(</mo><mi>π</mi><mo>)</mo><mo fence=\"true\">)</mo></mrow><mtext> </mtext><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">\\left(\\dfrac{1}{n!}\\sum_\\pi f(\\pi)\\right) \\bmod 998244353\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">(</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.050005em;\"><span style=\"top:-1.8999949999999999em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">π</span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.250005em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mclose\">)</span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">)</span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>B</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le A_i,B_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定两个长度为 nnn 的序列 A,BA,BA,B，满足： ∀1≤i&lt;n,Ai≥Ai+1\\forall 1\\le i&lt;n,A_i \\ge A_{i+1}∀1≤i&lt;n,Ai​≥Ai+1​ An≥min⁡i=1n(Bi)A_n\\ge \\min\\limits_{i=1}^n(B_i)An​≥i=1minn​(Bi​) π\\piπ 是一个长度为 nnn 的排列，定义价值函数 f(π)f(\\pi)f(π)： f(π)=∏i=1nmin⁡(Ai,Bπ(i))f(\\pi)=\\prod_{i=1}^n\\min(A_i,B_{\\pi(i)}) f(π)=i=1∏n​min(Ai​,Bπ(i)​) 每种排列出现的概率相等，求 f(π)f(\\pi)f(π) 的期望对 998244353998244353998244353 取模的结果。 即求: (1n!∑πf(π)) mod 998244353\\left(\\dfrac{1}{n!}\\sum_\\pi f(\\pi)\\right) \\bmod 998244353 (n!1​π∑​f(π))mod998244353 1≤n≤50001\\le n\\le 50001≤n≤5000，1≤Ai,Bi≤1091\\le A_i,B_i\\le 10^91≤Ai​,Bi​≤109。 首先不难发现顺序是没有任何影响的，所以先把 aaa 和 bbb 一起放到一个数组 ccc 里从大到小排序，并把从 aaa 来的元素染红，从 bbb 来的元素染蓝。 不难发现，问题转化为让所有红元素和蓝元素两两配对，每一对后面那个数乘起来的和。看到这种 ∑∏\\sum\\prod∑∏ 的题就能想到提取公因数，考虑 cic_ici​ 的贡献，显然只有当它和前面的元素配对的时候才会有贡献，那么我们设 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个元素，有 jjj 个蓝元素没有配对的 ∑∏\\sum\\prod∑∏，那么考虑 iii 的配对情况转移即可。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int p=998244353; const int S=5005; struct node { int x,tpe; }c[S*2]; int n,a[S],b[S]; int dp[S*2][S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) { c[i*2-1]=(node){a[i],1}; c[i*2]=(node){b[i],2}; } sort(c+1,c+n*2+1,[&amp;](node x,node y){return x.x&gt;y.x;}); // for(int i=1;i&lt;=n*2;i++) printf(&quot;%d %d\\n&quot;,c[i].x,c[i].tpe); // puts(&quot;---------------------------------------------&quot;); dp[0][0]=1; for(int i=1,cnt1=0;i&lt;=n*2;i++) { cnt1+=c[i].tpe==1; int cnt2=i-cnt1; for(int j=0;j&lt;=cnt2;j++) { if(c[i].tpe==1) { int bse=j+1; dp[i][j]=(dp[i-1][j]+1ll*dp[i-1][j+1]*c[i].x%p*bse%p)%p; } else { int bse=max(0,cnt1-(cnt2-1-j)); dp[i][j]=1ll*dp[i-1][j]*c[i].x%p*bse%p; if(j&gt;0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%p; } // printf(&quot;%d &quot;,dp[i][j]); } // printf(&quot;\\n&quot;); } int fra=1; for(int i=1;i&lt;=n;i++) fra=1ll*fra*i%p; printf(&quot;%d\\n&quot;,1ll*dp[n*2][0]*qpow(fra,p-2)%p); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P8321 『JROI-4』沈阳大街 2 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p8321-jroi-4-shen-yang-da-jie-2-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":222000,"words":694,"minutes":4},"date":"2023-04-14 19:33:28","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给定两个排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，每次可以交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 中的两个数，代价为它们间的距离，问最小代价使 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>。输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定两个排列 sss 和 ppp，每次可以交换 ppp 中的两个数，代价为它们间的距离，问最小代价使 ppp 变为 sss。输出方案。 1≤n≤20001\\le n\\le 20001≤n≤2000。 遇到这种题一定要考虑答案下界和怎么取到。 首先设 posi=j∣sj=pipos_i=j|s_j=p_iposi​=j∣sj​=pi​ 即 pip_ipi​ 要去的位置，那么由于 pip_ipi​ 应该在 posipos_iposi​ 而不是 iii，并且一次交换最多可以让两个数字归位，所以答案下界为 ∑i=1n∣i−posi∣2\\frac{\\sum\\limits_{i=1}^n|i-pos_i|}{2}2i=1∑n​∣i−posi​∣​。 考虑如何取到这个下界，不难发现，只要保证 iii 移动的时候只往 posipos_iposi​ 的方向移动就行了，也就是 posi&lt;ipos_i&lt;iposi​&lt;i 的 iii 只向左运动，posi&gt;ipos_i&gt;iposi​&gt;i 的 iii 只向右运动，posi=ipos_i=iposi​=i 的 iii 不动就行了。那么考虑按照 posipos_iposi​ 从大到小逐个操作，先让 posipos_iposi​ 大的归位，那么操作到 iii 的时候若 i=posii\\not=pos_ii​=posi​ 则 iii 一定要向右运动，并且 posipos_iposi​ 一定要向左运动；而 posposipos_{pos_i}posposi​​ 要么 ≤i\\le i≤i，要么存在 j∈[posposi,posi]j\\in[pos_{pos_i},pos_i]j∈[posposi​​,posi​] 满足 posj&lt;posposipos_j&lt;pos_{pos_i}posj​&lt;posposi​​。所以设 tmptmptmp 为当前 iii 运动到的位置，我们总能找到满足 j&gt;tmpj&gt;tmpj&gt;tmp 且 posj&lt;tmppos_j&lt;tmpposj​&lt;tmp 的 jjj 来让 tmptmptmp 和 jjj 交换。因为这样做每个 iii 都只会往 posipos_iposi​ 移动，所以答案取到了下界。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=2005; struct node { int x,y; }res[S*S]; int n,a[S],b[S]; int pos[S],p[S],id[S]; int tot; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) pos[b[i]]=i; int ans=0; for(int i=1;i&lt;=n;i++) ans+=abs((p[i]=pos[a[i]])-i); for(int i=1;i&lt;=n;i++) id[p[i]]=i; for(int i=n;i&gt;=1;i--) { int pp=id[i]; for(int j=pp+1;j&lt;=i;j++) { if(p[j]&lt;=pp) { res[++tot]=(node){pp,j}; swap(p[pp],p[j]); swap(id[p[pp]],id[p[j]]); pp=j; } } } printf(&quot;%d\\n&quot;,ans/2); printf(&quot;%d\\n&quot;,tot); for(int i=1;i&lt;=tot;i++) { printf(&quot;%d %d\\n&quot;,res[i].x,res[i].y); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF584E Anton and Ira 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf584e-anton-and-ira-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":175000,"words":590,"minutes":3},"date":"2023-04-14 19:29:52","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条有向边，每条有向边 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">u_i,v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>u</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>u</mi><mi>i</mi></msub><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1\\le u_i&lt;v_i\\le u_i+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 组询问，每次给定两个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x\\le y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，判断是否能从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 走到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，强制在线。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le 200</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" nnn 个点，mmm 条有向边，每条有向边 ui,viu_i,v_iui​,vi​ 满足 1≤ui&lt;vi≤ui+k1\\le u_i&lt;v_i\\le u_i+k1≤ui​&lt;vi​≤ui​+k。qqq 组询问，每次给定两个点 x,yx,yx,y 满足 x≤yx\\le yx≤y，判断是否能从 xxx 走到 yyy，强制在线。 1≤n,m≤2×1051\\le n,m\\le 2\\times10^51≤n,m≤2×105，1≤k≤2001\\le k\\le 2001≤k≤200。 对于一个区间 [l,r][l,r][l,r]，设 mid=⌊l+r2⌋mid=\\lfloor\\frac{l+r}{2}\\rfloormid=⌊2l+r​⌋，则想要从 [l,mid][l,mid][l,mid] 去 [mid+1,r][mid+1,r][mid+1,r] 就一定要经过 [mid,min⁡(mid+k,r)][mid,\\min(mid+k,r)][mid,min(mid+k,r)] 中的至少一个点，所以可以分治预处理出每个区间中左半部分的点能到 [mid,min⁡(mid+k,r)][mid,\\min(mid+k,r)][mid,min(mid+k,r)] 中的哪些点，右半部分的点能由哪些点到达，用 bitset 维护一下。查询的时候直接找到对应的区间把 bitset 按位与一下即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;bitset&gt; #include &lt;vector&gt; using namespace std; const int S=200005; int n,m,k; vector&lt;int&gt; g[S]; bitset&lt;205&gt; dp[25][S]; int q; void init(int l,int r,int d) { if(l==r) return; int mid=l+r&gt;&gt;1; for(int i=mid;i&lt;=min(mid+k,r);i++) dp[d][i][i-mid]=1; for(int u=mid-1;u&gt;=l;u--) for(int v:g[u]) if(v&lt;=r) dp[d][u]|=dp[d][v]; for(int u=mid;u&lt;=r;u++) for(int v:g[u]) if(v&lt;=r) dp[d][v]|=dp[d][u]; init(l,mid,d+1),init(mid+1,r,d+1); } bool que(int l,int r,int d,int s,int t) { int mid=l+r&gt;&gt;1; if(t&lt;=mid) return que(l,mid,d+1,s,t); else if(mid&lt;s) return que(mid+1,r,d+1,s,t); return (dp[d][s]&amp;dp[d][t]).any(); } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(y); } init(1,n,0); scanf(&quot;%d&quot;,&amp;q); int c=0; while(q--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x=((1ll*c*c)^x)%n+1,y=((1ll*c*c)^y)%n+1; if(x&gt;y) swap(x,y); if(x==y||que(1,n,0,x,y)) c++,puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"【2022 NOIP 多校联测 2】划船 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-duo-xiao-lian-ce-2-hua-chuan-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":185000,"words":557,"minutes":4},"date":"2023-04-14 19:26:37","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>本题为交互题。</p>\n<p>有一个字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>，只由字符 <code>a</code> 和 <code>b</code> 组成。每次你可以询问一个字符串，它会返回这两个字符串的编辑距离。编辑距离定义为一个字符串经过修改，删除或插入单个字符操作得到另一个字符串，两个字符串编辑距离的定义为最小的操作次数。</p>\n<p>你需要在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">|s| + 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 次操作内求出字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding=\"application/x-tex\">1\\le |s|\\le 300</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 本题为交互题。 有一个字符串 sss，只由字符 a 和 b 组成。每次你可以询问一个字符串，它会返回这两个字符串的编辑距离。编辑距离定义为一个字符串经过修改，删除或插入单个字符操作得到另一个字符串，两个字符串编辑距离的定义为最小的操作次数。 你需要在 ∣s∣+2|s| + 2∣s∣+2 次操作内求出字符串 sss。 1≤∣s∣≤3001\\le |s|\\le 3001≤∣s∣≤300。 首先可以通过询问一个 a 和一个 b 来获得字符串的长度 nnn，这需要两次操作。，然后字符串一定是若干个 a，每个 a 前面和字符串的最后面都插入了若干个 b 这样的，记 AAA 为 a 的数量，BBB 为 b 的数量，若已知 AAA 则可以在 A+B=nA+B=nA+B=n 次操作中得到整个字符串。 接下来的问题变为怎么求 AAA，自己想一直只会暴力用 AAA 次操作尝试，看了题解才发现可以通过询问一次全 a 串来求。 这样做是 n+3n+3n+3 次的，考虑优化，受到询问全 a 求 AAA 的启发，不难想到可以询问一次长 300300300 的全 a 串和一次长为 300300300 的全 b 串来获得 AAA、BBB 和 nnn，这样询问次数就是 n+2n+2n+2 了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=305; char a[S],ans[S]; inline int que(int n) { a[n+1]=0; printf(&quot;%s\\n&quot;,a+1); fflush(stdout); int res; scanf(&quot;%d&quot;,&amp;res); return res; } int main() { int A,B; for(int i=1;i&lt;=300;i++) a[i]='a'; A=300-que(300); for(int i=1;i&lt;=300;i++) a[i]='b'; B=300-que(300); if(A==0) { for(int i=1;i&lt;=B;i++) ans[i]='b'; ans[B+1]=0; printf(&quot;%s\\n&quot;,ans+1); fflush(stdout); return 0; } int pre=B,tot=0; for(int i=1;i&lt;=A;i++) { while(pre!=0) { ans[++tot]='b'; for(int j=1;j&lt;=tot;j++) a[j]=ans[j]; for(int j=i;j&lt;=A;j++) a[tot+j-i+1]='a'; int re=que(tot+A-i+1); if(re&lt;pre) pre=re; else { tot--; break; } } ans[++tot]='a'; } for(int i=tot+1;i&lt;=A+B;i++) ans[i]='b'; ans[A+B+1]=0; printf(&quot;%s\\n&quot;,ans+1); fflush(stdout); return 0; } ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1282D Enchanted Artifact 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1282d-enchanted-artifact-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":159000,"words":568,"minutes":3},"date":"2023-04-14 19:23:31","dateFormat":"2023-04-14"},{"abstract":"","content":"Day -3 到酒店隔离了。 饭好贵，25 块。 Day -2 早餐是自助餐，拿了好多牛肉。 晚餐 18 块的刀削面结块了，好难吃。 世界杯 0:00:00:0，笑死。 Day -1 早餐禁止堂食了，打包好的难吃死了。 Day 0 说好的 7 点出发，结果番禺封了，只好 6：20 偷渡。 酒店的早餐打包去考场吃，难吃死了。 T1 20 min 写完了，没什么好说的。 T2 想了好久，显然 2n−22n-22n−2 直接让每个栈管两种颜色，空出来一个辅助栈。 2n−12n-12n−1 类似，每个栈管两个，多一个辅助栈，如果不得不有一个栈管三个，那么就找到一个不会出现 1,2,3,21,2,3,21,2,3,2 这种情况的栈放进去，找不到就用辅助栈。 感觉很对，过了大样例。 时间复杂度大概是 m(n+log⁡m)m(n+\\log m)m(n+logm)，有点悬。 T3 11：50 左右才看 T3，一眼缩点然后树形 dp，开始疯狂敲键盘。 小样例过了，大样例 WA+RE，没调出来。。。 T4 想 T2 的时候顺便写了个 O(n2q)O(n^2q)O(n2q) 暴力。 大众分了/ll 我的 300300300/ll 自估：100+[15,100]+[0,100]+8=[123,308]100+[15,100]+[0,100]+8=[123,308]100+[15,100]+[0,100]+8=[123,308] infoj：100+35+20+8=163100+35+20+8=163100+35+20+8=163 为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？为什么不先写 T3？ T2 思路是对的，T3 也是，都写挂了，笑死。 CCF 太强了 100+35+0+8=143100 + 35 + 0 + 8 = 143100+35+0+8=143 ","tags":[{"name":2022,"slug":"GJvEuJsM-","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GJvEuJsM-/"},{"name":"NOIP","slug":"rs_nI3vFV","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/rs_nI3vFV/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"}],"title":"NOIP 2022 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/noip-2022-you-ji/","stats":{"text":"3 min read","time":153000,"words":628,"minutes":3},"date":"2023-04-14 19:20:42","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给你 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点和它们的坐标，现在给它们两两连上边，如果在同一组为黄色，不同组为蓝色。现在让你给出任意一种分组方案，使得所有长度相同的边颜色相同。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\le n \\le 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给你 nnn 个点和它们的坐标，现在给它们两两连上边，如果在同一组为黄色，不同组为蓝色。现在让你给出任意一种分组方案，使得所有长度相同的边颜色相同。 2≤n≤1032 \\le n \\le 10^32≤n≤103。 发现两点距离相等等价于两点的距离的平方相等，所以考虑距离的平方。 发现要把距离分成两组，不难想到奇偶性分类。设 tpe⁡(x,y)={0x≡y(mod2)1x≡y(mod2)\\operatorname{tpe}(x,y)=\\begin{cases}0&amp;x\\equiv y\\pmod2\\\\1&amp;x\\not\\equiv y\\pmod2\\end{cases}tpe(x,y)={01​x≡y(mod2)x​≡y(mod2)​，由于 (x1,y1),(x2,y2)(x1,y1),(x2,y2)(x1,y1),(x2,y2) 的距离的平方 (x1−x2)2+(y1−y2)2(x1-x2)^2+(y1-y2)^2(x1−x2)2+(y1−y2)2 为奇数当且仅当 tpe⁡(x1,y1)=tpe⁡(x2,y2)\\operatorname{tpe}(x1,y1)\\not=\\operatorname{tpe}(x2,y2)tpe(x1,y1)​=tpe(x2,y2)，为偶数当且仅当 tpe⁡(x1,y1)=tpe⁡(x2,y2)\\operatorname{tpe}(x1,y1)=\\operatorname{tpe}(x2,y2)tpe(x1,y1)=tpe(x2,y2)，那么把 tpe⁡(x,y)=0\\operatorname{tpe}(x,y)=0tpe(x,y)=0 的 (x,y)(x,y)(x,y) 分到一组，tpe(x,y)=1tpe(x,y)=1tpe(x,y)=1 的 (x,y)(x,y)(x,y) 分到另一组即可。 但是发现 tpe⁡(x,y)\\operatorname{tpe}(x,y)tpe(x,y) 有可能都为 000 或者都为 111，考虑到平移对距离没有影响，所以当 tpe⁡(x,y)=1\\operatorname{tpe}(x,y)=1tpe(x,y)=1 时让所有 xxx 同时加上 111，这样就可以只讨论 tpe⁡(x,y)=0\\operatorname{tpe}(x,y)=0tpe(x,y)=0 的情况。 注意到当 tpe⁡(x,y)=0\\operatorname{tpe}(x,y)=0tpe(x,y)=0 时 x+y≡x−y≡0(mod2)x+y\\equiv x-y\\equiv 0\\pmod2x+y≡x−y≡0(mod2)，所以有一个很奇妙的操作：旋转并拉伸坐标系。具体的，让 (x,y)→(x+y2,x−y2)(x,y)\\to(\\frac{x+y}{2},\\frac{x-y}{2})(x,y)→(2x+y​,2x−y​) 即让 [xy]→[xy]×[121212−12]\\begin{bmatrix}x\\\\y\\end{bmatrix}\\to\\begin{bmatrix}x\\\\y\\end{bmatrix}\\times\\begin{bmatrix}\\frac{1}{2}&amp;\\frac{1}{2}\\\\\\frac{1}{2}&amp;-\\frac{1}{2}\\end{bmatrix}[xy​]→[xy​]×[21​21​​21​−21​​]，由于旋转操作最多进行 log⁡V\\log VlogV 次，所以这样可以在 O(nlog⁡V)O(n\\log V)O(nlogV) 的时间复杂度内解决此题。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; struct node { int x,y; }a[S]; int n; int tot,ans[S]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); while(1) { tot=0; for(int j=1;j&lt;=n;j++) if((a[j].x&amp;1)==(a[j].y&amp;1)) ans[++tot]=j; if(tot&gt;=1&amp;&amp;tot&lt;=n-1) { printf(&quot;%d\\n&quot;,tot); for(int j=1;j&lt;=tot;j++) printf(&quot;%d &quot;,ans[j]); printf(&quot;\\n&quot;); break; } for(int j=1;j&lt;=n;j++) { if((a[j].x&amp;1)!=(a[j].y&amp;1)) a[j].x++; int tx=a[j].x,ty=a[j].y; a[j].x=(tx+ty)/2; a[j].y=(tx-ty)/2; } } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1270E Divide Points 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1270e-divide-points-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":226000,"words":727,"minutes":4},"date":"2023-04-14 19:17:07","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>构造 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列，使得其前缀积在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mod\\,n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 意义下两两不同。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq n \\leq 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 构造 nnn 的排列，使得其前缀积在 mod nmod\\,nmodn 意义下两两不同。 1≤n≤1051 \\leq n \\leq 10^51≤n≤105。 首先显然 111 放最前面，nnn 放最后面。并且若 n&gt;4n&gt;4n&gt;4 且 nnn 为合数就一定无解，因为 nnn 的所有因数都会出现，所以前缀积至少会出现两个 000。 那么特判掉 n≤4n\\le 4n≤4 的情况，考虑 n&gt;4n&gt;4n&gt;4 且 nnn 为质数的情况。 发现原排列似乎不是很好处理，于是考虑前缀积序列，考虑构造形如 [1,2,3,4,5,…,n−1,0][1,2,3,4,5,\\dots,n-1,0][1,2,3,4,5,…,n−1,0] 这样的前缀积序列，显然原序列一定是这个序列的差商，即 [1,21,32.43,…,n−1n−2,n][1,\\frac{2}{1},\\frac{3}{2}.\\frac{4}{3},\\dots,\\frac{n-1}{n-2},n][1,12​,23​.34​,…,n−2n−1​,n] 这样的。容易发现中间的分数显然和首尾两个数不同，并且中间的分数都是形如 xx−1\\frac{x}{x-1}x−1x​ 这样的，统统减去 111 之后变成了 1x−1\\frac{1}{x-1}x−11​，也两两不同，所以整个序列是排列，这样构造合法。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; int n,ans[S]; inline bool chk(int n) { for(int i=2;i&lt;=n-1;i++) if(n%i==0) return false; return true; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%n) res=(y&amp;1)?1ll*res*x%n:res; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); if(n==1) puts(&quot;YES\\n1&quot;); else if(n==2) puts(&quot;YES\\n1\\n2&quot;); else if(n==3) puts(&quot;YES\\n1\\n2\\n3&quot;); else if(n==4) puts(&quot;YES\\n1\\n3\\n2\\n4&quot;); else if(!chk(n)) puts(&quot;NO&quot;); else { ans[1]=1,ans[n]=n; for(int i=2;i&lt;=n-1;i++) ans[i]=1ll*i*qpow(i-1,n-2)%n; puts(&quot;YES&quot;); for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans[i]); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF487C Prefix Product Sequence 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf487c-prefix-product-sequence-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":150000,"words":497,"minutes":3},"date":"2023-04-14 19:10:14","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给定一个字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，你每次可以交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的相邻两个字符，问最少进行多少次交换才能使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 变为回文串。数据保证一定能够在有限次交换操作后使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 变为回文串。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le |a|\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">a</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个字符串 aaa，你每次可以交换 aaa 的相邻两个字符，问最少进行多少次交换才能使得 aaa 变为回文串。数据保证一定能够在有限次交换操作后使得 aaa 变为回文串。 1≤∣a∣≤1061\\le |a|\\le 10^61≤∣a∣≤106。 设 pip_ipi​ 表示最后第 iii 个位置的字符原来是哪个位置上的，显然答案就是 ppp 的逆序对个数，并且确定了 p[1,⌊n2⌋]p_{[1,\\lfloor\\frac{n}{2}\\rfloor]}p[1,⌊2n​⌋]​ 就可以确定 p[⌊n2⌋+1,n]p_{[\\lfloor\\frac{n}{2}\\rfloor+1,n]}p[⌊2n​⌋+1,n]​。 这里有个结论：p[1,⌊n2⌋]p_{[1,\\lfloor\\frac{n}{2}\\rfloor]}p[1,⌊2n​⌋]​ 一定是递增的。 证明： 若存在 1≤i&lt;⌊n2⌋1\\le i&lt; \\lfloor\\frac{n}{2}\\rfloor1≤i&lt;⌊2n​⌋ 满足 pi&gt;pi+1p_i&gt;p_{i+1}pi​&gt;pi+1​，则我们可以交换 pip_ipi​ 和 pi+1p_{i+1}pi+1​，此时逆序对个数一定会减 111，相应的我们也要交换 pn−i+1p_{n-i}+1pn−i​+1 和 pn−ip_{n-i}pn−i​，这会让逆序对个数加 111 或者减 111，所以这样调整一定是不劣的。 那么乱贪就行了，代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;deque&gt; using namespace std; const int S=1000005; int n; char a[S]; deque&lt;int&gt; q[30]; int c[S],res[S]; inline void add(int x,int val) { for(int i=x;i&lt;=n;i+=i&amp;-i) c[i]+=val; } inline int que(int x) { int res=0; for(int i=x;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } int main() { scanf(&quot;%s&quot;,a+1); n=strlen(a+1); for(int i=1;i&lt;=n;i++) a[i]=a[i]-'a'+1; for(int i=1;i&lt;=n;i++) q[a[i]].push_back(i); for(int i=1;i&lt;=n/2;i++) { int mnval=1e8,idx=0; for(int j=1;j&lt;=26;j++) { if(q[j].size()&gt;1) { int pre=abs(q[j].front()-i); if(pre&lt;mnval) mnval=pre,idx=j; } } res[i]=q[idx].front(); res[n-i+1]=q[idx].back(); q[idx].pop_front(); q[idx].pop_back(); } if(n&amp;1) for(int j=1;j&lt;=26;j++) if(q[j].size()&gt;=1) res[n/2+1]=q[j].front(); long long ans=0; for(int i=n;i&gt;=1;i--) { ans+=que(res[i]); add(res[i],1); } printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022 NOIP 模拟赛 46】Palindrome 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-46-palindrome-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":168000,"words":538,"minutes":3},"date":"2023-04-14 19:01:42","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给定一个含有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个正整数的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> ，对于一次操作，你可以任选一个位置 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 且满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">a_i=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，那么就可以移除这个元素，并将后面所有的元素向前移动一位。</p>\n<p>对于每个相互独立的询问 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 需要你求出在前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 个元素以及后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 个元素不能被移除的情况下，最多可以进行几次操作。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">n,q \\leq 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个含有 nnn 个正整数的序列 aaa ，对于一次操作，你可以任选一个位置 iii 且满足 ai=ia_i=iai​=i，那么就可以移除这个元素，并将后面所有的元素向前移动一位。 对于每个相互独立的询问 x,yx,yx,y 需要你求出在前 xxx 个元素以及后 yyy 个元素不能被移除的情况下，最多可以进行几次操作。 n,q≤3×105n,q \\leq 3\\times 10^5n,q≤3×105。 首先不难想到让 ai→i−aia_i\\to i-a_iai​→i−ai​，这样问题就转变为每次操作可以删去 ai=0a_i=0ai​=0 的 aia_iai​ 并且让 a[i+1,n]a_{[i+1,n]}a[i+1,n]​ 减去 111。 不难发现 aia_iai​ 能被删掉当且仅当 a[1,i−1]a_{[1,i-1]}a[1,i−1]​ 中有至少 aia_iai​ 个能被删掉，因为删掉 aia_iai​ 的这次操作可以插到删掉 aia_iai​ 个数之后。 发现询问相当于选一个区间 [l,r][l,r][l,r] 里的 aia_iai​ 出来算答案。在线不太好做，考虑离线。 把询问离线到序列上，把询问按 rrr 从小到大排序，处理到第 iii 个询问的时候把把 a[1,ri]a_{[1,r_i]}a[1,ri​]​ 都加入某个可以维护从 iii 开始操作的答案 fif_ifi​ 的数据结构里即可。 考虑怎么维护 fif_ifi​，不难发现它具有单调性，即满足 fi≥fi+1f_i\\ge f_{i+1}fi​≥fi+1​，那么设 kkk 满足 f1≥f2≥f3≥⋯≥fk≥ai&gt;fk+1≥⋯≥fnf_1\\ge f_2\\ge f_3\\ge\\dots\\ge f_k\\ge a_i &gt; f_{k+1}\\ge\\dots\\ge f_nf1​≥f2​≥f3​≥⋯≥fk​≥ai​&gt;fk+1​≥⋯≥fn​，则 aia_iai​ 对 f[1,k]f_{[1,k]}f[1,k]​ 都有 111 的贡献。不难发现这个可以用树状数组维护，由于每次都是 [1,x][1,x][1,x] 这样的区间，所以干脆直接维护每个位置减了多少次，然后找 kkk 就可以用树状数组上二分来维护。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=300005; struct node { int l,r,id; }que[S]; int n,m; int a[S],c[S]; int ans[S]; inline void addt(int pos,int x) { for(int i=pos;i&lt;=n;i+=i&amp;-i) c[i]+=x; } inline int quet(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } inline int fndk(int k) { int pos=0,val=0; for(int i=20;i&gt;=0;i--) { int nxt=pos+(1&lt;&lt;i); if(nxt&lt;=n&amp;&amp;val+c[nxt]&lt;=k) val+=c[nxt],pos=nxt; } return pos; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),a[i]=i-a[i]; for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); que[i].l=x+1,que[i].r=n-y; que[i].id=i; } sort(que+1,que+m+1,[&amp;](node x,node y){return x.r&lt;y.r;}); int j=1; for(int i=1;i&lt;=m;i++) { for(;j&lt;=n&amp;&amp;j&lt;=que[i].r;j++) { if(a[j]&lt;0) { addt(1,1); continue; } int k=min(fndk(j-1-a[j]),j); addt(k+1,1); } ans[que[i].id]=j-1-quet(que[i].l); } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF1404C Fixed Point Removal 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1404c-fixed-point-removal-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":232000,"words":785,"minutes":4},"date":"2023-04-14 18:58:42","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>你有一个随机生成器，每次会均匀随机地生成一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mclose\">]</span></span></span></span> 之间的整数。你用这个随机生成器生成了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数，你想知道你生成的前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数的和比后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数的和大的概率是多少。你只需求出这个概率对质数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span> 取模后的结果即可。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 2\\times 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 你有一个随机生成器，每次会均匀随机地生成一个 [0,m][0,m][0,m] 之间的整数。你用这个随机生成器生成了 2n2n2n 个整数，你想知道你生成的前 nnn 个整数的和比后 nnn 个整数的和大的概率是多少。你只需求出这个概率对质数 PPP 取模后的结果即可。 1≤n,m≤2×1031\\le n,m\\le 2\\times 10^31≤n,m≤2×103。 考虑计算两部分和相同的方案数 resresres，答案即为 1−res(m+1)2n2\\frac{1-\\frac{res}{(m+1)^{2n}}}{2}21−(m+1)2nres​​。 转化问题，resresres 相当于前 nnn 个数在 [0,m][0,m][0,m] 中，后 nnn 个数在 [−m,0][-m,0][−m,0] 中，序列总和为 000 的方案数。 给后 nnn 个数整体加上 mmm，那么 resresres 相当于所有 2n2n2n 个数都在 [0,m][0,m][0,m] 中，序列总和为 nmnmnm 的方案数。 这是典题，枚举有多少个数爆表了容斥一下即可。 res=∑i=0n(−1)i(2ni)(2n+nm−i(m+1)−12n−1)res=\\sum\\limits_{i=0}^n (-1)^i\\binom{2n}{i}\\binom{2n+nm-i(m+1)-1}{2n-1} res=i=0∑n​(−1)i(i2n​)(2n−12n+nm−i(m+1)−1​) 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; inline void fio(string name) { freopen((name+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin); freopen((name+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout); } const int S=5000005; int p,T; int fra[S],inv[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } inline int C(int n,int m) { if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } inline void slove() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int ans=0; for(int i=0,f=0;i&lt;=n;i++,f=1-f) { int pre=1ll*C(n*2,i)*C(n*2+n*m-i*(m+1)-1,n*2-1)%p; if(f==0) ans=(ans+pre)%p; else ans=(ans-pre+p)%p; } printf(&quot;%d\\n&quot;,1ll*(1+p-1ll*ans*qpow(qpow(m+1,n*2),p-2)%p)%p*qpow(2,p-2)%p); } int main() { fio(&quot;Y&quot;); scanf(&quot;%d%d&quot;,&amp;p,&amp;T); fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; while(T--) slove(); return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 42】Y 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-42-y-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":181000,"words":572,"minutes":4},"date":"2023-04-14 18:53:09","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个结点的无向完全图。每个点有一个点权为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。连接 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 号结点和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 号结点的边的边权为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i\\oplus a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>求这个图的 MST 的权值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le a_i&lt; 2^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 个结点的无向完全图。每个点有一个点权为 aia_iai​。连接 iii 号结点和 jjj 号结点的边的边权为 ai⊕aja_i\\oplus a_jai​⊕aj​。 求这个图的 MST 的权值。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，0≤ai&lt;2300\\le a_i&lt; 2^{30}0≤ai​&lt;230。 看到异或最小，想到 01 trie。 不妨先把所有数插入 01 trie，然后问题就变成不断选 lca 来合并这些点。不难发现 lca 深度越大越好，所以可以跑一遍 dfs，遍历到 uuu 的时候： 若 uuu 没有儿子，回溯； 若 uuu 只有一个儿子，往唯一的儿子递归； 若 uuu 有两个儿子，通过遍历左子树内所有的数来求合并两个子树的最小代价，给答案加上这个代价，再往两个儿子递归； #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=5000005,BS=30; int n,a[S]; int cnt=1,son[S][2]; int lb[S],rb[S]; long long ans; void dfs1(int u) { if(lb[u]==0&amp;&amp;rb[u]==0) lb[u]=1e8,rb[u]=0; if(son[u][0]!=0) { int v=son[u][0]; dfs1(v); lb[u]=min(lb[u],lb[v]),rb[u]=max(rb[u],rb[v]); } if(son[u][1]!=0) { int v=son[u][1]; dfs1(v); lb[u]=min(lb[u],lb[v]),rb[u]=max(rb[u],rb[v]); } } inline int que(int val,int rt,int bse) { int u=rt,res=0; for(int i=bse;i&gt;=0;i--) { int id=val&gt;&gt;i&amp;1; if(son[u][id]==0) u=son[u][id^1],res+=1&lt;&lt;i; else u=son[u][id]; } return res; } void dfs2(int u,int bse) { if(son[u][0]!=0) dfs2(son[u][0],bse-1); if(son[u][1]!=0) dfs2(son[u][1],bse-1); if(son[u][0]!=0&amp;&amp;son[u][1]!=0) { int mn=que(a[lb[son[u][0]]],son[u][1],bse-1); for(int i=lb[son[u][0]]+1;i&lt;=rb[son[u][0]];i++) mn=min(mn,que(a[i],son[u][1],bse-1)); ans+=(long long)mn+(1&lt;&lt;bse); } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) { int u=1; for(int j=BS;j&gt;=0;j--) { int id=a[i]&gt;&gt;j&amp;1; if(son[u][id]==0) son[u][id]=++cnt; u=son[u][id]; } lb[u]=rb[u]=i; } dfs1(1); dfs2(1,BS); printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF888G Xor-MST 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf888g-xor-mst-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":177000,"words":553,"minutes":3},"date":"2023-04-14 17:16:43","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>zzh 有一个矩形，这个矩形被划分成了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个区域，每个区域中都写了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 或 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 。</p>\n<p>zzh 可以对这个矩形进行翻转操作，翻转操作定义如下：</p>\n<p>选择一条只经过区域边界，从矩形左上角到矩形右下角的<strong>最短路</strong>，然后将这条路径下方的所有区域中的数翻转（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>）。</p>\n<p>请问最少需要多少次操作可以将这个矩阵中的所有数变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，保证一定有解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 5\\times 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" zzh 有一个矩形，这个矩形被划分成了 n×mn\\times mn×m 个区域，每个区域中都写了 000 或 111 。 zzh 可以对这个矩形进行翻转操作，翻转操作定义如下： 选择一条只经过区域边界，从矩形左上角到矩形右下角的最短路，然后将这条路径下方的所有区域中的数翻转（000 变为 111, 111 变为 000）。 请问最少需要多少次操作可以将这个矩阵中的所有数变为 000，保证一定有解。 1≤n,m≤5×1031\\le n,m\\le 5\\times 10^31≤n,m≤5×103。 首先可以证明一定有解，考虑贪心，每次选择顶着最上面的 111 的路径： 路径不包含所有 111 一定不会更优，而包含更多的 000 也不会更优，所以这样一定是最优的，并且 iii 次操作至少可以清空左上到右下的 iii 条斜对角线，所以答案是 O(n)O(n)O(n) 级别的。 考虑计算答案，一种显然的做法是直接模拟贪心，实现优秀则可以 O(nm)O(nm)O(nm) 解决本题，但还有更优美的做法。 考虑用从右上到左下的最短路去截取我们选择的路径，显然这样的最短路会和每一条我们选择的路径产生恰好一个交点：（重合部分不算） 由于我们选取的路径一定有至少一个位置满足路径内部的状态与外部不同，并且从右上到左下的最短路一定可以在这些位置与我们选取的路径相交，所以所有从右上到左下的最短路中这些位置的最多个数即为答案。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; inline void fio(string name) { freopen((name+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin); freopen((name+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout); } const int S=2005; int n,m; char tmp[S]; int a[S][S]; int dp[S][S]; int main() { fio(&quot;flip&quot;); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,tmp+1); for(int j=1;j&lt;=m;j++) a[i][j]=tmp[j]-'0'; } for(int i=1;i&lt;=n;i++) { for(int j=m;j&gt;=1;j--) { dp[i][j]=max(dp[i-1][j]+(a[i][j]!=a[i-1][j]),dp[i][j+1]+(a[i][j]!=a[i][j+1])); } } printf(&quot;%d\\n&quot;,dp[n][1]); return 0; } ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022 NOIP 模拟赛 40】翻转 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-40-fan-zhuan-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":157000,"words":612,"minutes":3},"date":"2023-04-14 17:15:00","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">n,d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span> 和一个长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，每次操作可以将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2\\le i\\le n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 或者减掉 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，求最少多少次操作可以使得对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 都有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">|a_i-a_{i+1}|\\le d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>300</mn><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>d</mi><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 300,0\\le d,a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 n,dn,dn,d 和一个长为 nnn 的序列 aaa，每次操作可以将 2≤i≤n−12\\le i\\le n-12≤i≤n−1 的 aia_iai​ 加上 111 或者减掉 111，求最少多少次操作可以使得对于所有 1≤i≤n−11\\le i\\le n-11≤i≤n−1 都有 ∣ai−ai+1∣≤d|a_i-a_{i+1}|\\le d∣ai​−ai+1​∣≤d。 2≤n≤300,0≤d,ai≤1092\\le n\\le 300,0\\le d,a_i\\le 10^92≤n≤300,0≤d,ai​≤109。 首先显然有朴素的 O(nV2)O(nV^2)O(nV2) dp，设 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个 aaa，修改后 ai=ja_i=jai​=j 的最少操作次数，单调队列即可优化到 O(nV)O(nV)O(nV)，但是这样过不了。 不难发现有用的状态很少，设 SSS 表示有用的 jjj 的集合，有一个结论就是 S={ai+jd ∣ 1≤i≤n,−n≤j≤n}S=\\{a_i+jd\\,|\\,1\\le i\\le n,-n\\le j\\le n\\}S={ai​+jd∣1≤i≤n,−n≤j≤n}。 证明如下： 设操作之后的序列为 bbb，考虑最小值 bib_ibi​，显然 bib_ibi​ 要么是 aia_iai​，要么是 bi−1−db_{i-1}-dbi−1​−d，要么是 bi+1−db_{i+1}-dbi+1​−d，仿照这样归纳证明 j∈[1,i−1]j\\in[1,i-1]j∈[1,i−1] 和 j∈[i+1,n]j\\in[i+1,n]j∈[i+1,n] 即可。 这样时间复杂度是 O(n3)O(n^3)O(n3) 的，足以通过此题。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; inline void fio(string name) { freopen((name+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin); freopen((name+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout); } const int S=305; int n; long long d,a[S]; int tot; long long b[S*S*2]; int h,t,que[S*S*2]; long long dp[S][S*S*2]; inline long long absll(long long x) { return x&lt;0?-x:x; } int main() { fio(&quot;climb&quot;); scanf(&quot;%d%lld&quot;,&amp;n,&amp;d); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) for(int j=-n;j&lt;=n;j++) b[++tot]=a[i]+d*j; sort(b+1,b+tot+1); tot=unique(b+1,b+tot+1)-b-1; memset(dp,127,sizeof(dp)); long long inf=dp[0][0]; dp[1][lower_bound(b+1,b+tot+1,a[1])-b]=0; for(int i=2;i&lt;=n;i++) { h=1,t=0; int j=1; for(int k=1;k&lt;=tot;k++) { while(j&lt;=tot&amp;&amp;absll(b[j]-b[k])&lt;=d) { while(h&lt;=t&amp;&amp;dp[i-1][que[t]]&gt;=dp[i-1][j]) t--; que[++t]=j++; } while(h&lt;=t&amp;&amp;absll(b[que[h]]-b[k])&gt;d) h++; if(h&lt;=t&amp;&amp;dp[i-1][que[h]]!=inf) dp[i][k]=dp[i-1][que[h]]+absll(b[k]-a[i]); } } long long ans=dp[n][lower_bound(b+1,b+tot+1,a[n])-b]; printf(&quot;%lld\\n&quot;,ans==inf?-1:ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 39】六出祁山 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-39-liu-chu-qi-shan-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":214000,"words":647,"minutes":4},"date":"2023-04-14 17:12:00","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>小 A 有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数绕成一个环，他们分别是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\cdots,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>每一轮，小A可以选择某个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>， 把它变成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">-a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，并让两个相邻的数加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>小 A 想知道，她最少经过几轮操作可以让所有的数都是<strong>非负整数</strong>呢？</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le |a_i|\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 小 A 有 nnn 个数绕成一个环，他们分别是 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​。 每一轮，小A可以选择某个数 aia_iai​， 把它变成 −ai-a_i−ai​，并让两个相邻的数加上 aia_iai​。 小 A 想知道，她最少经过几轮操作可以让所有的数都是非负整数呢？ 2≤n≤1052\\le n\\le 10^52≤n≤105，0≤∣ai∣≤1050\\le |a_i|\\le 10^50≤∣ai​∣≤105。 不考虑环的限制，考虑在序列上的情况。不难发现，这样一次操作的本质其实是交换了相邻两个位置的前缀和，所以设 sumisum_isumi​ 为 ∑j=1iaj\\sum\\limits_{j=1}^ia_jj=1∑i​aj​ 则一次操作为交换 sumi,sumi+1sum_i,sum_{i+1}sumi​,sumi+1​，目标即为让所有 sumi≥0sum_i\\ge0sumi​≥0 并且对于所有 1≤i≤n−11\\le i\\le n-11≤i≤n−1 有 sumi≤sumi+1sum_i\\le sum_{i+1}sumi​≤sumi+1​。 考虑这个性质拓展到环上，我们把原序列复制无数次，钦定某个位置的前缀和为 000，并求出整个序列的前缀和 sumisum_isumi​： 这样一次操作就相当于交换所有满足 xmod⁡n=ix\\operatorname{mod}n=ixmodn=i 的 sumxsum_xsumx​ 和 sumx+1sum_{x+1}sumx+1​： 考虑固定 n−1n-1n−1 这个位置，即以它为参照系，假定它不会移动，那么交换中间那些前缀和肯定没有影响，考虑操作 i=n−1i=n-1i=n−1 的情况： 这里平移了是因为我们认为 n−1n-1n−1 是不动的，那么操作就变成了把 sum0sum_0sum0​ 加上 sumn−1sum_{n-1}sumn−1​ 然后放到 n−1n-1n−1 的前面。 同理，操作 i=n−2i=n-2i=n−2 就相当于把 sumn−2sum_{n-2}sumn−2​ 减去 sumn−1sum_{n-1}sumn−1​，然后放到最前面： 那么有个显然的贪心策略：把所有 sumi&lt;0sum_i&lt;0sumi​&lt;0 和 sumi&gt;sumn−1sum_i&gt;sum_{n-1}sumi​&gt;sumn−1​ 的 sumisum_isumi​ 都通过不断减去 sumn−1sum_{n-1}sumn−1​ 使得 0≤sumi≤sumn−10\\le sum_i\\le sum_{n-1}0≤sumi​≤sumn−1​，最后再通过交换来排序。 直接做不好维护，不妨先把 sumi&lt;0sum_i&lt;0sumi​&lt;0 的换到最前面，sumi&gt;sumn−1sum_i&gt;sum_{n-1}sumi​&gt;sumn−1​ 的换到最后面，这样一定不会让答案变大。然后考虑贪心： 显然先处理 sumi&lt;0sum_i&lt;0sumi​&lt;0 的再处理 sumi&gt;sumn−1sum_i&gt;sum_{n-1}sumi​&gt;sumn−1​ 的是最优的； 绕圈的时候不“超车”是最优的； 那么用树状数组维护即可，可以结合代码理解： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; inline void fio(string name) { freopen((name+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin); freopen((name+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout); } const int S=1000005; int n,a[S]; long long s,ans,sum[S],b[S]; int c[S]; long long c2[S]; long long ned[S],nxt[S]; int id[S]; inline void add(int pos) { for(int i=pos;i&lt;=n;i+=i&amp;-i) c[i]++; } inline int que(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } inline void add2(int pos,long long val) { for(int i=pos;i&lt;=n;i+=i&amp;-i) c2[i]+=val; } inline long long que2(int pos) { long long res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=c2[i]; return res; } inline bool cmp1(int x,int y) { int tpex=sum[x]&lt;0?0:(sum[x]&lt;=s?1:2); int tpey=sum[y]&lt;0?0:(sum[y]&lt;=s?1:2); if(tpex!=tpey) return tpex&lt;tpey; return x&lt;y; } inline bool cmp2(int x,int y) { int tpex=sum[x]&lt;0?2:(sum[x]&lt;=s?1:0); int tpey=sum[y]&lt;0?2:(sum[y]&lt;=s?1:0); if(tpex!=tpey) return tpex&lt;tpey; if(ned[x]!=ned[y]) return tpex==2?ned[x]&lt;ned[y]:ned[x]&gt;ned[y]; else return x&lt;y; } inline void slove() { for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i]; s=sum[n],ans=0; if(s==0) { for(int i=1;i&lt;=n;i++) if(sum[i]!=0) return void(puts(&quot;-1&quot;)); return void(puts(&quot;0&quot;)); } if(s&lt;0) return void(puts(&quot;-1&quot;)); for(int i=1;i&lt;=n-1;i++) id[i]=i; sort(id+1,id+n,cmp1); for(int i=1;i&lt;=n-1;i++) nxt[i]=sum[id[i]]; for(int i=1;i&lt;=n-1;i++) sum[i]=nxt[i]; for(int i=1;i&lt;=n;i++) c[i]=0; for(int i=n-1;i&gt;=1;i--) { ans+=que(id[i]-1); add(id[i]); } for(int i=1;i&lt;=n-1;i++) { if(sum[i]&lt;0) ned[i]=(-sum[i]+s-1)/s; else if(sum[i]&lt;=s) ned[i]=0; else ned[i]=(sum[i]-1)/s; } int cntsm=0,cntbg=0; for(int i=1;i&lt;=n-1;i++) cntsm+=sum[i]&gt;=0,cntbg+=sum[i]&lt;=s; for(int i=1;i&lt;=n-1;i++) b[i]=ned[i]; sort(b+1,b+n); int m=unique(b+1,b+n)-b-1; for(int i=1;i&lt;=n;i++) c[i]=c2[i]=0; for(int i=1;i&lt;=n-1;i++) { if(sum[i]&lt;0) { int id=lower_bound(b+1,b+m,ned[i])-b; add(id),add2(id,ned[i]); int sm=upper_bound(b+1,b+m,ned[i]-1)-b-1; ans+=ned[i]*que(sm)-que2(sm)+(ned[i]-1)*cntsm+ned[i]+n-1-cntbg; } } for(int i=1;i&lt;=n;i++) c[i]=c2[i]=0; for(int i=n-1;i&gt;=1;i--) { if(sum[i]&lt;0) { int id=lower_bound(b+1,b+m,ned[i])-b; add(id),add2(id,ned[i]); int sm=upper_bound(b+1,b+m,ned[i]-1)-b-1; ans+=(ned[i]-1)*que(sm)-que2(sm); } } for(int i=1;i&lt;=n;i++) c[i]=c2[i]=0; for(int i=n-1;i&gt;=1;i--) { if(sum[i]&gt;s) { int id=lower_bound(b+1,b+m,ned[i])-b; add(id),add2(id,ned[i]); int sm=upper_bound(b+1,b+m,ned[i]-1)-b-1; ans+=ned[i]*que(sm)-que2(sm)+(ned[i]-1)*cntbg+ned[i]; } } for(int i=1;i&lt;=n;i++) c[i]=c2[i]=0; for(int i=1;i&lt;=n-1;i++) { if(sum[i]&gt;s) { int id=lower_bound(b+1,b+m,ned[i])-b; add(id),add2(id,ned[i]); int sm=upper_bound(b+1,b+m,ned[i]-1)-b-1; ans+=(ned[i]-1)*que(sm)-que2(sm); } } for(int i=1;i&lt;=n-1;i++) nxt[i]=sum[i]&lt;0?sum[i]+s*ned[i]:sum[i]-s*ned[i]; for(int i=1;i&lt;=n-1;i++) id[i]=i; sort(id+1,id+n,cmp2); for(int i=1;i&lt;=n-1;i++) b[i]=sum[i]=nxt[id[i]]; sort(b+1,b+n); for(int i=1;i&lt;=n;i++) c[i]=0; for(int i=n-1;i&gt;=1;i--) { int id=lower_bound(b+1,b+n,sum[i])-b; ans+=que(id-1); add(id); } printf(&quot;%lld\\n&quot;,ans); } int main() { fio(&quot;elasticity&quot;); while(1) { scanf(&quot;%d&quot;,&amp;n); if(n==0) break; slove(); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022 NOIP 模拟赛 38】数环 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-38-shu-huan-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":500000,"words":1529,"minutes":9},"date":"2023-04-14 17:08:59","dateFormat":"2023-04-14"},{"abstract":"<blockquote>\n<p>输入正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，要求把一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n \\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的棋盘染成蓝色和黄色，且每行恰好有一段蓝色的格子，每列恰好有一段黄色的格子。输出总方案数对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>2021</mn></mrow><annotation encoding=\"application/x-tex\">n,m\\le2021</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\">1</span></span></span></span>。</p>\n</blockquote>\n","content":" 输入正整数 n,mn,mn,m，要求把一个 n×mn \\times mn×m 的棋盘染成蓝色和黄色，且每行恰好有一段蓝色的格子，每列恰好有一段黄色的格子。输出总方案数对 998244353998244353998244353 取模的结果。 n,m≤2021n,m\\le2021n,m≤2021。 CF *3100 虚高。 显然合法的棋盘是长这样的： 抽象一点： 大概就是上面一个山坡下面一个山坡，并且两个山坡没有接触。 先考虑怎么数山坡的方案数，显然可以把山坡劈成单调不降的两段，设 dpi,jdp_{i,j}dpi,j​ 表示 iii 根柱子，最高的柱子（第 iii 根）高 jjj 的方案数，显然有 dp0,0=1dp_{0,0}=1dp0,0​=1，转移为： dpi,j=∑k=0jdpi−1,kdp_{i,j}=\\sum\\limits_{k=0}^{j}dp_{i-1,k} dpi,j​=k=0∑j​dpi−1,k​ 接下来考虑拼接形成山坡，由于上面的山坡和下面的山坡不能有接触，但是每一行都必须有某一个山坡经过，所以两个山坡最高的柱子之间只有两种情况： （最高的柱子交错） 和： （最高的柱子高度和为 nnn） 交错的情况很简单，显然两根最高的柱子一定是相邻的，那么把网格劈成两半，算出 dp2i,jdp2_{i,j}dp2i,j​ 表示上下都有 iii 根柱子，下面最高的那根柱子长度为 jjj，上面最高的那根柱子长度 ≤n−j−1\\le n-j-1≤n−j−1 的方案数，显然有 dp2i,j=dpi,j×∑k=0n−j−1dpi,kdp2_{i,j}=dp_{i,j}\\times\\sum\\limits_{k=0}^{n-j-1}dp_{i,k}dp2i,j​=dpi,j​×k=0∑n−j−1​dpi,k​。然后枚举左边的那一半有多长和上面最高的柱子的高度，和右边拼起来即可： ans1=∑i=1m−1∑j=2n−1dp2i,j×∑k=n−j+1n−1dp2m−i,kans1=\\sum\\limits_{i=1}^{m-1}\\sum\\limits_{j=2}^{n-1}dp2_{i,j}\\times\\sum\\limits_{k=n-j+1}^{n-1}dp2_{m-i,k} ans1=i=1∑m−1​j=2∑n−1​dp2i,j​×k=n−j+1∑n−1​dp2m−i,k​ 高度和为 nnn 的情况有点麻烦，不难发现上面的最高柱子区间和下面的最高柱子区间一定不相交，那么仍旧把网格劈成两半，求出 dp3i,jdp3_{i,j}dp3i,j​ 表示一共有 iii 个柱子可以是最高的，最高的柱子高度为 jjj 时山坡的方案，显然有 dp3i,j=dpi,j×∑k=0j−1dpm−i,kdp3_{i,j}=dp_{i,j}\\times\\sum\\limits_{k=0}^{j-1}dp_{m-i,k}dp3i,j​=dpi,j​×k=0∑j−1​dpm−i,k​。然后强制让上面最高柱子的区间右端点为 iii，枚举下面最高柱子的区间左端点 jjj 即可： ans2=∑i=1m−1∑j=1n−1dp3i,j×∑k=i+1mdp3m−i+1,n−jans2=\\sum\\limits_{i=1}^{m-1}\\sum\\limits_{j=1}^{n-1}dp3_{i,j}\\times\\sum\\limits_{k=i+1}^{m}dp3_{m-i+1,n-j} ans2=i=1∑m−1​j=1∑n−1​dp3i,j​×k=i+1∑m​dp3m−i+1,n−j​ 答案即为 ans=2(ans1+ans2)ans=2(ans1+ans2)ans=2(ans1+ans2) 因为上下可以反过来。 不难发现所有式子都可以用前缀和优化到 O(nm)O(nm)O(nm)，那么就做完了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int S=3005,p=998244353; int n,m; int dp[S][S],sm[S][S]; int sm2[S][S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); dp[0][0]=1; for(int i=0;i&lt;=n;i++) sm[0][i]=1; for(int i=1;i&lt;=m;i++) { for(int j=0;j&lt;=n;j++) dp[i][j]=sm[i-1][j]; for(int j=0;j&lt;=n;j++) { if(j&gt;0) sm[i][j]=sm[i][j-1]; add(sm[i][j],dp[i][j]); } } for(int i=1;i&lt;=m;i++) { for(int j=n-1;j&gt;=0;j--) { sm2[i][j]=sm2[i][j+1]; add(sm2[i][j],1ll*dp[i][j]*sm[i][n-j-1]%p); } } int ans=0; for(int i=1;i&lt;=m-1;i++) { for(int j=2;j&lt;=n-1;j++) { int pre=1ll*dp[i][j]*sm[i][n-j-1]%p*sm2[m-i][n-j+1]%p; add(ans,pre); } } memset(sm2,0,sizeof(sm2)); for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n-1;j++) { int pre=1ll*dp[i][j]*sm[m-i][j-1]%p; sm2[i][j]=sm2[i-1][j]; add(sm2[i][j],pre); } } for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n-1;j++) { int pre=1ll*dp[i][j]*sm[m-i][j-1]%p*sm2[m-i][n-j]%p; add(ans,pre); } } ans=2ll*ans%p; printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1503E 2-Coloring 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1503e-2-coloring-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":328000,"words":1108,"minutes":6},"date":"2023-04-08 09:09:37","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>小 C 将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi><mo>×</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">r\\times c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 堆石子摆成一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi><mo>×</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">r\\times c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 的矩形 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，每一轮玩家可以从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 行中选择任意几行（至少一行），然后从选择的行中各选择非空的一堆石子，拿走其中的一个石子，形式化的说，你可以选择若干正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>i</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>i</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>i</mi><mi>k</mi></msub><mo>≤</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">1\\leq i_1&lt;i_2&lt;\\dots&lt;i_k\\leq r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span>，然后选择 正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>j</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>j</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>j</mi><mi>k</mi></msub><mo>≤</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">1\\leq j_1,j_2,\\dots,j_k\\leq c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span>，然后将所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><msub><mi>i</mi><mi>l</mi></msub><mo separator=\"true\">,</mo><msub><mi>j</mi><mi>l</mi></msub></mrow></msub><mtext>  </mtext><mo>(</mo><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a_{i_l,j_l}\\ \\ (1\\leq l\\leq k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15122857142857138em;\"><span></span></span></span></span></span></span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3487714285714287em;margin-left:-0.05724em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15122857142857138em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> 减一，且保证操作完后非负 。不能操作的人输。你先手操作。</p>\n<p>现在有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 堆石子摆成了一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的矩形，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 行第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 列有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 个石子，小 C 会在这个矩形中随机选择一个子矩形进行游戏。</p>\n<p>你想要知道你获胜的概率乘以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mi>m</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>4</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{nm(n+1)(m+1)}{4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mathdefault mtight\">m</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">m</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 的值，可以证明这一定是个整数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>3000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 3000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le a_{i,j}\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.922078em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 小 C 将 r×cr\\times cr×c 堆石子摆成一个 r×cr\\times cr×c 的矩形 aaa，每一轮玩家可以从 rrr 行中选择任意几行（至少一行），然后从选择的行中各选择非空的一堆石子，拿走其中的一个石子，形式化的说，你可以选择若干正整数 1≤i1&lt;i2&lt;⋯&lt;ik≤r1\\leq i_1&lt;i_2&lt;\\dots&lt;i_k\\leq r1≤i1​&lt;i2​&lt;⋯&lt;ik​≤r，然后选择 正整数 1≤j1,j2,…,jk≤c1\\leq j_1,j_2,\\dots,j_k\\leq c1≤j1​,j2​,…,jk​≤c，然后将所有 ail,jl (1≤l≤k)a_{i_l,j_l}\\ \\ (1\\leq l\\leq k)ail​,jl​​ (1≤l≤k) 减一，且保证操作完后非负 。不能操作的人输。你先手操作。 现在有 n×mn\\times mn×m 堆石子摆成了一个 n×mn\\times mn×m 的矩形，第 iii 行第 jjj 列有 ai,ja_{i,j}ai,j​ 个石子，小 C 会在这个矩形中随机选择一个子矩形进行游戏。 你想要知道你获胜的概率乘以 nm(n+1)(m+1)4\\frac{nm(n+1)(m+1)}{4}4nm(n+1)(m+1)​ 的值，可以证明这一定是个整数。 1≤n,m≤30001\\le n,m\\le 30001≤n,m≤3000，0≤ai,j≤1090\\le a_{i,j}\\le 10^90≤ai,j​≤109。 首先不难发现答案就是先手必胜子矩形个数，并且不难证明一个子矩形是先手必胜当且仅当这个子矩形有至少一行的和为奇数。 考虑容斥，问题转化为求有多少个子矩形所有行的和都是偶数。 设 sumi,j=∑k=1jaimod⁡2sum_{i,j}=\\sum\\limits_{k=1}^ja_i\\operatorname{mod}2sumi,j​=k=1∑j​ai​mod2，那么若固定了子矩形的上边界 lblblb 和下边界 rbrbrb，那么子矩形 (lb,x,rb,y)(lb,x,rb,y)(lb,x,rb,y) 合法当且仅当 sumlb,x−1=sumlb,y,sumlb+1,x−1=sumlb,y,…,sumrb,x−1=sumrb,ysum_{lb,x-1}=sum_{lb,y},sum_{lb+1,x-1}=sum_{lb,y},\\dots,sum_{rb,x-1}=sum_{rb,y}sumlb,x−1​=sumlb,y​,sumlb+1,x−1​=sumlb,y​,…,sumrb,x−1​=sumrb,y​。 那么维护若干个等价类，每个等价类的贡献即为 siz(siz−1)2\\frac{siz(siz-1)}{2}2siz(siz−1)​。 考虑如何快速维护等价类，显然下边界往上推一位相当于去掉最后一位的影响，也就是在 trie 上合并两棵子树，那么维护一下即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout); const int MS=3005; int n,m,a[MS][MS]; int cnt=1,siz[MS*MS],son[MS*MS][2]; long long pre,ans; void dfs(int u) { if(son[u][0]!=0) dfs(son[u][0]); if(son[u][1]!=0) dfs(son[u][1]); siz[u]+=siz[son[u][0]]+siz[son[u][1]]; pre+=1ll*siz[u]*(siz[u]-1)/2; } int meg(int x,int y) { if(x==0||y==0) return x+y; son[x][0]=meg(son[x][0],son[y][0]); son[x][1]=meg(son[x][1],son[y][1]); pre+=1ll*siz[x]*siz[y]; siz[x]+=siz[y]; return x; } int main() { fio(&quot;matrix&quot;); int T; scanf(&quot;%d&quot;,&amp;T); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { scanf(&quot;%d&quot;,&amp;a[i][j]); a[i][j]&amp;=1,a[i][j]^=a[i][j-1]; } } for(int i=0;i&lt;=m;i++) { int u=1; for(int j=n;j&gt;=1;j--) { if(son[u][a[j][i]]==0) son[u][a[j][i]]=++cnt; u=son[u][a[j][i]]; } siz[u]++; } dfs(1); int rt=1; for(int i=n;i&gt;=1;i--) { pre-=1ll*m*(m+1)/2; ans+=pre; rt=meg(son[rt][0],son[rt][1]); } printf(&quot;%lld\\n&quot;,1ll*n*(n+1)/2*m*(m+1)/2-ans); return 0; } ","tags":[{"name":"博弈论","slug":"6A-_b3w3J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/6A-_b3w3J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"【2022 NOIP 模拟赛 34】矩阵博弈 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-34-ju-zhen-bo-yi-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":269000,"words":887,"minutes":5},"date":"2023-04-08 09:07:48","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>题目包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span></span></span></span> 组数据。</p>\n<p>对于每一组数据，给出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">n=2^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span></span></span></span></span></span></span></span>，给出一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的树的边，你要定出树的根，和树上的所有点权和边权，使得所有点权和边权构成一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1 \\sim 2 n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的排列，且从根到<strong>每个节点和每条边</strong>的<strong>简单路径</strong>上点权和边权的异或和的<strong>最大值最小</strong>。输出方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>p</mi><mo>≤</mo><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">1\\le p\\le 17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span></span></span></span>。</p>\n</blockquote>\n","content":" 题目包含 QQQ 组数据。 对于每一组数据，给出 ppp，使得 n=2pn=2^pn=2p，给出一棵 nnn 个点的树的边，你要定出树的根，和树上的所有点权和边权，使得所有点权和边权构成一个 1∼2n−11 \\sim 2 n - 11∼2n−1 的排列，且从根到每个节点和每条边的简单路径上点权和边权的异或和的最大值最小。输出方案。 1≤p≤171\\le p\\le 171≤p≤17。 首先显然答案下界是 2p2^p2p，因为无论如何都至少有一条简单路径的异或和二进制第 ppp 位为 111。 那么不妨猜测能取到下界，尝试构造并证明之。 不妨设根为 111，令 a1=2pa_1=2^pa1​=2p，接下来往下递归： 若此时异或和为 2p2^p2p，那么让边权为 2p+c2^p+c2p+c（ccc 是一个常数），子节点点权为 ccc，让异或和变成 000； 若此时异或和为 000，那么让边权为 ccc，子节点点权为 2p+c2^p+c2p+c，让异或和变成 2p2^p2p； 不难发现，这样构造除了根之外的所有节点都需要不同的 ccc，由于不同的 ccc 共有 n−1n-1n−1 个，所以刚好够。 代码如下： // Problem: CF1670E Hemose on the Tree // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1670E // Memory Limit: 250 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=500005; int p,n; int esum,to[S],id[S],nxt[S],h[S]; int c; int a[S],b[S]; inline void add(int x,int y,int idx) { to[++esum]=y; id[esum]=idx; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u,int fa,bool isn) { for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; c++; b[id[i]]=c+(isn?n:0); a[v]=c+(isn?0:n); dfs(v,u,!isn); } } void slove() { scanf(&quot;%d&quot;,&amp;p); n=1&lt;&lt;p; esum=0; for(int i=1;i&lt;=n;i++) h[i]=0; for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y,i),add(y,x,i); } a[1]=n; c=0; dfs(1,0,true); puts(&quot;1&quot;); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); for(int i=1;i&lt;=n-1;i++) printf(&quot;%d &quot;,b[i]); printf(&quot;\\n&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1670E Hemose on the Tree 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1670e-hemose-on-the-tree-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":170000,"words":576,"minutes":3},"date":"2023-04-08 09:06:42","dateFormat":"2023-04-08"},{"abstract":"","content":"Prufer 序列是一种常用于解决树的计数问题的序列，它是一种无根树到序列的双射。 定义 一棵无根树的 Prufer 序列是这样定义的： 删掉叶子节点（度为 111）中编号最小的节点，把与它相连的节点的编号加入序列的末尾 重复这个操作直到剩余节点数为 222 Prufer 序列的构造过程可以看作是一层一层地把树扒开（ 很明显，Prufer 序列和无根树互为双射，一棵 nnn 个节点的无根树的 Prufer 序列长度为 n−2n-2n−2。 运用 一棵 nnn 个节点的无根树共有 nn−2n^{n-2}nn−2 种形态，因为 Prufer 序列的每一位都可以任选； 一棵 nnn 个节点的有根树共有 nn−1n^{n-1}nn−1 种形态； 某个节点 uuu 的度数是它在 Prufer 序列中的出现次数 +1+1+1； 一棵 mmm 个节点，第 iii 个节点有 aia_iai​ 中连接方式的无根树共有 (∑i=1mai)m−2∏i=1mai(\\sum\\limits_{i=1}^m a_i)^{m-2}\\prod\\limits_{i=1}^m a_i(i=1∑m​ai​)m−2i=1∏m​ai​ 种； 证明如下： 考虑生成出来的树的长度为 m−2m-2m−2 的 Prufer 序列，显然每个位置可以任选。iii 的度即为它在 Prufer 序列中出现的次数 +1+1+1，所以 iii 的贡献是 ai出现次数+1a_i^{\\text{出现次数}+1}ai出现次数+1​，把 +1+1+1 拉出来，变成 (∏ai出现次数)(∏ai)(\\prod a_i^{\\text{出现次数}})(\\prod a_i)(∏ai出现次数​)(∏ai​)。 所有情况下的 ∏ai出现次数\\prod a_i^{\\text{出现次数}}∏ai出现次数​ 之和显然和 (∑ai)m−2(\\sum a_i)^{m-2}(∑ai​)m−2 是等价的，得证。 例题 板子：CF156D Clues 板子：P2290 [HNOI2004]树的计数 板子，但是下降幂：ARC106F 设 cnticnt_icnti​ 为 iii 在 Prufer 序列中的出现次数，那么答案为： ∏dicnti+1‾=(∏di)∏(di−1)cnti‾=(∏di)(∑di−1)n−2‾\\begin{aligned} &amp;\\prod d_i^{\\underline{cnt_i+1}}\\\\ &amp;=\\left(\\prod d_i\\right)\\prod (d_i-1)^{\\underline{cnt_i}}\\\\ &amp;=\\left(\\prod d_i\\right)\\left(\\sum d_i-1\\right)^{\\underline{n-2}}\\\\ \\end{aligned} ​∏dicnti​+1​​=(∏di​)∏(di​−1)cnti​​=(∏di​)(∑di​−1)n−2​​ ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Prufer 序列学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/prufer-xu-lie-xue-xi-bi-ji/","stats":{"text":"3 min read","time":137000,"words":540,"minutes":3},"date":"2023-04-08 09:05:12","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>求满足以下条件的长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 的个数：</p>\n<ul>\n<li>对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mi mathvariant=\"normal\">mod</mi><mo>⁡</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>≤</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">p_i\\operatorname{mod} p_{i+1}\\le2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>n</mi></msub><mi mathvariant=\"normal\">mod</mi><mo>⁡</mo><msub><mi>p</mi><mn>1</mn></msub><mo>≤</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">p_n\\operatorname{mod}p_1\\le 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>；</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 求满足以下条件的长为 nnn 的排列 ppp 的个数： 对于所有 1≤i≤n−11\\le i\\le n-11≤i≤n−1 有 pimod⁡pi+1≤2p_i\\operatorname{mod} p_{i+1}\\le2pi​modpi+1​≤2； pnmod⁡p1≤2p_n\\operatorname{mod}p_1\\le 2pn​modp1​≤2； 1≤n≤1061\\le n\\le 10^61≤n≤106。 首先去掉 111 和 222 之后，完美的排列显然可以分成两段下降的序列 AAA 和 BBB，它们之间需要用 111 和 222 拼起来。 观察到显然 {x,x−1,x−2,…,3,2,1}\\{x,x-1,x-2,\\dots,3,2,1\\}{x,x−1,x−2,…,3,2,1} 这样的一段连续序列一定是合法的，那么去掉 111 和 222 之后的序列 {n,n−1,n−2,…,5,4,3}\\{n,n-1,n-2,\\dots,5,4,3\\}{n,n−1,n−2,…,5,4,3} 一定可以分成若干段，第 1,3,5,7,9,…1,3,5,7,9,\\dots1,3,5,7,9,… 段分给 AAA 并且互相连接，第 2,4,6,8,10,…2,4,6,8,10,\\dots2,4,6,8,10,… 段分给 BBB 并且互相连接。 考虑动态规划，设 dpidp_idpi​ 表示 [i+1,n][i+1,n][i+1,n] 划分好了，最后一段以 iii 开头的方案数，那么考虑以 iii 开头的那一段前面是哪一段，有转移： dpi=1+∑i∣jdpj−1+dpj+dpj+1dp_{i}=1+\\sum\\limits_{i|j}dp_{j-1}+dp_j+dp_{j+1} dpi​=1+i∣j∑​dpj−1​+dpj​+dpj+1​ 其中 +1+1+1 是因为 [i+1,n][i+1,n][i+1,n] 划分为一整段一定是合法的。 最后的答案即为 2n×∑i=1n−1dpi2n\\times\\sum\\limits_{i=1}^{n-1}dp_i2n×i=1∑n−1​dpi​，因为 [1,i][1,i][1,i] 这一段需要另外算，并且 AAA 和 BBB 可以任意交换顺序且环可以转。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout) const int S=1000005,p=1000000007; int n,dp[S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { fio(&quot;permutation&quot;); scanf(&quot;%d&quot;,&amp;n); if(n&lt;=2) return printf(&quot;%d\\n&quot;,n),0; int ans=1; for(int i=n-1;i&gt;=3;i--) { int tmp=1; for(int j=i;j&lt;=n;j+=i) add(tmp,((long long)dp[j-1]+dp[j]+dp[j+1])%p); dp[i]=tmp; add(ans,dp[i]); } printf(&quot;%d\\n&quot;,1ll*ans*2%p*n%p); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 29】排列 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-29-pai-lie-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":177000,"words":574,"minutes":3},"date":"2023-04-08 09:03:26","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>奆 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ζ</mi></mrow><annotation encoding=\"application/x-tex\">\\zeta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07378em;\">ζ</span></span></span></span> 有一颗 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点有标号的树，点从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 标号，边从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\sim n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 标号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>(</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">u_i,v_i(i\\lt n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>现在他想在这棵树的基础上构造一些新的树</p>\n<p>具体的，他想知道在能构造出的所有 <strong><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点有标号无根树</strong>中，恰好的有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 条边与原树相同的数量</p>\n<p>并且对于每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>∩</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">x\\in[0,n-1]\\cap \\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>，输出答案 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">mod</mi><mo>⁡</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">\\operatorname{mod} 10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 的结果。</p>\n</blockquote>\n","content":" 奆 ζ\\zetaζ 有一颗 nnn 个点有标号的树，点从 1∼n1\\sim n1∼n 标号，边从 1∼n−11\\sim n-11∼n−1 标号为 ui,vi(i&lt;n)u_i,v_i(i\\lt n)ui​,vi​(i&lt;n)。 现在他想在这棵树的基础上构造一些新的树 具体的，他想知道在能构造出的所有 nnn 个点有标号无根树中，恰好的有 xxx 条边与原树相同的数量 并且对于每个 x∈[0,n−1]∩Zx\\in[0,n-1]\\cap \\mathbb{Z}x∈[0,n−1]∩Z，输出答案 mod⁡109+7\\operatorname{mod} 10^9+7mod109+7 的结果。 原题：CF917D Stranger Trees 首先若求出 f(i)f(i)f(i) 表示钦定 iii 条边固定的方案数，设 ans(i)ans(i)ans(i) 为恰好 iii 条边相同的方案数，显然有： ans(i)=∑j=in−1(−1)j−i(ji)f(j)ans(i)=\\sum\\limits_{j=i}^{n-1}(-1)^{j-i}\\binom{j}{i}f(j) ans(i)=j=i∑n−1​(−1)j−i(ij​)f(j) 考虑求出 f(i)f(i)f(i)，钦定了 iii 条边固定就相当于有 n−in-in−i 个连通块，有个结论： 有 mmm 个点，每个点有 aia_iai​ 种连边方式的树有 (∑ai)m−2∏ai(\\sum a_i)^{m-2}\\prod a_i(∑ai​)m−2∏ai​。 证明： 考虑生成出来的树的长度为 m−2m-2m−2 的 prufer 序列，显然每个位置可以任选。iii 的度即为它在 prufer 序列中出现的次数 +1+1+1，所以每个点的贡献是 ai出现次数+1a_i^{\\text{出现次数}+1}ai出现次数+1​，把 +1+1+1 拉出来，变成 (∏ai出现次数)(∏ai)(\\prod a_i^{\\text{出现次数}})(\\prod a_i)(∏ai出现次数​)(∏ai​)。 所有情况下的 ∏ai出现次数\\prod a_i^{\\text{出现次数}}∏ai出现次数​ 之和显然和 (∑ai)m−2(\\sum a_i)^{m-2}(∑ai​)m−2 是等价的，得证。 那么考虑设 dpu,i,jdp_{u,i,j}dpu,i,j​ 表示 uuu 的子树，选了 iii 条边，包含 uuu 的连通块大小为 jjj 的 ∑∏siz\\sum\\prod siz∑∏siz（jjj 没有乘进去）。 dpu,i,j=∑k=0i∑l=1jdpu,i−k−1,j−l×dpv,k,l+∑k=0i−1∑ldpu,i−k,j×l×dpv,k,ldp_{u,i,j}=\\sum\\limits_{k=0}^i\\sum\\limits_{l=1}^j dp_{u,i-k-1,j-l}\\times dp_{v,k,l}+\\sum\\limits_{k=0}^{i-1}\\sum\\limits_l dp_{u,i-k,j}\\times l\\times dp_{v,k,l} dpu,i,j​=k=0∑i​l=1∑j​dpu,i−k−1,j−l​×dpv,k,l​+k=0∑i−1​l∑​dpu,i−k,j​×l×dpv,k,l​ 考虑优化，压掉一维，设 fu,i=∑jdpu,i,j,gu,i=∑jj×dpu,i,jf_{u,i}=\\sum\\limits_{j}dp_{u,i,j},g_{u,i}=\\sum\\limits_{j}j\\times dp_{u,i,j}fu,i​=j∑​dpu,i,j​,gu,i​=j∑​j×dpu,i,j​，考虑转移，有： fu,i=∑jdpu,i,j=∑j∑k=0i−1∑l=1jdpu,i−k−1,j−l×dpv,k,l+∑j∑k=0i∑ldpu,i−k,j×l×dpv,k,l=∑k=0i−1fu,i−k−1×fv,k+∑k=0ifu,i−k×gv,k\\begin{aligned} f_{u,i}&amp;=\\sum\\limits_{j}dp_{u,i,j}\\\\ &amp;=\\sum\\limits_{j}\\sum\\limits_{k=0}^{i-1}\\sum\\limits_{l=1}^j dp_{u,i-k-1,j-l}\\times dp_{v,k,l}+\\sum\\limits_{j}\\sum\\limits_{k=0}^i\\sum\\limits_l dp_{u,i-k,j}\\times l\\times dp_{v,k,l}\\\\ &amp;=\\sum\\limits_{k=0}^{i-1} f_{u,i-k-1}\\times f_{v,k}+\\sum\\limits_{k=0}^{i}f_{u,i-k}\\times g_{v,k} \\end{aligned} fu,i​​=j∑​dpu,i,j​=j∑​k=0∑i−1​l=1∑j​dpu,i−k−1,j−l​×dpv,k,l​+j∑​k=0∑i​l∑​dpu,i−k,j​×l×dpv,k,l​=k=0∑i−1​fu,i−k−1​×fv,k​+k=0∑i​fu,i−k​×gv,k​​ gu,i=∑jj×dpu,i,j=∑jj∑k=0i−1∑l=1jdpu,i−k−1,j−l×dpv,k,l+∑jj∑k=0i∑ldpu,i−k,j×l×dpv,k,l=∑j∑k=0i−1∑l=1j(j−l+l)×dpu,i−k−1,j−l×dpv,k,l+∑k=0igu,i−k×gv,k=∑j∑k=0i−1∑l=1j(j−l)×dpu,i−k−1,j−l×dpv,k,l+∑j∑k=0i−1∑l=1jl×dpu,i−k−1,j−l×dpv,k,l+∑k=0igu,i−k−1×gv,k=∑k=0i−1gu,i−k−1×fv,k+∑k=0i−1fu,i−k−1×gv,k+∑k=0igu,i−k×gv,k=∑k=0i−1gu,i−k−1×fv,k+fu,i−k−1×gv,k+∑k=0igu,i−k×gv,k\\begin{aligned} g_{u,i}&amp;=\\sum\\limits_{j}j\\times dp_{u,i,j}\\\\ &amp;=\\sum\\limits_{j}j\\sum\\limits_{k=0}^{i-1}\\sum\\limits_{l=1}^j dp_{u,i-k-1,j-l}\\times dp_{v,k,l}+\\sum\\limits_{j}j\\sum\\limits_{k=0}^{i}\\sum\\limits_l dp_{u,i-k,j}\\times l\\times dp_{v,k,l}\\\\ &amp;=\\sum\\limits_{j}\\sum\\limits_{k=0}^{i-1}\\sum\\limits_{l=1}^j (j-l+l)\\times dp_{u,i-k-1,j-l}\\times dp_{v,k,l}+\\sum\\limits_{k=0}^{i}g_{u,i-k}\\times g_{v,k}\\\\ &amp;=\\sum\\limits_{j}\\sum\\limits_{k=0}^{i-1}\\sum\\limits_{l=1}^j (j-l)\\times dp_{u,i-k-1,j-l}\\times dp_{v,k,l}+\\sum\\limits_{j}\\sum\\limits_{k=0}^{i-1}\\sum\\limits_{l=1}^j l\\times dp_{u,i-k-1,j-l}\\times dp_{v,k,l}+\\sum\\limits_{k=0}^{i}g_{u,i-k-1}\\times g_{v,k}\\\\ &amp;=\\sum\\limits_{k=0}^{i-1}g_{u,i-k-1}\\times f_{v,k}+\\sum\\limits_{k=0}^{i-1}f_{u,i-k-1}\\times g_{v,k}+\\sum\\limits_{k=0}^{i}g_{u,i-k}\\times g_{v,k}\\\\ &amp;=\\sum\\limits_{k=0}^{i-1}g_{u,i-k-1}\\times f_{v,k}+f_{u,i-k-1}\\times g_{v,k}+\\sum\\limits_{k=0}^{i}g_{u,i-k}\\times g_{v,k} \\end{aligned} gu,i​​=j∑​j×dpu,i,j​=j∑​jk=0∑i−1​l=1∑j​dpu,i−k−1,j−l​×dpv,k,l​+j∑​jk=0∑i​l∑​dpu,i−k,j​×l×dpv,k,l​=j∑​k=0∑i−1​l=1∑j​(j−l+l)×dpu,i−k−1,j−l​×dpv,k,l​+k=0∑i​gu,i−k​×gv,k​=j∑​k=0∑i−1​l=1∑j​(j−l)×dpu,i−k−1,j−l​×dpv,k,l​+j∑​k=0∑i−1​l=1∑j​l×dpu,i−k−1,j−l​×dpv,k,l​+k=0∑i​gu,i−k−1​×gv,k​=k=0∑i−1​gu,i−k−1​×fv,k​+k=0∑i−1​fu,i−k−1​×gv,k​+k=0∑i​gu,i−k​×gv,k​=k=0∑i−1​gu,i−k−1​×fv,k​+fu,i−k−1​×gv,k​+k=0∑i​gu,i−k​×gv,k​​ 代码如下： // Problem: #148. 构树 // Contest: Hydro // URL: http://oiclass.com/d/tigao/p/148 // Memory Limit: 256 MB // Time Limit: 4000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout); const int MS=8005,S=100005,p=1000000007; int n; int esum,to[S],nxt[S],h[MS]; int siz[MS]; vector&lt;int&gt; f[MS],g[MS]; int tmpf[MS],tmpg[MS]; int ml[MS],fra[MS],inv[MS]; int ans[MS]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } inline void addd(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } inline int C(int n,int m) { return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } void dfs(int u,int fa) { siz[u]=1; f[u].push_back(1),g[u].push_back(1); for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); for(int j=0;j&lt;=n;j++) tmpf[j]=tmpg[j]=0; for(int j=0;j&lt;=siz[u]-1;j++) { for(int k=0;k&lt;=siz[v]-1;k++) { addd(tmpf[j+k+1],1ll*f[u][j]*f[v][k]%p); addd(tmpf[j+k],1ll*f[u][j]*g[v][k]%p); addd(tmpg[j+k+1],(1ll*g[u][j]*f[v][k]+1ll*f[u][j]*g[v][k])%p); addd(tmpg[j+k],1ll*g[u][j]*g[v][k]%p); } } siz[u]+=siz[v]; for(int j=0;j&lt;=siz[u]-1;j++) { if(j&lt;f[u].size()) f[u][j]=tmpf[j],g[u][j]=tmpg[j]; else f[u].push_back(tmpf[j]),g[u].push_back(tmpg[j]); } } } int main() { fio(&quot;tree&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } dfs(1,0); ml[0]=1; for(int i=1;i&lt;=n;i++) ml[i]=1ll*ml[i-1]*n%p; fra[0]=1; for(int i=1;i&lt;=n;i++) fra[i]=1ll*fra[i-1]*i%p; inv[n]=qpow(fra[n],p-2); for(int i=n;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; for(int i=0;i&lt;=n-1;i++) ans[i]=i!=n-1?1ll*ml[n-i-2]*g[1][i]%p:1; for(int i=0;i&lt;=n-1;i++) { int pre=0; for(int j=i;j&lt;=n-1;j++) { if(j-i&amp;1^1) addd(pre,1ll*C(j,i)*ans[j]%p); else addd(pre,p-1ll*C(j,i)*ans[j]%p); } printf(&quot;%d &quot;,pre); } printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 28】构树 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-28-gou-shu-zuo-ti-ji-lu/","stats":{"text":"12 min read","time":683000,"words":1973,"minutes":12},"date":"2023-04-08 08:59:29","dateFormat":"2023-04-08"},{"abstract":"","content":"李超树是一种用来维护直线的数据结构，可以在 O(log⁡V)O(\\log V)O(logV) 的时间复杂度内求出所有直线中在 x=kx=kx=k 处的最大 yyy 取值。 考虑用线段树去维护这个东西，可以让每个节点维护在它的区间中点 x=midx=midx=mid 处 yyy 最大的直线，每新插入一条直线时，若这条直线在 x=midx=midx=mid 处的 yyy 取值比 uuu 上之前的直线小，那么分两种情况： 当前直线的斜率 k′k&#x27;k′ 大于之前直线的斜率 kkk，此时这条直线往左走肯定比 uuu 上之前的直线低，那么只能往右走，所以递归插入右儿子； 当前直线的斜率 k′k&#x27;k′ 小于之前直线的斜率 kkk，此时这条直线往右走肯定比 uuu 上之前的直线低，那么只能往左走，所以递归插入左儿子； 否则若这条直线在 x=midx=midx=mid 处的 yyy 取值大于等于 uuu 上之前的直线，那么更新 uuu 上的直线，并且把之前 uuu 上的直线往下插入。 查询 kkk 时不断在线段树上往 kkk 递归，把路径上的线段在 x=kx=kx=k 处的取值取个 max⁡\\maxmax 即可，正确性显然。 注意每个节点的直线要初始化为 y=0x+(−∞)y=0x+(-\\infin)y=0x+(−∞)。 代码如下： struct node { int k,b; inline int slove(int x) {return k*x+b;} }mx[S&lt;&lt;2]; inline void built(int u,int l,int r) { mx[u].k=0; mx[u].b=-1e8; if(l==r) return; int mid=l+r&gt;&gt;1; built(u&lt;&lt;1,l,mid),built(u&lt;&lt;1|1,mid+1,r); } void ins(int u,int l,int r,node val) { if(l==r) return void(mx[u]=(val.slove(l)&gt;mx[u].slove(l)?val:mx[u])); int mid=l+r&gt;&gt;1; int pre=val.slove(mid); if(pre&gt;mx[u].slove(mid)) swap(val,mx[u]); if(val.k&gt;mx[u].k) ins(u&lt;&lt;1|1,mid+1,r,val); else ins(u&lt;&lt;1,l,mid,val); } int que(int u,int l,int r,int x) { if(l==r) return mx[u].slove(x); int mid=l+r&gt;&gt;1; if(x&lt;=mid) return max(mx[u].slove(x),que(u&lt;&lt;1,l,mid,x)); else return max(mx[u].slove(x),que(u&lt;&lt;1|1,mid+1,r,x)); } ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"李超线段树学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/li-chao-xian-duan-shu-xue-xi-bi-ji/","stats":{"text":"3 min read","time":158000,"words":566,"minutes":3},"date":"2023-04-08 08:58:50","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，考虑以下过程：</p>\n<p>维护一个初始为空的栈，然后从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 枚举 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 比栈顶严格大或栈为空，那么把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加入栈中；</li>\n<li>否则：\n<ul>\n<li>把栈顶弹出，并把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加入栈中。注意，你需要保证操作完成后栈中元素从底到顶严格单调递增；</li>\n<li>什么也不干；</li>\n</ul>\n</li>\n</ul>\n<p>请你求出最后栈大小的最大值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 和一个 nnn 的排列 aaa，考虑以下过程： 维护一个初始为空的栈，然后从 111 到 nnn 枚举 iii： aia_iai​ 比栈顶严格大或栈为空，那么把 aia_iai​ 加入栈中； 否则： 把栈顶弹出，并把 aia_iai​ 加入栈中。注意，你需要保证操作完成后栈中元素从底到顶严格单调递增； 什么也不干； 请你求出最后栈大小的最大值。 1≤n≤5×1051\\le n\\le 5\\times 10^51≤n≤5×105。 首先若设 nxt_i=\\min\\{j|j&gt;i\\and a_j&gt;a_i\\}，dpidp_idpi​ 表示以 aia_iai​ 结尾且最终序列包含 aia_iai​ 的最长子序列长度，那么 dpi+1dp_i+1dpi​+1 能转移到 dpjdp_jdpj​ 当且仅当 j∈[nxti,nxtnxti−1]j\\in[nxt_i,nxt_{nxt_i}-1]j∈[nxti​,nxtnxti​​−1] 且 aj&gt;aia_j&gt;a_iaj​&gt;ai​。 考虑消除 aj&gt;aia_j&gt;a_iaj​&gt;ai​ 这个限制，一种巧妙的做法是按照 aia_iai​ 从小到大枚举 iii。消掉限制后直接用线段树维护转移即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int S=500005; int n,a[S],pos[S]; int top,sta[S]; int nxt[S]; int tag[S&lt;&lt;2],mx[S&lt;&lt;2],dp[S]; inline void addtag(int u,int val) { tag[u]=max(tag[u],val),mx[u]=max(mx[u],val); } inline void dwntag(int u) { addtag(u&lt;&lt;1,tag[u]),addtag(u&lt;&lt;1|1,tag[u]); tag[u]=-1e8; } void upd(int u,int l,int r,int L,int R,int val) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) { addtag(u,val); return; } dwntag(u); int mid=l+r&gt;&gt;1; if(L&lt;=mid) upd(u&lt;&lt;1,l,mid,L,R,val); if(R&gt;=mid+1) upd(u&lt;&lt;1|1,mid+1,r,L,R,val); mx[u]=max(mx[u&lt;&lt;1],mx[u&lt;&lt;1|1]); } int que(int u,int l,int r,int pos) { if(l==r) return mx[u]; dwntag(u); int mid=l+r&gt;&gt;1; if(pos&lt;=mid) return que(u&lt;&lt;1,l,mid,pos); else return que(u&lt;&lt;1|1,mid+1,r,pos); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),pos[a[i]]=i; pos[a[0]=0]=0; sta[top=0]=n+1; for(int i=n;i&gt;=0;i--) { while(top&gt;0&amp;&amp;a[sta[top]]&lt;a[i]) top--; nxt[i]=sta[top]; sta[++top]=i; } memset(mx,128,sizeof(mx)); memset(tag,128,sizeof(tag)); for(int i=0;i&lt;=n;i++) { int id=pos[i]; int lb=nxt[id],rb=nxt[nxt[id]]-1; dp[id]=id==0?0:que(1,1,n,id); if(lb&gt;rb) continue; if(lb&lt;1||rb&gt;n) continue; upd(1,1,n,lb,rb,dp[id]+1); } int ans=0; for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【Public Judge NOIP Round 2】排序 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/public-judge-noip-round-2-pai-xu-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":205000,"words":633,"minutes":4},"date":"2023-04-08 08:52:49","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>小可可又在造数据，只不过这次是一个联通图。</p>\n<p>小可可要造一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的联通图，由于她非常懒，于是决定每次在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1, n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 中独立地等概率随机两个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u, v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span>（可以相同），然后将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u, v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 之间连一条边。</p>\n<p>小可可发现要等到整张图联通需要不少时间，于是问你期望连多少次边后整张图联通，答案对一个质数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 小可可又在造数据，只不过这次是一个联通图。 小可可要造一个 nnn 个点的联通图，由于她非常懒，于是决定每次在 [1,n][1, n][1,n] 中独立地等概率随机两个点 u,vu, vu,v（可以相同），然后将 u,vu, vu,v 之间连一条边。 小可可发现要等到整张图联通需要不少时间，于是问你期望连多少次边后整张图联通，答案对一个质数 ppp 取模。 1≤n≤1001\\le n\\le 1001≤n≤100。 设 dpn,kdp_{n, k}dpn,k​ 表示 nnn 个点的图，经过 kkk 次之后仍然不联通的概率。 枚举与 111 联通的点个数，有： dpn,k=∑i=1n−1∑j=0k(n−1i−1)(kj)(1−dpi,j)(i2n2)j((n−i)2n2)k−j=∑i=1n−1∑j=0k(n−1i−1)(kj)(i2n2)j((n−i)2n2)k−j−(n−1i−1)(kj)dpi,j(i2n2)j((n−i)2n2)k−j=∑i=1n−1(n−1i−1)(i2+(n−i)2n2)k−∑i=1n−1∑j=0k(n−1i−1)(kj)dpi,j(i2n2)j((n−i)2n2)k−j\\begin{aligned} dp_{n, k} =&amp;\\sum\\limits_{i = 1}^{n - 1} \\sum\\limits_{j = 0}^k \\binom{n - 1}{i - 1} \\binom{k}{j} (1 - dp_{i, j}) \\left( \\frac{i^2}{n^2} \\right) ^j \\left( \\frac{(n - i)^2}{n^2} \\right) ^{k - j}\\\\ &amp;= \\sum\\limits_{i = 1}^{n - 1} \\sum\\limits_{j = 0}^k \\binom{n - 1}{i - 1} \\binom{k}{j} \\left( \\frac{i^2}{n^2} \\right) ^j \\left( \\frac{(n - i)^2}{n^2} \\right) ^{k - j} - \\binom{n - 1}{i - 1} \\binom{k}{j} dp_{i, j} \\left( \\frac{i^2}{n^2} \\right) ^j \\left( \\frac{(n - i)^2}{n^2} \\right) ^{k - j}\\\\ &amp;= \\sum\\limits_{i = 1}^{n - 1} \\binom{n - 1}{i - 1} \\left( \\frac{i^2 + (n - i)^2}{n^2} \\right) ^k - \\sum\\limits_{i = 1}^{n - 1} \\sum\\limits_{j = 0}^k \\binom{n - 1}{i - 1} \\binom{k}{j} dp_{i, j} \\left( \\frac{i^2}{n^2} \\right) ^j \\left( \\frac{(n - i)^2}{n^2} \\right) ^{k - j} \\end{aligned} dpn,k​=​i=1∑n−1​j=0∑k​(i−1n−1​)(jk​)(1−dpi,j​)(n2i2​)j(n2(n−i)2​)k−j=i=1∑n−1​j=0∑k​(i−1n−1​)(jk​)(n2i2​)j(n2(n−i)2​)k−j−(i−1n−1​)(jk​)dpi,j​(n2i2​)j(n2(n−i)2​)k−j=i=1∑n−1​(i−1n−1​)(n2i2+(n−i)2​)k−i=1∑n−1​j=0∑k​(i−1n−1​)(jk​)dpi,j​(n2i2​)j(n2(n−i)2​)k−j​ 归纳证明 dpn,k=∑l=0n2−1fn,l(ln2)kdp_{n, k} = \\sum\\limits_{l = 0}^{n^2 - 1} f_{n, l} \\left( \\frac{l}{n^2} \\right) ^kdpn,k​=l=0∑n2−1​fn,l​(n2l​)k，其中 fn,lf_{n, l}fn,l​ 是递推得出的系数。 等式前面一部分形式已经符合此形式，考虑后面一部分： =∑i=1n−1∑j=0k(n−1i−1)(kj)dpi,j(i2n2)j((n−i)2n2)k−j=∑i=1n−1(n−1i−1)∑l=0i2−1fi,l∑j=0k(kj)(li2)j(i2n2)j((n−i)2n2)k−j=∑i=1n−1(n−1i−1)∑l=0i2−1fi,l(l+(n−i)2n2)k\\begin{aligned} &amp;= \\sum\\limits_{i = 1}^{n - 1} \\sum\\limits_{j = 0}^k \\binom{n - 1}{i - 1} \\binom{k}{j} dp_{i, j} \\left( \\frac{i^2}{n^2} \\right) ^j \\left( \\frac{(n - i)^2}{n^2} \\right) ^{k - j}\\\\ &amp;= \\sum\\limits_{i = 1}^{n - 1} \\binom{n - 1}{i - 1} \\sum\\limits_{l = 0}^{i^2 - 1} f_{i, l} \\sum\\limits_{j = 0}^k \\binom{k}{j} \\left( \\frac{l}{i^2} \\right) ^j \\left( \\frac{i^2}{n^2} \\right) ^j \\left( \\frac{(n - i)^2}{n^2} \\right) ^{k - j}\\\\ &amp;= \\sum\\limits_{i = 1}^{n - 1} \\binom{n - 1}{i - 1} \\sum\\limits_{l = 0}^{i^2 - 1} f_{i, l} \\left( \\frac{l + (n - i)^2}{n^2} \\right) ^k \\end{aligned} ​=i=1∑n−1​j=0∑k​(i−1n−1​)(jk​)dpi,j​(n2i2​)j(n2(n−i)2​)k−j=i=1∑n−1​(i−1n−1​)l=0∑i2−1​fi,l​j=0∑k​(jk​)(i2l​)j(n2i2​)j(n2(n−i)2​)k−j=i=1∑n−1​(i−1n−1​)l=0∑i2−1​fi,l​(n2l+(n−i)2​)k​ 于是 ∑l=0n2−1fn,l(ln2)k=∑i=1n−1(n−1i−1)(i2+(n−i)2n2)k−∑i=1n−1∑l=0i2−1fi,l(n−1i−1)(l+(n−i)2n2)k\\sum\\limits_{l = 0}^{n^2 - 1} f_{n, l} \\left( \\frac{l}{n^2} \\right) ^k=\\sum\\limits_{i = 1}^{n - 1} \\binom{n - 1}{i - 1} \\left( \\frac{i^2 + (n - i)^2}{n^2} \\right) ^k-\\sum\\limits_{i = 1}^{n - 1} \\sum\\limits_{l = 0}^{i^2 - 1} f_{i, l} \\binom{n - 1}{i - 1}\\left( \\frac{l + (n - i)^2}{n^2} \\right) ^k l=0∑n2−1​fn,l​(n2l​)k=i=1∑n−1​(i−1n−1​)(n2i2+(n−i)2​)k−i=1∑n−1​l=0∑i2−1​fi,l​(i−1n−1​)(n2l+(n−i)2​)k 那么可以 O(n4)O(n^4)O(n4) 求出 f(n,l)f(n,l)f(n,l)。 答案即为 ∑i=0n2−1∑k=0+∞fn,i(in2)k=∑i=0n2−1fn,in2n2−i\\sum\\limits_{i = 0}^{n^2 - 1} \\sum\\limits_{k = 0}^{+\\infty} f_{n, i} \\left( \\frac{i}{n^2} \\right) ^k = \\sum\\limits_{i = 0}^{n^2 - 1} f_{n, i} \\frac{n^2}{n^2 - i}i=0∑n2−1​k=0∑+∞​fn,i​(n2i​)k=i=0∑n2−1​fn,i​n2−in2​。 ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 25】取啊 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-25-qu-a-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":377000,"words":1097,"minutes":7},"date":"2023-04-08 08:51:10","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和两个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的正整数数列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，以如下方式生成一棵树：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 的父亲 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">fa_u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>u</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,u-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 中取，取到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的概率是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><msub><mi>a</mi><mi>i</mi></msub><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>a</mi><mi>j</mi></msub></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{a_i}{\\sum\\limits_{j=1}^{u-1}a_j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.427099em;vertical-align:-1.715607em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7114919999999999em;\"><span style=\"top:-2.19em;\"><span class=\"pstrut\" style=\"height:3.0873235em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop op-limits mtight\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.553319285714286em;\"><span style=\"top:-1.8629092857142857em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.75em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-2.7500050000000003em;\"><span class=\"pstrut\" style=\"height:2.75em;\"></span><span><span class=\"mop op-symbol small-op mtight\">∑</span></span></span><span style=\"top:-3.7000050000000004em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.75em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">u</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1689764285714286em;\"><span></span></span></span></span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2818857142857143em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.3173235em;\"><span class=\"pstrut\" style=\"height:3.0873235em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4974235em;\"><span class=\"pstrut\" style=\"height:3.0873235em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.715607em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">fa_u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 之间有一条长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>u</mi></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>f</mi><msub><mi>a</mi><mi>u</mi></msub></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b_u+b_{fa_u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16454285714285719em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 的边。</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 组询问，每次给出两个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 之间的期望距离对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n,q\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i,b_i\\le 3\\times 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定 nnn 和两个长度为 nnn 的正整数数列 a,ba,ba,b，以如下方式生成一棵树： uuu 的父亲 faufa_ufau​ 在 [1,u−1][1,u-1][1,u−1] 中取，取到 iii 的概率是 ai∑j=1u−1aj\\frac{a_i}{\\sum\\limits_{j=1}^{u-1}a_j}j=1∑u−1​aj​ai​​； uuu 和 faufa_ufau​ 之间有一条长度为 bu+bfaub_u+b_{fa_u}bu​+bfau​​ 的边。 qqq 组询问，每次给出两个点 x,yx,yx,y，求 x,yx,yx,y 之间的期望距离对 109+710^9+7109+7 取模的结果。 2≤n,q≤3×1052\\le n,q\\le 3\\times 10^52≤n,q≤3×105，1≤ai,bi≤3×1031\\le a_i,b_i\\le 3\\times 10^31≤ai​,bi​≤3×103。 首先由于期望是线性的，所以设 lenilen_ileni​ 为 iii 到 111 的期望距离，那么 x,yx,yx,y 之间的期望距离即为 lenx+leny−2lenlca⁡(x,y)len_x+len_y-2len_{\\operatorname{lca}(x,y)}lenx​+leny​−2lenlca(x,y)​。 设 si=∑j=1iajs_i=\\sum\\limits_{j=1}^{i}a_jsi​=j=1∑i​aj​，lenilen_ileni​ 显然即为 ∑j=1i−1ajsi−1(lenj+bi+bj)\\sum\\limits_{j=1}^{i-1} \\frac{a_j}{s_{i-1}}(len_{j}+b_i+b_j)j=1∑i−1​si−1​aj​​(lenj​+bi​+bj​)，可以前缀和快速求。 考虑求解 2lenlca⁡(x,y)2len_{\\operatorname{lca}(x,y)}2lenlca(x,y)​，显然求 lenlca⁡(x,y)len_{\\operatorname{lca}(x,y)}lenlca(x,y)​ 再乘上 222 即可。不妨钦定 x&lt;yx&lt;yx&lt;y，那么一定有 lca⁡(x,y)&lt;x\\operatorname{lca}(x,y)&lt;xlca(x,y)&lt;x，考虑让 yyy 在树上不断往父亲跳，跳到 y′≤xy&#x27;\\le xy′≤x 时停下。设 y′=iy&#x27;=iy′=i 的概率是 f(i)f(i)f(i)，那么有 f(i)=aisxf(i)=\\frac{a_i}{s_x}f(i)=sx​ai​​，归纳证明如下： 显然从 x+1x+1x+1 开始跳，跳一步就会停下，跳到 iii 的概率是 aisx\\frac{a_i}{s_x}sx​ai​​； 考虑从 kkk（k≥x+2k\\ge x+2k≥x+2）开始跳，设下一步跳到 p≤xp\\le xp≤x 的概率是 www，跳到 p&gt;xp&gt;xp&gt;x 的概率是 vvv。若 p≤xp\\le xp≤x 则概率就是 w×apsxw\\times \\frac{a_p}{s_x}w×sx​ap​​，否则由于 ppp 跳到 p′≤xp&#x27;\\le xp′≤x 的概率是 ap′sx\\frac{a_{p&#x27;}}{s_x}sx​ap′​​，所以 ppp 跳到 p′≤xp&#x27;\\le xp′≤x 的概率是 v×ap′sxv\\times \\frac{a_{p&#x27;}}{s_x}v×sx​ap′​​。那么最后跳到 ppp 的概率就是 w×apsx+v×apsx=apsxw\\times \\frac{a_p}{s_x}+v\\times \\frac{a_p}{s_x}=\\frac{a_p}{s_x}w×sx​ap​​+v×sx​ap​​=sx​ap​​。 那么若最后 yyy 跳到了 xxx 则 lenlca⁡(x,y)len_{\\operatorname{lca}(x,y)}lenlca(x,y)​ 就是 lenxlen_xlenx​，否则设最后跳到了 ppp 则变成求 lenlca⁡(x,p)len_{\\operatorname{lca}(x,p)}lenlca(x,p)​，可以让 xxx 不断往父亲跳解决。所以设 dpxdp_xdpx​ 表示 lenlca⁡(x,y)len_{\\operatorname{lca}(x,y)}lenlca(x,y)​（y&gt;xy&gt;xy&gt;x）的期望值，那么有转移： dpx=axsx×lenx+∑i=1x−1aisx×dpidp_{x}=\\frac{a_x}{s_x}\\times len_x+\\sum\\limits_{i=1}^{x-1} \\frac{a_i}{s_x}\\times dp_i dpx​=sx​ax​​×lenx​+i=1∑x−1​sx​ai​​×dpi​ 可以用前缀和快速求，那么做完了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout) const int S=300005,p=1000000007; int n,q,a[S],b[S]; int sm[S],len[S],dp[S]; inline int qpow(int x,int y=p-2) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } int main() { fio(&quot;name&quot;); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) sm[i]=(sm[i-1]+a[i])%p; len[1]=0; for(int i=2,val=1ll*a[1]*b[1]%p;i&lt;=n;i++) { len[i]=(1ll*val*qpow(sm[i-1])%p+b[i])%p; val=(val+1ll*a[i]*(len[i]+b[i])%p)%p; } dp[1]=0; for(int i=2,val=0;i&lt;=n;i++) { dp[i]=1ll*(val+1ll*a[i]*len[i]%p)*qpow(sm[i])%p; val=(val+1ll*a[i]*dp[i]%p)%p; } while(q--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x==y) { puts(&quot;0&quot;); continue; } if(x&gt;y) swap(x,y); printf(&quot;%d\\n&quot;,((len[x]+len[y])%p-2ll*dp[x]%p+p)%p); } return 0; } ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 25】名字 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-25-ming-zi-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":324000,"words":1009,"minutes":6},"date":"2023-04-08 08:49:37","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>定义：</p>\n</blockquote>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mo>(</mo><mn>102</mn><msup><mn>3</mn><mi>i</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>)</mo><mtext> </mtext><mi>x</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mo>(</mo><mn>102</mn><msup><mn>5</mn><mi>i</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">A_i=(1023^i\\ mod\\ 10^9)\\ xor\\ (1025^i\\ mod\\ 10^9)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1246639999999999em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8746639999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span></span></span></span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\"> </span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8746639999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span></span></span></span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mspace\"> </span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<blockquote>\n<p>求：</p>\n</blockquote>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><msub><mi>l</mi><mn>1</mn></msub></mrow><msub><mi>r</mi><mn>1</mn></msub></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><msub><mi>l</mi><mn>2</mn></msub><mo>)</mo></mrow><msub><mi>r</mi><mn>2</mn></msub></munderover><mrow><mo fence=\"true\">{</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>⋯</mo><mi>j</mi></mrow></msub><mo>}</mo><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>{</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>⋯</mo><mi>j</mi></mrow></msub><mo>}</mo><mo fence=\"true\">}</mo></mrow></mrow><annotation encoding=\"application/x-tex\">sum=\\sum_{i=l_1}^{r_1}\\sum_{j=max(i,l_2)}^{r_2}\\left \\{ max\\{A_{i\\cdots j}\\}-min\\{A_{i\\cdots j}\\} \\right \\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.1785020000000004em;vertical-align:-1.5160049999999998em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6624970000000003em;\"><span style=\"top:-1.847887em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.311105em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.402213em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6624970000000006em;\"><span style=\"top:-1.8089950000000001em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\">m</span><span class=\"mord mathdefault mtight\">a</span><span class=\"mord mathdefault mtight\">x</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.311105em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5160049999999998em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">{</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"minner mtight\">⋯</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"minner mtight\">⋯</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mclose delimcenter\" style=\"top:0em;\">}</span></span></span></span></span></span></p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> 组询问。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>t</mi><mo>≤</mo><mn>40000</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><msub><mi>L</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>R</mi><mn>1</mn></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><msub><mi>L</mi><mn>2</mn></msub><mo>≤</mo><msub><mi>R</mi><mn>2</mn></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le t\\le 40000,1\\le L_1\\le R_1\\le10^5,1\\le L_2\\le R_2\\le10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">4</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 定义： Ai=(1023i mod 109) xor (1025i mod 109)A_i=(1023^i\\ mod\\ 10^9)\\ xor\\ (1025^i\\ mod\\ 10^9) Ai​=(1023i mod 109) xor (1025i mod 109) 求： sum=∑i=l1r1∑j=max(i,l2)r2{max{Ai⋯j}−min{Ai⋯j}}sum=\\sum_{i=l_1}^{r_1}\\sum_{j=max(i,l_2)}^{r_2}\\left \\{ max\\{A_{i\\cdots j}\\}-min\\{A_{i\\cdots j}\\} \\right \\} sum=i=l1​∑r1​​j=max(i,l2​)∑r2​​{max{Ai⋯j​}−min{Ai⋯j​}} ttt 组询问。 1≤t≤40000,1≤L1≤R1≤105,1≤L2≤R2≤1051\\le t\\le 40000,1\\le L_1\\le R_1\\le10^5,1\\le L_2\\le R_2\\le10^51≤t≤40000,1≤L1​≤R1​≤105,1≤L2​≤R2​≤105。 洛谷原题 在线算法，瓶颈在建出 ST 表，时间复杂度 O(nlog⁡n+q)O(n\\log n+q)O(nlogn+q)，吊打所有奇奇怪怪数据结构做法。 首先有： ∑l=l1r1∑r=max⁡(l,l2)r2{max⁡{A[l,r]}−min⁡{A[l,r]}}=∑l=l1r1∑r=max⁡(l,l2)r2max⁡{A[l,r]}−∑l=l1r1∑r=max⁡(l,l2)r2min⁡{A[l,r]}=∑l=l1r1∑r=max⁡(l,l2)r2max⁡{A[l,r]}+∑l=l1r1∑r=max⁡(l,l2)r2max⁡{−A[l,r]}\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\{\\max\\{A_{[l,r]}\\}-\\min\\{A_{[l,r]}\\}\\}\\\\ =\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\max\\{A_{[l,r]}\\}-\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\min\\{A_{[l,r]}\\}\\\\ =\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\max\\{A_{[l,r]}\\}+\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\max\\{-A_{[l,r]}\\} l=l1​∑r1​​r=max(l,l2​)∑r2​​{max{A[l,r]​}−min{A[l,r]​}}=l=l1​∑r1​​r=max(l,l2​)∑r2​​max{A[l,r]​}−l=l1​∑r1​​r=max(l,l2​)∑r2​​min{A[l,r]​}=l=l1​∑r1​​r=max(l,l2​)∑r2​​max{A[l,r]​}+l=l1​∑r1​​r=max(l,l2​)∑r2​​max{−A[l,r]​} 那么只需要会求 ∑l=l1r1∑r=max⁡(l,l2)r2max⁡{A[l,r]}\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\max\\{A_{[l,r]}\\}l=l1​∑r1​​r=max(l,l2​)∑r2​​max{A[l,r]​} 就行了，记 f(L,R)=∑[l,r]⊆[L,R]max⁡{A[l,r]}f(L,R)=\\sum\\limits_{[l,r]\\subseteq [L,R]}\\max\\{A_{[l,r]}\\}f(L,R)=[l,r]⊆[L,R]∑​max{A[l,r]​} 并且由于 ∑l=l1r1∑r=max⁡(l,l2)r2max⁡{A[l,r]}=f(l1,r2)−f(l1,l2−1)−f(r1+1,r2)+f(r1+1,l2−1)\\sum\\limits_{l=l_1}^{r_1}\\sum\\limits_{r=\\max(l,l_2)}^{r_2}\\max\\{A_{[l,r]}\\}=f(l_1,r_2)-f(l_1,l_2-1)-f(r_1+1,r_2)+f(r_1+1,l_2-1)l=l1​∑r1​​r=max(l,l2​)∑r2​​max{A[l,r]​}=f(l1​,r2​)−f(l1​,l2​−1)−f(r1​+1,r2​)+f(r1​+1,l2​−1)，所以只要会求 f(L,R)f(L,R)f(L,R) 就行了。 考虑怎么求解 f(L,R)f(L,R)f(L,R)，考虑 [L,R][L,R][L,R] 中最左边的最大值的位置 ppp，它的地位是无法撼动的，所有包含 ppp 的区间最大值都是 ApA_pAp​，所以它的贡献为 (p−L+1)(R−p+1)Ap(p-L+1)(R-p+1)A_p(p−L+1)(R−p+1)Ap​。 除去包含 ppp 的区间后，只剩下 [l,r]⊆[L,p−1][l,r]\\subseteq [L,p-1][l,r]⊆[L,p−1] 和 [l,r]⊆[p+1,R][l,r]\\subseteq [p+1,R][l,r]⊆[p+1,R] 的区间了。 考虑求 [l,r]⊆[p+1,R][l,r]\\subseteq [p+1,R][l,r]⊆[p+1,R] 的贡献，设 dpi,jdp_{i,j}dpi,j​ 为 r=j,l∈[i,j]r=j,l\\in[i,j]r=j,l∈[i,j] 的 [l,r][l,r][l,r] 的贡献，设 A0=∞,pmxi=max⁡0≤j&lt;i,Aj≥AijA_0=\\infin,pmx_i=\\max\\limits_{0\\le j&lt;i,A_j\\ge A_i} jA0​=∞,pmxi​=0≤j&lt;i,Aj​≥Ai​max​j，那么有转移 dpi,j=dpi,pmxi+(j−pmxi)Ajdp_{i,j}=dp_{i,pmx_i}+(j-pmx_i)A_jdpi,j​=dpi,pmxi​​+(j−pmxi​)Aj​，[l,r]⊆[p+1,R][l,r]\\subseteq [p+1,R][l,r]⊆[p+1,R] 的贡献显然即为 ∑i=p+1Rdpp+1,i\\sum\\limits_{i=p+1}^R dp_{p+1,i}i=p+1∑R​dpp+1,i​。 观察到由于 ApA_pAp​ 是 A[L,R]A_{[L,R]}A[L,R]​ 中的最大值，所以把 ∑i=p+1Rdpp+1,i=∑i=p+1Rdp1,i−dp1,p=−(R−p)dp1,p+∑i=p+1Rdp1,i\\sum\\limits_{i=p+1}^R dp_{p+1,i}=\\sum\\limits_{i=p+1}^Rdp_{1,i}-dp_{1,p}=-(R-p) dp_{1,p}+\\sum\\limits_{i=p+1}^Rdp_{1,i}i=p+1∑R​dpp+1,i​=i=p+1∑R​dp1,i​−dp1,p​=−(R−p)dp1,p​+i=p+1∑R​dp1,i​，那么预处理出 dp1,idp_{1,i}dp1,i​ 和它的前缀和即可。 [l,r]⊆[L,p−1][l,r]\\subseteq [L,p-1][l,r]⊆[L,p−1] 的贡献也差不多，倒着求一遍 dpdpdp 即可。 用单调栈求 dp1,idp_{1,i}dp1,i​ 和前缀和的时间复杂度是 O(n)O(n)O(n) 的，预处理 ST 表的时间复杂度是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，两个东西查询都是 O(1)O(1)O(1) 的，所以时间复杂度为 O(nlog⁡n+q)O(n\\log n+q)O(nlogn+q)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout) const int S=100005,p=1000000000; int n,a[S]; int top1,top2,sta1[S],sta2[S]; int pmn[S],pmx[S],smn[S],smx[S]; long long fmn[S],fmx[S],gmn[S],gmx[S]; long long sfmn[S],sfmx[S],sgmn[S],sgmx[S]; int mylog[S],mn[S][25],mx[S][25]; inline int quemn(int l,int r) { int k=mylog[r-l+1]; return a[mn[l][k]]&lt;a[mn[r-(1&lt;&lt;k)+1][k]]?mn[l][k]:mn[r-(1&lt;&lt;k)+1][k]; } inline int quemx(int l,int r) { int k=mylog[r-l+1]; return a[mx[l][k]]&gt;a[mx[r-(1&lt;&lt;k)+1][k]]?mx[l][k]:mx[r-(1&lt;&lt;k)+1][k]; } inline void slove(int l,int r,long long &amp;mns,long long &amp;mxs,int p) { int mnp=quemn(l,r); mns+=1ll*p*a[mnp]*(mnp-l+1)*(r-mnp+1); mns+=1ll*p*((sgmn[mnp-1]-sgmn[l-1]-gmn[mnp]*(mnp-l))+(sfmn[r]-sfmn[mnp]-fmn[mnp]*(r-mnp))); int mxp=quemx(l,r); mxs+=1ll*p*a[mxp]*(mxp-l+1)*(r-mxp+1); mxs+=1ll*p*((sgmx[mxp-1]-sgmx[l-1]-gmx[mxp]*(mxp-l))+(sfmx[r]-sfmx[mxp]-fmx[mxp]*(r-mxp))); } int main() { fio(&quot;c&quot;); n=100000; for(int i=1,pw1=1023,pw2=1025;i&lt;=n;i++) { a[i]=pw1^pw2; pw1=1ll*pw1*1023%p,pw2=1ll*pw2*1025%p; } for(int i=1;i&lt;=n;i++) { while(top1&gt;0&amp;&amp;a[sta1[top1]]&gt;a[i]) top1--; while(top2&gt;0&amp;&amp;a[sta2[top2]]&lt;a[i]) top2--; pmn[i]=sta1[top1],pmx[i]=sta2[top2]; sta1[++top1]=sta2[++top2]=i; } sta1[top1=0]=sta2[top2=0]=n+1; for(int i=n;i&gt;=1;i--) { while(top1&gt;0&amp;&amp;a[sta1[top1]]&gt;a[i]) top1--; while(top2&gt;0&amp;&amp;a[sta2[top2]]&lt;a[i]) top2--; smn[i]=sta1[top1],smx[i]=sta2[top2]; sta1[++top1]=sta2[++top2]=i; } for(int i=1;i&lt;=n;i++) fmn[i]=fmn[pmn[i]]+1ll*a[i]*(i-pmn[i]),fmx[i]=fmx[pmx[i]]+1ll*a[i]*(i-pmx[i]); for(int i=n;i&gt;=1;i--) gmn[i]=gmn[smn[i]]+1ll*a[i]*(smn[i]-i),gmx[i]=gmx[smx[i]]+1ll*a[i]*(smx[i]-i); for(int i=1;i&lt;=n;i++) sfmn[i]=sfmn[i-1]+fmn[i],sfmx[i]=sfmx[i-1]+fmx[i]; for(int i=1;i&lt;=n;i++) sgmn[i]=sgmn[i-1]+gmn[i],sgmx[i]=sgmx[i-1]+gmx[i]; mylog[0]=-1; for(int i=1;i&lt;=n;i++) mylog[i]=mylog[i&gt;&gt;1]+1,mn[i][0]=mx[i][0]=i; for(int j=1;j&lt;=mylog[n];j++) { for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++) { mn[i][j]=a[mn[i][j-1]]&lt;a[mn[i+(1&lt;&lt;j-1)][j-1]]?mn[i][j-1]:mn[i+(1&lt;&lt;j-1)][j-1]; mx[i][j]=a[mx[i][j-1]]&gt;a[mx[i+(1&lt;&lt;j-1)][j-1]]?mx[i][j-1]:mx[i+(1&lt;&lt;j-1)][j-1]; } } int q; scanf(&quot;%d&quot;,&amp;q); while(q--) { int l1,r1,l2,r2; scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2); if(l1&gt;r2) { puts(&quot;0&quot;); continue; } long long mns=0,mxs=0; slove(l1,r2,mns,mxs,1); if(l1&lt;l2) slove(l1,l2-1,mns,mxs,-1); if(r1&lt;r2) slove(r1+1,r2,mns,mxs,-1); if(r1&lt;l2-1) slove(r1+1,l2-1,mns,mxs,1); printf(&quot;%lld\\n&quot;,mxs-mns); } return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"【2022 NOIP 模拟赛 24】求和 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-24-qiu-he-zuo-ti-ji-lu/","stats":{"text":"11 min read","time":636000,"words":1812,"minutes":11},"date":"2023-04-08 08:45:34","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>Byteland 的选民们要进行总统选举。一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 位选民和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 位候选人，编号分别从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 。</p>\n<p>每位选民有一个<strong>非空</strong>的喜欢的候选人的列表，这个列表是按照喜欢程度排序的。比如说一位选民的列表是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>7</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{2,4,7\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">7</span><span class=\"mclose\">}</span></span></span></span> ，那么他最喜欢的候选人是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 号候选人，次喜欢的是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span></span></span></span> 号候选人，再次是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 号候选人，其余候选人都不喜欢。</p>\n<p>选举会进行若干轮，具体规则如下：</p>\n<ul>\n<li>每一轮，每位选民会投给某位在自己列表中的候选人恰好一票。</li>\n<li>第一轮，每位选民会投给自己最喜欢的候选人。</li>\n<li>从第二轮开始，每位选民会投给<strong>自己列表</strong>中<strong>上一轮</strong>票数最多的候选人。如果有多位在列表中的候选人票数都是 最多的，那么会投给<strong>这些人</strong>中最喜欢的那一位（即按照票数为第一关键字，喜欢程度为第二关键字排序）。</li>\n<li>如果每位选民在第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 轮 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>&gt;</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i\\gt 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 投给的候选人都和在第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 轮投给的候选人一样，那么选举会在第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 轮结束后停止，并且 <strong>random</strong> 一位候选人作为总统。</li>\n</ul>\n<p>聪明的你一定发现了这个选举没有什么蛋用，但是你只关心选举进行的轮数。</p>\n<p>你需要构造出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 和每一位选民的喜欢的候选人的列表，使得最终选举进行的轮数尽可能多。</p>\n<p>你还需要保证 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le m&lt;n\\leq 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，所有人的喜欢的候选人的列表大小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 之和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\leq 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" Byteland 的选民们要进行总统选举。一共有 nnn 位选民和 mmm 位候选人，编号分别从 111 到 nnn 和从 111 到 mmm 。 每位选民有一个非空的喜欢的候选人的列表，这个列表是按照喜欢程度排序的。比如说一位选民的列表是 {2,4,7}\\{2,4,7\\}{2,4,7} ，那么他最喜欢的候选人是 222 号候选人，次喜欢的是 444 号候选人，再次是 777 号候选人，其余候选人都不喜欢。 选举会进行若干轮，具体规则如下： 每一轮，每位选民会投给某位在自己列表中的候选人恰好一票。 第一轮，每位选民会投给自己最喜欢的候选人。 从第二轮开始，每位选民会投给自己列表中上一轮票数最多的候选人。如果有多位在列表中的候选人票数都是 最多的，那么会投给这些人中最喜欢的那一位（即按照票数为第一关键字，喜欢程度为第二关键字排序）。 如果每位选民在第 iii 轮 (i&gt;1)(i\\gt 1)(i&gt;1) 投给的候选人都和在第 i−1i-1i−1 轮投给的候选人一样，那么选举会在第 iii 轮结束后停止，并且 random 一位候选人作为总统。 聪明的你一定发现了这个选举没有什么蛋用，但是你只关心选举进行的轮数。 你需要构造出 n,mn,mn,m 和每一位选民的喜欢的候选人的列表，使得最终选举进行的轮数尽可能多。 你还需要保证 1≤m&lt;n≤10001\\le m&lt;n\\leq 10001≤m&lt;n≤1000，所有人的喜欢的候选人的列表大小 kkk 之和 ≤105\\leq 10^5≤105。 猜测每个点的列表不会很长（因为太长不好构造），那么尝试构造 k≤2k\\le 2k≤2 的答案。这时每个 k=2k=2k=2 的选民都可以看成一条边，候选人则可以看成点，不妨规定每条边出发的点优先级低于指向的点。 不难发现投票的过程相当于是「上一轮最多票的人」不断改变，那么考虑构造一条链，让「上一轮最多票的人」在这条链上一个一个点地跳，先来考虑有 222 个点的情况，显然可以这样构造：（没有出发点的边是 k=1k=1k=1 的选民） 若这样构造「上一轮的票」会这样变化： [0,0]→[3,0]→[3,0][0,0]\\to[3,0]\\to[3,0] [0,0]→[3,0]→[3,0] 共变化 333 轮。 考虑 444 个点的情况： 若这样构造「上一轮的票」会这样变化： [0,0,0,0]→[2,2,3,0]→[2,1,4,0]→[3,0,4,0]→[3,0,4,0][0,0,0,0]\\to[2,2,3,0]\\to[2,1,4,0]\\to [3,0,4,0]\\to [3,0,4,0] [0,0,0,0]→[2,2,3,0]→[2,1,4,0]→[3,0,4,0]→[3,0,4,0] 共变化 555 轮。 不难发现，这样构造刚开始「上一轮的票」是 [2,2,2,…,2,2,3,0][2,2,2,\\dots,2,2,3,0][2,2,2,…,2,2,3,0] 这样的，两轮后变成了 [2,2,2,…,3,0,4,0][2,2,2,\\dots,3,0,4,0][2,2,2,…,3,0,4,0]，333 往前移动了两个点，并且后面的点对前面的点和总轮数没有任何影响，所以这样构造的总轮数是 m+1m+1m+1。 不难发现，若有 mmm 个点就会有 2m−12m-12m−1 条边，所以最多可以有 500500500 个点，总轮数为 501501501，足以通过本题。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int main() { freopen(&quot;t.out&quot;,&quot;w&quot;,stdout); int k=250-1; printf(&quot;%d %d\\n&quot;,k*4+3,(k+1)*2); for(int i=1;i&lt;=k;i++) { printf(&quot;1 %d\\n&quot;,i*2-1); printf(&quot;1 %d\\n&quot;,i*2-1); printf(&quot;2 %d %d\\n&quot;,i*2,i*2-1); printf(&quot;2 %d %d\\n&quot;,i*2,i*2+1); } printf(&quot;1 %d\\n&quot;,(k+1)*2-1); printf(&quot;1 %d\\n&quot;,(k+1)*2-1); printf(&quot;2 %d %d\\n&quot;,(k+1)*2-1,(k+1)*2); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022 NOIP 模拟赛 22】选举 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-22-xuan-ju-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":269000,"words":1051,"minutes":5},"date":"2023-04-08 08:44:05","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>给一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的树，构造 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 条线段，要求每个端点都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 中的整数且不重复，并使得两个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 在树上有边，当且仅当线段 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 相交且不包含。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 5 \\cdot 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给一棵 nnn 个点的树，构造 nnn 条线段，要求每个端点都是 [1,2n][1,2n][1,2n] 中的整数且不重复，并使得两个点 i,ji,ji,j 在树上有边，当且仅当线段 i,ji,ji,j 相交且不包含。 1≤n≤5⋅1051 \\le n \\le 5 \\cdot 10^51≤n≤5⋅105。 不难发现两个区间相交但不包含只有两种情况：xxx 在 yyy 左边或者 yyy 在 xxx 左边，那么不妨钦定 uuu 的区间在它父亲 fafafa 的区间右边和 fafafa 的区间相交，在左边和它儿子 vvv 的区间相交，构造这样的东西：（红框是递归构造下去的儿子的子树） 这样递归构造一定是合法的，设节点 uuu 的儿子个数为 sonuson_usonu​，那么 uuu 的区间除去属于它父亲和兄弟的部分后长度只有 sonu+1son_u+1sonu​+1，刚好够连接 uuu 的所有儿子，所以没有任何位置浪费。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005; int n; int esum,to[S],nxt[S],h[S]; int rig,l[S],r[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u,int fa) { int cnt=0; for(int i=h[u];i;i=nxt[i]) cnt+=to[i]!=fa; rig=r[u]=rig+cnt+1; int lft=rig; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; l[v]=--lft; dfs(v,u); } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } rig=l[1]=1; dfs(1,0); for(int i=1;i&lt;=n;i++) printf(&quot;%d %d\\n&quot;,l[i],r[i]); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1278E Tests for problem D 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1278e-tests-for-problem-d-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":119000,"words":415,"minutes":2},"date":"2023-04-08 08:42:26","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>给定奇数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 和长度分别为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 包含所有整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\leq i\\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 是给定的单调不减的序列。</p>\n<p>现在你可以进行零次或若干次操作，每次操作选择序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个整数，然后删除这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数里除了他们的中位数的其他 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(k-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 个数。</p>\n<p>求能否通过零次或若干次操作从序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的到序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>。能就输出 <code>YES</code>，不能输出 <code>NO</code>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">;</mo><mn>3</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">;</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">3\\leq n\\leq 2\\times 10^5;3\\leq k\\leq n;1\\leq m&lt;n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>b</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>b</mi><mn>2</mn></msub><mo>&lt;</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>&lt;</mo><msub><mi>b</mi><mi>m</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\leq b_1&lt;b_2&lt;...&lt;b_m\\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定奇数 kkk 和长度分别为 n,mn,mn,m 的序列 a,ba,ba,b，序列 aaa 包含所有整数 iii 满足 1≤i≤n1\\leq i\\leq n1≤i≤n，bbb 是给定的单调不减的序列。 现在你可以进行零次或若干次操作，每次操作选择序列 aaa 的 kkk 个整数，然后删除这 kkk 个数里除了他们的中位数的其他 (k−1)(k-1)(k−1) 个数。 求能否通过零次或若干次操作从序列 aaa 的到序列 bbb。能就输出 YES，不能输出 NO。 3≤n≤2×105;3≤k≤n;1≤m&lt;n3\\leq n\\leq 2\\times 10^5;3\\leq k\\leq n;1\\leq m&lt;n3≤n≤2×105;3≤k≤n;1≤m&lt;n，1≤b1&lt;b2&lt;...&lt;bm≤n1\\leq b_1&lt;b_2&lt;...&lt;b_m\\leq n1≤b1​&lt;b2​&lt;...&lt;bm​≤n。 遇到这种操作题，可以先考虑无解，然后想最后几次操作的情况，不要想太复杂。 首先若由于每次操作都会删掉 k−1k-1k−1 个数，所以 n−m≡0(modk−1)n-m\\not\\equiv 0\\pmod{k-1}n−m​≡0(modk−1) 一定无解。 考虑最后一次操作，不难发现，中位数一定是最后某个要留下的数，这个数左边和右边都要有 k−12\\frac{k-1}{2}2k−1​ 个要删掉的数。除了这 k−1k-1k−1 个要删掉的数，其它要删掉的数都可以乱删，由于 n−m≡0(modk−1)n-m\\equiv 0\\pmod{k-1}n−m≡0(modk−1)，所以可以让其它要删掉的数内部自己匹配。 那么只要找到某个最后要留下的数且这个数两边都至少有 k−12\\frac{k-1}{2}2k−1​ 个要删除的数即有解，否则无解。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=200005; int n,k,m; int b[S],cnt[S]; int pre[S],suf[S]; inline void slove() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); if((n-m)%(k-1)!=0) return void(puts(&quot;NO&quot;)); b[0]=0,b[m+1]=n+1; for(int i=1;i&lt;=m+1;i++) cnt[i]=b[i]-b[i-1]-1; pre[0]=suf[m+2]=0; for(int i=1;i&lt;=m+1;i++) pre[i]=pre[i-1]+cnt[i]; for(int i=m+1;i&gt;=1;i--) suf[i]=suf[i+1]+cnt[i]; bool f=false; for(int i=1;i&lt;=m;i++) { int lft=pre[i],rig=suf[i+1]; if(lft&gt;=(k-1)/2&amp;&amp;rig&gt;=(k-1)/2) return void(puts(&quot;YES&quot;)); } puts(&quot;NO&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1468H K and Medians 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1468h-k-and-medians-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":188000,"words":638,"minutes":4},"date":"2023-04-08 08:06:56","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>给出长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> 的两个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[0,2^k-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8081799999999999em;vertical-align:-0.3776199999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34479999999999994em;\"><span style=\"top:-2.49738em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">0</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7820285714285713em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3776199999999999em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b_{[0,2^k-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0720599999999998em;vertical-align:-0.3776199999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34479999999999994em;\"><span style=\"top:-2.49738em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">0</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7820285714285713em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3776199999999999em;\"><span></span></span></span></span></span></span></span></span></span>，求一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">c_{[0,2^k-1]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8081799999999999em;vertical-align:-0.3776199999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34479999999999994em;\"><span style=\"top:-2.49738em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">0</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7820285714285713em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3776199999999999em;\"><span></span></span></span></span></span></span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>=</mo><msub><mi>max</mi><mo>⁡</mo><mrow><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mi>j</mi><mo>=</mo><mi>p</mi></mrow></msub><mo>{</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>j</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">c_p=\\max\\limits_{i|j=p}\\{a_i+b_j\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.716em;vertical-align:-0.966em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43055999999999994em;\"><span style=\"top:-2.009em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mord mtight\">∣</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\">p</span></span></span></span><span style=\"top:-2.7em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span><span class=\"mop\">max</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.966em;\"><span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le 17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span></span></span></span>。</p>\n</blockquote>\n","content":" 给出长度为 2k2^k2k 的两个序列 a[0,2k−1]a_{[0,2^k-1]}a[0,2k−1]​ 和 b[0,2k−1]b_{[0,2^k-1]}b[0,2k−1]​，求一个长度为 2k2^k2k 的序列 c[0,2k−1]c_{[0,2^k-1]}c[0,2k−1]​，满足 cp=max⁡i∣j=p{ai+bj}c_p=\\max\\limits_{i|j=p}\\{a_i+b_j\\}cp​=i∣j=pmax​{ai​+bj​}。 1≤k≤171\\le k\\le 171≤k≤17。 考虑枚举 iii，不难发现，iii 为 111 的二进制位 jjj 都能随便选。那么只要用某种方法求出 mxxmx_xmxx​ 表示 iii 为 111 的二进制位可以乱选且其他二进制位和 xxx 一致的 jjj 中最大的 bjb_jbj​，就可以更新 ci∣xc_{i|x}ci∣x​。 不难发现，只要在枚举 iii 的第 ppp 位为 111 时，枚举 iii 的补集的子集 jjj，令 mxj∣i→max⁡(mxj∣i,mxj∣i−2p)mx_{j|i}\\to \\max(mx_{j|i},mx_{j|i-2^p})mxj∣i​→max(mxj∣i​,mxj∣i−2p​) 即让这一位为 111 的 mxmxmx 加上这一位为 000 的 mxmxmx 的贡献就可以快速维护 mxmxmx。 维护 mxmxmx 的时间复杂度是 O(3k)O(3^k)O(3k) 的，更新答案的时间复杂度也是 O(3k)O(3^k)O(3k) 的，足以通过此题。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=300005; int k,n; long long a[S],b[S]; long long mx[20][S],ans[S]; void slove(int pos,int cnt,int sta) { int inv=n-1^sta; if(pos==k) { for(int T=inv;;T=inv&amp;(T-1)) { ans[T|sta]=max(ans[T|sta],a[sta]+mx[cnt][T|sta]); if(T==0) break; } return; } slove(pos+1,cnt,sta); sta|=1&lt;&lt;pos; inv=n-1^sta; for(int T=inv;;T=inv&amp;(T-1)) { mx[cnt+1][T|sta]=max(mx[cnt][T|sta],mx[cnt][T|sta^(1&lt;&lt;pos)]); if(T==0) break; } slove(pos+1,cnt+1,sta); } int main() { scanf(&quot;%d&quot;,&amp;k); n=1&lt;&lt;k; for(int i=0;i&lt;=n-1;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=0;i&lt;=n-1;i++) scanf(&quot;%lld&quot;,&amp;b[i]),mx[1][i]=b[i]; slove(0,1,0); for(int i=0;i&lt;=n-1;i++) printf(&quot;%lld &quot;,ans[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 19】卷积之王 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-19-juan-ji-zhi-wang-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":161000,"words":507,"minutes":3},"date":"2023-04-08 08:04:57","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人，等概率随机一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列作为他们的编号。每两个人都会进行且仅进行一场比赛，编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的两个人（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i&lt;j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>）比赛时，编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的人有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 的概率获胜，编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的人有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">1-p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 的概率获胜。</p>\n<p>设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> 表示能把这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人分成两个集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo separator=\"true\">,</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">S,T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi>k</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∣</mi><mi>T</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">|S|=k,|T|=n-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 且对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi><mo>∈</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">u\\in S,v\\in T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 比赛都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 获胜的概率。</p>\n<p>设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">g(1)=1,g(i)=g(i-1)^2+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>，你需要求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>f</mi><mo>(</mo><mi>k</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>k</mi><mo>)</mo><mi mathvariant=\"normal\">mod</mi><mo>⁡</mo><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{k=1}^{n-1}f(k)g(k)\\operatorname{mod}998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.503226em;vertical-align:-1.002113em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5011130000000001em;\"><span style=\"top:-2.097887em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.000005em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.002113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0&lt;p&lt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个人，等概率随机一个 nnn 的排列作为他们的编号。每两个人都会进行且仅进行一场比赛，编号为 i,ji,ji,j 的两个人（i&lt;ji&lt;ji&lt;j）比赛时，编号为 iii 的人有 ppp 的概率获胜，编号为 jjj 的人有 1−p1-p1−p 的概率获胜。 设 f(k)f(k)f(k) 表示能把这 nnn 个人分成两个集合 S,TS,TS,T 满足 ∣S∣=k,∣T∣=n−k|S|=k,|T|=n-k∣S∣=k,∣T∣=n−k 且对于所有 u∈S,v∈Tu\\in S,v\\in Tu∈S,v∈T，uuu 和 vvv 比赛都是 uuu 获胜的概率。 设 g(1)=1,g(i)=g(i−1)2+2g(1)=1,g(i)=g(i-1)^2+2g(1)=1,g(i)=g(i−1)2+2，你需要求出 ∑k=1n−1f(k)g(k)mod⁡998244353\\sum\\limits_{k=1}^{n-1}f(k)g(k)\\operatorname{mod}998244353k=1∑n−1​f(k)g(k)mod998244353。 2≤n≤1062\\le n\\le 10^62≤n≤106，0&lt;p&lt;10&lt;p&lt;10&lt;p&lt;1。 首先易证明若能选出 kkk 个人做胜者，那么这 kkk 个人的集合一定是唯一的。 那么设 fn,kf_{n,k}fn,k​ 表示 nnn 个人中能选出 kkk 个人做胜者的概率，那么考虑编号为 nnn 的人被分到哪一组，有： fn,k=fn−1,k−1×pn−k+fn−1,k×qkf_{n,k}=f_{n-1,k-1}\\times p^{n-k}+f_{n-1,k}\\times q^{k} fn,k​=fn−1,k−1​×pn−k+fn−1,k​×qk 其中 q=1−pq=1-pq=1−p。 换一个角度，考虑编号为 111 的人被分到哪一组，有： fn,k=fn−1,k−1×qn−k+fn−1,k×pkf_{n,k}=f_{n-1,k-1}\\times q^{n-k}+f_{n-1,k}\\times p^{k} fn,k​=fn−1,k−1​×qn−k+fn−1,k​×pk 那么有： fn−1,k−1×pn−k+fn−1,k×qk=fn−1,k−1×qn−k+fn−1,k×pkfn−1,k−1×(pn−k−qn−k)=fn−1,k×(pk−qk)fn−1,k−1×pn−k−qn−kpk−qk=fn−1,kfn−1,k=∏i=1kpn−i−qn−ipi−qifn,k=∏i=1kpn+1−i−qn+1−ipi−qif_{n-1,k-1}\\times p^{n-k}+f_{n-1,k}\\times q^{k}=f_{n-1,k-1}\\times q^{n-k}+f_{n-1,k}\\times p^{k}\\\\ f_{n-1,k-1}\\times (p^{n-k}-q^{n-k})=f_{n-1,k}\\times (p^{k}-q^{k})\\\\ f_{n-1,k-1}\\times \\frac{p^{n-k}-q^{n-k}}{p^{k}-q^{k}}=f_{n-1,k}\\\\ f_{n-1,k}=\\prod\\limits_{i=1}^{k}\\frac{p^{n-i}-q^{n-i}}{p^{i}-q^{i}}\\\\ f_{n,k}=\\prod\\limits_{i=1}^{k}\\frac{p^{n+1-i}-q^{n+1-i}}{p^{i}-q^{i}}\\\\ fn−1,k−1​×pn−k+fn−1,k​×qk=fn−1,k−1​×qn−k+fn−1,k​×pkfn−1,k−1​×(pn−k−qn−k)=fn−1,k​×(pk−qk)fn−1,k−1​×pk−qkpn−k−qn−k​=fn−1,k​fn−1,k​=i=1∏k​pi−qipn−i−qn−i​fn,k​=i=1∏k​pi−qipn+1−i−qn+1−i​ 这样就可以 O(nlog⁡n)O(n\\log n)O(nlogn) 递推出 fn,[1,n−1]f_{n,[1,n-1]}fn,[1,n−1]​，求出答案了。 但是有个特殊情况，当 p=12p=\\frac{1}{2}p=21​ 时，分母为 000，无法计算，所以需要额外讨论。 不难发现 p=12p=\\frac{1}{2}p=21​ 时，编号的大小关系对比赛结果没有任何影响，所以有 fn,k=(nk)×12k(n−k)f_{n,k}=\\binom{n}{k}\\times\\frac{1}{2^{k(n-k)}}fn,k​=(kn​)×2k(n−k)1​。 那么这题就真的做完了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout) const int S=1000005,p=998244353; int n,P,Q; int fra[S],inv[S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } inline int C(int n,int m) { return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } int main() { fio(&quot;contest&quot;); scanf(&quot;%d&quot;,&amp;n); int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); P=1ll*a*qpow(b,p-2)%p,Q=(1-P+p)%p; if(P!=Q) { int g=1,f=1,ans=0; for(int i=1;i&lt;=n-1;i++) { int up=(qpow(P,n+1-i)-qpow(Q,n+1-i)+p)%p; int dwn=(qpow(P,i)-qpow(Q,i)+p)%p; f=1ll*f*up%p*qpow(dwn,p-2)%p; ans=(ans+1ll*f*g%p)%p; g=(1ll*g*g%p+2)%p; } printf(&quot;%d\\n&quot;,ans); } else { fra[0]=1; for(int i=1;i&lt;=n;i++) fra[i]=1ll*fra[i-1]*i%p; inv[n]=qpow(fra[n],p-2); for(int i=n;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; int g=1,ans=0; for(int i=1;i&lt;=n-1;i++) { ans=(ans+1ll*C(n,i)*qpow(qpow(2,1ll*i*(n-i)%(p-2))%p,p-2)*g%p)%p; g=(1ll*g*g%p+2)%p; } printf(&quot;%d\\n&quot;,ans); } return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 18】比赛 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-18-bi-sai-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":376000,"words":1129,"minutes":7},"date":"2023-04-08 08:02:27","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>有一颗 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的树 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 种冰淇淋，树上的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个节点有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 个冰淇淋，且所有相同种类的冰淇淋在树上构成了一个联通块。</p>\n<p>构造一个新的图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> ，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个节点，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 中的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u,v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 之间有边，当且仅当存在至少一个在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 上的节点满足他同时有第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 种和第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 种冰淇淋。</p>\n<p>你的任务是用尽可能少的颜色种类数给 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 的每一个节点染色，使得没有两个相邻的节点有相同的颜色，要求输出方案。</p>\n<p>注意空的点集也被认为是一个联通块。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 3\\times 10^{5}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>s</mi><mi>i</mi></msub><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le s_{i}\\le 3\\times 10^{5}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><msub><mi>s</mi><mi>i</mi></msub><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\sum s_i\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一颗 nnn 个节点的树 TTT 和 mmm 种冰淇淋，树上的第 iii 个节点有 sis_isi​ 个冰淇淋，且所有相同种类的冰淇淋在树上构成了一个联通块。 构造一个新的图 GGG ，GGG 有 mmm 个节点，GGG 中的 u,vu,vu,v 之间有边，当且仅当存在至少一个在 TTT 上的节点满足他同时有第 uuu 种和第 vvv 种冰淇淋。 你的任务是用尽可能少的颜色种类数给 GGG 的每一个节点染色，使得没有两个相邻的节点有相同的颜色，要求输出方案。 注意空的点集也被认为是一个联通块。 1≤n,m≤3×1051\\le n,m\\le 3\\times 10^{5}1≤n,m≤3×105，0≤si≤3×1050\\le s_{i}\\le 3\\times 10^{5}0≤si​≤3×105，∑si≤5×105\\sum s_i\\le 5\\times 10^5∑si​≤5×105。 不难发现，由于每个节点上的冰淇淋种类一定构成了一张完全子图，所以颜色数量下界为 max⁡i=1nsi\\max\\limits_{i=1}^n s_ii=1maxn​si​，猜测答案一定能取到这个下界，尝试证明之。 尝试归纳证明： 首先有且仅有一个根节点的树是合法的； 考虑根节点 rtrtrt，假设它的所有儿子的子树都合法，那么因为同种冰淇淋是连通的所以两端冰淇淋颜色相同的边的两端的冰淇淋一定都在 rtrtrt 上出现过，颜色一定够用； 综上，证毕。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; const int S=1000005; int n,m,mx; vector&lt;int&gt; col[S]; int esum,to[S],nxt[S],h[S]; int ans[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u,int fa) { set&lt;int&gt; st; for(int v:col[u]) st.insert(ans[v]); int cnt=1; for(int v:col[u]) { if(ans[v]==0) { while(st.count(cnt)) cnt++; ans[v]=cnt; st.insert(cnt); } } for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mx=1; for(int i=1;i&lt;=n;i++) { int cnt; scanf(&quot;%d&quot;,&amp;cnt); mx=max(mx,cnt); while(cnt--&gt;0) { int x; scanf(&quot;%d&quot;,&amp;x); col[i].push_back(x); } } for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } dfs(1,0); printf(&quot;%d\\n&quot;,mx); for(int i=1;i&lt;=m;i++) printf(&quot;%d &quot;,ans[i]==0?1:ans[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF804C Ice cream coloring 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf804c-ice-cream-coloring-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":178000,"words":619,"minutes":3},"date":"2023-04-08 07:59:32","dateFormat":"2023-04-08"},{"abstract":"","content":"众所周知，若已知一 nnn 次多项式 f(x)f(x)f(x) 在 x={x0,x1,x2,…,xn}x=\\{x_0,x_1,x_2,\\dots,x_n\\}x={x0​,x1​,x2​,…,xn​} 这 n+1n+1n+1 个点的值 {y0,y1,y2,…,yn}\\{y_0,y_1,y_2,\\dots,y_n\\}{y0​,y1​,y2​,…,yn​}，那么就可以唯一确定这个多项式。而拉格朗日插值就是一种根据 {x0,x1,x2,…,xn}\\{x_0,x_1,x_2,\\dots,x_n\\}{x0​,x1​,x2​,…,xn​} 和 {y0,y1,y2,…,yn}\\{y_0,y_1,y_2,\\dots,y_n\\}{y0​,y1​,y2​,…,yn​} 求出 f(x)f(x)f(x) 的算法。 不难发现，若我们构造 n+1n+1n+1 个函数 f[0,n](x)f_{[0,n]}(x)f[0,n]​(x)，满足 gi(x)={1x=xi0x=xi??otherwiseg_i(x)=\\begin{cases}1&amp;x=x_i\\\\0&amp;x\\not=x_i\\\\??&amp;otherwise\\end{cases}gi​(x)=⎩⎪⎨⎪⎧​10??​x=xi​x​=xi​otherwise​，那么有 f(x)=∑i=0nyigi(x)f(x)=\\sum\\limits_{i=0}^n y_ig_i(x)f(x)=i=0∑n​yi​gi​(x)。 考虑怎么构造 gi(x)g_i(x)gi​(x)，当 x=xix\\not=x_ix​=xi​ 时 gi(x)=0g_i(x)=0gi​(x)=0 显然可以通过让 gi(x)=∏j=ix−xjg_i(x)=\\prod\\limits_{j\\not=i}x-x_jgi​(x)=j​=i∏​x−xj​，但是当 x=xix=x_ix=xi​ 时 gi(x)=∏j=ixi−xjg_i(x)=\\prod\\limits_{j\\not=i}x_i-x_jgi​(x)=j​=i∏​xi​−xj​，所以可以让这个东西除掉它，令 gi(x)=∏j=ix−xj∏j=ixi−xjg_i(x)=\\frac{\\prod\\limits_{j\\not=i}x-x_j}{\\prod\\limits_{j\\not=i}x_i-x_j}gi​(x)=j​=i∏​xi​−xj​j​=i∏​x−xj​​ 即可，这样就可以满足以上两个条件。 综上，有： f(x)=∑i=0nyigi(x)=∑i=0nyi∏j=ix−xj∏j=ixi−xj\\begin{aligned} f(x)&amp;=\\sum\\limits_{i=0}^n y_ig_i(x)\\\\ &amp;=\\sum\\limits_{i=0}^n y_i\\frac{\\prod\\limits_{j\\not=i}x-x_j}{\\prod\\limits_{j\\not=i}x_i-x_j}\\\\ \\end{aligned} f(x)​=i=0∑n​yi​gi​(x)=i=0∑n​yi​j​=i∏​xi​−xj​j​=i∏​x−xj​​​ 按照这个公式直接插值的时间复杂度是 O(n2)O(n^2)O(n2) 的。 看一道例题： 给 n+1n+1n+1 个点，请你求出经过这 n+1n+1n+1 个点的 nnn 次多项式 f(x)f(x)f(x) 在 x=kx=kx=k 时的取值，对 998244353998244353998244353 取模。 1≤n≤2×1031\\le n\\le 2\\times 10^31≤n≤2×103。 直接 O(n2)O(n^2)O(n2) 插值然后计算即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=2005,p=998244353; int n,k; int x[S],y[S]; inline int qpow(int x,int y=p-2) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); n--; for(int i=0;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); int ans=0; for(int i=0;i&lt;=n;i++) { int s1=y[i],s2=1; for(int j=0;j&lt;=n;j++) if(j!=i) s1=1ll*s1*(k-x[j])%p,s2=1ll*s2*(x[i]-x[j])%p; ans=(ans+1ll*s1*qpow(s2)%p+p)%p; } printf(&quot;%d\\n&quot;,ans); return 0; } 实际应用：求自然数幂和 fk(x)=∑i=1xikf_k(x)=\\sum\\limits_{i=1}^x i^kfk​(x)=i=1∑x​ik 首先需要证明这个东西是多项式： fk(x)=∑i=1xik=1+∑i=1x−1(i+1)k=1+∑i=1x−1∑j=0k(kj)ij=1+∑j=0k(kj)∑i=1x−1ij=∑i=1x−1ik+1+∑j=0k−1(kj)fj(x−1)\\begin{aligned} f_k(x)&amp;=\\sum\\limits_{i=1}^x i^k\\\\ &amp;=1+\\sum\\limits_{i=1}^{x-1} (i+1)^k\\\\ &amp;=1+\\sum\\limits_{i=1}^{x-1} \\sum\\limits_{j=0}^{k}\\binom{k}{j}i^j\\\\ &amp;=1+\\sum\\limits_{j=0}^{k}\\binom{k}{j} \\sum\\limits_{i=1}^{x-1}i^j\\\\ &amp;=\\sum\\limits_{i=1}^{x-1}i^k+1+\\sum\\limits_{j=0}^{k-1}\\binom{k}{j} f_{j}(x-1)\\\\ \\end{aligned} fk​(x)​=i=1∑x​ik=1+i=1∑x−1​(i+1)k=1+i=1∑x−1​j=0∑k​(jk​)ij=1+j=0∑k​(jk​)i=1∑x−1​ij=i=1∑x−1​ik+1+j=0∑k−1​(jk​)fj​(x−1)​ ∑i=1xik=∑i=1x−1ik+1+∑j=0k−1(kj)fj(x−1)xk=1+∑j=0k−1(kj)fj(x−1)xk−(kk−1)fk−1(x−1)=1+∑j=0k−2(kj)fj(x−1)(kk−1)fk−1(x−1)=xk−1−∑j=0k−2(kj)fj(x−1)fk−1(x−1)=xk−1−∑j=0k−2(kj)fj(x−1)(kk−1)\\sum\\limits_{i=1}^x i^k=\\sum\\limits_{i=1}^{x-1}i^k+1+\\sum\\limits_{j=0}^{k-1}\\binom{k}{j} f_{j}(x-1)\\\\ x^k=1+\\sum\\limits_{j=0}^{k-1}\\binom{k}{j} f_{j}(x-1)\\\\ x^k-\\binom{k}{k-1}f_{k-1}(x-1)=1+\\sum\\limits_{j=0}^{k-2}\\binom{k}{j} f_{j}(x-1)\\\\ \\binom{k}{k-1}f_{k-1}(x-1)=x^k-1-\\sum\\limits_{j=0}^{k-2}\\binom{k}{j} f_{j}(x-1)\\\\ f_{k-1}(x-1)=\\frac{x^k-1-\\sum\\limits_{j=0}^{k-2}\\binom{k}{j} f_{j}(x-1)}{\\binom{k}{k-1}}\\\\ i=1∑x​ik=i=1∑x−1​ik+1+j=0∑k−1​(jk​)fj​(x−1)xk=1+j=0∑k−1​(jk​)fj​(x−1)xk−(k−1k​)fk−1​(x−1)=1+j=0∑k−2​(jk​)fj​(x−1)(k−1k​)fk−1​(x−1)=xk−1−j=0∑k−2​(jk​)fj​(x−1)fk−1​(x−1)=(k−1k​)xk−1−j=0∑k−2​(jk​)fj​(x−1)​ 观察到 f0(x)=xf_0(x)=xf0​(x)=x 是个 111 次多项式，所以 fk(x)f_k(x)fk​(x) 是 k+1k+1k+1 次多项式。 例题： 求 ∑i=1xikmod 109+7\\sum\\limits_{i=1}^xi^k\\mod 10^9+7i=1∑x​ikmod109+7。 1≤x≤109,0≤k≤1061\\le x\\le 10^9,0\\le k\\le 10^61≤x≤109,0≤k≤106。 直接拉插即可，但是直接拉插是 O(k2)O(k^2)O(k2) 的，所以需要一些优化。 看回拉插式子： f(x)=∑i=0k+1yi∏j=ix−xj∏j=ixi−xjf(x)=\\sum\\limits_{i=0}^{k+1} y_i\\frac{\\prod\\limits_{j\\not=i}x-x_j}{\\prod\\limits_{j\\not=i}x_i-x_j} f(x)=i=0∑k+1​yi​j​=i∏​xi​−xj​j​=i∏​x−xj​​ 观察到 x={0,1,2,…,k+1}x=\\{0,1,2,\\dots,k+1\\}x={0,1,2,…,k+1} 时，∏j=ixi−xj\\prod\\limits_{j\\not=i}x_i-x_jj​=i∏​xi​−xj​ 是两个阶乘乘起来，∏j=ix−xj\\prod\\limits_{j\\not=i}x-x_jj​=i∏​x−xj​ 可以预处理前缀后缀积，所以可以优化到 O(klog⁡k)O(k\\log k)O(klogk) 预处理，O(k)O(k)O(k) 插值计算。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005,p=1000000007; int n,k; int y[S]; int fra[S],inv[S]; int pre[S],suf[S]; inline int qpow(int x,int y=p-2) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } inline void init(int k) { y[0]=0; for(int i=1;i&lt;=k+1;i++) y[i]=(y[i-1]+qpow(i,k))%p; fra[0]=1; for(int i=1;i&lt;=k+1;i++) fra[i]=1ll*fra[i-1]*i%p; inv[k+1]=qpow(fra[k+1]); for(int i=k+1;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; } inline int calc(int n,int k) { pre[0]=n; for(int i=1;i&lt;=k+1;i++) pre[i]=1ll*pre[i-1]*(n-i+p)%p; suf[k+1]=(n-k-1+p)%p; for(int i=k;i&gt;=0;i--) suf[i]=1ll*suf[i+1]*(n-i+p)%p; int res=0; for(int i=0;i&lt;=k+1;i++) { int s1=1ll*(i==0?1:pre[i-1])*(i==k+1?1:suf[i+1])%p; int s2=1ll*inv[i]*((k+1-i&amp;1)?p-inv[k+1-i]:inv[k+1-i])%p; res=(res+1ll*y[i]*s1%p*s2%p)%p; } return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); init(k); printf(&quot;%d\\n&quot;,calc(n,k)); return 0; } 例题2：（原题面极其垃圾，给出正确的题面） 小豆喜欢玩游戏，现在他在玩一个游戏遇到这样的场面，有 n−mn-mn−m 个怪，血量为 {1,2,3,…,n}−{a1,a2,a3,…,am}\\{1,2,3,\\dots,n\\}-\\{a_1,a_2,a_3,\\dots,a_m\\}{1,2,3,…,n}−{a1​,a2​,a3​,…,am​}。小豆手里有无限张“亵渎”。亵渎的效果是对所有的怪造成 111 点伤害，如果有怪死亡，则再次施放该法术（再次施放不消耗额外的“亵渎”）。我们认为血量为 000 怪物死亡。 小豆使用一张“亵渎”会获得一定的分数，在使用一张“亵渎”之后，每一个被该“亵渎”造成伤害的怪会产生 xkx^kxk 的分数，其中 xxx 是造成伤害前怪的血量，kkk 是杀死所有怪物所需的“亵渎”的张数。 请求出杀死所有怪物后小豆的分数，对 109+710^9+7109+7 取模。 1≤m≤50,1≤n≤10131\\le m\\le 50,1\\le n\\le 10^{13}1≤m≤50,1≤n≤1013。 不难发现，血量为 {1,2,3,…,n}\\{1,2,3,\\dots,n\\}{1,2,3,…,n} 这样连续的怪只需要一张“亵渎”即可杀光，所以 k=m+1k=m+1k=m+1，并且杀光一段的得分为 ∑i=1nik=∑i=1nim+1\\sum\\limits_{i=1}^n i^k=\\sum\\limits_{i=1}^n i^{m+1}i=1∑n​ik=i=1∑n​im+1。 也就是说，若令 a0=0a_0=0a0​=0，a1&lt;a2&lt;a3&lt;⋯&lt;ama_1&lt;a_2&lt;a_3&lt;\\dots&lt;a_ma1​&lt;a2​&lt;a3​&lt;⋯&lt;am​ 即给它排个序，那么答案即为 ∑i=0m∑j=1n−aijm+1−∑j=i+1m(aj−ai)m+1\\sum\\limits_{i=0}^m\\sum\\limits_{j=1}^{n-a_i}j^{m+1}-\\sum\\limits_{j=i+1}^{m} (a_j-a_i)^{m+1}i=0∑m​j=1∑n−ai​​jm+1−j=i+1∑m​(aj​−ai​)m+1，那么直接拉插即可。 更强力的应用：拉格朗日插值优化 dp 例题： 对于给定的 nnn 和 kkk，一个正整数序列 aaa 是合法的当且仅当： ∣a∣=n|a|=n∣a∣=n 1≤ai≤k1\\le a_i\\le k1≤ai​≤k aia_iai​ 两两不同 aaa 的权值定义为 ∏i=1nai\\prod\\limits_{i=1}^n a_ii=1∏n​ai​，请你求出所有不同的合法的 aaa 的权值和，其中两个序列 a,ba,ba,b 不同当且仅当有至少一个 iii 满足 1≤i≤n1\\le i\\le n1≤i≤n 且 ai=bia_i\\not=b_iai​​=bi​。 1≤n≤500,1≤k≤1091\\le n\\le 500,1\\le k\\le 10^91≤n≤500,1≤k≤109。 首先不难发现只要钦定序列是递增的，最后乘上 n!n!n! 就行了。那么就有个朴素的 dp 做法，设 dpi,jdp_{i,j}dpi,j​ 为填完 a[1,i]a_{[1,i]}a[1,i]​，1≤ai≤j1\\le a_i\\le j1≤ai​≤j 的不同的 aaa 的权值和，那么显然有转移 dpi,j=j×dpi−1,j−1+dpi,j−1dp_{i,j}=j\\times dp_{i-1,j-1}+dp_{i,j-1}dpi,j​=j×dpi−1,j−1​+dpi,j−1​。 但是这样做是 O(nk)O(nk)O(nk) 的，所以考虑优化。 第一种方法：猜测法（无脑，感性） 不妨猜测 dpi,jdp_{i,j}dpi,j​ 是一个关于 jjj 的多项式，严谨证明见第二种方法。 那么直接拉插即可，插 xxx 坐标连续的 nnn 个点可以做到线性时间复杂度，所以尽可能多算几个 dpn,…dp_{n,\\dots}dpn,…​，插值即可。 毕竟拉插不难写，考场上遇到某一维特别大的 dp 都可以试试。 第二种方法：证明法（理性） 有一个结论：若 f(x)f(x)f(x) 是 nnn 次多项式，那么 f(x)−f(x−1)f(x)-f(x-1)f(x)−f(x−1) 是 n−1n-1n−1 次多项式。 证明如下： 设 f(x)f(x)f(x) 的 nnn 次项系数为 aaa，即 f(x)=⋯+axnf(x)=\\dots+ax^nf(x)=⋯+axn。那么 f(x)−f(x−1)f(x)-f(x-1)f(x)−f(x−1) 的 nnn 次项为： axn−a(x−1)n=a(xn−(x−1)n)=a(xn−∑i=0n(ni)xi(−1)n−i)=a(xn−xn−∑i=0n−1(ni)xi(−1)n−i)=a∑i=0n−1(ni)xi(−1)n−i\\begin{aligned} &amp;ax^n-a(x-1)^n\\\\ &amp;=a(x^n-(x-1)^n)\\\\ &amp;=a\\left(x^n-\\sum\\limits_{i=0}^n\\binom{n}{i}x^i(-1)^{n-i}\\right)\\\\ &amp;=a\\left(x^n-x^n-\\sum\\limits_{i=0}^{n-1}\\binom{n}{i}x^i(-1)^{n-i}\\right)\\\\ &amp;=a\\sum\\limits_{i=0}^{n-1}\\binom{n}{i}x^i(-1)^{n-i} \\end{aligned} ​axn−a(x−1)n=a(xn−(x−1)n)=a(xn−i=0∑n​(in​)xi(−1)n−i)=a(xn−xn−i=0∑n−1​(in​)xi(−1)n−i)=ai=0∑n−1​(in​)xi(−1)n−i​ 这个东西是 n−1n-1n−1 次的，得证。 设 pdi,jpd_{i,j}pdi,j​ 为填完 a[1,i]a_{[1,i]}a[1,i]​，ai=ja_i=jai​=j 的所有合法序列的权值和，显然有转移 pdi,j=j∑k=1j−1pdi−1,kpd_{i,j}=j\\sum\\limits_{k=1}^{j-1}pd_{i-1,k}pdi,j​=jk=1∑j−1​pdi−1,k​，那么因为 pd1,jpd_{1,j}pd1,j​ 是关于 jjj 的 000 次多项式，并且以 jjj 为上界的求和会使次数加一，乘上 jjj 也会使次数加一，所以 pdi,jpd_{i,j}pdi,j​ 是关于 jjj 的 2i2i2i 次多项式。 因为 pdi,j=dpi,j−dpi,j−1pd_{i,j}=dp_{i,j}-dp_{i,j-1}pdi,j​=dpi,j​−dpi,j−1​，作差会使次数减 111，所以 dpi,jdp_{i,j}dpi,j​ 是关于 jjj 的 2i+12i+12i+1 次多项式。 那么问题就变得简单起来了，O(n2)O(n^2)O(n2) 求出 dpn,[0,2n+1]dp_{n,[0,2n+1]}dpn,[0,2n+1]​ 后直接拉插即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1005; int k,n,p; int dp[S][S]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d%d%d&quot;,&amp;k,&amp;n,&amp;p); for(int i=0;i&lt;=n*2+1;i++) dp[1][i]=(i+dp[1][i-1])%p; for(int i=2;i&lt;=n;i++) { dp[i][0]=0; for(int j=1;j&lt;=n*2+1;j++) dp[i][j]=(1ll*j*dp[i-1][j-1]%p+dp[i][j-1])%p; } int ans=0; for(int i=0;i&lt;=n*2+1;i++) { int s1=1,s2=1; for(int j=0;j&lt;=n*2+1;j++) if(j!=i) s1=1ll*s1*((k-j)%p+p)%p,s2=1ll*s2*((i-j)%p+p)%p; ans=(ans+1ll*dp[n][i]*s1%p*qpow(s2,p-2)%p)%p; } int fra=1; for(int i=1;i&lt;=n;i++) fra=1ll*fra*i%p; printf(&quot;%d\\n&quot;,1ll*ans*fra%p); return 0; } 后记 场上遇到一些某维很大的式子，可以猜测它是关于这维的多项式，线性拉插尽可能多个点来尝试求解。 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"拉格朗日插值学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/la-ge-lang-ri-cha-zhi-xue-xi-bi-ji/","stats":{"text":"18 min read","time":1067000,"words":3315,"minutes":18},"date":"2023-04-08 07:57:19","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\dots,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，你可以选择两个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≥</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\ge 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 的正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，然后将每一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 之中某一个取模得到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 中最少有多少种不同的数值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定 nnn 个整数 a1,a2,…,ana_1,a_2,\\dots,a_na1​,a2​,…,an​，你可以选择两个 ≥2\\ge 2≥2 的正整数 x,yx,yx,y，然后将每一个 aia_iai​ 对 x,yx,yx,y 之中某一个取模得到 bib_ibi​。 求 bib_ibi​ 中最少有多少种不同的数值。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105 1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109 首先答案肯定要么是 111 要么是 222，因为我们可以对 222 取模。 若已经知道了两个通过取模同一个数 xxx 来得到 bib_ibi​ 的 v1,v2v1,v2v1,v2，那么就可以知道 x∣(∣v1−v2∣)x|(|v1-v2|)x∣(∣v1−v2∣)。而若取三个数 v1,v2,v3v1,v2,v3v1,v2,v3，则至少有两个数是通过取模同一个数来得到 bib_ibi​ 的。 所以只需要选出极差最小且两两不同的三个数，枚举它们两两的差值的因子做 xxx，检验是否合法即可。 检验某个 xxx 的时间复杂度是 O(n+log⁡V)O(n+\\log V)O(n+logV) 的，所以时间复杂度是 O(3f(⌊Vn⌋)(n+logV))O(3f(\\lfloor\\frac{V}{n}\\rfloor)(n+logV))O(3f(⌊nV​⌋)(n+logV))，其中 f(x)f(x)f(x) 表示 [1,x][1,x][1,x] 内正整数的因子个数的最大值。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; #define fio(name) freopen(name&quot;.in&quot;,&quot;r&quot;,stdin),freopen(name&quot;.out&quot;,&quot;w&quot;,stdout); const int S=200005; int n,a[S]; inline int gcd(int x,int y) { if(x==0||y==0) return x+y; int t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } inline bool chk2(int val,int x) { if(x==1) return false; int rt=0,y=0; for(int i=1;i&lt;=n&amp;&amp;(y==0||(y&gt;val&amp;&amp;y!=1));i++) { if(a[i]%x!=val) { if(a[i]&lt;val) return false; y=gcd(y,a[i]-val); } } return y==0||(y&gt;val&amp;&amp;y!=1); } inline bool chk(int val,int x) { if(x&lt;2) return false; for(int d=1;d*d&lt;=x;d++) { if(x%d==0) { if(chk2(val%d,d)) return true; if(d*d!=x&amp;&amp;chk2(val%(x/d),x/d)) return true; } } return false; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); n=unique(a+1,a+n+1)-a-1; if(n&lt;=2) return puts(&quot;1&quot;),0; int mn=0; for(int i=3;i&lt;=n;i++) if(mn==0||a[i]-a[i-2]&lt;a[mn]-a[mn-2]) mn=i; puts( chk(a[mn],a[mn]-a[mn-1])|| chk(a[mn],a[mn]-a[mn-2])|| chk(a[mn-1],a[mn-1]-a[mn-2]) ?&quot;1&quot;:&quot;2&quot;); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"}],"title":"【2022 noip 模拟赛 14】A. 取模 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-14-a-qu-mo-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":196000,"words":617,"minutes":4},"date":"2023-04-08 07:53:21","dateFormat":"2023-04-08"},{"abstract":"<blockquote>\n<p>要求构造一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的二叉树，节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为根，要使所有节点到根的距离之和为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span>。要求先判断可不可以构造，如果可以输出 <code>YES</code>，下一行输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 号节点的父亲节点，否则输出 <code>NO</code>。</p>\n</blockquote>\n","content":" 要求构造一个 nnn 个节点的二叉树，节点 111 为根，要使所有节点到根的距离之和为 ddd。要求先判断可不可以构造，如果可以输出 YES，下一行输出 222 到 nnn 号节点的父亲节点，否则输出 NO。 首先显然可以增量构造，每次把某个叶子接到同层的节点下，令深度总和增加 111。 那么设深度总和下界（构造一棵完全二叉树）为 LLL，深度总和上界（构造一条链）为 RRR，显然 d&lt;Ld&lt;Ld&lt;L 或者 d&gt;Rd&gt;Rd&gt;R 的情况下都是无解的。不妨猜测反之一定有解，尝试证明之，那么由于可以增量构造，所以只需要证明从完全二叉树开始，每次一定能把某个叶子接到同层的节点下。 显然每次操作深度尽量深的叶子是最优的，因为深度深的叶子被移走之后深度较浅的节点更容易暴露出来，成为新的可操作的叶子，并且接深度尽量深的叶子不会减少深度浅的叶子的数量。 那么由于每次都操作深度尽量深的叶子，所以一旦 uuu 被操作了，并且下一次还能操作它，那么下一次操作一定还是操作它，所以 uuu 的轨迹一定是这样的： 那么最后肯定能形成一条链，证毕。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int S=5005; int n,k; bool vis[S]; int fat[S],du[S]; int dep[S]; int idx[S]; inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); int R=n*(n-1)/2; for(int i=1;i&lt;=n;i++) vis[i]=false,du[i]=0; queue&lt;int&gt; q; q.push(1); vis[1]=true; dep[1]=0; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=1,cnt=0;i&lt;=n&amp;&amp;cnt&lt;2;i++) { if(!vis[i]) { vis[i]=true; fat[i]=u; du[u]++; dep[i]=dep[u]+1; cnt++; q.push(i); } } } int L=0; for(int i=1;i&lt;=n;i++) L+=dep[i]; if(k&lt;L||k&gt;R) return void(puts(&quot;NO&quot;)); puts(&quot;YES&quot;); for(int tme=1;tme&lt;=k-L;tme++) { for(int i=1;i&lt;=n;i++) idx[i]=0; for(int i=1;i&lt;=n;i++) if(du[i]&lt;2&amp;&amp;(idx[dep[i]]==0||du[i]&gt;0)) idx[dep[i]]=i; int u=0; for(int i=1;i&lt;=n;i++) if(du[i]==0&amp;&amp;idx[dep[i]]!=0&amp;&amp;i!=idx[dep[i]]&amp;&amp;(u==0||dep[i]&gt;dep[u])) u=i; du[fat[u]]--; du[fat[u]=idx[dep[u]]]++; dep[u]++; } for(int i=2;i&lt;=n;i++) printf(&quot;%d &quot;,fat[i]); printf(&quot;\\n&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1311E Construct the Binary Tree 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1311e-construct-the-binary-tree-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":188000,"words":669,"minutes":4},"date":"2023-04-02 18:41:59","dateFormat":"2023-04-02"},{"abstract":"","content":"前置知识：树的重心 点分治是一种用来处理树上路径问题的思想，而非一种具体分治算法。 先看一到例题： 给出一棵 nnn 个点的无根树，求树上长度为 kkk 的路径条数。 朴素的做法是枚举路径开头的点，跑 O(n)O(n)O(n) 树形 dp。但是这样的时间复杂度是 O(n2)O(n^2)O(n2) 的，不够优秀。 考虑以点 uuu 为根的子树的情况，显然所有路径分成两类： 经过 uuu 的； 不经过 uuu，在 uuu 儿子的子树中的； 第二类路径可以递归到 uuu 的儿子子树中处理，而第一类路径可以 O(n)O(n)O(n) 遍历整棵子树来处理。 若递归的时候直接让根为 uuu 的某个儿子，显然来个链的情况就能把这个算法卡到 O(n2)O(n^2)O(n2)，所以每次选择的根很重要。 回忆一下重心： 定义：以重心为根，最大的子树大小是以所有节点为根的有根树中最小的。 性质：以重心为根，所有子树的大小都不超过整棵树的大小的一半。 所以只要每次选择子树的重心为根就行了，因为重心的优美性质，所以这样递归的层数是 O(log⁡n)O(\\log n)O(logn) 的，时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 回到例题，由于点分治的常数巨大，所以建议把所有询问离线下来做： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=50005,BS=10000005; int n,m,mxk,ks[S]; int esum,to[S],c[S],nxt[S],h[S]; int rot,siz[S],mx[S]; bool hasdis[BS],ans[S]; bool vis[S]; inline void add(int x,int y,int w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } void gethev(int u,int fa,int sizz) { siz[u]=1; mx[u]=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa||vis[v]) continue; gethev(v,u,sizz); siz[u]+=siz[v]; mx[u]=max(mx[u],siz[v]); } mx[u]=max(mx[u],sizz-siz[u]); if(rot==-1||mx[u]&lt;mx[rot]) rot=u; } void getdis(int u,int fa,int dis) { for(int i=1;i&lt;=m;i++) if(ks[i]&gt;=dis) ans[i]|=hasdis[ks[i]-dis]; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(v==fa||vis[v]) continue; getdis(v,u,dis+w); } } void adddis(int u,int fa,int dis,bool f) { if(dis&lt;=mxk) hasdis[dis]=f; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(v==fa||vis[v]) continue; adddis(v,u,dis+w,f); } } void slove(int u) { hasdis[0]=true; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(vis[v]) continue; getdis(v,u,w); adddis(v,u,w,true); } for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(vis[v]) continue; adddis(v,u,w,false); } vis[u]=true; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(vis[v]) continue; rot=-1; gethev(v,u,siz[v]); slove(rot); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) { int x,y,w; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w); add(x,y,w); add(y,x,w); } for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;ks[i]),mxk=max(mxk,ks[i]); rot=-1; gethev(1,0,n); slove(rot); for(int i=1;i&lt;=m;i++) puts(ans[i]?&quot;AYE&quot;:&quot;NAY&quot;); return 0; } ","tags":[{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"点分治学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/dian-fen-zhi-xue-xi-bi-ji/","stats":{"text":"5 min read","time":244000,"words":814,"minutes":5},"date":"2023-04-02 18:37:00","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>构造一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>，使得：</p>\n<ul>\n<li>\n<p>任意长度小于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串，或者不是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 的子串，或者在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 中出现了至少 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 次</p>\n</li>\n<li>\n<p>至少存在一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串，在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 中出现了恰好一次</p>\n</li>\n</ul>\n<p>保证 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≡</mo><mi>k</mi><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">n\\equiv k (mod 2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46375em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le k\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 构造一个长度为 nnn 的 010101 串 sss，使得： 任意长度小于 kkk 的 010101 串，或者不是 sss 的子串，或者在 sss 中出现了至少 222 次 至少存在一个长度为 kkk 的 010101 串，在 sss 中出现了恰好一次 保证 n≡k(mod2)n\\equiv k (mod 2)n≡k(mod2)。 1≤k≤n≤1051\\le k\\le n\\le 10^51≤k≤n≤105。 构造方法：设 l=n−k2l=\\frac{n-k}{2}l=2n−k​，那么 si=[imod⁡(l+1)≥1]s_i=[i\\operatorname{mod} (l+1)\\ge 1]si​=[imod(l+1)≥1]。 证明： 这样构造出来的 sss 一定是形如 [1111…10][1111…10][1111…10][11111][1111\\dots10][1111\\dots10][1111\\dots10][11111][1111…10][1111…10][1111…10][11111] 这样一段一段的，除了最后一段之外的每一段都是由 lll 个 111 和 111 个 000 组成的。 先证明一定至少有一个长度为 kkk 的子串只出现了一次，可以证明 s[l+1,n−l]s_{[l+1,n-l]}s[l+1,n−l]​ 这个的长度为 n−n−k2−n−k2−1+1=kn-\\frac{n-k}{2}-\\frac{n-k}{2}-1+1=kn−2n−k​−2n−k​−1+1=k 的子串一定是只出现一次的，因为它的开头是 sl+1=0s_{l+1}=0sl+1​=0，而下一个最靠左的 000 却在 s2l+2s_{2l+2}s2l+2​，但是 n−2l−2+1=n−n+k−2+1=k−1&lt;kn-2l-2+1=n-n+k-2+1=k-1&lt;kn−2l−2+1=n−n+k−2+1=k−1&lt;k，容不下一个长度为 kkk 的字符串。 再来证明一定每个长度 &lt;k&lt;k&lt;k 的子串都出现了至少两次，设长度为 ttt，开头位置为 ppp。若 ppp 不在第一段，显然往左移动一段即可找到相同的子串；若 ppp 在第一段，那么往右移动一段即可。往左移动显然不会超出边界，下面来证明往右移动也不会超出边界： 显然最坏情况是 p=l+1p=l+1p=l+1，t=k−1t=k-1t=k−1，那么由于 2l+2+k−1−1=2n−k2+k=n2l+2+k-1-1=2\\frac{n-k}{2}+k=n2l+2+k−1−1=22n−k​+k=n 所以右端点不会超出 nnn。 综上，得证。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1158B The minimal unique substring 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1158b-the-minimal-unique-substring-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":149000,"words":540,"minutes":3},"date":"2023-04-02 18:35:18","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>给定一个字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，你可以任意打乱 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中字符的顺序，记打乱后的字符串为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>。记 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的价值为将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 转换为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 所需的最小交换次数（交换指交换两个相邻元素）。输出价值最大的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>。</p>\n<p>若有多种答案，任意输出一种。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>a</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le |a|\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">a</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个字符串 aaa，你可以任意打乱 aaa 中字符的顺序，记打乱后的字符串为 bbb。记 bbb 的价值为将 bbb 转换为 aaa 所需的最小交换次数（交换指交换两个相邻元素）。输出价值最大的 bbb。 若有多种答案，任意输出一种。 1≤∣a∣≤1051\\le |a|\\le 10^51≤∣a∣≤105。 这种题都有两个方向：直接构造 TTT 和研究 TTT 还原到 SSS 的性质。 发现直接构造不好做，那么考虑研究 TTT 还原到 SSS 的性质。 显然若知道了 pip_ipi​ 表示 TiT_iTi​ 最终要去的位置，那么把 TTT 还原到 SSS 所需的操作就是 ppp 的逆序对个数。 不难发现，对于两个满足 x&lt;y,Tx=Tyx&lt;y,T_x=T_yx&lt;y,Tx​=Ty​ 的位置 x,yx,yx,y，px&lt;pyp_x&lt;p_ypx​&lt;py​ 显然是最优的，因为 px&gt;pyp_x&gt;p_ypx​&gt;py​ 会增加至少一对逆序对，并且由于一个更大的数被放到前面了，所以逆序对个数并不会减少。 继续研究两个满足 x&lt;y,Tx=Ty,T[x+1,y−1]=Txx&lt;y,T_x=T_y,T_{[x+1,y-1]}\\not=T_xx&lt;y,Tx​=Ty​,T[x+1,y−1]​​=Tx​ 的两个位置 x,yx,yx,y，考虑 x&lt;k&lt;yx&lt;k&lt;yx&lt;k&lt;y，令 Sx={k∣x&lt;k&lt;y,px&gt;pk},Sy={k∣x&lt;k&lt;y,py&lt;pk}Sx=\\{k|x&lt;k&lt;y,p_x&gt;p_k\\},Sy=\\{k|x&lt;k&lt;y,p_y&lt;p_k\\}Sx={k∣x&lt;k&lt;y,px​&gt;pk​},Sy={k∣x&lt;k&lt;y,py​&lt;pk​}，显然有 Sx∩Sy=∅Sx\\cap Sy=\\varnothingSx∩Sy=∅，那么令 Sz={k∣x&lt;k&lt;y}−Sx−SySz=\\{k|x&lt;k&lt;y\\}-Sx-SySz={k∣x&lt;k&lt;y}−Sx−Sy。 显然所有 k∈Sxk\\in Sxk∈Sx 和 k∈Syk\\in Syk∈Sy 的 kkk 对逆序对个数都有 111 的贡献，所有 k∈Szk\\in Szk∈Sz 的 kkk 对逆序对个数都没有贡献。那么考虑把 TxT_xTx​ 换到 Ty−1T_{y-1}Ty−1​ 和把 TyT_{y}Ty​ 换到 Tx+1T_{x+1}Tx+1​ 这两种操作： 把 TxT_xTx​ 换到 Ty−1T_{y-1}Ty−1​，此时逆序对个数会减少 ∣Sx∣|Sx|∣Sx∣，但是又会加上 ∣Sy∣|Sy|∣Sy∣； 把 TyT_yTy​ 换到 Tx+1T_{x+1}Tx+1​，此时逆序对个数会减少 ∣Sy∣|Sy|∣Sy∣，但是又会加上 ∣Sx∣|Sx|∣Sx∣； 并且两种操作都会造成一些额外的非负的来自 k∈Szk\\in Szk∈Sz 的逆序对个数贡献，这两种操作中对逆序对贡献更多的操作的贡献肯定至少为 000，那么让 TxT_xTx​ 和 TyT_yTy​ 相邻显然更优。 所以所有相同的字符相邻肯定是最优的。 那么枚举所有 4!=244!=244!=24 种字符串，O(nlog⁡n)O(n\\log n)O(nlogn) 计算逆序对个数即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int S=200005; int n; char a[S]; vector&lt;int&gt; pos[4]; int b[S],c[S]; char res[S]; inline int id(char x) { return x=='A'?0:(x=='N'?1:(x=='T'?2:3)); } inline char di(int x) { return x==0?'A':(x==1?'N':(x==2?'T':'O')); } inline void add(int pos,int val) { for(int i=pos;i&lt;=n;i+=i&amp;-i) c[i]+=val; } inline int que(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } inline void slove() { scanf(&quot;%s&quot;,a+1); n=strlen(a+1); for(int i=0;i&lt;4;i++) pos[i].clear(); for(int i=1;i&lt;=n;i++) pos[id(a[i])].push_back(i); long long mx=-1; for(int i=0;i&lt;4;i++) { for(int j=0;j&lt;4;j++) { if(i==j) continue; for(int k=0;k&lt;4;k++) { if(i==k||j==k) continue; for(int l=0;l&lt;4;l++) { if(i==l||j==l||k==l) continue; int p=0; for(int &amp;u:pos[i]) b[++p]=u; for(int &amp;u:pos[j]) b[++p]=u; for(int &amp;u:pos[k]) b[++p]=u; for(int &amp;u:pos[l]) b[++p]=u; for(int o=1;o&lt;=n;o++) c[o]=0; long long pre=0; for(int o=n;o&gt;=1;o--) { pre+=que(b[o]-1); add(b[o],1); } if(pre&gt;mx) { mx=pre; p=0; for(int &amp;u:pos[i]) res[++p]=di(i); for(int &amp;u:pos[j]) res[++p]=di(j); for(int &amp;u:pos[k]) res[++p]=di(k); for(int &amp;u:pos[l]) res[++p]=di(l); } } } } } res[n+1]=0; printf(&quot;%s\\n&quot;,res+1); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1526D Kill Anton 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1526d-kill-anton-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":323000,"words":1061,"minutes":6},"date":"2023-04-02 18:29:12","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个点和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 条边的连通图，求一条简单路径 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">path</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">h</span></span></span></span> 和两个点集 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">s1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">s2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span></span></span></span>，满足：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mn>1</mn><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mn>2</mn><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|s1| = |s2|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span><span class=\"mord\">∣</span></span></span></span>，两个点集大小相同（可以为空）；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mn>1</mn><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mn>2</mn><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">|s1| + |s2| + |path| = N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">h</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>1</mn><mo>∩</mo><mi>s</mi><mn>2</mn><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">s1 \\cap s2 = \\varnothing</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66334em;vertical-align:-0.08167em;\"></span><span class=\"mord amsrm\">∅</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>1</mn><mo>∩</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">s1 \\cap path = \\varnothing</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66334em;vertical-align:-0.08167em;\"></span><span class=\"mord amsrm\">∅</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>2</mn><mo>∩</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">s2 \\cap path = \\varnothing</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66334em;vertical-align:-0.08167em;\"></span><span class=\"mord amsrm\">∅</span></span></span></span>，即两个点集和简单路径恰好覆盖了所有点；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">s1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">s2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span></span></span></span> 之间没有边直接相连。</li>\n</ul>\n<p>或者宣称这样的方案不存在。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le N,M\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定 NNN 个点和 MMM 条边的连通图，求一条简单路径 pathpathpath 和两个点集 s1s1s1 和 s2s2s2，满足： ∣s1∣=∣s2∣|s1| = |s2|∣s1∣=∣s2∣，两个点集大小相同（可以为空）； ∣s1∣+∣s2∣+∣path∣=N|s1| + |s2| + |path| = N∣s1∣+∣s2∣+∣path∣=N 且 s1∩s2=∅s1 \\cap s2 = \\varnothings1∩s2=∅ 且 s1∩path=∅s1 \\cap path = \\varnothings1∩path=∅ 且 s2∩path=∅s2 \\cap path = \\varnothings2∩path=∅，即两个点集和简单路径恰好覆盖了所有点； s1s1s1 和 s2s2s2 之间没有边直接相连。 或者宣称这样的方案不存在。 1≤N,M≤2×1051\\le N,M\\le 2\\times 10^51≤N,M≤2×105 一眼 dfs 树，然后考虑在树上构造。 根本不会无解。 显然根节点 rtrtrt 一定要让公主占领，然后若根节点 rtrtrt 的儿子的子树恰好可以分给两个王子使得满足条件，那么公主选根节点，根节点的儿子子树平均分给两个王子就行。 否则考虑递归构造，设当前两个王子分别占领了 sum0sum0sum0 个点和 sum1sum1sum1 个点，那么不难想到一个策略： 先让公主占领 rtrtrt； 遍历 rtrtrt 除重儿子 hsonhsonhson 之外的儿子 vvv，若 sum0&lt;sum1sum0&lt;sum1sum0&lt;sum1，那么 vvv 的子树分配给第一个王子，否则分配给第二个王子； 若分配完之后 ∣sum0−sum1∣=sizhson|sum0-sum1|=siz_{hson}∣sum0−sum1∣=sizhson​ 那么构造完成，否则此时一定有 ∣sum0−sum1∣&lt;sizhson|sum0-sum1|&lt;siz_{hson}∣sum0−sum1∣&lt;sizhson​，那么递归构造 hsonhsonhson 的子树。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022 NOIP 模拟赛 8】C. 退休计划 II 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-8-c-tui-xiu-ji-hua-ii-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":93000,"words":374,"minutes":2},"date":"2023-04-02 18:24:06","dateFormat":"2023-04-02"},{"abstract":"","content":"初赛 PJ 没什么好说的。 xtl 估分：909090 luogu 估分：929292 实际： 898989 TG 出题人的马被宇宙射线轰炸啦！ 大作业只用选两个人两个人做，其他人抄就行了！ 哇，出题人竟然发明了能让 for(int j=0;j&lt;n;j*=2) 停下来的 C++114，tql！ 寄了。 两个民间答案分数相差 7.57.57.5。 xtl 估分：888888 luogu 估分：80.580.580.5 实际： 77.577.577.5 复赛 PJ 十点 AK 了，后面一直在睡觉。 见到 zlt 了，他也 AK 了。 xtl 估分：100+100+100+100=400100+100+100+100=400100+100+100+100=400 luogu 估分：100+100+100+100=400100+100+100+100=400100+100+100+100=400 实际： 100+100+100+100=400100+100+100+100=400100+100+100+100=400 TG T1 想了 1.5h，刚开始写了一个 dfs 找环，假了，后来发现可以维护前三大。 T2 一眼，2h 做完 T1T2。 T3 想到了维护每个点出度，0.5h 没想到随机赋权，加上题面长，没信心，写 606060 分暴力走人，看 T4。 T4 一眼 DDP，怒码 1.5h，5k。忘记判跳到链外了，还写挂了，喜提 000 分。 挺破防的，T4 606060 多分暴力没拿到，T3 随机赋权也没想到，就不该怒码 T4 的。 luogu 估分：100+100+60+0=260100+100+60+0=260100+100+60+0=260 Infoj 估分：100+100+60+0=260100+100+60+0=260100+100+60+0=260 实际： 100+100+60+0=260100+100+60+0=260100+100+60+0=260 人均 300+ 吗 /ll ","tags":[{"name":2022,"slug":"GJvEuJsM-","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GJvEuJsM-/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"},{"name":"CSP","slug":"hWQ-FoFtNl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/hWQ-FoFtNl/"}],"title":"CSP 2022 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/csp-2022-you-ji/","stats":{"text":"2 min read","time":97000,"words":362,"minutes":2},"date":"2023-04-02 18:23:41","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个元素的整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>, 任意时刻对于任一对<strong>相邻元素</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a_{i-1},a_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>&gt;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_{i-1} &gt; a_{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.747431em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 则要依次执行如下操作：</p>\n<p><code>a[i-1]--,a[i]++</code>，然后交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的位置。</p>\n<p>经过若干次操作后，若能使整个序列变成<strong>非降的</strong>，则输出最终的序列；否则输出 <code>:(</code> 。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq n \\leq 2\\times 10^5, 0 \\leq a[i] \\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 个元素的整数序列 aaa, 任意时刻对于任一对相邻元素 (ai−1,ai)(a_{i-1},a_i)(ai−1​,ai​)，若 ai−1&gt;aia_{i-1} &gt; a_{i}ai−1​&gt;ai​ 则要依次执行如下操作： a[i-1]--,a[i]++，然后交换 ai−1a_{i-1}ai−1​ 和 aia_iai​ 的位置。 经过若干次操作后，若能使整个序列变成非降的，则输出最终的序列；否则输出 :( 。 1≤n≤2×105,0≤a[i]≤1091 \\leq n \\leq 2\\times 10^5, 0 \\leq a[i] \\leq 10^91≤n≤2×105,0≤a[i]≤109。 以后看到这种操作中带加一减一的都要考虑减掉下标。 设 bi=ai−ib_i=a_i-ibi​=ai​−i，不难发现一次操作 (i,i+1)(i,i+1)(i,i+1) 相当于交换了 bib_ibi​ 和 bi+1b_{i+1}bi+1​。 那么对 bib_ibi​ 排序，判断是否两两不同即可。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF549G Happy Line 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf549g-happy-line-zuo-ti-ji-lu/","stats":{"text":"1 min read","time":59000,"words":220,"minutes":1},"date":"2023-04-02 18:21:25","dateFormat":"2023-04-02"},{"abstract":"","content":" 原题链接 给一棵 nnn 个点的有根树，节点 111 是根。节点 iii 的初始权值为 wiw_iwi​。 定义一次操作是对于每个 iii，将 wiw_iwi​ 修改成操作前 iii 的子树的所有权值的异或和。 有 qqq 次独立的询问，每次询问是求 tit_iti​ 次操作后 w1w_1w1​ 的值。 1≤n,q≤2×1051\\le n,q\\le 2\\times 10^51≤n,q≤2×105，1≤wi,ti≤1091\\le w_i,t_i\\le 10^91≤wi​,ti​≤109。 首先不难发现由于每一次操作相当于做前缀和，所以同一层上的点要么都有贡献，要么都没贡献。那么设 fi,jf_{i,j}fi,j​ 表示第 i+1i+1i+1 次操作之后深度为 jjj 的点是否有贡献，显然 f0,j=1f_{0,j}=1f0,j​=1。 稍加思考可以发现递推式 fi,j=fi−1,jxor⁡fi,j−1f_{i,j}=f_{i-1,j}\\operatorname{xor} f_{i,j-1}fi,j​=fi−1,j​xorfi,j−1​，因为第 jjj 层的点对第 j−1j-1j−1 层的点有贡献。 画出转移图： 旋转 45°45\\degree45°： 所以说 fi,j≡Ci+jj(mod2)f_{i,j}\\equiv C_{i+j}^j\\pmod 2fi,j​≡Ci+jj​(mod2)。 或者说其实这个递推式相当于求从左上角只能向下向右走走到 (i,j)(i,j)(i,j) 的方案数，一共有 i+ji+ji+j 次操作，其中有 jjj 次向下。 然后根据 Lucas 定理，Cnm≡Cnmod⁡2mmod⁡2×C⌊n2⌋⌊m2⌋(mod2)C_{n}^m\\equiv C_{n\\operatorname{mod} 2}^{m\\operatorname{mod} 2}\\times C_{\\lfloor\\frac{n}{2}\\rfloor}^{\\lfloor\\frac{m}{2}\\rfloor}\\pmod 2Cnm​≡Cnmod2mmod2​×C⌊2n​⌋⌊2m​⌋​(mod2)，那么对于 n,mn,mn,m 二进制第 iii 位 x,yx,yx,y，当 x=0,y=1x=0,y=1x=0,y=1 时这一位就会让乘积变成 000，所以 fi,j=1f_{i,j}=1fi,j​=1 当且仅当 i+jand⁡j=ji+j\\operatorname{and}j=ji+jandj=j，即 iand⁡j=0i\\operatorname{and} j=0iandj=0。 那么求出 aia_iai​ 表示所有深度为 iii 的点的点权的异或和，sumi=xor⁡jand⁡i=jajsum_i=\\operatorname{xor}_{j\\operatorname{and} i=j} a_jsumi​=xorjandi=j​aj​，那么 ttt 次操作之后的答案就相当于是 sum(t−1)二进制按位取反的结果sum_{(t-1)二进制按位取反的结果}sum(t−1)二进制按位取反的结果​。 注意 t=0t=0t=0 的情况要特判。 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"Codechef WEASELTX 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/codechef-weaseltx-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":156000,"words":568,"minutes":3},"date":"2023-04-02 18:18:17","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>构造一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 满足以下条件：</p>\n<ol>\n<li>长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\forall i, 1\\leq a_i\\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span> 。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo>&gt;</mo><mn>1</mn><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\forall i&gt;1,a_i&gt;a_{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li>满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">i&lt;j&lt;k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>a</mi><mi>j</mi></msub><mo>=</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i+a_j=a_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的三元组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j,k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> 数量恰好为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>。</li>\n</ol>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\leq 5000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le m\\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 构造一个序列 aaa 满足以下条件： 长度为 nnn 。 ∀i,1≤ai≤109\\forall i, 1\\leq a_i\\leq 10^9∀i,1≤ai​≤109 。 ∀i&gt;1,ai&gt;ai−1\\forall i&gt;1,a_i&gt;a_{i-1}∀i&gt;1,ai​&gt;ai−1​。 满足 i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k 且 ai+aj=aka_i+a_j=a_kai​+aj​=ak​ 的三元组 (i,j,k)(i,j,k)(i,j,k) 数量恰好为 mmm。 1≤n≤50001\\le n\\leq 50001≤n≤5000，0≤m≤1090\\le m\\leq 10^90≤m≤109。 考虑填入正整数序列。 1,2,3,4,5,6,7,8,91,2,3,4,5,6,7,8,91,2,3,4,5,6,7,8,9，贡献为 0,0,1,1,2,2,3,3,4,40,0,1,1,2,2,3,3,4,40,0,1,1,2,2,3,3,4,4，不难发现这样构造的三元组是最多的，因为 iii 前面的 i−1i-1i−1 个数除了中间那个都会参与贡献。 那么如果这样构造都不够就不合法，否则一直填直到总是 ≥m\\ge m≥m，假设多了 www 个，不难发现最后填到的这个位置每 +2+2+2 三元组个数就会 −1-1−1，所以当前位置直接加上 2w2w2w 即可。 如果最后没有填满 nnn 个数，假设最大数为 vvv，那么依次填入 3v,5v,7v,9v,…3v,5v,7v,9v,\\dots3v,5v,7v,9v,… 即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=5005; int n,m; int a[S]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int tot=0; for(int i=1;i&lt;=n;i++) { a[i]=i; tot+=(i-1)/2; if(tot&gt;=m) { int w=tot-m; a[i]+=w*2; for(int j=i+1;j&lt;=n;j++) a[j]=a[i]*((j-i)*2+1); for(int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,a[j]); printf(&quot;\\n&quot;); return 0; } } puts(&quot;-1&quot;); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1305E Kuroni and the Score Distribution 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1305e-kuroni-and-the-score-distribution-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":137000,"words":443,"minutes":3},"date":"2023-04-02 18:16:00","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个僵尸，每个僵尸头上有一个值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 的数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，每个僵尸只能看到其他 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个僵尸头顶的数字，当然，他们也知道自己的编号。 要求提供一种策略，使所有僵尸只利用自己知道的信息<strong>同时</strong>猜自己头顶的数字，保证至少有一个僵尸猜对。</p>\n<p>对于每组数据，第一行包含两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span>，表示僵尸总数与当前僵尸的编号，下一行包括 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">−</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n−1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> 个正整数，表示当前僵尸看到的所有其他僵尸头顶的编号是多少（按僵尸编号升序排列）。你要输出当前僵尸应该猜测的数字。</p>\n<p>时间复杂度要求线性。</p>\n</blockquote>\n","content":" 一共有 nnn 个僵尸，每个僵尸头上有一个值域 [1,n][1,n][1,n] 的数字 aia_iai​，每个僵尸只能看到其他 n−1n - 1n−1 个僵尸头顶的数字，当然，他们也知道自己的编号。 要求提供一种策略，使所有僵尸只利用自己知道的信息同时猜自己头顶的数字，保证至少有一个僵尸猜对。 对于每组数据，第一行包含两个正整数 nnn 和 rrr，表示僵尸总数与当前僵尸的编号，下一行包括 n−1n−1n−1 个正整数，表示当前僵尸看到的所有其他僵尸头顶的编号是多少（按僵尸编号升序排列）。你要输出当前僵尸应该猜测的数字。 时间复杂度要求线性。 神仙题。 首先如果 xxx 知道每个人头上的数字和对 nnn 取模的结果 rrr，那么他显然可以求出自己头上的数字。那么考虑让第 111 个人猜 r=0r=0r=0，第 222 个人猜 r=1r=1r=1，依次类推，第 iii 个人猜 r=i−1r=i-1r=i−1，就可以保证至少有一个人猜对。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n,m; inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int res=m-1; for(int i=1;i&lt;=n-1;i++) { int x; scanf(&quot;%d&quot;,&amp;x); res=(res+x)%n; } res=n-res; printf(&quot;%d\\n&quot;,res); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF690A3 Collective Mindsets (hard) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf690a3-collective-mindsets-hard-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":97000,"words":384,"minutes":2},"date":"2023-04-02 18:14:53","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>给定一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\ldots ,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">b,c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 符合以下条件</p>\n<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub><mo>+</mo><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i=b_i+c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 为不下降序列，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 为不上升序列，即 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b_i\\geq b_{i-1}, c_i\\leq c_{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 个操作，每次操作把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[l,r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 的数增加 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>。求每次操作后最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo>(</mo><msub><mi>b</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\max(b_i,c_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n","content":" 给定一个序列 a1,a2,…,ana_1,a_2,\\ldots ,a_na1​,a2​,…,an​，长度为 nnn 的序列 b,cb,cb,c 符合以下条件 ai=bi+cia_i=b_i+c_iai​=bi​+ci​ bbb 为不下降序列，ccc 为不上升序列，即 bi≥bi−1,ci≤ci−1b_i\\geq b_{i-1}, c_i\\leq c_{i-1}bi​≥bi−1​,ci​≤ci−1​ 有 qqq 个操作，每次操作把 [l,r][l,r][l,r] 的数增加 xxx。求每次操作后最小的 max⁡(bi,ci)\\max(b_i,c_i)max(bi​,ci​) 看到单调不降和单调不升，就不难想到作差分。 设 adi=ai−ai−1,bdi=bi−bi−1,cdi=ci−ci−1ad_i=a_i-a_{i-1},bd_i=b_i-b_{i-1},cd_i=c_i-c_{i-1}adi​=ai​−ai−1​,bdi​=bi​−bi−1​,cdi​=ci​−ci−1​（a0=0,b0=0,c0=0a_0=0,b_0=0,c_0=0a0​=0,b0​=0,c0​=0），显然对于所有 2≤i≤n2\\le i\\le n2≤i≤n，有 bdi≥0,cdi≤0bd_i\\ge 0,cd_i\\le 0bdi​≥0,cdi​≤0。那么问题就转化为： 给定一个长度为 nnn 的序列 adadad，构造两个长度为 nnn，对于所有 2≤i≤n2\\le i\\le n2≤i≤n 都满足 bdi≥0,cdi≤0bd_i\\ge 0,cd_i\\le 0bdi​≥0,cdi​≤0 且对于所有 1≤i≤n1\\le i\\le n1≤i≤n 都满足 bdi+cdi=adibd_i+cd_i=ad_ibdi​+cdi​=adi​ 的序列 bd,cdbd,cdbd,cd，使得 max⁡(∑bdi,−∑cdi)\\max(\\sum bd_i,-\\sum cd_i)max(∑bdi​,−∑cdi​) 最小。 不难发现，因为 bdi≥0,cdi≤0bd_i\\ge 0,cd_i\\le 0bdi​≥0,cdi​≤0，所以对于所有 adi≥0ad_i\\ge 0adi​≥0 的 iii 一定有 bdi=adi,cdi=0bd_i=ad_i,cd_i=0bdi​=adi​,cdi​=0，对于所有 adi&lt;0ad_i&lt;0adi​&lt;0 的 iii 一定有 bdi=0,cdi=adibd_i=0,cd_i=ad_ibdi​=0,cdi​=adi​。那么不妨钦定 max⁡(∑bdi,cd1)\\max(\\sum bd_i,cd_1)max(∑bdi​,cd1​) 一定为 cd1cd_1cd1​，那么设 sm=∑i=2nmax⁡(adi,0)sm=\\sum\\limits_{i=2}^n \\max(ad_i,0)sm=i=2∑n​max(adi​,0)，显然有 ad1−cd1+sm≤cd1ad_1-cd_1+sm\\le cd_1ad1​−cd1​+sm≤cd1​，那么有 cd1≥⌈ad1+sm2⌉cd_1\\ge \\lceil\\frac{ad_1+sm}{2}\\rceilcd1​≥⌈2ad1​+sm​⌉，所以答案就是 ⌈ad1+sm2⌉\\lceil\\frac{ad_1+sm}{2}\\rceil⌈2ad1​+sm​⌉。 每次操作只会改动两个位置，那么动态维护差分即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; int n; long long a[S]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=n;i&gt;=1;i--) a[i]-=a[i-1]; long long sm=0; for(int i=2;i&lt;=n;i++) if(a[i]&gt;0) sm+=a[i]; printf(&quot;%lld\\n&quot;,(sm+a[1])/2+(sm+a[1]&gt;0)*((sm+a[1])%2)); int q; scanf(&quot;%d&quot;,&amp;q); while(q--) { int l,r; long long x; scanf(&quot;%d%d%lld&quot;,&amp;l,&amp;r,&amp;x); r++; if(l&gt;1) { if(a[l]&gt;0) sm-=a[l]; a[l]+=x; if(a[l]&gt;0) sm+=a[l]; } else a[l]+=x; if(r&lt;=n) { if(a[r]&gt;0) sm-=a[r]; a[r]-=x; if(a[r]&gt;0) sm+=a[r]; } printf(&quot;%lld\\n&quot;,(sm+a[1])/2+(sm+a[1]&gt;0)*((sm+a[1])%2)); } return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1406D Three Sequences 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1406d-three-sequences-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":226000,"words":697,"minutes":4},"date":"2023-04-02 18:10:39","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>一次操作选择<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1&lt;i&lt;n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，使<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>变为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi>c</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">c_i&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.010556em;vertical-align:-0.258664em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-2.441336em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.258664em;\"><span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi>c</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>=</mo><msub><mi>c</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i&#x27;=c_{i+1}+c_{i-1}-c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.010556em;vertical-align:-0.258664em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-2.441336em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.258664em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.791661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.791661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>是否能做若干次操作，使每个<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>相等？</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><msub><mi>c</mi><mi>i</mi></msub><mo>≤</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><msub><mi>t</mi><mi>i</mi></msub><mo>≤</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 10^5, 0\\le c_i\\le 2*10^9, 0\\le t_i\\le 2*10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 一次操作选择1&lt;i&lt;n1&lt;i&lt;n1&lt;i&lt;n，使cic_ici​变为ci′c_i&#x27;ci′​，ci′=ci+1+ci−1−cic_i&#x27;=c_{i+1}+c_{i-1}-c_ici′​=ci+1​+ci−1​−ci​ 是否能做若干次操作，使每个cic_ici​和tit_iti​相等？ 2≤n≤105,0≤ci≤2∗109,0≤ti≤2∗1092\\le n\\le 10^5, 0\\le c_i\\le 2*10^9, 0\\le t_i\\le 2*10^92≤n≤105,0≤ci​≤2∗109,0≤ti​≤2∗109。 首先遇到这种序列操作的题，肯定要考虑原序列、差分序列和前缀后缀和序列。 那么原序列似乎规律，那么观察差分序列。设 ai=ci+1−cia_i=c_{i+1}-c_iai​=ci+1​−ci​，那么一次 ci=ci−1+ci+1−cic_i=c_{i-1}+c_{i+1}-c_ici​=ci−1​+ci+1​−ci​ 的操作相当于让 ai−1=ci−1+ci+1−ci−ci−1=ci+1−ci=aia_{i-1}=c_{i-1}+c_{i+1}-c_i-c_{i-1}=c_{i+1}-c_i=a_iai−1​=ci−1​+ci+1​−ci​−ci−1​=ci+1​−ci​=ai​，ai=ci+1−(ci−1+ci+1−ci)=ci−ci−1=ai−1a_{i}=c_{i+1}-(c_{i-1}+c_{i+1}-c_i)=c_i-c_{i-1}=a_{i-1}ai​=ci+1​−(ci−1​+ci+1​−ci​)=ci​−ci−1​=ai−1​，也就是交换 aia_{i}ai​ 和 ai−1a_{i-1}ai−1​。 那么本题就变得就很简单了，特判掉 c1=t1,cn=tnc_1\\not=t_1,c_n\\not=t_nc1​​=t1​,cn​​=tn​ 的情况，排序即可。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1110E Magic Stones 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1110e-magic-stones-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":103000,"words":328,"minutes":2},"date":"2023-04-02 18:08:16","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> ,请你构造一个矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> ，使得：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><msub><mi>b</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">0&lt;b_{i,j}\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 的倍数</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 中相邻的两个数的差的绝对值可以写成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>k</mi><mn>4</mn></msup><mo>(</mo><mi>k</mi><mo>∈</mo><msup><mi mathvariant=\"double-struck\">N</mi><mo>+</mo></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">k^4(k\\in\\mathbb{N}^+)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">1\\le a_{i,j}\\le 16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.922078em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个 n×mn\\times mn×m 的矩阵 aaa ,请你构造一个矩阵 bbb ，使得： 0&lt;bi,j≤1060&lt;b_{i,j}\\le 10^60&lt;bi,j​≤106 bi,jb_{i,j}bi,j​ 是 ai,ja_{i,j}ai,j​ 的倍数 bbb 中相邻的两个数的差的绝对值可以写成 k4(k∈N+)k^4(k\\in\\mathbb{N}^+)k4(k∈N+) 1≤n,m≤5001\\le n,m\\le 5001≤n,m≤500，1≤ai,j≤161\\le a_{i,j}\\le 161≤ai,j​≤16。 以后看到这种范围很小的奇奇怪怪的倍数题都要往 lcm⁡\\operatorname{lcm}lcm 上想…… 观察到 lcm⁡(1,2,3,…,16)=720720\\operatorname{lcm}(1,2,3,\\dots,16)=720720lcm(1,2,3,…,16)=720720，并且 720720&gt;164720720&gt;16^4720720&gt;164，所以可以给方格黑白染色，黑色格子填 720720720720720720，白色格子填 720720−ai,j4720720-a_{i,j}^4720720−ai,j4​。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1485D Multiples and Power Differences 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1485d-multiples-and-power-differences-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":60000,"words":201,"minutes":2},"date":"2023-04-02 18:04:56","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>对于一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{1\\dots n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"minner mtight\">…</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，定义 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>(</mo><mi>a</mi><msub><mo>)</mo><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">b(a)_{1\\dots n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"minner mtight\">…</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>(</mo><mi>a</mi><msub><mo>)</mo><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><mi>j</mi><mi mathvariant=\"normal\">∣</mi><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo>&gt;</mo><msub><mi>a</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">b(a)_i = max\\{j | j &lt; i, a_j &gt; a_i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9456279999999999em;vertical-align:-0.286108em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>。特别地，若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>(</mo><mi>a</mi><msub><mo>)</mo><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">b(a)_i = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，表示不存在这样的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>。</p>\n<p>给定一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">p_{1\\dots n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"minner mtight\">…</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和值域大小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn><mo>≤</mo><mi>p</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">-1\\le p&lt;i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，请求出有多少个序列  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{1\\dots n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"minner mtight\">…</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 满足：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span></li>\n<li>对于所有满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p_i\\not=-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，都有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>(</mo><mi>a</mi><msub><mo>)</mo><mi>i</mi></msub><mo>=</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b(a)_i=p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p>答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模，满足答案至少为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>300</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 300,1\\le m\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 对于一个序列 a1…na_{1\\dots n}a1…n​，定义 b(a)1…nb(a)_{1\\dots n}b(a)1…n​，满足 b(a)i=max{j∣j&lt;i,aj&gt;ai}b(a)_i = max\\{j | j &lt; i, a_j &gt; a_i\\}b(a)i​=max{j∣j&lt;i,aj​&gt;ai​}。特别地，若 b(a)i=0b(a)_i = 0b(a)i​=0，表示不存在这样的 jjj。 给定一个序列 p1…np_{1\\dots n}p1…n​ 和值域大小 mmm，满足 −1≤p&lt;i-1\\le p&lt;i−1≤p&lt;i，请求出有多少个序列 a1…na_{1\\dots n}a1…n​ 满足： 1≤ai≤m1\\le a_i\\le m1≤ai​≤m 对于所有满足 pi=−1p_i\\not=-1pi​​=−1 的 iii，都有 b(a)i=pib(a)_i=p_ib(a)i​=pi​ 答案对 109+710^9+7109+7 取模，满足答案至少为 111。 1≤n≤300,1≤m≤1051\\le n\\le 300,1\\le m\\le 10^51≤n≤300,1≤m≤105。 观察到若 pi=−1p_i\\not=-1pi​​=−1，那么一定有 a[pi+1,i]≤ai,ai&lt;apia_{[p_i+1,i]}\\le a_i,a_i&lt;a_{p_i}a[pi​+1,i]​≤ai​,ai​&lt;api​​。 所以由于答案至少为 111，那么若对于所有满足 pi=−1p_i\\not=-1pi​​=−1 的 iii 都从 iii 向 pip_ipi​ 连一条有向边，这些边肯定不会相交： 观察到这些边构成了包含关系，并且内层的值一定小于等于外层的，所以不难想到堆，那么考虑建立一棵树，跑树形 dp。不难发现，关系只有大于和大于等于两种，所以考虑给树加上边权，边权为 111 表示父亲的值要大于儿子，边权为 000 表示父亲的值要大于等于儿子。 首先虚拟出一个点 n+1n+1n+1，令 pn+1=0p_{n+1}=0pn+1​=0。这么做是为了让所有 pi=0p_i=0pi​=0 联通，最后能够组成一棵树。 考虑 pi=−1p_i=-1pi​=−1 的点。显然，设 xxx 表示包含 iii 的最内层的边的右端点，在树上只要让 iii 的父亲为 xxx，边权为 000 即可。特别的，若 x=n+1x=n+1x=n+1，那么要让 iii 的父亲为 000，边权为 000： 接下来考虑 pi=−1p_i\\not=-1pi​​=−1 的点，朴素的想法是在树上让 iii 的父亲为 pip_ipi​，边权为 111。但是考虑如下情况： 显然要满足 a4≤a6&lt;a2a_4\\le a_6&lt;a_2a4​≤a6​&lt;a2​，那么在树上这样建边即可： 代码实现也不难，倒着扫即可。 建出树之后直接跑 dp 即可，在此不过多赘述。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; inline int read() { int s=0,w=1,c=getchar(); while(c&lt;'0'||c&gt;'9') c=='-'?w=-1,c=getchar():c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') s=s*10+c-'0',c=getchar(); return s*w; } const int S=305,MS=100005,SS=1000005,p=1000000007; int n,m; int pre[S],lst[S]; int esum,to[SS],c[SS],nxt[SS],h[S]; int dp[S][MS]; inline void add(int x,int y,int w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } inline void addd(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } void dfs(int u) { for(int j=1;j&lt;=m;j++) dp[u][j]=1; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; dfs(v); int presm=0; for(int j=1;j&lt;=m;j++) { addd(presm,dp[v][j-w]); dp[u][j]=1ll*dp[u][j]*presm%p; } } } int main() { freopen(&quot;stack.in&quot;,&quot;r&quot;,stdin); freopen(&quot;stack.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); for(int i=1;i&lt;=n;i++) pre[i]=read(); for(int i=1;i&lt;=n;i++) lst[i]=i; pre[n+1]=0; for(int i=n;i&gt;=1;i--) { if(pre[i]!=-1) { add(lst[pre[i]],i,lst[pre[i]]==pre[i]&amp;&amp;pre[i]!=0); lst[pre[i]]=i; } else { for(int j=i+1;j&lt;=n+1;j++) { if(pre[j]!=-1&amp;&amp;pre[j]&lt;i) { add(j==n+1?0:j,i,0); break; } } } } dfs(0); printf(&quot;%d\\n&quot;,dp[0][m]); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"【2022 NOIP 模拟赛 3】C. 单调栈 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-noip-mo-ni-sai-3-c-dan-diao-zhan-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":281000,"words":926,"minutes":5},"date":"2023-04-02 18:02:57","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>构造 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个集合，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">S_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>N</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 。</p>\n<p>每个集合满足以下条件：</p>\n<ul>\n<li>每个元素是不大于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 的正整数；</li>\n<li>对于两个相邻的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">S_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>，有且仅有一个数恰好在这两个集合中的一个里出现。</li>\n</ul>\n<p>定义这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个集合的分数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mi>c</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod\\limits_{i=1}^m cnt(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.329066em;vertical-align:-0.9776689999999999em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3513970000000004em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∏</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9776689999999999em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span></span></span></span> ，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">cnt(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">)</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 在所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个集合中出现的次数。</p>\n<p>求所有满足条件的集合簇的分数之和，答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le N,M\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span> 。</p>\n</blockquote>\n","content":" 构造 NNN 个集合，S1S_1S1​ 到 SNS_NSN​ 。 每个集合满足以下条件： 每个元素是不大于 MMM 的正整数； 对于两个相邻的集合 SiS_iSi​ 和 Si+1S_{i+1}Si+1​，有且仅有一个数恰好在这两个集合中的一个里出现。 定义这 NNN 个集合的分数为 ∏i=1mcnt(i)\\prod\\limits_{i=1}^m cnt(i)i=1∏m​cnt(i) ，其中 cnt(i)cnt(i)cnt(i) 为 iii 在所有 NNN 个集合中出现的次数。 求所有满足条件的集合簇的分数之和，答案对 998244353998244353998244353 取模。 1≤N,M≤2×1051\\le N,M\\le 2\\times 10^51≤N,M≤2×105 。 不难发现，元素是互相独立的，所以考虑某个元素 xxx 的情况，设 f(x)i=[x∈Si]f(x)_i=[x\\in S_i]f(x)i​=[x∈Si​]，那么 f(x)f(x)f(x) 一定是一个形如 [0,0,1,1,0,1][0,0,1,1,0,1][0,0,1,1,0,1] 这样的 010101 数组。 容易发现，由于有且仅有一个元素只被相邻的 Si,Si+1S_i,S_{i+1}Si​,Si+1​ 中的一个包含，设这个元素为 valival_ivali​。由于 vali=xval_i=xvali​=x 的 valival_ivali​ 已经确定了下来，不能再给别的元素用，所以当 posx={i∣vali=x}pos_x=\\{i|val_i=x\\}posx​={i∣vali​=x} 相同时，这两种方案对于其它元素来说是本质相同的。 观察到 vali=xval_i=xvali​=x 当且仅当 f(x)i=f(x)i+1f(x)_i\\not=f(x)_{i+1}f(x)i​​=f(x)i+1​，所以若给 f(x)f(x)f(x) 取反，即 111 变成 000，000 变成 111，posxpos_xposx​ 是不变的，所以其它元素出现次数的乘积也不变，设这个值为 VVV。假设取反之前 f(x)f(x)f(x) 中有 aaa 个 111，取反之后显然有 n−an-an−a 个，取反之前的答案是 V⋅aV\\cdot aV⋅a，取反之后的答案是 V⋅(n−a)V\\cdot (n-a)V⋅(n−a)，总的答案是这两部分的加和，观察到加和就是 nVnVnV，所以元素 xxx 对乘积的贡献就是 nnn。那么每种本质不同的方案的答案加起来就是 nmn^mnm。 考虑计算本质不同的方案数，显然所有方案数是 2mmn−12^mm^{n-1}2mmn−1，因为 S1S_1S1​ 可以任意选，之后的 SiS_iSi​ 和 Si−1S_{i-1}Si−1​ 只能有一个元素的差异。那么由于每种元素本质相同的方案都会算两次，所以本质不同的方案数就是 2mmn−12m=mn−1\\frac{2^mm^{n-1}}{2^m}=m^{n-1}2m2mmn−1​=mn−1，答案即为 nmmn−1n^mm^{n-1}nmmn−1。 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ARC147D Sets Scores 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/arc147d-sets-scores-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":171000,"words":654,"minutes":3},"date":"2023-04-02 17:59:45","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>有一无穷长的流水线 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，初始时 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo>≤</mo><mn>0</mn><mtext> 和 </mtext><mi>i</mi><mo>&gt;</mo><mn>2</mn><mi>n</mi><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\forall i\\le0\\text{ 和 } i&gt;2n ,a_i=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">和</span><span class=\"mord\"> </span></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。<strong>否则</strong>，若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为奇数，则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">a_i=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>；若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 为偶数，则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a_i=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。<strong>也就是说，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">a_i=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a_i=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 是交替出现的。</strong></p>\n<p>现需要进行若干次 <strong>如下</strong> 操作，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中的所有 <strong>非零元素</strong> 为 <strong>连续</strong> 的一段且所有的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 均在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> <strong>前面</strong>。</p>\n<p>选择两个位置 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>p</mi></msub><mi mathvariant=\"normal\">≠</mi><mn>0</mn><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant=\"normal\">≠</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a_p\\ne0,a_{p+1}\\ne0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>q</mi></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a_q=a_{q+1}=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>q</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 设为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{q+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 设为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{p+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，并且将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{p+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 均设为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。<strong>输出时将此操作表示为 <code>p to q</code>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>  和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 是具体的值）</strong>。</p>\n<p>最小化操作步数，并输出操作序列，出题人将用 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>Special Judge</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Special Judge}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord text\"><span class=\"mord\">Special Judge</span></span></span></span></span> 来评判您的答案的正确性。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">3\\le n\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 有一无穷长的流水线 aaa，初始时 ∀i≤0 和 i&gt;2n,ai=0\\forall i\\le0\\text{ 和 } i&gt;2n ,a_i=0∀i≤0 和 i&gt;2n,ai​=0。否则，若 iii 为奇数，则 ai=2a_i=2ai​=2；若 iii 为偶数，则 ai=1a_i=1ai​=1。也就是说，ai=2a_i=2ai​=2 和 ai=1a_i=1ai​=1 是交替出现的。 现需要进行若干次 如下 操作，使得 aaa 中的所有 非零元素 为 连续 的一段且所有的 111 均在 222 前面。 选择两个位置 ppp 和 qqq，满足 ap≠0,ap+1≠0a_p\\ne0,a_{p+1}\\ne0ap​​=0,ap+1​​=0 且 aq=aq+1=0a_q=a_{q+1}=0aq​=aq+1​=0，将 aqa_qaq​ 设为 apa_pap​，aq+1a_{q+1}aq+1​ 设为 ap+1a_{p+1}ap+1​，并且将 apa_pap​ 和 ap+1a_{p+1}ap+1​ 均设为 000。输出时将此操作表示为 p to q（ppp 和 qqq 是具体的值）。 最小化操作步数，并输出操作序列，出题人将用 Special Judge\\text{Special Judge}Special Judge 来评判您的答案的正确性。 3≤n≤1003\\le n\\le 1003≤n≤100。 容易证明操作次数下界是 nnn，因为设相邻两个类型相同的包裹有 ttt 组，初始 t=0t=0t=0，最终要令 t=2n−2t=2n-2t=2n−2。每次操作取出包裹时 ttt 不会增加，而放回则最多增加 222，并且第一次操作只能令 ttt 增加 111，所以操作次数下界为 1+⌈2n−32⌉=n1+\\lceil \\frac{2n-3}{2}\\rceil=n1+⌈22n−3​⌉=n。 手模一下 3≤n≤73\\le n\\le 73≤n≤7 的情况： OOOOOOBABABA OOOOABBOOABA OOOOABBBAAOO OOAAABBBOOOO OOOOOOOOBABABABA OOOOOOABBABABOOA OOOOOOABBAOOBBAA OOOOOOAOOABBBBOO OOOOOOAAAABBBBOO OOOOOOOOOOBABABABABA OOOOOOOOABBABABABOOA OOOOOOOOABBAOOBABBAA OOOOOOOOABBAABBOOBAA OOOOOOOOAAAAABBBBBOO OOOOOOOOOOOOBABABABABABA OOOOOOOOOOABBABABABABOOA OOOOOOOOOOABBABABAOOBBAA OOOOOOOOOOABBOOABAABBBAA OOOOOOOOOOABBAAABOOBBBAA OOOOOOOOOOAOOAAABBBBBBAA OOOOOOOOOOAAAAAABBBBBBOO OOOOOOOOOOOOOOBABABABABABABA OOOOOOOOOOOOABBABABABOOABABA OOOOOOOOOOOOABBABAOOBBAABABA OOOOOOOOOOOOABBABAABBBAABOOA OOOOOOOOOOOOABBAOOABBBAABBAA OOOOOOOOOOOOABBAAAABBBOOBBAA OOOOOOOOOOOOAOOAAAABBBBBBBAA OOOOOOOOOOOOAAAAAAABBBBBBBOO 不难发现，n&gt;3n&gt;3n&gt;3 时，第一步总是 2n-2 to -1，并且最后包裹总是停留在 [−1,2n−2][-1,2n-2][−1,2n−2]。那么考虑构造 n≥8n\\ge 8n≥8 的操作序列： OOO...OOOBA[BABABA...BABA]BABA OOO...OABBA[BABABA...BABA]BOOA OOO...OABBA[OOBABA...BABA]BBAA 此时若我们递归构造，将中括号内变成 AAA...AB...BBBOO，那么可以这样构造接下来的操作序列： OOO...OABBA[AAA...AB...BBBOO]BBAA OOO...OAOOA[AAA...AB...BBBBB]BBAA OOO...OAAAA[AAA...AB...BBBBB]BBOO 不难发现，这样在递归下去之前用了两次操作，递归完之后又用了两次操作，递归到到子问题 nnn 减少了 444，所以总共恰好使用了 nnn 次操作。 边界条件显然是 3≤n≤73\\le n\\le 73≤n≤7，因为此时递归到到子问题 nnn 就会 ≤3\\le 3≤3，不满足最后包裹停留在 [−1,2n−2][-1,2n-2][−1,2n−2]。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; inline void mov(int x,int y) { printf(&quot;%d to %d\\n&quot;,x,y); } void inline run3(int l) { mov(l+1,l-2); mov(l+4,l+1); mov(l+2,l-4); } void inline run4(int l) { mov(l+5,l-2); mov(l+2,l+5); mov(l-1,l+2); mov(l+6,l-1); } void inline run5(int l) { mov(l+7,l-2); mov(l+2,l+7); mov(l+5,l+2); mov(l-1,l+5); mov(l+8,l-1); } void inline run6(int l) { mov(l+9,l-2); mov(l+6,l+9); mov(l+1,l+6); mov(l+5,l+1); mov(l-1,l+5); mov(l+10,l-1); } void inline run7(int l) { mov(l+7,l-2); mov(l+4,l+7); mov(l+11,l+4); mov(l+2,l+11); mov(l+8,l+2); mov(l-1,l+8); mov(l+12,l-1); } inline void slove(int l,int r) { if((r-l+1)/2==3) { run3(l); return; } if((r-l+1)/2==4) { run4(l); return; } if((r-l+1)/2==5) { run5(l); return; } if((r-l+1)/2==6) { run6(l); return; } if((r-l+1)/2==7) { run7(l); return; } mov(r-2,l-2); mov(l+2,r-2); slove(l+4,r-4); mov(l-1,r-5); mov(r-1,l-1); } int main() { int n; scanf(&quot;%d&quot;,&amp;n); slove(1,n*2); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"P6892 [ICPC2014 WF]Baggage 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p6892-icpc2014-wfbaggage-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":277000,"words":916,"minutes":5},"date":"2023-04-02 17:57:03","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>扫雷地图是一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 列的网格，其中每个格子是地雷或空地。每个空地会显示一个数字代表与它相邻的雷的数量（两个格子相邻当且仅当它们共用一个顶点或一条边，不在边界上的格子与恰好 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 个格子相邻）。 在一次操作中，你可以将一个地雷改成空地，或将空地改成地雷。 给定两张扫雷地图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，你需要对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 进行不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mi>n</mi><mi>m</mi></mrow><mn>2</mn></mfrac><mo>⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor\\frac{nm}{2}\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mord mathdefault mtight\">m</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span> 次操作，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 所有空地上的数字之和等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 所有空地上的数字之和。</p>\n</blockquote>\n","content":" 扫雷地图是一张 nnn 行 mmm 列的网格，其中每个格子是地雷或空地。每个空地会显示一个数字代表与它相邻的雷的数量（两个格子相邻当且仅当它们共用一个顶点或一条边，不在边界上的格子与恰好 888 个格子相邻）。 在一次操作中，你可以将一个地雷改成空地，或将空地改成地雷。 给定两张扫雷地图 AAA 和 BBB，你需要对 AAA 进行不超过 ⌊nm2⌋\\lfloor\\frac{nm}{2}\\rfloor⌊2nm​⌋ 次操作，使得 AAA 所有空地上的数字之和等于 BBB 所有空地上的数字之和。 不难发现，对于一张给定的地图，数字的和有两种计算方式： 与每个空地格子相邻的地雷格子个数的和； 与每个地雷格子相邻的空地格子个数的和； 所以若把整个地图取反，即空地都变成地雷，地雷都变成空地，那么数字和不变。 设 BBB 取反之后的地图是 B′B&#x27;B′，把 AAA 变成 BBB 的最小操作次数是 xxx，把 AAA 变成 B′B&#x27;B′ 的最小操作次数是 yyy，那么由于 x+y≤nmx+y\\le nmx+y≤nm，所以根据抽屉原理，有 min⁡(x,y)≤⌊nm2⌋\\min(x,y)\\le \\lfloor\\frac{nm}{2}\\rfloormin(x,y)≤⌊2nm​⌋。所以把 AAA 变成 BBB 和 B′B&#x27;B′ 中需要更少次操作的即可。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"Mine Sweeper II 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/mine-sweeper-ii-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":83000,"words":367,"minutes":2},"date":"2023-04-02 17:56:03","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 列的棋盘，每个格子可能是空的或包含一个标志，标志有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>X</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{X}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">X</span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>O</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{O}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">O</span></span></span></span></span> 两种。</p>\n<p>如果有三个相同的标志排列在一行或一列上的三个连续的位置，则称这个棋盘是一个 <strong>胜局</strong>，<br>\n否则称其为 <strong>平局</strong>。</p>\n<figure data-type=\"image\" tabindex=\"1\"><img src=\"/../post-images/1680429260021.png\" alt=\"\" loading=\"lazy\"></figure>\n<p>例如，上图第一行的局面都是胜局，而第二行的局面都是平局。</p>\n<p>在一次操作中，你可以将一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>X</mtext></mrow><annotation encoding=\"application/x-tex\">\\text X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">X</span></span></span></span></span> 改成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>O</mtext></mrow><annotation encoding=\"application/x-tex\">\\text O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">O</span></span></span></span></span>，或将一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>O</mtext></mrow><annotation encoding=\"application/x-tex\">\\text O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">O</span></span></span></span></span> 改成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext>X</mtext></mrow><annotation encoding=\"application/x-tex\">\\text X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">X</span></span></span></span></span>。</p>\n<p>设棋盘中标志的总数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，你需要用不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌊</mo><mfrac><mi>k</mi><mn>3</mn></mfrac><mo>⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{k}{3}\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span><br>\n次操作把给定的局面变成平局。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding=\"application/x-tex\">1\\leq n\\leq 300</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一张 nnn 行 nnn 列的棋盘，每个格子可能是空的或包含一个标志，标志有 X\\text{X}X 和 O\\text{O}O 两种。 如果有三个相同的标志排列在一行或一列上的三个连续的位置，则称这个棋盘是一个 胜局， 否则称其为 平局。 例如，上图第一行的局面都是胜局，而第二行的局面都是平局。 在一次操作中，你可以将一个 X\\text XX 改成 O\\text OO，或将一个 O\\text OO 改成 X\\text XX。 设棋盘中标志的总数为 kkk，你需要用不超过 ⌊k3⌋\\lfloor \\frac{k}{3}\\rfloor⌊3k​⌋ 次操作把给定的局面变成平局。 1≤n≤3001\\leq n\\leq 3001≤n≤300。 看到 ⌊k3⌋\\lfloor\\frac{k}{3}\\rfloor⌊3k​⌋ 和 333 子棋就很容易想到抽屉原理，那么考虑把所有格子 (i,j)(i,j)(i,j) 按照 (i+j)mod 3(i+j)\\mod 3(i+j)mod3 分成三类。 不难发现，若 0≤x&lt;3,0≤y&lt;3,x=y0\\le x&lt;3,0\\le y&lt;3,x\\not=y0≤x&lt;3,0≤y&lt;3,x​=y，那么只要所有格子满足以下条件： 满足 (i+j)mod 3=x(i+j)\\mod 3=x(i+j)mod3=x 的有棋子的格子都为 X\\texttt{X}X； 满足 (i+j)mod 3=y(i+j)\\mod 3=y(i+j)mod3=y 的有棋子的格子都为 O\\texttt{O}O； 就可以使局面为平局，因为同一行上或同一列上相邻三个棋子的分类一定不同。 那么枚举 x,yx,yx,y 即可，不难发现有 666 种情况，所有情况的操作总次数为 2k2k2k。那么由于抽屉原理 ⌊2k6⌋=⌊k3⌋\\lfloor\\frac{2k}{6}\\rfloor=\\lfloor\\frac{k}{3}\\rfloor⌊62k​⌋=⌊3k​⌋，所以一定有一种情况合法。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=305; int n; char a[S][S],b[S][S]; inline int work(int tp1,int tp2) { int tot=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++) b[i][j]=a[i][j]; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { int id=(i+j)%3; if(a[i][j]=='X'&amp;&amp;id==tp1) tot++,b[i][j]='O'; if(a[i][j]=='O'&amp;&amp;id==tp2) tot++,b[i][j]='X'; } } return tot; } inline void print() { for(int i=1;i&lt;=n;i++) printf(&quot;%s\\n&quot;,b[i]+1); } inline void slove() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,a[i]+1); int k=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) k+=a[i][j]!='.'; for(int i=0;i&lt;3;i++) { for(int j=0;j&lt;3;j++) { if(i==j) continue; if(work(i,j)&lt;=k/3) { print(); return; } } } } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1450C2 Errich-Tac-Toe (Hard Version) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1450c2-errich-tac-toe-hard-version-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":199000,"words":674,"minutes":4},"date":"2023-04-02 17:53:21","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p>风见幽香的太阳花田是一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的矩阵。</p>\n<p><code>X</code> 的位置是空地，<code>.</code> 的位置是向日葵，Imakf <strong>保证给出的矩阵满足所有 <code>X</code> 两两之间的切比雪夫距离大于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>（没有公共点）</strong>。</p>\n<p>请把一些 <code>.</code> 换成 <code>X</code>，使得所有的 <code>X</code> 四连通且不存在简单环（形成一棵树）。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 风见幽香的太阳花田是一个 n×mn\\times mn×m 的矩阵。 X 的位置是空地，. 的位置是向日葵，Imakf 保证给出的矩阵满足所有 X 两两之间的切比雪夫距离大于 111（没有公共点）。 请把一些 . 换成 X，使得所有的 X 四连通且不存在简单环（形成一棵树）。 1≤n,m≤5001\\le n,m\\le 5001≤n,m≤500。 不难想到由于题目对 X\\texttt{X}X 的个数没有限制，所以可以让某些行全都是 X\\texttt{X}X 来使得整张图联通。 首先相邻两行都全是 X\\texttt{X}X 肯定是不行的，空一行也不行，因为有如下情况： XXXXXX X X X XXXXXX 而由于原图满足任意两个 X\\texttt{X}X 没有公共边和公共顶点，所以如果我们空两行，肯定不会形成环。此时所有全是 X\\texttt{X}X 的行都和它上面和下面两行联通，而和其它行不连通： XXXXXX X X X XXXXXX 考虑合并这些联通块，显然只需要合并相邻的全为 X\\texttt{X}X 的行即可。由于原图满足任意两个 X\\texttt{X}X 没有公共顶点，所以只需要找到这两行之间有 X\\texttt{X}X 的一列，让这一列不为 X\\texttt{X}X 的位置也为 X\\texttt{X}X 即可。若找不到这样的列那么直接让第一列的两个位置都为 X\\texttt{X}X。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=505; int n,m; char a[S][S]; inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,a[i]+1); for(int i=1+(n%3==0);i&lt;=n;i+=3) { for(int j=1;j&lt;=m;j++) a[i][j]='X'; if(i+2&lt;=n) { int pos=1; for(int j=2;j&lt;=m;j++) { if(a[i+1][j]=='X'||a[i+2][j]=='X') { pos=j; break; } } a[i+1][pos]=a[i+2][pos]='X'; } } for(int i=1;i&lt;=n;i++) printf(&quot;%s\\n&quot;,a[i]+1); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1495C Garden of the Sun 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1495c-garden-of-the-sun-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":144000,"words":530,"minutes":3},"date":"2023-04-02 17:51:27","dateFormat":"2023-04-02"},{"abstract":"<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n \\times k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个格子，编号从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n \\times k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，染成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 种颜色，每种颜色恰好 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个。<br>\n构造 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个区间，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个区间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[a_i, b_i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> 满足</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le a_i &lt; b_i \\le n \\times k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span></li>\n<li>第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 个和第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 个格子的颜色都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>。</li>\n<li>每个格子被包含不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>n</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil \\frac{n}{k-1} \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.153331em;vertical-align:-0.403331em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌉</span></span></span></span> 次。</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">2\\le k\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" n×kn \\times kn×k 个格子，编号从 111 到 n×kn \\times kn×k，染成 nnn 种颜色，每种颜色恰好 kkk 个。 构造 nnn 个区间，第 iii 个区间 [ai,bi][a_i, b_i][ai​,bi​] 满足 1≤ai&lt;bi≤n×k1 \\le a_i &lt; b_i \\le n \\times k1≤ai​&lt;bi​≤n×k 第 aia_iai​ 个和第 bib_ibi​ 个格子的颜色都是 iii。 每个格子被包含不超过 ⌈nk−1⌉\\lceil \\frac{n}{k-1} \\rceil⌈k−1n​⌉ 次。 1≤n≤1001\\le n\\le 1001≤n≤100，2≤k≤1002\\le k\\le 1002≤k≤100。 先求出 posi,jpos_{i,j}posi,j​ 表示颜色 iii 第 jjj 次出现的位置。 不难发现，只要把 nnn 个颜色分为 k−1k-1k−1 组，每组大小 ≤⌈nk−1⌉\\le \\lceil\\frac{n}{k-1}\\rceil≤⌈k−1n​⌉，不同组的区间互不相交即可。并且每个颜色选择区间 [posi,j,posi,j+1][pos_{i,j},pos_{i,j+1}][posi,j​,posi,j+1​] 肯定是最优的。 考虑较为简单的情况的构造，k=2k=2k=2 未免太简单了，考虑 k=3k=3k=3 的情况。这时要分 222 组，每组大小 ⌈n2⌉\\lceil\\frac{n}{2}\\rceil⌈2n​⌉，稍加思考可以发现，只要按照 posi,2pos_{i,2}posi,2​ 排序，前 ⌈n2⌉\\lceil\\frac{n}{2}\\rceil⌈2n​⌉ 个颜色选择区间 [posi,1,posi,2][pos_{i,1},pos_{i,2}][posi,1​,posi,2​]，其它颜色选择区间 [posi,2,posi,3][pos_{i,2},pos_{i,3}][posi,2​,posi,3​] 即可。 考虑推广这个构造方法，容易发现，只要重复 k−1k-1k−1 次，第 TTT 次按照 posi,T+1pos_{i,T+1}posi,T+1​ 排序，排序后前 ⌈nk−1⌉\\lceil\\frac{n}{k-1}\\rceil⌈k−1n​⌉ 个颜色选择区间 [posi,T,posi,T+1][pos_{i,T},pos_{i,T+1}][posi,T​,posi,T+1​] 即可。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=105; int n,k; int pos[S][S],tot[S]; int ansl[S],ansr[S]; int id[S]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n*k;i++) { int x; scanf(&quot;%d&quot;,&amp;x); pos[x][++tot[x]]=i; } int val=n/(k-1)+!!(n%(k-1)); for(int i=1;i&lt;=k-1;i++) { int cnt=0; for(int j=1;j&lt;=n;j++) if(ansl[j]==ansr[j]) id[++cnt]=j; sort(id+1,id+cnt+1,[&amp;](int x,int y){return pos[x][i+1]&lt;pos[y][i+1];}); for(int j=1;j&lt;=cnt&amp;&amp;j&lt;=val;j++) ansl[id[j]]=pos[id[j]][i],ansr[id[j]]=pos[id[j]][i+1]; } for(int i=1;i&lt;=n;i++) printf(&quot;%d %d\\n&quot;,ansl[i],ansr[i]); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1552E Colors and Intervals 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1552e-colors-and-intervals-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":187000,"words":602,"minutes":4},"date":"2023-04-02 17:48:22","dateFormat":"2023-04-02"},{"abstract":"","content":"Day 1 开局 10 min 写完 T1，然后发现 T2 T3 不会。 T2 想了很久，知道大概怎么做了，但是有很多细节，不会写。 T3 打两个 log 暴力走人。 估分：100+25+[35,48]=[160,173]100+25+[35,48]=[160,173]100+25+[35,48]=[160,173]。 Day 2 T1 写了 3.5h。 写完 T1 就 12 点了，直接开始打暴力。 T3 写了 10pts 爆搜剪枝。 T2 写了前五个点和特殊性质 A 的匈牙利。 最后 10 min 冲 T2 特殊性质 C，费用流板子，结果 spfa 队列爆内存了，电脑死机了。 估分：100+25+10=135100+25+10=135100+25+10=135。 赛后 云斗学院自测： Day1：T2 不知道为啥挂了，100+10+48=158100+10+48=158100+10+48=158 Day2：T1 过了大样例但是还是挂了，60+28+?=?60+28+?=?60+28+?=? CCF 数据：100+15+48+30+28+5=226100+15+48+30+28+5=226100+15+48+30+28+5=226。 ","tags":[{"name":2023,"slug":"duHpjt30p","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/duHpjt30p/"},{"name":"GDOI","slug":"m_dUCQqMxF","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/m_dUCQqMxF/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"}],"title":"GDOI2023 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/gdoi2023-you-ji/","stats":{"text":"2 min read","time":61000,"words":225,"minutes":2},"date":"2023-04-01 21:25:41","dateFormat":"2023-04-01"},{"abstract":"<blockquote>\n<p>有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的网格，刚开始每个格子都是白色的，你要把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的颜色通过以下三种方式变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>：</p>\n<ul>\n<li>涂白横着/竖着排列的若干格子，若涂了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 格，则代价为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mi>k</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">Ak+B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>；</li>\n<li>涂黑横着/竖着排列的若干格子，若涂了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 格，则代价为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mi>k</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">Ak+B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>；</li>\n<li>涂黑/涂白单独某个格子，代价为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>；</li>\n</ul>\n<p>一个格子不能被涂色超过两次，并且一个格子不能被涂白再涂黑。</p>\n<p>求最小代价。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>40</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 40</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi><mo>≤</mo><mn>40</mn></mrow><annotation encoding=\"application/x-tex\">0\\le A,B,C\\le 40</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi><mo>≤</mo><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">C\\le A+B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>。</p>\n</blockquote>\n","content":" 有一个 n×mn\\times mn×m 的网格，刚开始每个格子都是白色的，你要把 (i,j)(i,j)(i,j) 的颜色通过以下三种方式变为 ai,ja_{i,j}ai,j​： 涂白横着/竖着排列的若干格子，若涂了 kkk 格，则代价为 Ak+BAk+BAk+B； 涂黑横着/竖着排列的若干格子，若涂了 kkk 格，则代价为 Ak+BAk+BAk+B； 涂黑/涂白单独某个格子，代价为 CCC； 一个格子不能被涂色超过两次，并且一个格子不能被涂白再涂黑。 求最小代价。 1≤n,m≤401\\le n,m\\le 401≤n,m≤40，0≤A,B,C≤400\\le A,B,C\\le 400≤A,B,C≤40，C≤A+BC\\le A+BC≤A+B。 考虑最小割的本质，设点 uuu 最终在源点 SSS 所在的连通块则 bu=1b_u=1bu​=1，在汇点 TTT 所在的连通块则 bu=0b_u=0bu​=0，那么： 边 (S,x,a)(S,x,a)(S,x,a) 对答案的贡献为 a×(1−bx)a\\times (1-b_x)a×(1−bx​)； 边 (x,T,a)(x,T,a)(x,T,a) 对答案的贡献为 a×bxa\\times b_xa×bx​； 边 (x,y,a)(x,y,a)(x,y,a) 对答案的贡献为 a×bx(1−by)a\\times b_x(1-b_y)a×bx​(1−by​)； 回到本题，考虑涂色的顺序，显然可以分为三步： 横竖涂黑 横竖涂白 单点涂色 确认了第一步和第二步，第三步就可以唯一确定了，那么设： bhx,ybh_{x,y}bhx,y​ 为 [(x,y) 被横着涂黑][(x,y)\\text{ 被横着涂黑}][(x,y) 被横着涂黑]； bsx,ybs_{x,y}bsx,y​ 为 [(x,y) 未被竖着涂黑][(x,y)\\text{ 未被竖着涂黑}][(x,y) 未被竖着涂黑]； whx,ywh_{x,y}whx,y​ 为 [(x,y) 未被横着涂白][(x,y)\\text{ 未被横着涂白}][(x,y) 未被横着涂白]； wsx,yws_{x,y}wsx,y​ 为 [(x,y) 被横着涂白][(x,y)\\text{ 被横着涂白}][(x,y) 被横着涂白]； 现在来考虑代价，对于横竖涂色，考虑把 AkAkAk 算在每个格子上，把 BBB 算在末尾格子上。那么有贡献： A×bhx,yA\\times bh_{x,y}A×bhx,y​，B×bhx,y(1−bhx,y+1)B\\times bh_{x,y}(1-bh_{x,y+1})B×bhx,y​(1−bhx,y+1​)； A×bsx,yA\\times bs_{x,y}A×bsx,y​，B×bsx,y(1−bsx+1,y)B\\times bs_{x,y}(1-bs_{x+1,y})B×bsx,y​(1−bsx+1,y​)； A×whx,yA\\times wh_{x,y}A×whx,y​，B×whx,y(1−whx,y+1)B\\times wh_{x,y}(1-wh_{x,y+1})B×whx,y​(1−whx,y+1​)； A×wsx,yA\\times ws_{x,y}A×wsx,y​，B×wsx,y(1−wsx+1,y)B\\times ws_{x,y}(1-ws_{x+1,y})B×wsx,y​(1−wsx+1,y​)； 注意边界情况要特判。 然后考虑单点涂色的代价和不合法的情况，显然一个格子不会被以一个方向涂色两次，所以横竖涂色时一个格子的涂色次数不会超过 222 次，不会不合法： 最后要涂白的格子 (x,y)(x,y)(x,y)： 有贡献情况为该格被涂黑了，但未被涂白：C×whx,y(1−bsx,y)+C×bhx,y(1−wsx,y)C\\times wh_{x,y}(1-bs_{x,y})+C\\times bh_{x,y}(1-ws_{x,y})C×whx,y​(1−bsx,y​)+C×bhx,y​(1−wsx,y​)； 不合法情况为该格已被两次涂黑：∞×bhx,y(1−bsx,y)\\infin\\times bh_{x,y}(1-bs_{x,y})∞×bhx,y​(1−bsx,y​)； 最后要涂黑的格子 (x,y)(x,y)(x,y)： 由于涂白后不能再涂黑，所以有贡献的情况为该格未被涂黑：C×(1−bhx,y)+C×bsx,yC\\times (1-bh_{x,y})+C\\times bs_{x,y}C×(1−bhx,y​)+C×bsx,y​； 不合法情况为该格已被涂白：∞×(1−bhx,y)+∞×bsx,y\\infin\\times (1-bh_{x,y})+\\infin \\times bs_{x,y}∞×(1−bhx,y​)+∞×bsx,y​； 那么建图跑最小割即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int MS=45,S=10000,BS=100005; int n,m,A,B,C; char a[MS][MS]; int s,t; int esum,to[BS],c[BS],nxt[BS],h[S]; int dep[S]; inline void init() { esum=1; memset(h,0,sizeof(h)); s=0,t=n*m*4+1; } inline void add(int x,int y,int w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } inline void Add(int x,int y,int w) { // printf(&quot;%d %d %d\\n&quot;,x,y,w); add(x,y,w); add(y,x,0); } inline bool bfs() { memset(dep+s,0,(t-s+1)*sizeof(int)); dep[s]=1; queue&lt;int&gt; q; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[v]==0) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]!=0; } int dfs(int u,int w) { if(u==t) return w; int sum=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[v]==dep[u]+1) { int re=dfs(v,min(w,c[i])); c[i]-=re; c[i^1]+=re; w-=re; sum+=re; if(w==0) break; } } if(sum==0) dep[u]=0; return sum; } inline int dinic() { int ans=0; while(bfs()) ans+=dfs(s,1e8); return ans; } inline int getid(int x,int y,int id) { return (id-1)*n*m+(x-1)*m+y; } inline void slove() { scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;A,&amp;B,&amp;C); for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,a[i]+1); init(); // 1: 横着涂黑 // 2: 1-竖着涂黑 // 3: 1-横着涂白 // 4: 竖着涂白 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { Add(s,getid(i,j,1),0); Add(s,getid(i,j,2),A+(i==n)*B); Add(s,getid(i,j,3),A+(j==m)*B); Add(s,getid(i,j,4),0); Add(getid(i,j,1),t,A+(j==m)*B); Add(getid(i,j,2),t,0); Add(getid(i,j,3),t,0); Add(getid(i,j,4),t,A+(i==n)*B); } } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m-1;j++) { Add(getid(i,j,1),getid(i,j+1,1),B); Add(getid(i,j+1,3),getid(i,j,3),B); } } for(int i=1;i&lt;=n-1;i++) { for(int j=1;j&lt;=m;j++) { Add(getid(i+1,j,2),getid(i,j,2),B); Add(getid(i,j,4),getid(i+1,j,4),B); } } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(a[i][j]=='#') { Add(getid(i,j,2),getid(i,j,1),C); Add(s,getid(i,j,3),1e8); Add(getid(i,j,4),t,1e8); } else { Add(getid(i,j,1),getid(i,j,4),C); Add(getid(i,j,3),getid(i,j,2),C); Add(getid(i,j,1),getid(i,j,2),1e8); } } } printf(&quot;%d\\n&quot;,dinic()); } int main() { freopen(&quot;color.in&quot;,&quot;r&quot;,stdin); freopen(&quot;color.out&quot;,&quot;w&quot;,stdout); int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"网络流","slug":"19EjLeSB_D","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/19EjLeSB_D/"}],"title":"【2023NOI模拟赛19】color on board 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-19-color-on-board-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":497000,"words":1572,"minutes":9},"date":"2023-03-31 20:52:51","dateFormat":"2023-03-31"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个矩形 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>l</mi><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>r</mi><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>l</mi><msub><mi>y</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>r</mi><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(lx_i,rx_i,ly_i,ry_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，求选出三个互不相交的矩形的方案数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><msub><mi>x</mi><mi>i</mi></msub><mo>&lt;</mo><mi>r</mi><msub><mi>x</mi><mi>i</mi></msub><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le lx_i&lt;rx_i\\le 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><msub><mi>y</mi><mi>i</mi></msub><mo>&lt;</mo><mi>r</mi><msub><mi>y</mi><mi>i</mi></msub><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le ly_i&lt;ry_i\\le 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span>，所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">lx_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">rx_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 构成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列，所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">ly_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">ry_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 构成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列。</p>\n</blockquote>\n","content":" 给定 nnn 个矩形 (lxi,rxi,lyi,ryi)(lx_i,rx_i,ly_i,ry_i)(lxi​,rxi​,lyi​,ryi​)，求选出三个互不相交的矩形的方案数。 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤lxi&lt;rxi≤2n1\\le lx_i&lt;rx_i\\le 2n1≤lxi​&lt;rxi​≤2n，1≤lyi&lt;ryi≤2n1\\le ly_i&lt;ry_i\\le 2n1≤lyi​&lt;ryi​≤2n，所有 lxilx_ilxi​、rxirx_irxi​ 构成 2n2n2n 的排列，所有 lyily_ilyi​、ryiry_iryi​ 构成 2n2n2n 的排列。 考虑容斥，答案即为乱选的方案数，先减去钦定两个矩形有交的方案数，再加上钦定某个矩形和两个矩形有交的方案数，最后减掉三个矩形两两都有交的方案数。第一个显然就是 (n3)\\binom{n}{3}(3n​)，第二个和第三个可以通过算出和第 iii 个矩形相交的矩形个数 sumisum_isumi​ 来解决，先来考虑第四个。 考虑计算选择三个两两有交的矩形的方案数，有如下式子： ∑选 3 个不同的矩形 A,B,C[∣A∩B∩C∣=0]\\sum\\limits_{\\text{选 }3\\text{ 个不同的矩形 }A,B,C}[|A\\cap B\\cap C|\\not= 0] 选 3 个不同的矩形 A,B,C∑​[∣A∩B∩C∣​=0] 观察到 A∩B∩CA\\cap B\\cap CA∩B∩C 一定是一个矩形，本质上是数 A∩B∩CA\\cap B\\cap CA∩B∩C 有多少个简单连通块（内部没有洞）。那么考虑网格图上一种特殊的可以把数简单连通块个数转换为数面积的容斥：简单连通块个数等于 1×11\\times 11×1 的小联通块的个数，减去 1×21\\times 21×2 的小连通块的个数，减去 2×12\\times 12×1 的小连通块的个数，最后再加上 2×22\\times 22×2 的小连通块的个数。 这个容斥本质上其实相当于把连通块往下、往右缩，类似于点边容斥，最后每个凹进去的下右拐角会有 −1-1−1 的贡献，突出来的左上拐角会有 111 的贡献： 那么式子就变成了： 调换求和顺序： 显然可以四遍扫描线求解，维护组合数可以利用范德蒙德卷积和标记永久化。 然后考虑求解 sumisum_isumi​，仍套用以上容斥，扫描线用区间加区间查树状数组维护历史和即可，不用线段树是因为卡常。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int S=100005; struct node { int lx,rx,ly,ry; }; struct prr { int lx,rx; long long k,b; }; int n,on_my_love_ruiruiruiruirui__don_t__STAY______on_my_love_ruiruiruiruirui_non_t__STAY_____; node a[S]; vector&lt;prr&gt; vec[S*2],que[S*2]; int sum[S]; long long ans; namespace tr1 { struct node { long long k,b; inline node(){k=b=0;} inline node(long long x,long long y){k=x,b=y;} inline node operator+(node bb){return (node){k+bb.k,b+bb.b};} inline node operator*(int y){return (node){k*y,b*y};} inline node operator-(){return (node){-k,-b};} inline node operator-(node bb){return (node){k-bb.k,b-bb.b};} }tr1[S*2],tr2[S*2]; inline void clear(){memset(tr1,0,sizeof(tr1));memset(tr2,0,sizeof(tr2));} inline void addt(int p,node x){for(int i=p;i&lt;=n*2;i+=i&amp;-i) tr1[i]=tr1[i]+x,tr2[i]=tr2[i]+x*p;} inline node quet(int p) { node re1,re2; for(int i=p;i&gt;=1;i-=i&amp;-i) re1=re1+tr1[i],re2=re2+tr2[i]; return re1*(p+1)-re2; } void add(int l,int r,long long k,long long b) { node val(k,b); addt(l,val),addt(r+1,-val); } long long que(int l,int r,int tme) { node res=quet(r)-quet(l-1); return res.k*tme+res.b; } } namespace tr2 { long long val[4][S&lt;&lt;3]; int tag[S&lt;&lt;3]; void clear(int u,int l,int r) { val[0][u]=r-l+1,val[1][u]=val[2][u]=val[3][u]=0; tag[u]=0; if(l==r) return; int mid=l+r&gt;&gt;1; clear(u&lt;&lt;1,l,mid),clear(u&lt;&lt;1|1,mid+1,r); } inline void upd(int u,int l,int r) { if(l!=r) { int ls=u&lt;&lt;1,rs=u&lt;&lt;1|1; val[0][u]=val[0][ls]+val[0][rs]; val[1][u]=val[1][ls]+val[1][rs]; val[2][u]=val[2][ls]+val[2][rs]; val[3][u]=val[3][ls]+val[3][rs]; } else val[0][u]=1,val[1][u]=val[2][u]=val[3][u]=0; long long t0=val[0][u],t1=val[1][u],t2=val[2][u],t3=val[3][u]; long long w0=1,w1=tag[u],w2=1ll*tag[u]*(tag[u]-1)/2,w3=1ll*tag[u]*(tag[u]-1)*(tag[u]-2)/6; val[0][u]=t0*w0; val[1][u]=t0*w1+t1*w0; val[2][u]=t0*w2+t1*w1+t2*w0; val[3][u]=t0*w3+t1*w2+t2*w1+t3*w0; } void add(int u,int l,int r,int L,int R,int val) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R) return tag[u]+=val,upd(u,l,r),void(); int mid=l+r&gt;&gt;1; if(L&lt;=mid) add(u&lt;&lt;1,l,mid,L,R,val); if(R&gt;=mid+1) add(u&lt;&lt;1|1,mid+1,r,L,R,val); upd(u,l,r); } } inline void calcsum(int bse) { for(int i=1;i&lt;=n*2;i++) vec[i].clear(),que[i].clear(); tr1::clear(); for(int i=1;i&lt;=n;i++) { vec[a[i].ly].push_back((prr){a[i].lx,a[i].rx,1,-(a[i].ly-1)}); if(a[i].ry&lt;n*2) vec[a[i].ry+1].push_back((prr){a[i].lx,a[i].rx,-1,a[i].ry}); if(a[i].ly&gt;1) que[a[i].ly-1].push_back((prr){a[i].lx,a[i].rx,i,-1}); que[a[i].ry].push_back((prr){a[i].lx,a[i].rx,i,1}); } for(int i=1;i&lt;=n*2;i++) { for(prr &amp;u:vec[i]) tr1::add(u.lx,u.rx,u.k,u.b); for(prr &amp;u:que[i]) sum[u.k]+=bse*u.b*tr1::que(u.lx,u.rx,i); } } inline void calcans(int bse) { for(int i=1;i&lt;=n*2;i++) vec[i].clear(); tr2::clear(1,1,n*2); for(int i=1;i&lt;=n;i++) { vec[a[i].ly].push_back((prr){a[i].lx,a[i].rx,1,0}); if(a[i].ry&lt;n*2) vec[a[i].ry+1].push_back((prr){a[i].lx,a[i].rx,-1,0}); } for(int i=1;i&lt;=n*2;i++) { for(prr &amp;u:vec[i]) tr2::add(1,1,n*2,u.lx,u.rx,u.k); ans+=bse*tr2::val[3][1]; } } int main() { freopen(&quot;gift.in&quot;,&quot;r&quot;,stdin); freopen(&quot;gift.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;on_my_love_ruiruiruiruirui__don_t__STAY______on_my_love_ruiruiruiruirui_non_t__STAY_____); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;a[i].lx,&amp;a[i].rx,&amp;a[i].ly,&amp;a[i].ry); calcsum(1); calcans(1); for(int i=1;i&lt;=n;i++) a[i].rx--; calcsum(-1); calcans(-1); for(int i=1;i&lt;=n;i++) a[i].rx++; for(int i=1;i&lt;=n;i++) a[i].ry--; calcsum(-1); calcans(-1); for(int i=1;i&lt;=n;i++) a[i].ry++; for(int i=1;i&lt;=n;i++) a[i].rx--,a[i].ry--; calcsum(1); calcans(1); for(int i=1;i&lt;=n;i++) a[i].rx++,a[i].ry++; for(int i=1;i&lt;=n;i++) sum[i]--; long long res1=1ll*n*(n-1)*(n-2)/6; long long res2=0,res3=0; for(int i=1;i&lt;=n;i++) { res2+=1ll*sum[i]*(n-2); res3+=1ll*sum[i]*(sum[i]-1)/2; } res2/=2; printf(&quot;%lld\\n&quot;,res1-res2+res3-ans); return 0; } ","tags":[{"name":"容斥","slug":"1Ur0PWueZ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/1Ur0PWueZ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"}],"title":"【2023NOI模拟赛18】送分题 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-18-song-fen-ti-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":524000,"words":1610,"minutes":9},"date":"2023-03-29 22:05:44","dateFormat":"2023-03-29"},{"abstract":"<blockquote>\n<p>对于一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mclose\">]</span></span></span></span> 的正整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>k</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_1,a_2,a_3,\\dots,a_k\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>，定义它的逆转函数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 为满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mi>f</mi><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><msub><mi>a</mi><mn>3</mn></msub><mo>)</mo><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><msub><mi>a</mi><mi>k</mi></msub><mo>)</mo><mo>}</mo><mo>=</mo><mo>{</mo><msub><mi>a</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{f(a_1),f(a_2),f(a_3),\\dots,f(a_k)\\}=\\{a_k,a_{k-1},a_{k-2},\\dots,a_1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> 的定义域和值域均为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mclose\">]</span></span></span></span> 的函数。</p>\n<p>给定长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mclose\">]</span></span></span></span> 的正整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，定义 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">g(l,r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mi>l</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>r</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_l,a_{l+1},a_{l+2},\\dots,a_r\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> 的逆转函数个数，你需要求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mi>l</mi></mrow><mi>n</mi></msubsup><mi>g</mi><mo>(</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^n g(l,r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.35351em;vertical-align:-1.002113em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.351397em;\"><span style=\"top:-2.097887em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.000005em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.002113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.351397em;\"><span style=\"top:-2.097887em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span style=\"top:-3.000005em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.002113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> 对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 3\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 对于一个长度为 kkk，值域 [1,m][1,m][1,m] 的正整数序列 {a1,a2,a3,…,ak}\\{a_1,a_2,a_3,\\dots,a_k\\}{a1​,a2​,a3​,…,ak​}，定义它的逆转函数 fff 为满足 {f(a1),f(a2),f(a3),…,f(ak)}={ak,ak−1,ak−2,…,a1}\\{f(a_1),f(a_2),f(a_3),\\dots,f(a_k)\\}=\\{a_k,a_{k-1},a_{k-2},\\dots,a_1\\}{f(a1​),f(a2​),f(a3​),…,f(ak​)}={ak​,ak−1​,ak−2​,…,a1​} 的定义域和值域均为 [1,m][1,m][1,m] 的函数。 给定长度为 nnn，值域 [1,m][1,m][1,m] 的正整数序列 aaa，定义 g(l,r)g(l,r)g(l,r) 为 {al,al+1,al+2,…,ar}\\{a_l,a_{l+1},a_{l+2},\\dots,a_r\\}{al​,al+1​,al+2​,…,ar​} 的逆转函数个数，你需要求出 ∑l=1n∑r=lng(l,r)\\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^n g(l,r)l=1∑n​r=l∑n​g(l,r) 对 998244353998244353998244353 取模的结果。 1≤n,m≤3×1051\\le n,m\\le 3\\times 10^51≤n,m≤3×105。 不难发现，若一个序列存在逆转函数，那么它的逆转函数的个数就是 mm−cntm^{m-cnt}mm−cnt，其中 cntcntcnt 是这个序列中不同整数的个数。 考虑 O(nm)O(nm)O(nm) 暴力，由于翻转的性质，枚举中心点显然是更方便的，那么可以暴力从中心点往两边拓展，开桶维护答案。 考虑优化，先考虑长度为奇数的区间，设 a[i−leni,i+leni]a_{[i-len_i,i+len_i]}a[i−leni​,i+leni​]​ 是以 iii 为中心的最长的合法子区间。不难发现由于逆转函数的性质，对于每个 iii，若存在 p&lt;ip&lt;ip&lt;i 且 i≤p+lenpi\\le p+len_pi≤p+lenp​，那么 lenilen_ileni​ 至少是 min⁡(len2p−i,p+lenp−i)\\min(len_{2p-i},p+len_p-i)min(len2p−i​,p+lenp​−i)，因为这两个区间构成双射： 那么根据这个性质，我们可以直接套 manacher，这样就可以求出每个位置的 lenilen_ileni​。 考虑方案数怎么求，在继承区间的时候，若已经知道当前区间内有多少个不同的数 smcntsmcntsmcnt，且知道所有 [i−j,i+j][i-j,i+j][i−j,i+j]（j≤min⁡(len2p−i,p+lenp−i)j\\le \\min(len_{2p-i},p+len_p-i)j≤min(len2p−i​,p+lenp​−i)）的区间的答案的和 smanssmanssmans，那么在暴力拓展的时候就可以直接利用前驱后继来快速维护这两个东西。 考虑在继承的时候如何快速获取这两个东西，显然继承的区间一定也是由某个区间继承过来的，并且一个区间只会从一个区间继承过来，那么设 iii 是从 faifa_ifai​ 继承过来的，继承过来的区间为 [i−len1i,i+len1i][i-len1_i,i+len1_i][i−len1i​,i+len1i​]，暴力拓展后的区间为 [i−len2i,i+len2i][i-len2_i,i+len2_i][i−len2i​,i+len2i​]。 那么在暴力拓展的时候可以开个 vector 维护拓展到每个位置的状态 (smcnt,smans)(smcnt,smans)(smcnt,smans)，继承的时候倍增找到第一个 len1j&lt;min⁡(len2p−i,p+lenp−i)len1_j&lt;\\min(len_{2p-i},p+len_p-i)len1j​&lt;min(len2p−i​,p+lenp​−i) 的 jjj 从它的 vector 里继承过来即可。 需要注意的是 len1len1len1 没有单调性，所以要记一下路径上的 min⁡\\minmin。 长度为偶数的情况也是好做的，再跑一次即可。 代码如下： // Problem: #196. 逆转函数 // Contest: Hydro // URL: http://oiclass.com/d/AKNOI/p/196 // Memory Limit: 128 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int S=300005,BS=25; const int p=998244353; int n,m; int a[S],pos[S]; int lft[S],rig[S]; int len1[S],len2[S]; int fa[S][BS],mn[S][BS]; vector&lt;pair&lt;int,int&gt;&gt; sum[S]; int ans; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=y&amp;1?1LL*res*x%p:res; return res; } inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { freopen(&quot;invfunc.in&quot;,&quot;r&quot;,stdin); freopen(&quot;invfunc.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) pos[i]=0; for(int i=1;i&lt;=n;i++) { lft[i]=pos[a[i]]; pos[a[i]]=i; } for(int i=1;i&lt;=m;i++) pos[i]=n+1; for(int i=n;i&gt;=1;i--) { rig[i]=pos[a[i]]; pos[a[i]]=i; } for(int i=0;i&lt;=n;i++) { len1[i]=len2[i]=0; memset(fa[i],0,sizeof(fa[i])); memset(mn[i],127,sizeof(mn[i])); sum[i].clear(); } memset(mn[0],0,sizeof(mn[0])); sum[0].push_back(make_pair(1,qpow(m,m-1))); for(int i=1,j=0;i&lt;=n;i++) { int pp=0; if(i&lt;=j+len2[j]) { pp=2*j-i; len1[i]=min(len2[pp],j+len2[j]-i); } fa[i][0]=pp; mn[i][0]=len1[i]; for(int k=1;k&lt;=BS-3;k++) { fa[i][k]=fa[fa[i][k-1]][k-1]; mn[i][k]=min(mn[i][k-1],mn[fa[i][k-1]][k-1]); } int pp2=pp; for(int k=BS-3;k&gt;=0;k--) if(mn[pp2][k]&gt;len1[i]) pp2=fa[pp2][k]; sum[i].push_back(sum[pp2][len1[i]-len1[pp2]]); len2[i]=len1[i]; int smcnt=sum[i][0].first,smans=sum[i][0].second; len2[i]++; while(1) { if(i-len2[i]&lt;1||i+len2[i]&gt;n) { len2[i]--; break; } if(rig[i-len2[i]]&lt;i+len2[i]) { int pp=rig[i-len2[i]]; if(a[i+len2[i]]!=a[2*i-pp]) { len2[i]--; break; } } else smcnt++; if(lft[i+len2[i]]&gt;=i-len2[i]) { int pp=lft[i+len2[i]]; if(a[i-len2[i]]!=a[2*i-pp]) { len2[i]--; break; } } else smcnt++; add(smans,qpow(m,m-smcnt)); sum[i].push_back(make_pair(smcnt,smans)); len2[i]++; } if(i+len2[i]&gt;j+len2[j]) j=i; } for(int i=1;i&lt;=n;i++) add(ans,sum[i][sum[i].size()-1].second); for(int i=0;i&lt;=n;i++) { len1[i]=len2[i]=-1; memset(fa[i],0,sizeof(fa[i])); memset(mn[i],127,sizeof(mn[i])); sum[i].clear(); } memset(mn[0],-1,sizeof(mn[0])); sum[0].push_back(make_pair(0,0)); for(int i=1,j=0;i&lt;=n-1;i++) { int pp=0; if(i&lt;=j+1+len2[j]) { pp=2*j-i; len1[i]=min(len2[pp],j+len2[j]-i); } fa[i][0]=pp; mn[i][0]=len1[i]; for(int k=1;k&lt;=BS-3;k++) { fa[i][k]=fa[fa[i][k-1]][k-1]; mn[i][k]=min(mn[i][k-1],mn[fa[i][k-1]][k-1]); } int pp2=pp; for(int k=BS-3;k&gt;=0;k--) if(mn[pp2][k]&gt;len1[i]) pp2=fa[pp2][k]; sum[i].push_back(sum[pp2][len1[i]-len1[pp2]]); len2[i]=len1[i]; int smcnt=sum[i][0].first,smans=sum[i][0].second; len2[i]++; while(1) { if(i-len2[i]&lt;1||i+1+len2[i]&gt;n) { len2[i]--; break; } if(rig[i-len2[i]]&lt;i+1+len2[i]) { int pp=rig[i-len2[i]]; if(a[i+1+len2[i]]!=a[2*i+1-pp]) { len2[i]--; break; } } else smcnt++; if(lft[i+1+len2[i]]&gt;=i-len2[i]) { int pp=lft[i+1+len2[i]]; if(a[i-len2[i]]!=a[2*i+1-pp]) { len2[i]--; break; } } else smcnt++; add(smans,qpow(m,m-smcnt)); sum[i].push_back(make_pair(smcnt,smans)); len2[i]++; } if(i+len2[i]&gt;j+len2[j]) j=i; } for(int i=1;i&lt;=n-1;i++) add(ans,sum[i][sum[i].size()-1].second); printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"【2023NOI模拟赛17】逆转函数 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-17-ni-zhuan-han-shu-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":534000,"words":1665,"minutes":9},"date":"2023-03-29 11:09:13","dateFormat":"2023-03-29"},{"abstract":"<blockquote>\n<p>给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mo>−</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator=\"true\">,</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[-2\\times 10^{9},2\\times 10^{9}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> 的整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，要求构造一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，值域 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[-10^{10},10^{10}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> 的正数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，满足对于每一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，都可以找到一对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(j,k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 可以等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>），满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub><mo>+</mo><msub><mi>b</mi><mi>k</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_j+b_k=a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，或者报告无解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 30</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长度为 nnn，值域 [−2×109,2×109][-2\\times 10^{9},2\\times 10^{9}][−2×109,2×109] 的整数序列 aaa，要求构造一个长度为 nnn，值域 [−1010,1010][-10^{10},10^{10}][−1010,1010] 的正数序列 bbb，满足对于每一个 1≤i≤n1\\le i\\le n1≤i≤n 的 iii，都可以找到一对 (j,k)(j,k)(j,k)（jjj 可以等于 kkk），满足 bj+bk=aib_j+b_k=a_ibj​+bk​=ai​，或者报告无解。 1≤n≤301\\le n\\le 301≤n≤30。 考虑一个合法的解 bbb，建出一个 nnn 个点的图，把每个 aaa 中元素的拆分都看作一条边，那么由于有 nnn 条边所以一定有环。 如果 aaa 中元素都是奇数，那么考虑图中的一个环 b1,b2,…,bkb_1,b_2,\\dots,b_kb1​,b2​,…,bk​，ai=bi+bi+1a_i=b_i+b_{i+1}ai​=bi​+bi+1​（bk+1=b1b_{k+1}=b_1bk+1​=b1​），一定有 ∑i=1kai=2∑i=1nbi\\sum\\limits_{i=1}^k a_i=2\\sum\\limits_{i=1}^{n}b_ii=1∑k​ai​=2i=1∑n​bi​，所以 2∣k2|k2∣k。所以有 a1+a3+⋯+ak−1=∑i=1kbi=a2+a4+⋯+aka_1+a_3+\\dots+a_{k-1}=\\sum\\limits_{i=1}^k b_i=a_2+a_4+\\dots+a_ka1​+a3​+⋯+ak−1​=i=1∑k​bi​=a2​+a4​+⋯+ak​。 那么若能找到 aaa 的两个不交的非空子集 AAA、BBB，满足 ∣A∣=∣B∣|A|=|B|∣A∣=∣B∣ 且 ∑u∈Au=∑u∈Bu\\sum\\limits_{u\\in A}u=\\sum\\limits_{u\\in B}uu∈A∑​u=u∈B∑​u 则可以令 b1=0b_1=0b1​=0 然后构造出解，否则一定无解。 注意到 aaa 包含偶数的情况可以直接把那个偶数拆成两个相同的数相加来做，所以问题就变成了找到 aaa 的两个不交的非空子集 AAA、BBB，满足 ∣A∣=∣B∣|A|=|B|∣A∣=∣B∣ 且 ∑u∈Au=∑u∈Bu\\sum\\limits_{u\\in A}u=\\sum\\limits_{u\\in B}uu∈A∑​u=u∈B∑​u。 考虑令 ai′=ai+1+∑i=1n∣ai∣a&#x27;_i=a_i+1+\\sum\\limits_{i=1}^n |a_i|ai′​=ai​+1+i=1∑n​∣ai​∣，则问题就变成了找到 aaa 的两个不交的非空子集 AAA、BBB，满足 ∑u∈Au=∑u∈Bu\\sum\\limits_{u\\in A}u=\\sum\\limits_{u\\in B}uu∈A∑​u=u∈B∑​u。注意这是个经典背包问题，那么可以直接折半，枚举前一半集合划分的所有状态、后一半集合划分的所有状态，哈希表合并即可。 注意构造答案的时候要贪心，具体就是大于等于 000 时选最大的 aia_iai​ 填入，小于 000 时选最小的 aia_iai​ 填入，这样才能保证构造出来的 bbb 合法。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=35,MS=20000005,hashp=20000003; struct node { long long st,val; }; struct hashmap { int esum,nxt[MS],h[hashp]; node dat[MS]; inline void ins(node x) { int id=(x.val%hashp+hashp)%hashp; dat[++esum]=x; nxt[esum]=h[id]; h[id]=esum; } inline long long fnd(long long sm) { int id=(sm%hashp+hashp)%hashp; for(int i=h[id];i;i=nxt[i]) if(dat[i].val==sm) return dat[i].st; return -1; } }; int n; long long sum,a[S],b[S]; hashmap hmap; long long ans; vector&lt;pair&lt;long long,int&gt;&gt; st1,st2; bool vis[S]; int tot; long long res[S]; void dfs1(int u,long long st,long long sm) { if(u==n/2+1) return hmap.ins((node){st,sm}),void(); dfs1(u+1,st*3+0,sm); dfs1(u+1,st*3+1,sm+b[u]); dfs1(u+1,st*3+2,sm-b[u]); } void dfs2(int u,long long st,long long sm) { if(u==n+1) { long long res=hmap.fnd(-sm); if(res!=-1&amp;&amp;ans==0) { for(int i=1;i&lt;=n-n/2;i++) res*=3; res+=st; ans=res; } return; } dfs2(u+1,st*3+0,sm); dfs2(u+1,st*3+1,sm+b[u]); dfs2(u+1,st*3+2,sm-b[u]); } int main() { scanf(&quot;%d&quot;,&amp;n); sum=1; for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),sum+=llabs(a[i]); for(int i=1;i&lt;=n;i++) b[i]=a[i]+sum; for(int i=1;i&lt;=n;i++) { if(a[i]&amp;1^1) { long long x=a[i]/2; puts(&quot;Yes&quot;); for(int j=1;j&lt;=n;j++) printf(&quot;%lld &quot;,a[j]-x); printf(&quot;\\n&quot;); for(int j=1;j&lt;=n;j++) printf(&quot;%d %d\\n&quot;,i,j); return 0; } } dfs1(1,0,0),dfs2(n/2+1,0,0); if(ans==0) return puts(&quot;No&quot;),0; for(int i=n;i&gt;=1;i--) { if(ans%3==1) st1.push_back(make_pair(a[i],i)); if(ans%3==2) st2.push_back(make_pair(a[i],i)); ans/=3; } sort(st1.begin(),st1.end()),sort(st2.begin(),st2.end()); int l1=0,r1=st1.size()-1,l2=0,r2=st2.size()-1; long long pre=0; for(int i=0;i&lt;st1.size();i++) { if(pre&lt;0) { res[++tot]=pre; vis[st1[l1].second]=true; pre=st1[l1].first-pre; l1++; } else { res[++tot]=pre; vis[st1[r1].second]=true; pre=st1[r1].first-pre; r1--; } if(pre&lt;0) { res[++tot]=pre; vis[st2[l2].second]=true; pre=st2[l2].first-pre; l2++; } else { res[++tot]=pre; vis[st2[r2].second]=true; pre=st2[r2].first-pre; r2--; } } for(int i=1;i&lt;=n;i++) if(!vis[i]) res[++tot]=a[i]; puts(&quot;Yes&quot;); for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,res[i]); printf(&quot;\\n&quot;); for(int i=1;i&lt;=n;i++) { bool f=false; for(int j=1;j&lt;=n&amp;&amp;!f;j++) { for(int k=1;k&lt;=n&amp;&amp;!f;k++) { if(res[j]+res[k]==a[i]) { f=true; printf(&quot;%d %d\\n&quot;,j,k); } } } if(!f) puts(&quot;NO&quot;); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛17】出题人 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-17-chu-ti-ren-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":396000,"words":1220,"minutes":7},"date":"2023-03-28 19:22:01","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n \\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，求满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中任意一个元素等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 中与其相邻元素的异或和的矩阵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的异或和。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">2 \\le n \\le 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 是偶数。</p>\n</blockquote>\n","content":" 给定 n×nn \\times nn×n 的矩阵 aaa，求满足 aaa 中任意一个元素等于 bbb 中与其相邻元素的异或和的矩阵 bbb 的异或和。 2≤n≤10002 \\le n \\le 10002≤n≤1000，nnn 是偶数。 直接在斜线上面构造即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1005; int n,a[S][S]; inline void slove() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); int ans=0; for(int i=1;i&lt;=n+n-1;i+=4) { int sx=1+max(i-n,0),sy=min(i,n); for(int i=1;i&lt;=n;i+=2) { int px=sx+i-1,py=sy-i+1; if(px&lt;1||px&gt;n||py&lt;1||py&gt;n) break; ans^=a[px][py]; } sx=1+max(i-n,0),sy=max(1,n-i+1); for(int i=1;i&lt;=n;i+=2) { int px=sx+i-1,py=sy+i-1; if(px&lt;1||px&gt;n||py&lt;1||py&gt;n) break; ans^=a[px][py]; } } printf(&quot;%d\\n&quot;,ans); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1628C Grid Xor 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1628c-grid-xor-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":86000,"words":255,"minutes":2},"date":"2023-03-28 19:08:20","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定一棵无根树，有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个顶点。在这棵树上有一个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，你希望找到它。</p>\n<p>要找到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，你可以进行  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次查询 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mn>2</mn></msub><mi mathvariant=\"normal\">，</mi><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_1 , v_2 ，\\ldots , v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 是树中的各个顶点)。当你进行完所有查询后，你会得到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>d</mi><mn>2</mn></msub><mi mathvariant=\"normal\">，</mi><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_1 , d_2 ，\\ldots , d_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 之间的最短路径上的边数)。注意，您知道哪个距离对应于哪个查询。</p>\n<p>请你求出最小的  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> ，使存在这样的一些查询 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mn>2</mn></msub><mi mathvariant=\"normal\">，</mi><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_1 , v_2 ，\\ldots , v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，让你总能找到唯一的一个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> (无论 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 是什么)。</p>\n<p>注意，你不需要输出这些查询。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一棵无根树，有 nnn 个顶点。在这棵树上有一个顶点 xxx，你希望找到它。 要找到 xxx，你可以进行 kkk 次查询 v1,v2，…,vkv_1 , v_2 ，\\ldots , v_kv1​,v2​，…,vk​ (其中 viv_ivi​ 是树中的各个顶点)。当你进行完所有查询后，你会得到 kkk 个数字 d1,d2，…,dkd_1 , d_2 ，\\ldots , d_kd1​,d2​，…,dk​ ，(did_idi​ 是 viv_ivi​ 和 xxx 之间的最短路径上的边数)。注意，您知道哪个距离对应于哪个查询。 请你求出最小的 kkk ，使存在这样的一些查询 v1,v2，…,vkv_1 , v_2 ，\\ldots , v_kv1​,v2​，…,vk​ ，让你总能找到唯一的一个节点 xxx (无论 xxx 是什么)。 注意，你不需要输出这些查询。 1≤n≤2×1051 \\le n \\le 2\\times 10^51≤n≤2×105。 首先特掉 n=1n=1n=1 和链的情况。 不难发现查询所有度为 111 的叶子节点一定是可以的。 具体证明： 可以考虑从这些节点开始染色，遇到度数 ≥3\\ge 3≥3 的点停下（度数 ≥3\\ge 3≥3 的点不染色）。 那么若神秘点染了色那么一定能找到，否则删掉所有染了色的点后还是相当于询问了所有叶子节点，重复上述过程即可得证。 考虑从每个叶子节点 uuu 开始染色停下的节点 touto_utou​，设 Sx={u∣tou=x}S_x=\\{u|to_u=x\\}Sx​={u∣tou​=x}，那么答案即为 ∑max⁡(∣Sx∣−1,0)\\sum \\max(|S_x|-1,0)∑max(∣Sx​∣−1,0)。 证明如下： 柿子的本质就是每个 SxS_xSx​ 里可以少选一个，假设最后选的集合为 AAA，那么考虑所有满足 u∈A,v∈A,u=vu\\in A,v\\in A,u\\not=vu∈A,v∈A,u​=v 的 u,vu,vu,v，那么 u,vu,vu,v 之间的路径上的点都可以找到，把这些点染色。 考虑最后没被染色的点，显然它们构成了若干条链，每条链都一端“挂在”某两个被选择的点的路径上，所以也可以确定。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=500005; int n; int esum,to[S],nxt[S],h[S]; int d[S]; int tot,siz[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } int dfs(int u,int fa) { int res=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; res+=dfs(v,u); } if(d[u]&gt;=3) { tot+=res&gt;0; return 0; } if(d[u]==1) return 1; return res; } inline void slove() { scanf(&quot;%d&quot;,&amp;n); esum=0; for(int i=1;i&lt;=n;i++) h[i]=d[i]=0; for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); d[x]++,d[y]++; } if(n==1) { puts(&quot;0&quot;); return; } int ans=0; for(int i=1;i&lt;=n;i++) ans+=d[i]==1; bool f=false; for(int i=1;i&lt;=n;i++) { if(d[i]&gt;=3) { f=true; tot=0; dfs(i,0); break; } } if(!f) { puts(&quot;1&quot;); return; } ans-=tot; printf(&quot;%d\\n&quot;,ans); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1695D2 Tree Queries (Hard Version) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1695d2-tree-queries-hard-version-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":210000,"words":744,"minutes":4},"date":"2023-03-28 19:04:35","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>有排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">nxt_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">x</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 右侧第一个大于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的数的位置，若不存在则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">nxt_i=n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">x</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>现在整个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">nxt</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">t</span></span></span></span> 的一部分丢失了，请根据剩余的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">nxt</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">t</span></span></span></span>，构造出一个符合情况的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，输出任意一解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有排列 ppp，令 nxtinxt_inxti​ 为 pip_ipi​ 右侧第一个大于 pip_ipi​ 的数的位置，若不存在则 nxti=n+1nxt_i=n+1nxti​=n+1。 现在整个 ppp 和 nxtnxtnxt 的一部分丢失了，请根据剩余的 nxtnxtnxt，构造出一个符合情况的 ppp，输出任意一解。 1≤n≤5×1051\\le n\\le 5\\times 10^51≤n≤5×105。 O(n)O(n)O(n) 单调栈+递归构造即可，完全不需要线段树优化建图跑拓扑。 首先发现由于 nxti=min⁡{j∣j&gt;i,pj&gt;pj}nxt_i=\\min\\{j|j&gt;i,p_j&gt;p_j\\}nxti​=min{j∣j&gt;i,pj​&gt;pj​}，所以 a[i,nxti−1]a_{[i,nxt_i-1]}a[i,nxti​−1]​ 都要比 anxtia_{nxt_i}anxti​​ 小，nxt[i,nxti−1]nxt_{[i,nxt_i-1]}nxt[i,nxti​−1]​ 也都要小于等于 nxtinxt_inxti​。设 firi=min⁡{j∣nxtj=i}fir_i=\\min\\{j|nxt_j=i\\}firi​=min{j∣nxtj​=i}，那么不难发现 firi,ifir_i,ifiri​,i 构成了类似括号匹配的关系： 那么扫一遍序列，用单调栈找到最内层的“右括号”的位置 pospospos，刚开始单调栈中只有一个元素 n+1n+1n+1。扫到位置 iii 时： 先将单调栈顶小于等于 iii 的元素弹出； 若 nxti=−1nxt_i=-1nxti​=−1，那么让 nxti→posnxt_i\\to posnxti​→pos； 否则： 若 nxti&gt;posnxt_i&gt;posnxti​&gt;pos，那么无解； 否则若 nxti=posnxt_i\\not= posnxti​​=pos 那么把 nxtinxt_inxti​ 加入单调栈； 可以通过下面的构造 ppp 序列的方法证明这样构造 nxtnxtnxt 是正确的： 不难发现，由于括号的嵌套关系，所以内层小段的构造方法和外层大段的基本相同，只需要加上一个偏移量即可，所以考虑递归构造。 设 dfs(l,r,mov)dfs(l,r,mov)dfs(l,r,mov) 表示构造在括号 lftnxtr,nxtrlft_{nxt_r},nxt_rlftnxtr​​,nxtr​ 中的 p[l,r]p_{[l,r]}p[l,r]​ 这一段，并且整一段的偏移量为 movmovmov。 显然边界条件是 nxt[l,r]=nxtrnxt_{[l,r]}=nxt_rnxt[l,r]​=nxtr​，这时只要构造 {r−l+1+mov,r−l+mov,r−l−1+mov,…,2+mov,1+mov}\\{r-l+1+mov,r-l+mov,r-l-1+mov,\\dots,2+mov,1+mov\\}{r−l+1+mov,r−l+mov,r−l−1+mov,…,2+mov,1+mov} 这样倒着的序列即可。 由于某个 “右括号” 也有可能是左括号，这时这两段要看作一段处理。所以先预处理出 lbilb_ilbi​ 表示以 iii 为右端点的“连通块”的左端点： 注意若 iii 不为“左括号”或者“右括号”，那么 lbi=ilb_i=ilbi​=i。 在 dfs(l,r,mov)dfs(l,r,mov)dfs(l,r,mov) 中： 初始化一个空队列 vecvecvec，令 pmov=movpmov=movpmov=mov； 从右往左扫过区间，扫到 iii 时： 若 nxti=nxtrnxt_i=nxt_rnxti​=nxtr​，说明 pip_ipi​ 属于最外层的括号，那么把 iii 放入队列 vecvecvec 的末尾，最后再处理； 若 nxti=nxtrnxt_i\\not=nxt_rnxti​​=nxtr​，说明 pip_ipi​ 属于内层的某个括号中，那么递归处理 dfs(lbi,i,pmov)dfs(lb_i,i,pmov)dfs(lbi​,i,pmov)，令 i→lbi−1i\\to lb_i-1i→lbi​−1，pmov→pmov+i−lbi+1pmov\\to pmov+i-lb_i+1pmov→pmov+i−lbi​+1； 队列 vecvecvec 中的元素 iii 都满足 nxti=nxtrnxt_i=nxt_rnxti​=nxtr​，并且队列中元素是从大到小排列的。那么参照 nxt[l,r]=nxtrnxt_{[l,r]}=nxt_rnxt[l,r]​=nxtr​ 情况的构造方法，不断从队头取出元素 iii，令 pi→pmovp_i\\to pmovpi​→pmov，pmov→pmov+1pmov\\to pmov+1pmov→pmov+1 即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=500005; int n,nxt[S]; int sta[S]; int lb[S],a[S]; void dfs(int l,int r,int mov) { int len=r-l+1,nxmov=mov; vector&lt;int&gt; vec; for(int i=r;i&gt;=l;i--) { if(nxt[i]!=nxt[r]) dfs(lb[i],i,nxmov),nxmov+=i-lb[i]+1,i=lb[i]; else vec.push_back(i); } for(int u:vec) a[u]=++nxmov; } inline void slove() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;nxt[i]); int top=1; sta[1]=n+1; for(int i=1;i&lt;=n;i++) { while(sta[top]&lt;=i) top--; if(nxt[i]==-1) nxt[i]=sta[top]; else { if(nxt[i]&gt;sta[top]) { puts(&quot;-1&quot;); return; } else if(nxt[i]&lt;sta[top]) sta[++top]=nxt[i]; } } for(int i=1;i&lt;=n;i++) lb[i]=i; for(int i=1;i&lt;=n;i++) lb[nxt[i]]=min(lb[nxt[i]],lb[i]); dfs(1,n,0); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1158C Permutation recovery 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1158c-permutation-recovery-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":308000,"words":1058,"minutes":6},"date":"2023-03-28 19:01:12","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>有一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">n&lt;=10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>）的<strong>内容未知</strong>的序列，再给 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">m&lt;=50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span>）个限制，每个限制会给一个位置集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，需要让 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中所有位置上的数的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">lcm</mi><mo>⁡</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{lcm}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">l</span><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">m</span></span></span></span></span> 严格大于序列里剩下的数的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">lcm</mi><mo>⁡</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{lcm}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">l</span><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">m</span></span></span></span></span>，求是否存在一个这样的序列满足所有限制。存在一个序列输出 <code>possible</code>，否则输出 <code>impossible</code>。</p>\n</blockquote>\n","content":" 有一个长度为 nnn（n&lt;=104n&lt;=10^4n&lt;=104）的内容未知的序列，再给 mmm（m&lt;=50m&lt;=50m&lt;=50）个限制，每个限制会给一个位置集合 SSS，需要让 SSS 中所有位置上的数的 lcm⁡\\operatorname{lcm}lcm 严格大于序列里剩下的数的 lcm⁡\\operatorname{lcm}lcm，求是否存在一个这样的序列满足所有限制。存在一个序列输出 possible，否则输出 impossible。 有个结论，这 mmm 个集合只要两两有交就有解，否则无解。 首先证明不是两两有交就无解，考虑反证。若存在两个集合 AAA 和 BBB 无交，则设 lcm⁡u∈Aau=x,lcm⁡u∈Bau=y\\operatorname{lcm}_{u\\in A} a_u=x,\\operatorname{lcm}_{u\\in B}a_u=ylcmu∈A​au​=x,lcmu∈B​au​=y。那么由于 AAA 的补集包含 BBB，所以 AAA 的补集的 lcm⁡\\operatorname{lcm}lcm 一定大于等于 yyy，设它为 zzz；同理，BBB 的补集的 lcm⁡\\operatorname{lcm}lcm 一定大于等于 xxx，设它为 www。由于 x&gt;z,z≥yx&gt;z,z\\ge yx&gt;z,z≥y，所以 x&gt;yx&gt;yx&gt;y；又由于 y&gt;w,w≥xy&gt;w,w\\ge xy&gt;w,w≥x，所以 y&gt;xy&gt;xy&gt;x，与 x&gt;yx&gt;yx&gt;y 矛盾，得证。 然后考虑在集合两两有交的情况下构造解，可以考虑如下构造： 把所有 aia_iai​ 赋值为 111； 给每个集合 SiS_iSi​ 赋一个和别的集合不同的质数 pip_ipi​，每个满足 u∈Siu\\in S_iu∈Si​ 的 aua_uau​ 都乘上 pip_ipi​； 由于集合两两有交，所以一个集合内的 lcm⁡\\operatorname{lcm}lcm 都是 ∏i=1mpi\\prod\\limits_{i=1}^mp_ii=1∏m​pi​，而集合外面的 lcm⁡\\operatorname{lcm}lcm 一定会少一个 pip_ipi​，比集合里的小。 所以直接 O(m2n)O(m^2n)O(m2n) 就行了。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1166E The LCMs Must be Large 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1166e-the-lcms-must-be-large-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":119000,"words":454,"minutes":2},"date":"2023-03-28 18:57:56","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>平面上有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个与坐标轴平行的矩形。矩形的所有边的长度都是奇数。矩形不能相交，但它们可以互相接触。</p>\n<p>你要让每两个接触的矩形有不同的颜色。如果可以则输出 <code>YES</code>，并给出每个矩形图上的颜色（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\in[1,4]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">]</span></span></span></span>；如果不行输出<code>NO</code>。</p>\n</blockquote>\n","content":" 平面上有 nnn 个与坐标轴平行的矩形。矩形的所有边的长度都是奇数。矩形不能相交，但它们可以互相接触。 你要让每两个接触的矩形有不同的颜色。如果可以则输出 YES，并给出每个矩形图上的颜色（∈[1,4]\\in[1,4]∈[1,4]；如果不行输出NO。 根据四色定理，所以一定可以染色。 由于长方形的边长都是奇数，所以可以按照长方形左下角两个坐标的奇偶性分类，分别叫做奇奇、奇偶、偶奇、偶偶。与某种类型的长方形相邻的长方形一定是另外三种类型之一，所以可以给奇奇涂 111、奇偶涂 222、偶奇涂 333、偶偶涂 444。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF763B Timofey and rectangles 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf763b-timofey-and-rectangles-zuo-ti-ji-lu/","stats":{"text":"1 min read","time":42000,"words":201,"minutes":1},"date":"2023-03-28 18:53:02","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>最近，Alice 迷上了一款名为 Sirtet 的游戏。</p>\n<p>在 Sirtet 中，玩家会得到一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n \\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的网格。初始时，格 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i, j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 上码放有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i, j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 个方块。若两个格子有一条公共边，我们称这两个格子时相邻的。玩家可以进行以下两种操作：</p>\n<ul>\n<li>在两个相邻的格子上各码上一个方块。</li>\n<li>在一个格子上码上两个方块。</li>\n</ul>\n<p>上述中所提到的所有方块都具有相同的高度。</p>\n<p>玩家的目标是通过这些操作，使得所有的格子拥有同样的高度（也就是说，每个格子上堆放的方块数相同）。</p>\n<p>然而，Alice 发现存在有某些初始局面，使得无论她采用什么策略，都无法达到目标。因此，她希望知道有多少初始局面，满足，</p>\n<ul>\n<li>对于所有的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le i \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le j \\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo>≤</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L \\le a_{i, j} \\le R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.922078em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>。</li>\n<li>玩家可以通过执行这些操作，达到目标。</li>\n</ul>\n<p>请帮助 Alice 解决这个问题。注意答案可能很大，请输出所求答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模的值。</p>\n</blockquote>\n","content":" 最近，Alice 迷上了一款名为 Sirtet 的游戏。 在 Sirtet 中，玩家会得到一个 n×mn \\times mn×m 的网格。初始时，格 (i,j)(i, j)(i,j) 上码放有 ai,ja_{i, j}ai,j​ 个方块。若两个格子有一条公共边，我们称这两个格子时相邻的。玩家可以进行以下两种操作： 在两个相邻的格子上各码上一个方块。 在一个格子上码上两个方块。 上述中所提到的所有方块都具有相同的高度。 玩家的目标是通过这些操作，使得所有的格子拥有同样的高度（也就是说，每个格子上堆放的方块数相同）。 然而，Alice 发现存在有某些初始局面，使得无论她采用什么策略，都无法达到目标。因此，她希望知道有多少初始局面，满足， 对于所有的 1≤i≤n1 \\le i \\le n1≤i≤n，1≤j≤m1 \\le j \\le m1≤j≤m，L≤ai,j≤RL \\le a_{i, j} \\le RL≤ai,j​≤R。 玩家可以通过执行这些操作，达到目标。 请帮助 Alice 解决这个问题。注意答案可能很大，请输出所求答案对 998244353998244353998244353 取模的值。 观察到奇偶性相同的情况下只要不断应用操作 222 就可以达到目标，所以问题就转化为求能让所有 ai,ja_{i,j}ai,j​ 奇偶性相同的方案数。 改变奇偶性的操作只有操作 111，它一次可以改变相邻两个位置的奇偶性。不难发现，对于两个位置 (x1,y1)(x1,y1)(x1,y1) 和 (x2,y2)(x2,y2)(x2,y2)，只要在它们之间的最短路上相邻的每两个位置都操作一次，就可以只改变 ax1,y1a_{x1,y1}ax1,y1​ 和 ax2,y2a_{x2,y2}ax2,y2​ 的奇偶性而不对其它的位置造成影响。所以问题就转化为： 有多少个 n×mn\\times mn×m，元素值域 [L,R][L,R][L,R] 的网格满足可以通过任意多次改变恰好两个位置奇偶性来让所有元素的奇偶性相同？ 不难发现，这个操作并不能改变奇元素个数的奇偶性和偶元素个数的奇偶性，所以一个网格满足条件当且仅当奇元素个数和偶元素个数中有至少一个是偶数。 那么显然 nmnmnm 为奇数时网格的所有元素都可以任意取，方案数为 (R−L+1)nm(R-L+1)^{nm}(R−L+1)nm。 当 nmnmnm 为偶数时，设 [L,R][L,R][L,R] 内偶数有 EEE 个，奇数有 OOO 个，那么方案数为： ∑i=0nm2(nm2i)E2iOnm−2i\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i} i=0∑2nm​​(2inm​)E2iOnm−2i 发现这个很像二项式定理，那么考虑： (E+O)nm=∑i=0nm(nmi)EiOnm−i(E+O)^{nm}=\\sum\\limits_{i=0}^{nm}\\binom{nm}{i}E^iO^{nm-i} (E+O)nm=i=0∑nm​(inm​)EiOnm−i 把奇数项和偶数项拆开看： ∑i=0nm2(nm2i)E2iOnm−2i+∑i=1nm2(nm2i−1)E2i−1Onm−2i+1\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}+\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1} i=0∑2nm​​(2inm​)E2iOnm−2i+i=1∑2nm​​(2i−1nm​)E2i−1Onm−2i+1 前面部分正好是我们想要的，考虑消去后面的部分，观察到： (E−O)nm=∑i=0nm2(nm2i)E2iOnm−2i−∑i=1nm2(nm2i−1)E2i−1Onm−2i+1(E-O)^{nm}=\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}-\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1} (E−O)nm=i=0∑2nm​​(2inm​)E2iOnm−2i−i=1∑2nm​​(2i−1nm​)E2i−1Onm−2i+1 中间是减号是因为后面 OOO 的指数是奇数，系数是 −1-1−1。 所以 ∑i=0nm2(nm2i)E2iOnm−2i=(∑i=0nm2(nm2i)E2iOnm−2i+∑i=1nm2(nm2i−1)E2i−1Onm−2i+1)+(∑i=0nm2(nm2i)E2iOnm−2i−∑i=1nm2(nm2i−1)E2i−1Onm−2i+1)2=(E+O)nm+(E−O)nm2\\begin{aligned} \\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}&amp;=\\frac{\\left(\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}+\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1}\\right)+\\left(\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}-\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1}\\right)}{2}\\\\ &amp;=\\frac{(E+O)^{nm}+(E-O)^{nm}}{2} \\end{aligned} i=0∑2nm​​(2inm​)E2iOnm−2i​=2(i=0∑2nm​​(2inm​)E2iOnm−2i+i=1∑2nm​​(2i−1nm​)E2i−1Onm−2i+1)+(i=0∑2nm​​(2inm​)E2iOnm−2i−i=1∑2nm​​(2i−1nm​)E2i−1Onm−2i+1)​=2(E+O)nm+(E−O)nm​​ 有个细节就是快速幂要特判底数为 000 的情况。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int p=998244353,inv2=499122177; int n,m,L,R; inline int qpow(int x,int y) { if(x==0) return 0; int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } int main() { scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;L,&amp;R); if(1ll*n*m&amp;1) { printf(&quot;%d\\n&quot;,qpow((R-L+1)%p,1ll*n*m%(p-1))); } else { int E=(R-L+1)/2+((L&amp;1)==(R&amp;1)),O=R-L+1-E; E%=p,O%=p; int val=1ll*n*m%(p-1); printf(&quot;%d\\n&quot;,1ll*(qpow((E+O)%p,val)+qpow((E-O+p)%p,val))%p*inv2%p); } return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1332E Height All the Same 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1332e-height-all-the-same-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":372000,"words":1297,"minutes":7},"date":"2023-03-28 18:12:03","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数排成一个环，每次可以选择一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 并把环上相邻的某两个整数其中一个加上 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，另一个减去 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>。求把所有整数都变成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 的最小操作次数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le |a_i|\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" nnn 个整数排成一个环，每次可以选择一个 xxx 并把环上相邻的某两个整数其中一个加上 xxx，另一个减去 xxx。求把所有整数都变成 000 的最小操作次数。 1≤n≤1051\\le n\\le 10^51≤n≤105，0≤∣ai∣≤1090\\le |a_i|\\le 10^90≤∣ai​∣≤109。 考虑设序列 si=a1+a2+a3,…,+ais_i=a_1+a_2+a_3,\\dots,+a_isi​=a1​+a2​+a3​,…,+ai​，那么一次操作相当于： 选定一个 1∼n−11\\sim n-11∼n−1 的整数 iii，让 sis_isi​ 减去任意一个整数 xxx（可正可负）； 让 s1∼n−1s_{1\\sim n-1}s1∼n−1​ 减去任意一个整数 xxx（可正可负）； 目标是让所有 sis_isi​ 都变成 000。 那么若 sn=0s_n\\not=0sn​​=0 就一定无解，否则注意到第一种操作相当于任意更改 s1∼n−1s_{1\\sim n-1}s1∼n−1​ 中的某个数，那么可以把 s1∼n−1s_{1\\sim n-1}s1∼n−1​ 都变成同一个数 yyy，最后若 x=0x\\not=0x​=0 再进行一次第二种操作。 那么解法就呼之欲出了，只要排序找到 s1∼ns_{1\\sim n}s1∼n​ 中出现次数最多的数并统计出它的出现次数 cntcntcnt，答案即为 n−cntn-cntn−cnt。时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 注意开 long long。 ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF675C Money Transfers 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf675c-money-transfers-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":86000,"words":330,"minutes":2},"date":"2023-03-28 18:07:12","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给出两个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，你需要判断能否在数次操作后使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 相同。</p>\n<p>操作是指你可以选择一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mo>⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>⌋</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">k(1\\le k\\le\\lfloor\\frac n2\\rfloor)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mclose\">)</span></span></span></span>，之后交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的前缀和长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的后缀。</p>\n<p>例如对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">a=\\{1,2,3,4,5,6\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mclose\">}</span></span></span></span>，选择 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">k=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>，那么交换后会得到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{5,6,3,4,1,2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i,b_i\\le10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给出两个长度为 nnn 的数列 a,ba,ba,b，你需要判断能否在数次操作后使得 aaa 与 bbb 相同。 操作是指你可以选择一个 k(1≤k≤⌊n2⌋)k(1\\le k\\le\\lfloor\\frac n2\\rfloor)k(1≤k≤⌊2n​⌋)，之后交换 aaa 的长度为 kkk 的前缀和长度为 kkk 的后缀。 例如对于 a={1,2,3,4,5,6}a=\\{1,2,3,4,5,6\\}a={1,2,3,4,5,6}，选择 k=2k=2k=2，那么交换后会得到 {5,6,3,4,1,2}\\{5,6,3,4,1,2\\}{5,6,3,4,1,2}。 1≤n≤5001\\le n\\le5001≤n≤500，1≤ai,bi≤1091\\le a_i,b_i\\le10^91≤ai​,bi​≤109。 结论题，别的题解都没给证明，我来证一下吧。 观察到每次操作中对于所有满足 i≤⌊n2⌋i\\le \\lfloor\\frac{n}{2}\\rfloori≤⌊2n​⌋ 的 iii 都进行了 swap⁡(ai,an−k+i)\\operatorname{swap}(a_i,a_{n-k+i})swap(ai​,an−k+i​)，而和 aia_iai​ 以序列中点对称的元素是 an−i+1a_{n-i+1}an−i+1​，操作中同时进行了 swap⁡(ak−i+1,an−i+1)\\operatorname{swap}(a_{k-i+1},a_{n-i+1})swap(ak−i+1​,an−i+1​)，所以 (ai,an−i+1)(a_i,a_{n-i+1})(ai​,an−i+1​) 和 (ak−i+1,an−k+i)(a_{k-i+1},a_{n-k+i})(ak−i+1​,an−k+i​) 在交换之后仍然以序列中点对称。 那么把 aaa “对折”，把 (ai,an−i+1)(a_i,a_{n-i+1})(ai​,an−i+1​) 这一对记作 bib_ibi​，那么每次操作相当于是交换了所有满足 i≤⌊k2⌋i\\le \\lfloor\\frac{k}{2}\\rfloori≤⌊2k​⌋ 的 bib_ibi​ 和 bk−i+1b_{k-i+1}bk−i+1​，并且所有满足 i≤ki\\le ki≤k 的 bib_ibi​ 组内顺序都被交换了。 不难发现，组内顺序是可以随便交换的，只要做一次 k=ik=ik=i，一次 k=1k=1k=1，一次 k=ik=ik=i 即可。 现在问题转化为： 有一个 nnn 的排列 ppp，请问能否通过任意次交换满足 1≤i≤⌊k2⌋1\\le i\\le \\lfloor\\frac{k}{2}\\rfloor1≤i≤⌊2k​⌋ 的 pip_ipi​ 和 pk−i+1p_{k-i+1}pk−i+1​，得到 nnn 的另外的一个排列 bbb？ 这个问题对于任意 p,bp,bp,b 的答案都是可以，证明如下： 引理：可以使用 222 次操作将 p1,p2,p3,…,pip_1,p_2,p_3,\\dots,p_ip1​,p2​,p3​,…,pi​ 变为 pi,p1,p2,…pi−1p_i,p_1,p_2,\\dots p_{i-1}pi​,p1​,p2​,…pi−1​，即让某个前缀往后循环移位一位。 证明：一次 k=i−1k=i-1k=i−1，一次 k=ik=ik=i 的操作即可。 不难发现，想要证明从任意 ppp 出发可以到达任意 bbb，只要证明能交换 ppp 中任意相邻两项即可。 考虑相邻的两项 i,i+1i,i+1i,i+1，我们只需要做一次 k=i−1k=i-1k=i−1 的操作，把 p[1,i+1]p_{[1,i+1]}p[1,i+1]​ 往后循环移位两位，再做一次 k=i+1k=i+1k=i+1 的操作即可交换 pi,pi+1p_i,p_{i+1}pi​,pi+1​，得证。 所以直接开桶做就行了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;map&gt; using namespace std; const int S=505; int n,a[S],b[S]; map&lt;int,map&lt;int,int&gt; &gt; mp; inline void slove() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); if((n&amp;1)&amp;&amp;a[n/2+1]!=b[n/2+1]) { puts(&quot;No&quot;); return; } if(n==1) { puts(&quot;Yes&quot;); return; } mp.clear(); for(int i=1;i&lt;=n/2;i++) mp[a[i]][a[n-i+1]]++,mp[a[n-i+1]][a[i]]++; for(int i=1;i&lt;=n/2;i++) { if(mp[b[i]][b[n-i+1]]==0) { puts(&quot;No&quot;); return; } mp[b[i]][b[n-i+1]]--; mp[b[n-i+1]][b[i]]--; } puts(&quot;Yes&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) slove(); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1365F Swaps Again 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1365f-swaps-again-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":281000,"words":938,"minutes":5},"date":"2023-03-28 18:05:14","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定两个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，要求串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 的任意子序列经过若干次“旋转”操作变为串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>。</p>\n<p>对于一次“旋转操作”我们这样定义：</p>\n<p>如果我们要旋转的序列为</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>3</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>4</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>5</mn></msub><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><msub><mi>c</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_1,c_2,c_3,c_4,c_5...c_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>那么旋转之后的序列为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>n</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>3</mn></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mn>4</mn></msub><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><msub><mi>c</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">c_n,c_1,c_2,c_3,c_4...c_{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>例如对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>=</mo><mn>1110100</mn></mrow><annotation encoding=\"application/x-tex\">s=1110100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span></p>\n<p>如果我们旋转的子序列的下标为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">{2,6,7}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">7</span></span></span></span></span>（从1开始）</p>\n<p>那么旋转之后的串为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1010110</mn></mrow><annotation encoding=\"application/x-tex\">1010110</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span></p>\n<p>求至少进行多少次“旋转”操作，能够把串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 变成串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">n(1\\le n\\le 10^6)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定两个长度为 nnn 的 010101 串 aaa 和 bbb，要求串 aaa 的任意子序列经过若干次“旋转”操作变为串 bbb。 对于一次“旋转操作”我们这样定义： 如果我们要旋转的序列为 c1,c2,c3,c4,c5...cnc_1,c_2,c_3,c_4,c_5...c_nc1​,c2​,c3​,c4​,c5​...cn​ 那么旋转之后的序列为 cn,c1,c2,c3,c4...cn−1c_n,c_1,c_2,c_3,c_4...c_{n-1}cn​,c1​,c2​,c3​,c4​...cn−1​ 例如对于 s=1110100s=1110100s=1110100 如果我们旋转的子序列的下标为 2,6,7{2,6,7}2,6,7（从1开始） 那么旋转之后的串为 101011010101101010110 求至少进行多少次“旋转”操作，能够把串 aaa 变成串 bbb n(1≤n≤106)n(1\\le n\\le 10^6)n(1≤n≤106)。 首先 000、111 数量不同显然无解。 发现 ai=bia_i=b_iai​=bi​ 的位置不动是最优的，只考虑 ai=bia_i\\not=b_iai​​=bi​ 的位置。 设剔除掉所有 ai=bia_i=b_iai​=bi​ 的位置后的 aaa 为 ccc，那么显然 ccc 中 000 的个数和 111 的个数是相等的。 考虑一次操作能干什么，显然可以选择 ccc 中的一个 000 和一个 111，消除这两个位置。更进一步，每一次操作都可以选一个 010101010101010101010101010101 或者 101010101010101010101010101010 这样 010101 相间的长度为偶数的子序列，把这些位置都消除。 那么问题就变成了把 ccc 划分成尽量少的 010101 相间的偶长子序列，有一个朴素的贪心算法： 设 cnt0,cnt1cnt_0,cnt_1cnt0​,cnt1​ 分别表示当前以 000 和 111 结尾的子序列有多少个，那么扫一遍 ccc，能接就接，否则新建即可。 这样选出来的 010101 相间的子序列显然是最少的，但是不一定都是偶长。不难发现，由于 ccc 中 000 和 111 的个数相等，所以一定不会出现长度为 111 的子序列，以 000 结尾的长度为奇数的子序列个数也一定与以 111 结尾的长度为奇数的子序列个数相等。那么让这些长度为奇数的子序列按照结尾字符两两配对，每对中结尾靠后的字符拼到结尾靠前的子序列后面即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005; int n; char a[S],b[S]; int main() { scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s%s&quot;,a+1,b+1); int cnta=0,cntb=0; for(int i=1;i&lt;=n;i++) cnta+=a[i]=='1',cntb+=b[i]=='1'; if(cnta!=cntb) { puts(&quot;-1&quot;); return 0; } int cnt0=0,cnt1=0; for(int i=1;i&lt;=n;i++) { if(a[i]!=b[i]) { if(a[i]=='0') { if(cnt1&gt;0) cnt1--; cnt0++; } else { if(cnt0&gt;0) cnt0--; cnt1++; } } } printf(&quot;%d\\n&quot;,cnt0+cnt1); return 0; } ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1370E Binary Subsequence Rotation 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1370e-binary-subsequence-rotation-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":176000,"words":680,"minutes":3},"date":"2023-03-28 18:02:17","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定一个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，将它的所有大于一的因数按照任意顺序排列在一个环上，你每次可以选择圈上相邻的两个数，在它们中间插入他们的最小公倍数，使得最后的环上不存在两个相邻且互质的数。你需要找到一个需要进行操作次数最少的排列。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\le n \\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个正整数 nnn，将它的所有大于一的因数按照任意顺序排列在一个环上，你每次可以选择圈上相邻的两个数，在它们中间插入他们的最小公倍数，使得最后的环上不存在两个相邻且互质的数。你需要找到一个需要进行操作次数最少的排列。 4≤n≤1094 \\le n \\le 10^94≤n≤109。 容易发现，若 n=pqn=pqn=pq，其中 ppp 和 qqq 都是质数，也就是说 nnn 除了 111 之外只有 333 个因子时，一定需要 111 次操作，否则需要 000 次操作。若 n=pkn=p^kn=pk 显然直接输出除了 111 外的所有因子即可，否则不难想到一种构造方法：把除了 111 外的因子按照最小质因子分类，每一类放连续一段，两段之间用两个质因子的乘积连接起来。 注意特判只有两类的情况，代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; const int S=5005; int n,a[S]; int tot; map&lt;int,int&gt; idx; vector&lt;int&gt; vec[S]; int ans[S]; inline void slove() { int x; scanf(&quot;%d&quot;,&amp;x); n=0; for(int i=2;i*i&lt;=x;i++) { if(x%i==0) { a[++n]=i; if(i*i!=x) a[++n]=x/i; } } a[++n]=x; sort(a+1,a+n+1); idx.clear(); tot=0; for(int i=1;i&lt;=n;i++) { int mxj=1; bool f=false; for(int j=2;j*j&lt;=a[i];j++) { mxj=j; if(a[i]%j==0) { if(idx.find(j)==idx.end()) idx[j]=++tot; vec[idx[j]].push_back(a[i]); f=true; break; } } for(int j=mxj;j&gt;=1&amp;&amp;!f;j--) { if(a[i]%j==0) { j=a[i]/j; if(idx.find(j)==idx.end()) idx[j]=++tot; vec[idx[j]].push_back(a[i]); break; } } } if(tot==1) { for(int u:vec[1]) printf(&quot;%d &quot;,u); printf(&quot;\\n0\\n&quot;); } else if(n==3) { for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n1\\n&quot;); } else if(tot==2) { int cnt=0; ans[n]=a[n]; for(int u:vec[1]) if(u!=ans[n]&amp;&amp;u!=vec[1][0]*vec[2][0]) ans[++cnt]=u; ans[++cnt]=vec[1][0]*vec[2][0]; for(int u:vec[2]) ans[++cnt]=u; for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n0\\n&quot;); } else { int cnt=0; ans[n]=vec[1][0]*vec[tot][0]; for(int u:vec[1]) if(u!=ans[n]&amp;&amp;u!=vec[1][0]*vec[2][0]) ans[++cnt]=u; ans[++cnt]=vec[1][0]*vec[2][0]; for(int i=2;i&lt;tot;i++) { for(int u:vec[i]) if(u!=vec[i][0]*vec[i+1][0]) ans[++cnt]=u; ans[++cnt]=vec[i][0]*vec[i+1][0]; } for(int u:vec[tot]) ans[++cnt]=u; for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n0\\n&quot;); } for(int i=1;i&lt;=tot;i++) vec[i].clear(); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1419E Decryption 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1419e-decryption-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":213000,"words":675,"minutes":4},"date":"2023-03-28 17:51:52","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定一个数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>, 你将将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 染为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 色, 其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 是由你指定的一个 <strong>01 数组</strong>. 将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 数组中被染成 0 色的数字取出来并依在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中出现的顺序排列, 组成数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>a</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">a^{(0)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">0</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span>. 同理, 将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 数组中被染成 1 色的数字取出来并依在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 中出现的顺序排列, 组成数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>a</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">a^{(1)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span>. 我们定义 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>g</mi><mo>(</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">seg(c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mclose\">)</span></span></span></span> 是一个正整数, 其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 是一个数组, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>g</mi><mo>(</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">seg(c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mclose\">)</span></span></span></span> 的值为在我们将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 中相邻的所有相同元素合并后, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 数组的大小. 例如, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>g</mi><mo>(</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo>]</mo><mo>)</mo><mo>=</mo><mi mathvariant=\"normal\">∣</mi><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>4</mn><mo>]</mo><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">seg([1, 1, 4, 5, 1, 4]) = |[1, 4, 5, 1, 4]|=5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">]</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span>. 最小化 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>g</mi><mo>(</mo><msup><mi>a</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup><mo>)</mo><mo>+</mo><mi>s</mi><mi>e</mi><mi>g</mi><mo>(</mo><msup><mi>a</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">seg(a^{(0)})+seg(a^{(1)})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">0</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\leq n\\leq 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个数组 aaa, 你将将 aia_iai​ 染为 bib_ibi​ 色, 其中 bbb 是由你指定的一个 01 数组. 将 aaa 数组中被染成 0 色的数字取出来并依在 aaa 中出现的顺序排列, 组成数组 a(0)a^{(0)}a(0). 同理, 将 aaa 数组中被染成 1 色的数字取出来并依在 aaa 中出现的顺序排列, 组成数组 a(1)a^{(1)}a(1). 我们定义 seg(c)seg(c)seg(c) 是一个正整数, 其中 ccc 是一个数组, seg(c)seg(c)seg(c) 的值为在我们将 ccc 中相邻的所有相同元素合并后, ccc 数组的大小. 例如, seg([1,1,4,5,1,4])=∣[1,4,5,1,4]∣=5seg([1, 1, 4, 5, 1, 4]) = |[1, 4, 5, 1, 4]|=5seg([1,1,4,5,1,4])=∣[1,4,5,1,4]∣=5. 最小化 seg(a(0))+seg(a(1))seg(a^{(0)})+seg(a^{(1)})seg(a(0))+seg(a(1))。 1≤n≤1051\\leq n\\leq 10^51≤n≤105，1≤ai≤n1\\le a_i\\le n1≤ai​≤n。 DP 先合并序列中相邻的相同元素，即让 aaa 中相邻两项不同，显然这样并不会改变答案。 设 dpidp_{i}dpi​ 表示前 iii 个分完组的答案，不难发现 iii 和 i−1i-1i−1 分到同一组一定是不优的，所以 dpidp_idpi​ 实际上的定义是前 iii 个分完组，iii 和 i−1i-1i−1 不在同一组的答案，那么可以通过枚举 iii 分到的组中它前面的那个元素的位置 j−1j-1j−1 来转移： dpi=min⁡j=1i−1dpj+(i−j−1)+[aj−1=ai]dp_{i}=\\min\\limits_{j=1}^{i-1} dp_j+(i-j-1)+[a_{j-1}\\not=a_i] dpi​=j=1mini−1​dpj​+(i−j−1)+[aj−1​​=ai​] 初始状态 dp1=1dp_1=1dp1​=1。 转移中加上 i−j−1i-j-1i−j−1 是因为 [j,i−1][j,i-1][j,i−1] 都要分配到一组里，但是 jjj 的贡献已经包含在了 dpjdp_jdpj​ 里面。 不难发现，由于 [j,i−1][j,i-1][j,i−1] 都要分配到一组里，所以 jjj 肯定越大越好，那么 jjj 就只能取 aia_iai​ 在 iii 之前最后的出现位置的后一个位置 lstai+1lst_{a_i}+1lstai​​+1 或者 i−1i-1i−1。 所以有转移： dpi=min⁡(dplstai+1+(i−lstai−2),dpi−1+[ai−2=ai])dp_{i}=\\min(dp_{lst_{a_i}+1}+(i-lst_{a_i}-2),dp_{i-1}+[a_{i-2}\\not=a_{i}]) dpi​=min(dplstai​​+1​+(i−lstai​​−2),dpi−1​+[ai−2​​=ai​]) 贪心 其实这就是 Bélády's algorithm，贪心策略如下： 建立两个数组 c0c_0c0​ 和 c1c_1c1​ 用来存储两组具体的数值，初始两个数组均为空，记 d0,d1d_0,d_1d0​,d1​ 分别表示两个数组的末尾元素； 预处理出 nxti,jnxt_{i,j}nxti,j​ 表示 iii 后面第一个出现的 jjj 的位置； 从前往后扫描 aaa，扫描到 aia_iai​ 的时候： 若 c0c_0c0​ 非空且 ai=d0a_i=d_0ai​=d0​，那么把 aia_iai​ 放到 c0c_0c0​ 末尾； 否则若 c1c_1c1​ 非空且 ai=d1a_i=d_1ai​=d1​，那么把 aia_iai​ 放到 c1c_1c1​ 末尾； 否则若 c0c_0c0​ 和 c1c_1c1​ 有一个为空，那么把 aia_iai​ 放入空的那个数组； 否则若 nxti,d0&gt;nxti,d1nxt_{i,d_0}&gt;nxt_{i,d_1}nxti,d0​​&gt;nxti,d1​​，那么把 aia_iai​ 放到 c0c_0c0​ 末尾； 否则把 aia_iai​ 放到 c1c_1c1​ 末尾； 最后扫一遍 c0,c1c_0,c_1c0​,c1​ 即可求出答案； 理性证明在官方题解中有提及，这里给出感性证明： 首先步骤 111、222 和 444 都很显然，重点证明步骤 333，第 111、222、333 条都很显然，重点证明第 444 条和第 555 条。 nxti,d0&gt;nxti,d1nxt_{i,d_0}&gt;nxt_{i,d_1}nxti,d0​​&gt;nxti,d1​​ 表明 d0d_0d0​ 和与它相等的元素相遇需要把更多元素放进 c1c_1c1​，让 d0d_0d0​ 等它后面相同的元素就不是很优，所以要把 aia_iai​ 放入 c0c_0c0​，第 555 条同理。 感性证明完毕。 参考代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=100005; int n,a[S]; namespace dp { int m,b[S]; int lst[S],dp[S]; inline void slove() { for(int i=1;i&lt;=n;i++) if(a[i]!=a[i-1]) b[++m]=a[i]; dp[1]=1; lst[b[1]]=1; for(int i=2;i&lt;=m;i++) { dp[i]=dp[i-1]+(b[i]!=b[i-2]); if(lst[b[i]]!=0) { int j=lst[b[i]]+1; dp[i]=min(dp[i],dp[j]+(i-j-1)); } lst[b[i]]=i; } printf(&quot;%d\\n&quot;,dp[m]); } } namespace greedy { vector&lt;int&gt; pos[S]; int tb,b[S]; int tc,c[S]; inline void slove() { for(int i=1;i&lt;=n;i++) pos[a[i]].push_back(i); for(int i=1;i&lt;=n;i++) pos[i].push_back(n+1); for(int i=1;i&lt;=n;i++) { if(a[i]==b[tb]||tb==0) b[++tb]=a[i]; else if(a[i]==c[tc]||tc==0) c[++tc]=a[i]; else if(pos[b[tb]]&gt;pos[c[tc]]) b[++tb]=a[i]; else c[++tc]=a[i]; pos[a[i]].erase(pos[a[i]].begin()); } int ans=0; for(int i=1;i&lt;=tb;i++) ans+=b[i]!=b[i-1]; for(int i=1;i&lt;=tc;i++) ans+=c[i]!=c[i-1]; printf(&quot;%d\\n&quot;,ans); } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); // dp::slove(); // greedy::slove(); return 0; } ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1479B2 Painting the Array II 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1479b2-painting-the-array-ii-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":355000,"words":1222,"minutes":6},"date":"2023-03-28 17:47:07","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的初始排列为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2,3,4,\\ldots,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 。</p>\n<p>对其进行下列操作：</p>\n<ul>\n<li>首先，我们将其循环移动 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 位， <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为一个未知数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(0 \\leq k \\leq n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n</ul>\n<p>将一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数组循环移动k位就是将原数组最后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 位移动到第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 位，并将其余 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 位移动到第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">k+1 \\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 位。比如说，我们将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2,3,4,5,6]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mclose\">]</span></span></span></span> 循环移动两位，就是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[5,6,1,2,3,4]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">]</span></span></span></span> 。</p>\n<ul>\n<li>然后，我们将数组中任意两个数交换，最多进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 次。</li>\n</ul>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 和最后的结果，你需要找出所有可能的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 值。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">3 \\leq n \\leq 3 \\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mfrac><mi>n</mi><mn>3</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">0 \\leq m \\leq \\dfrac{n}{3}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.7935600000000003em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.10756em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\leq p_i \\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> ，每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的整数均只出现一次。</p>\n</blockquote>\n","content":" 一个长度为 nnn 的初始排列为 [1,2,3,4,…,n][1,2,3,4,\\ldots,n][1,2,3,4,…,n] 。 对其进行下列操作： 首先，我们将其循环移动 kkk 位， kkk 为一个未知数 (0≤k≤n−1)(0 \\leq k \\leq n-1)(0≤k≤n−1) 。 将一个长度为 nnn 的数组循环移动k位就是将原数组最后 kkk 位移动到第 1∼k1 \\sim k1∼k 位，并将其余 n−kn-kn−k 位移动到第 k+1∼nk+1 \\sim nk+1∼n 位。比如说，我们将 [1,2,3,4,5,6][1,2,3,4,5,6][1,2,3,4,5,6] 循环移动两位，就是 [5,6,1,2,3,4][5,6,1,2,3,4][5,6,1,2,3,4] 。 然后，我们将数组中任意两个数交换，最多进行 mmm 次。 给定 n,mn,mn,m 和最后的结果，你需要找出所有可能的 kkk 值。 3≤n≤3×1053 \\leq n \\leq 3 \\times 10^53≤n≤3×105，0≤m≤n30 \\leq m \\leq \\dfrac{n}{3}0≤m≤3n​，1≤pi≤n1 \\leq p_i \\leq n1≤pi​≤n ，每个 1∼n1 \\sim n1∼n 的整数均只出现一次。 首先不难想到枚举每一个 kkk，求出循环移位之后的排列 aaa，快速判断能否在 mmm 次交换内让 p=ap=ap=a。 若我们交换 mmm 次，最多能让 ppp 中 2m2m2m 个数归位。也就是说，ppp 中至少要有 n−2mn-2mn−2m 个数不用交换就已经归位。 因为对于每个 iii，不交换就让 pi=aip_i=a_ipi​=ai​ 的 aaa 只会有一个，所以每个 iii 都只会有一个 kkk 能让 pip_ipi​ 不交换就已经归位，设这个 kkk 为 kik_iki​。 由于 m≤n3m\\le \\frac{n}{3}m≤3n​，所以 n−2m≥n3n-2m\\ge \\frac{n}{3}n−2m≥3n​。也就是说，我们枚举的 k=k′k=k&#x27;k=k′ 要满足至少有 n3\\frac n 33n​ 个 ki=kk_i=kki​=k，所以满足条件的 k′k&#x27;k′ 最多只有 333 个。 但是这个条件只是必要条件，不是充分条件，所以我们还要作进一步的判断。设循环移位 k′k&#x27;k′ 位之后的排列是 aaa，那么问题就转化为求让 p=ap=ap=a 的最少交换次数。 这是一个经典问题，建立 nnn 个点，对于每一个 pip_ipi​，都从 iii 向满足 pj=aip_j=a_ipj​=ai​ 的 jjj 连一条有向边，最少交换次数即为 n−环个数n-\\text{环个数}n−环个数。 其实也可以从 iii 向满足 pj=aip_j=a_ipj​=ai​ 的 jjj 连一条无向边，最少交换次数即为 n−连通块个数n-\\text{连通块个数}n−连通块个数。 解释： 考虑这样构造出来的图，显然每个点都有且仅有一个入度和一个出度，那么最后的图一定是由若干个环组成的。 考虑一次交换操作，显然只有交换同一个环内的点是有用的，交换 pi,pjp_i,p_jpi​,pj​ 就相当于把 iii 的出边和 jjj 的出边交换，相当于把大环断成两个小环，那么总共需要断 环的大小−1\\text{环的大小}-1环的大小−1 次，所以做法成立。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1553E Permutation Shift 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1553e-permutation-shift-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":200000,"words":793,"minutes":4},"date":"2023-03-28 14:31:15","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>交互题。</p>\n<p>在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 里有一个运动的点，要求找到这个点，每次可以查询一个区间内有没有这个点，每次这个点往左或者往右移动 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个位置，要求要在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4500</mn></mrow><annotation encoding=\"application/x-tex\">4500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> 次查询内找到这个点的位置。</p>\n</blockquote>\n","content":" 交互题。 在 111 到 nnn 里有一个运动的点，要求找到这个点，每次可以查询一个区间内有没有这个点，每次这个点往左或者往右移动 111 到 kkk 个位置，要求要在 450045004500 次查询内找到这个点的位置。 首先可以用二分缩小范围，但是不难发现长度最多只能缩小到 4k4k4k 左右。 观察到 kkk 很小，所以考虑随机化，每次随机问一个位置，若不是就扩大区间，若区间长度超过 4k4k4k 就重新二分。 由于 4k≤404k\\le 404k≤40，询问次数却有 450045004500 次，所以找不到答案的概率几乎为 000。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; using namespace std; long long n; int k; char str[15]; inline bool que(long long l,long long r) { printf(&quot;%lld %lld\\n&quot;,l,r); fflush(stdout); scanf(&quot;%s&quot;,str); return str[0]=='Y'; } int main() { srand(time(NULL)); scanf(&quot;%lld%d&quot;,&amp;n,&amp;k); long long l=1,r=n; while(l&lt;r) { if(r-l+1&lt;=k*4) { long long pos=l+1ll*rand()*rand()%(r-l+1); if(que(pos,pos)) break; l=max(l-k,1ll),r=min(r+k,n); } else { long long mid=l+r&gt;&gt;1; if(que(l,mid)) r=min(mid+k,n),l=max(l-k,1ll); else r=min(r+k,n),l=max(mid+1-k,1ll); } } que(l,l); return 0; } ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1039B Subway Pursuit 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1039b-subway-pursuit-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":95000,"words":331,"minutes":2},"date":"2023-03-28 14:28:54","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>本题是交互题。</p>\n<p>给定长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>[</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">a=[a_1,a_2,...,a_n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个互不相交的子集 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_1,S_2,...,S_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，这些子集中的元素都是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 之间的正整数。这些子集两两的<strong>交集</strong>为<strong>空</strong>。</p>\n<p>你可以进行最多 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding=\"application/x-tex\">12</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span></span></span></span> 次询问。每次询问你可以给出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> 个互不相同且在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 之间的正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>c</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_1,v_2,...,v_c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，然后你会得到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo>{</mo><msub><mi>v</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\max\\{v_i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>。</p>\n<p>对于每个子集 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，你需要求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><msub><mi>max</mi><mo>⁡</mo><mrow><mi>j</mi><mi mathvariant=\"normal\">∉</mi><msub><mi>S</mi><mi>i</mi></msub></mrow></msub><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i=\\max\\limits_{j \\notin S_i} a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.39656em;vertical-align:-0.966em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43055999999999994em;\"><span style=\"top:-2.009em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">∈</span></span><span class=\"mord mtight\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.75em;\"><span style=\"top:-2.75em;\"><span class=\"pstrut\" style=\"height:2.75em;\"></span><span class=\"llap mtight\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord mtight\"><span class=\"mord mtight\">/</span><span class=\"mspace mtight\" style=\"margin-right:0.06505555555555556em;\"></span></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25em;\"><span></span></span></span></span></span></span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-2.7em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span><span class=\"mop\">max</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.966em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>t</mi><mo>≤</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1 \\leq t \\le 10,2 \\leq n \\leq 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\leq a_i,k \\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>c</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\leq c &lt; n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 本题是交互题。 给定长为 nnn 的数组 a=[a1,a2,...,an]a=[a_1,a_2,...,a_n]a=[a1​,a2​,...,an​] 和 kkk 个互不相交的子集 S1,S2,...,SkS_1,S_2,...,S_kS1​,S2​,...,Sk​，这些子集中的元素都是 [1,n][1,n][1,n] 之间的正整数。这些子集两两的交集为空。 你可以进行最多 121212 次询问。每次询问你可以给出 ccc 个互不相同且在 [1,n][1,n][1,n] 之间的正整数 v1,v2,...,vcv_1,v_2,...,v_cv1​,v2​,...,vc​，然后你会得到 max⁡{vi}\\max\\{v_i\\}max{vi​}。 对于每个子集 SiS_iSi​，你需要求出 Pi=max⁡j∉SiajP_i=\\max\\limits_{j \\notin S_i} a_jPi​=j∈/​Si​max​aj​。 1≤t≤10,2≤n≤10001 \\leq t \\le 10,2 \\leq n \\leq 10001≤t≤10,2≤n≤1000，1≤ai,k≤n1 \\leq a_i,k \\leq n1≤ai​,k≤n，1≤c&lt;n1 \\leq c &lt; n1≤c&lt;n。 诈骗题。 首先二分找到序列中最大值的位置，共需要 1+⌈log⁡n⌉=111+\\lceil\\log n\\rceil=111+⌈logn⌉=11 次操作。 观察到子集两两不交，所以最多只有一个子集的最大值不是整个序列的最大值，再询问一次即可。 最多会用 11+1=1211+1=1211+1=12 次操作。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1363D Guess The Maximums 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1363d-guess-the-maximums-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":80000,"words":293,"minutes":2},"date":"2023-03-28 14:23:57","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>这是一道交互题。</p>\n<p>一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人做成一圈，他们的编号从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n<p>现在每个人的手里面都有一个数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，并且保证每个人与他周围两个人的数字差为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> ，即 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∣</mo><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>±</mo><mn>1</mn></mrow></msub><mo>∣</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\mid a_i-a_{i\\pm 1}\\mid =1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">±</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> ，特别地，编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的人也满足这个规则。</p>\n<p>在这个圈里面，编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的人的对面坐着的是编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">i+\\frac{n}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 的人（其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">i\\le \\frac{n}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>），现在要你找到哪个人与他对面坐着的那个人手中的数字一样。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>∣</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\mid n, n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 这是一道交互题。 一共有 nnn 个人做成一圈，他们的编号从 111 到 nnn。 现在每个人的手里面都有一个数字 aia_iai​ ，并且保证每个人与他周围两个人的数字差为 111 ，即 ∣ai−ai±1∣=1\\mid a_i-a_{i\\pm 1}\\mid =1∣ai​−ai±1​∣=1 ，特别地，编号为 111 与 nnn 的人也满足这个规则。 在这个圈里面，编号为 iii 的人的对面坐着的是编号为 i+n2i+\\frac{n}{2}i+2n​ 的人（其中 i≤n2i\\le \\frac{n}{2}i≤2n​），现在要你找到哪个人与他对面坐着的那个人手中的数字一样。 2∣n,n≤1052\\mid n, n\\le 10^52∣n,n≤105。 首先若 n2\\frac{n}{2}2n​ 是奇数那么无解，因为 iii 和 i+n2i+\\frac{n}{2}i+2n​ 之间隔了 n2\\frac{n}{2}2n​ 个 ±1\\pm 1±1，若 n2\\frac{n}{2}2n​ 是奇数那么 aia_iai​ 和 ai+n2a_{i+\\frac{n}{2}}ai+2n​​ 奇偶性一定不同。 考虑 n2\\frac{n}{2}2n​ 为偶数的情况，令 i′={i+n2i≤n2i−n2i&gt;n2i&#x27;=\\begin{cases}i+\\frac{n}{2}&amp;i\\le\\frac{n}{2}\\\\i-\\frac{n}{2}&amp;i&gt;\\frac{n}{2}\\\\\\end{cases}i′={i+2n​i−2n​​i≤2n​i&gt;2n​​，di=ai−ai′d_i=a_i-a_{i&#x27;}di​=ai​−ai′​。显然问题转化成找到一个 1≤i≤n21\\le i\\le \\frac{n}{2}1≤i≤2n​ 的 iii，满足 di=0d_i=0di​=0。那么观察到 did_idi​ 都是偶数，所以 di−di+1∈[2,−2,0]d_i-d_{i+1}\\in[2,-2,0]di​−di+1​∈[2,−2,0]。也就是说，若 dl,drd_l,d_rdl​,dr​ 异号，则 d[l,r]d_{[l,r]}d[l,r]​ 中一定有至少一个 000，即 [l,r][l,r][l,r] 中一定有满足条件的位置。 由于 di=−di+n2d_i=-d_{i+\\frac{n}{2}}di​=−di+2n​​，所以若 d1=0d_1\\not=0d1​​=0 那么 [1,1+n2][1,1+\\frac{n}{2}][1,1+2n​] 中一定有至少一个满足条件的位置。那么在这个区间中二分即可，若 dmidd_{mid}dmid​ 与 d1d_1d1​ 异号，那么往 [1,mid−1][1,mid-1][1,mid−1] 二分，否则往 [mid+1,r][mid+1,r][mid+1,r] 二分。 代码如下： // Problem: CF1019B The hat // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1019B // Memory Limit: 250 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; inline int que(int x) { printf(&quot;? %d\\n&quot;,x); fflush(stdout); int res; scanf(&quot;%d&quot;,&amp;res); return res; } int main() { scanf(&quot;%d&quot;,&amp;n); if(n%4!=0) { puts(&quot;! -1&quot;); fflush(stdout); return 0; } int l=1,r=n/2+1,ans=-1; int d1=que(1)-que(1+n/2); if(d1==0) { puts(&quot;! 1&quot;); fflush(stdout); return 0; } while(l&lt;=r) { int mid=l+r&gt;&gt;1; int di=que(mid)-que(mid+n/2); if(di==0) { ans=mid; break; } else if(di&lt;0^d1&lt;0) r=mid-1; else l=mid+1; } printf(&quot;! %d\\n&quot;,ans); fflush(stdout); return 0; } ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1019B The hat 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1019b-the-hat-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":210000,"words":687,"minutes":4},"date":"2023-03-28 14:21:41","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>这是一道交互题。</p>\n<p>你和 Alice 正在玩一个奇怪的游戏。给出一棵 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个点的树，双方分别给顶点编号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，双方都不知道对方给树编号的方式。</p>\n<p>接着双方在自己对应的树上选择一个联通子图，在<strong>你的编号方式对应的树上</strong>你选择了<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><msub><mi>k</mi><mn>1</mn></msub></msub></mrow><annotation encoding=\"application/x-tex\">x_1,x_2,\\dots,x_{k_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68066em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span>，<strong>在 Alice 的编号方式对应的树上</strong> Alice 选择了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>y</mi><msub><mi>k</mi><mn>2</mn></msub></msub></mrow><annotation encoding=\"application/x-tex\">y_1,y_2,\\dots,y_{k_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68066em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span>，双方都知道 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><msub><mi>k</mi><mn>1</mn></msub></msub></mrow><annotation encoding=\"application/x-tex\">x_1,\\dots,x_{k_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68066em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>y</mi><msub><mi>k</mi><mn>2</mn></msub></msub></mrow><annotation encoding=\"application/x-tex\">y_1,\\dots,y_{k_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68066em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> 的值</p>\n<p>现在你想知道两个子图是否存在至少一个公共点。你可以进行询问，问题有以下两种：</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">A,x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>：得到在你的编号方式下的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 号点在Alice的编号方式下的值<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">B,x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>：得到在Alice的编号方式下的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 号点在你的编号方式下的值</p>\n<p>现在请你使用<strong>不多于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 次</strong>询问得出是否存在公共点，或者确定两棵子树没有公共点。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 这是一道交互题。 你和 Alice 正在玩一个奇怪的游戏。给出一棵 NNN 个点的树，双方分别给顶点编号为 111 到 NNN，双方都不知道对方给树编号的方式。 接着双方在自己对应的树上选择一个联通子图，在你的编号方式对应的树上你选择了x1,x2,…,xk1x_1,x_2,\\dots,x_{k_1}x1​,x2​,…,xk1​​，在 Alice 的编号方式对应的树上 Alice 选择了 y1,y2,…,yk2y_1,y_2,\\dots,y_{k_2}y1​,y2​,…,yk2​​，双方都知道 x1,…,xk1x_1,\\dots,x_{k_1}x1​,…,xk1​​ 与 y1,…,yk2y_1,\\dots,y_{k_2}y1​,…,yk2​​ 的值 现在你想知道两个子图是否存在至少一个公共点。你可以进行询问，问题有以下两种： A,xA,xA,x：得到在你的编号方式下的 xxx 号点在Alice的编号方式下的值 B,xB,xB,x：得到在Alice的编号方式下的 xxx 号点在你的编号方式下的值 现在请你使用不多于 555 次询问得出是否存在公共点，或者确定两棵子树没有公共点。 1≤n≤10001\\le n\\le 10001≤n≤1000。 首先挑一个对方选了的点 uuu，询问我们对这个点的编号，设询问的结果为 vvv。 那么若 vvv 被我们选了显然直接输出答案，否则考虑以 vvv 为根的有根树： 显然对方选的点集若包含某个点 qqq 那么也一定包含 qqq 的所有祖先，那么设我们选的点集中深度最小的点为 ppp，公共点只会有两种情况： 没有公共点； ppp 是其中一个公共点。 所以再问一下 ppp 在对方编号方式里的编号即可。 一共用了两次询问，足以通过此题。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1044B Intersecting Subtrees 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1044b-intersecting-subtrees-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":102000,"words":450,"minutes":2},"date":"2023-03-28 14:16:48","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>构造一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的矩阵，满足元素 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>16</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\le 10^{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问，每次给出一条 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>)</mo><mo>→</mo><mo>(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(1,1)\\to (n,n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> <strong>只能向下向右走的路径</strong>上的元素的和，你需要保证矩阵对于这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问路径都能唯一确定。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>25</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 25</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le q\\le 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 构造一个 n×nn\\times nn×n 的矩阵，满足元素 ≤1016\\le 10^{16}≤1016。 qqq 次询问，每次给出一条 (1,1)→(n,n)(1,1)\\to (n,n)(1,1)→(n,n) 只能向下向右走的路径上的元素的和，你需要保证矩阵对于这 qqq 次询问路径都能唯一确定。 1≤n≤251\\le n\\le 251≤n≤25，1≤q≤1031\\le q\\le 10^31≤q≤103。 观察到我们只要知道偶数行在哪里，就可以得知整条路径，所以不妨考虑构造一个奇数行均为 000，偶数行均不为 000 的矩阵。 考虑偶数行的取值，显然可以考虑二进制拆位，给每一个处于偶数行的位置都分配一个 2p2^p2p 的权值。 考虑 ppp 的取值，由于不能向左走，所以不同行的 ppp 可以有重复的。第一行显然必须是 {1,2,3,4,5,… }\\{1,2,3,4,5,\\dots\\}{1,2,3,4,5,…}，第二行则可以是 {3,4,5,6,7,… }\\{3,4,5,6,7,\\dots\\}{3,4,5,6,7,…} 因为不能向左走。所以第 2i2i2i 行开头的 ppp 最小可以取第 2i−12_{i-1}2i−1​ 行从左往右数第 333 个 ppp。 这样我们一共用了 n+2(⌊n2⌋−1)n+2(\\lfloor\\frac{n}{2}\\rfloor-1)n+2(⌊2n​⌋−1) 个 ppp，n=25n=25n=25 时用了 25+2×11=4725+2\\times 11=4725+2×11=47 个 ppp，247≤10162^{47}\\le 10^{16}247≤1016，构造满足限制。 不难发现这样构造之后若路径的权值和为 sumsumsum，则 sumsumsum 的二进制序列（低位在前高位在后）SSS 中连续的 111 对应在同一偶数行中走，特判 nnn 的奇偶性输出方案即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=30,BS=500; int n,q; long long a[S][S]; int main() { scanf(&quot;%d&quot;,&amp;n); int cnt=0; for(int i=2;i&lt;=n;i+=2) { long long mul=1&lt;&lt;i-2; for(int j=1;j&lt;=n;j++) a[i][j]=mul,mul&lt;&lt;=1; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) printf(&quot;%lld &quot;,a[i][j]); printf(&quot;\\n&quot;); fflush(stdout); } scanf(&quot;%d&quot;,&amp;q); while(q--) { long long sm; scanf(&quot;%lld&quot;,&amp;sm); int lim=n+(n/2-1)*2-!(n&amp;1); int x=1,y=1; for(int i=-1;i&lt;=lim;i++) { printf(&quot;%d %d\\n&quot;,x,y); fflush(stdout); if((i&gt;=0&amp;&amp;(sm&gt;&gt;i&amp;1))&amp;&amp;!(sm&gt;&gt;i+1&amp;1)) x++; else if((1&lt;0||!(sm&gt;&gt;i&amp;1))&amp;&amp;(sm&gt;&gt;i+1&amp;1)) x++; else y++; } } return 0; } ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1392E Omkar and Duck 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1392e-omkar-and-duck-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":183000,"words":626,"minutes":4},"date":"2023-03-28 14:12:32","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>询问 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\cdots a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 能否通过若干次将任意区间全部赋值为其中位数这个操作，来使得整个序列全部变为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。（中位数指第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mo>∣</mo><mi>s</mi><mo>∣</mo><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac {∣s∣+1} 2 \\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">∣</span><span class=\"mord mathdefault mtight\">s</span><span class=\"mrel mtight\">∣</span><span class=\"mord mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span> 小的数）</p>\n<p>多次询问，每次第一行两个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，第二行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\cdots a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 10^5,1 \\le k \\le 10^9,1 \\le a_i \\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，并保证所有询问中<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>的和不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 询问 a1,a2,⋯ana_1,a_2,\\cdots a_na1​,a2​,⋯an​ 能否通过若干次将任意区间全部赋值为其中位数这个操作，来使得整个序列全部变为kkk。（中位数指第 ⌊∣s∣+12⌋\\lfloor \\frac {∣s∣+1} 2 \\rfloor⌊2∣s∣+1​⌋ 小的数） 多次询问，每次第一行两个整数 nnn 和 kkk，第二行 nnn 个整数 a1,a2,⋯ana_1,a_2,\\cdots a_na1​,a2​,⋯an​。 1≤n≤105,1≤k≤109,1≤ai≤1091 \\le n \\le 10^5,1 \\le k \\le 10^9,1 \\le a_i \\le 10^91≤n≤105,1≤k≤109,1≤ai​≤109，并保证所有询问中nnn的和不超过 10510^5105。 首先如果 aaa 中没有 kkk 那么无解。 容易发现，若有连续两个 kkk，那么就可以不断向外拓展，一定有解。 否则考虑一次操作之后的结果： 长度为 222 的连续段：都变成较小的数 长度为 333 且有两个数相同的连续段：都变成相同的数 所以当某个 kkk 旁边有一个 ≥k\\ge k≥k 的数就一定有解。 那么考虑找到两个相邻且 ≥k\\ge k≥k 的数，把它们变成相同的数，然后不断向外拓展，直到遇到 ai=ka_i=kai​=k 的位置。这样就可以造出两个相邻的 kkk，有解。 还有一种情况，若 aia_iai​ 和 ai+2a_{i+2}ai+2​ 都 ≥k\\ge k≥k 也可以变出相邻两个 ≥k\\ge k≥k 的数，否则就无解，因为 &lt;k&lt;k&lt;k 的数不会比 ≥k\\ge k≥k 的数少。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1349B Orac and Medians 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1349b-orac-and-medians-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":95000,"words":378,"minutes":2},"date":"2023-03-28 14:09:38","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\dots ,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>对于每一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 求出它的两个不为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的约数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">d_1,d_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>(</mo><msub><mi>d</mi><mn>1</mn></msub><mo>+</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\gcd(d_1 + d_2, a_i) = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span style=\"margin-right:0.01389em;\">g</span>cd</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，或指出不存在这样的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">d_1,d_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">n\\leq 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le a_i\\le 10^7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定 nnn 个数 a1,a2,…,ana_1,a_2,\\dots ,a_na1​,a2​,…,an​。 对于每一个 aia_iai​ 求出它的两个不为 111 的约数 d1,d2d_1,d_2d1​,d2​ ，满足 gcd⁡(d1+d2,ai)=1\\gcd(d_1 + d_2, a_i) = 1gcd(d1​+d2​,ai​)=1，或指出不存在这样的 d1,d2d_1,d_2d1​,d2​。 n≤5×105n\\leq 5\\times 10^5n≤5×105，2≤ai≤1072\\le a_i\\le 10^72≤ai​≤107 大力推一波式子： 设 gcd⁡(d1,d2)=d\\gcd(d_1,d_2)=dgcd(d1​,d2​)=d，d1′=d1/d,d2′=d2/dd_1&#x27;=d_1/d,d_2&#x27;=d_2/dd1′​=d1​/d,d2′​=d2​/d。 那么 d1+d2=d(d1′+d2′)d_1+d_2=d(d_1&#x27;+d_2&#x27;)d1​+d2​=d(d1′​+d2′​)，gcd⁡(d1+d2,ai)=gcd⁡(d(d1′+d2′),ai)=1\\gcd(d_1+d_2,a_i)=\\gcd(d(d_1&#x27;+d_2&#x27;),a_i)=1gcd(d1​+d2​,ai​)=gcd(d(d1′​+d2′​),ai​)=1。 由于 ddd 一定是 aia_iai​ 的因子，所以 gcd⁡(d(d1′,d2′),ai)≥d\\gcd(d(d_1&#x27;,d_2&#x27;),a_i)\\ge dgcd(d(d1′​,d2′​),ai​)≥d，所以 ddd 只能为 111。 也就是说，找到两个互质的 d1d_1d1​ 和 d2d_2d2​ 即可。 那么考虑线性筛预处理出每个数的最小质因子，把 aia_iai​ 的最小质因子 ppp 除光，剩下的数 xxx 显然和 ppp 互质，特判掉 x=1x=1x=1 的情况即可。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"}],"title":"CF1366D Two Divisors 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1366d-two-divisors-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":84000,"words":280,"minutes":2},"date":"2023-03-28 14:06:38","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给定长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，要对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">k=1,2,3,\\cdots,n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 求出，有多少个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant=\"normal\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">p&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant=\"normal\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">p&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 字典序比 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 小，且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><msup><mi>p</mi><mo mathvariant=\"normal\">′</mo></msup><mo>)</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">f(p&#x27;)=k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span></span></span></span> 表示 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 最少可以划分成多少个区间，使得每个区间中的元素都是公差为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的等差数列。</p>\n<p>答案对输入的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 取模，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 不一定是质数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">n\\le 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>10</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">10\\le m\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定长度为 nnn 的排列 ppp，要对于 k=1,2,3,⋯ ,nk=1,2,3,\\cdots,nk=1,2,3,⋯,n 求出，有多少个长度为 nnn 的排列 p′p&#x27;p′ 满足 p′p&#x27;p′ 字典序比 ppp 小，且 f(p′)=kf(p&#x27;)=kf(p′)=k，其中 f(a)f(a)f(a) 表示 aaa 最少可以划分成多少个区间，使得每个区间中的元素都是公差为 111 的等差数列。 答案对输入的 mmm 取模，mmm 不一定是质数。 n≤2000n\\le 2000n≤2000，10≤m≤10910\\le m\\le 10^910≤m≤109。 首先考虑没有字典序限制，求所有 nnn 的排列的答案。设 fif_{i}fi​ 表示恰好分成 iii 段的方案数，gig_igi​ 表示钦定分成 iii 段的方案数，那么有： gi=∑j=1i(n−ji−j)fjfi=gi−∑j=1i−1(n−ji−j)fjg_i=\\sum\\limits_{j=1}^{i}\\binom{n-j}{i-j}f_j\\\\ f_i=g_i-\\sum\\limits_{j=1}^{i-1}\\binom{n-j}{i-j}f_{j} gi​=j=1∑i​(i−jn−j​)fj​fi​=gi​−j=1∑i−1​(i−jn−j​)fj​ 那么问题变成了求 gig_igi​，没有字典序限制显然是简单的，字典序限制可以枚举 ppp 和 p′p&#x27;p′ 的 lcp⁡=i−1\\operatorname{lcp}=i-1lcp=i−1 来解决。那么设 (ct1,tt1+ct1)(ct1,tt1+ct1)(ct1,tt1+ct1) 分别表示未填入的数中 &lt;pi&lt;p_{i}&lt;pi​ 小的连续段个数，以及这样的数的个数；(ct2,tt2+ct2)(ct2,tt2+ct2)(ct2,tt2+ct2) 类似，只是把 &lt;pi&lt;p_i&lt;pi​ 换成 ≥pi\\ge p_i≥pi​。注意跨越 pip_ipi​ 的连续段被归为 (ct1,tt1+ct1)(ct1,tt1+ct1)(ct1,tt1+ct1) 里。 那么 p[i,n]′p&#x27;_{[i,n]}p[i,n]′​ 钦定分成 kkk 段的方案数就是： ∑j=0k−ct1−ct2(ct1+j)(k−1)!(tt1j)(tt2k−ct1−ct2−j)\\sum\\limits_{j=0}^{k-ct1-ct2}(ct1+j)(k-1)!\\binom{tt1}{j}\\binom{tt2}{k-ct1-ct2-j} j=0∑k−ct1−ct2​(ct1+j)(k−1)!(jtt1​)(k−ct1−ct2−jtt2​) 这个式子的意思是枚举 &lt;pi&lt;p_i&lt;pi​ 中断开了 jjj 个位置，≥pi\\ge p_i≥pi​ 中断开了 k−ct1−ct2−jk-ct1-ct2-jk−ct1−ct2−j 个位置，然后这些连续段中只有 ct1+jct1+jct1+j 个能当第一个，剩下 k−1k-1k−1 个乱选。 接下来考虑化简： ∑j=0k−ct1−ct2(ct1+j)(k−1)!(tt1j)(tt2k−ct1−ct2−j)=(k−1)!∑j=0k−ct1−ct2(ct1(tt1j)+tt1(tt1−1j−1))(tt2k−ct1−ct2−j)=(k−1)!(ct1(tt1+tt2k−ct1−ct2)+tt1(tt1+tt2−1k−ct1−ct2−1))\\begin{aligned} &amp;\\sum\\limits_{j=0}^{k-ct1-ct2}(ct1+j)(k-1)!\\binom{tt1}{j}\\binom{tt2}{k-ct1-ct2-j}\\\\ &amp;=(k-1)!\\sum\\limits_{j=0}^{k-ct1-ct2}\\left(ct1\\binom{tt1}{j}+tt1\\binom{tt1-1}{j-1}\\right)\\binom{tt2}{k-ct1-ct2-j}\\\\ &amp;=(k-1)!\\left(ct1\\binom{tt1+tt2}{k-ct1-ct2}+tt1\\binom{tt1+tt2-1}{k-ct1-ct2-1}\\right) \\end{aligned} ​j=0∑k−ct1−ct2​(ct1+j)(k−1)!(jtt1​)(k−ct1−ct2−jtt2​)=(k−1)!j=0∑k−ct1−ct2​(ct1(jtt1​)+tt1(j−1tt1−1​))(k−ct1−ct2−jtt2​)=(k−1)!(ct1(k−ct1−ct2tt1+tt2​)+tt1(k−ct1−ct2−1tt1+tt2−1​))​ 还有一种情况，pi′p&#x27;_ipi′​ 有可能能填入 pi−1+1p_{i-1}+1pi−1​+1 然后和 pi−1′p&#x27;_{i-1}pi−1′​ 组成一个连续段。这种情况钦定后面（包括 pi−1′p&#x27;_{i-1}pi−1′​ 和 pi′p&#x27;_ipi′​ 组成的那一段）有 kkk 段的方案数为： (k−1)!(tt1+tt2k−ct1−ct2)(k-1)!\\binom{tt1+tt2}{k-ct1-ct2} (k−1)!(k−ct1−ct2tt1+tt2​) 每次都容斥显然不行，那么弄个 dp 把 p[1,i−1]′p&#x27;_{[1,i-1]}p[1,i−1]′​ 钦定的情况也统计一下，最后一起累加进 ggg 容斥即可。 时间复杂度 O(n2)O(n^2)O(n2)。 代码如下： // Problem: Doping // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1750G // Memory Limit: 500 MB // Time Limit: 3000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=2005; int n,p; int a[S],C[S][S],fra[S]; bool vis[S],flg[S]; int dp[S][S]; int g[S],f[S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } inline int qc(int n,int m) { if(n&lt;m||n&lt;0||m&lt;0) return 0; return C[n][m]; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;p); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;=S-3;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; a[0]=-1; int cnt=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) flg[j]=false; int ct1=0,tt1=0,ct2=0,tt2=0; for(int j=1;j&lt;a[i];j++) { if(vis[j]) continue; if(flg[j-1]) tt1++; else ct1++; flg[j]=true; } for(int j=a[i];j&lt;=n;j++) { if(vis[j]) continue; if(flg[j-1]) tt2++; else ct2++; flg[j]=true; } for(int k=ct1+ct2;k&lt;=n-cnt;k++) { add(dp[i][cnt+k],1ll*fra[k-1]*(1ll*ct1*qc(tt1+tt2,k-ct1-ct2)%p+1ll*tt1*qc(tt1+tt2-1,k-ct1-ct2-1)%p)%p); } if(a[i-1]+1&gt;=1&amp;&amp;a[i-1]+1&lt;=n&amp;&amp;!vis[a[i-1]+1]&amp;&amp;a[i-1]+1&lt;a[i]) { for(int k=ct1+ct2;k&lt;=n-cnt+1;k++) { add(dp[i][cnt+k-1],1ll*fra[k-1]*qc(tt1+tt2,k-ct1-ct2)%p); } } vis[a[i]]=true; cnt+=a[i]!=a[i-1]+1; } for(int i=n;i&gt;=2;i--) { for(int j=1;j&lt;=n;j++) { add(dp[i-1][j],dp[i][j]); if(a[i-1]==a[i-2]+1&amp;&amp;j&lt;n) add(dp[i-1][j+1],dp[i][j]); } } for(int i=1;i&lt;=n;i++) g[i]=dp[1][i]; for(int i=1;i&lt;=n;i++) { f[i]=g[i]; for(int j=1;j&lt;=i-1;j++) { add(f[i],p-1ll*qc(n-j,i-j)*f[j]%p); } } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1750G Doping 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1750g-doping-zuo-ti-ji-lu/","stats":{"text":"8 min read","time":448000,"words":1367,"minutes":8},"date":"2023-03-28 09:57:44","dateFormat":"2023-03-28"},{"abstract":"<blockquote>\n<p>给你一个边权为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的无向图，动态加边，每次加边询问无向图的直径（所有点对的最短路中的最大值）。要求你的答案在真实答案的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∼</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2}\\sim 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 倍之间（向上取整）。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m,q\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给你一个边权为 111 的无向图，动态加边，每次加边询问无向图的直径（所有点对的最短路中的最大值）。要求你的答案在真实答案的 12∼2\\frac{1}{2}\\sim 221​∼2 倍之间（向上取整）。 1≤n,m,q≤1051\\le n,m,q\\le 10^51≤n,m,q≤105。 有一个结论：111 到其它点的最短路的最大值 disdisdis 和直径 ddd 一定满足 ⌈d2⌉≤dis≤d\\lceil\\frac{d}{2}\\rceil\\le dis\\le d⌈2d​⌉≤dis≤d。 证明 dis≤ddis\\le ddis≤d 显然，⌈d2⌉≤dis\\lceil\\frac{d}{2}\\rceil\\le dis⌈2d​⌉≤dis 则是因为要先走到直径上，再走到直径的两个端点。 所以初始答案 ans0ans0ans0 可以一直用到 dis&lt;⌈ans02⌉dis&lt;\\left\\lceil\\frac{ans0}{2}\\right\\rceildis&lt;⌈2ans0​⌉，那么二分出第一次减半的位置即可。 时间复杂度 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 代码如下： // Problem: Approximate Diameter // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1804F // Memory Limit: 500 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int S=100005; struct node { int x,y; }ed1[S],ed2[S]; int n,m,q; vector&lt;int&gt; g[S]; int dis[S],ans[S]; inline int calc(int id) { for(int i=1;i&lt;=id;i++) g[ed2[i].x].push_back(ed2[i].y),g[ed2[i].y].push_back(ed2[i].x); for(int i=1;i&lt;=n;i++) dis[i]=1e8; queue&lt;int&gt; q; q.push(1); dis[1]=0; while(!q.empty()) { int u=q.front(); q.pop(); for(int v:g[u]) { if(dis[u]+1&lt;dis[v]) { dis[v]=dis[u]+1; q.push(v); } } } int mx=0; for(int i=1;i&lt;=n;i++) mx=max(mx,dis[i]); for(int i=1;i&lt;=id;i++) g[ed2[i].x].pop_back(),g[ed2[i].y].pop_back(); return mx; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); ed1[i]=(node){x,y}; } for(int i=1;i&lt;=q;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); ed2[i]=(node){x,y}; } for(int i=1;i&lt;=m;i++) g[ed1[i].x].push_back(ed1[i].y),g[ed1[i].y].push_back(ed1[i].x); for(int i=0;i&lt;=q;i++) ans[i]=-1; for(int i=0;i&lt;=q;i++) { ans[i]=calc(i); int lb=i,rb=q,res=q; while(lb&lt;=rb) { int mid=lb+rb&gt;&gt;1; if(calc(mid)*2&gt;=ans[i]) res=mid,lb=mid+1; else rb=mid-1; } i=res; } for(int i=1;i&lt;=q;i++) if(ans[i]==-1) ans[i]=ans[i-1]; for(int i=0;i&lt;=q;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"CF1804F Approximate Diameter 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1804f-approximate-diameter-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":200000,"words":603,"minutes":4},"date":"2023-03-27 20:08:01","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>这是一道交互题，给定两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n,k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，你需要通过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\leq 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 次询问猜出长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> 中的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 小值。</p>\n<p>询问分为两种类型：</p>\n<ol>\n<li><code>or i j</code>，交互器会返回 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">or</mi><mo>⁡</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i \\operatorname{or}a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">r</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 的值。</li>\n<li><code>and i j</code>，交互器会返回 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant=\"normal\">and</mi><mo>⁡</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i\\operatorname{and}a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">n</span><span class=\"mord mathrm\">d</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 的值。</li>\n</ol>\n<p>其中需要满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\leq i,j\\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i\\not = j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>。</p>\n<p>最后你需要输出 <code>finish res</code>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">res</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">s</span></span></span></span> 表示你的答案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">3\\leq n \\leq 10^4,1\\leq k\\leq n,0\\leq a_i\\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 这是一道交互题，给定两个正整数 n,kn,kn,k，你需要通过 ≤2n\\leq 2n≤2n 次询问猜出长度为 nnn 的序列 {ai}\\{a_i\\}{ai​} 中的第 kkk 小值。 询问分为两种类型： or i j，交互器会返回 aior⁡aja_i \\operatorname{or}a_jai​oraj​ 的值。 and i j，交互器会返回 aiand⁡aja_i\\operatorname{and}a_jai​andaj​ 的值。 其中需要满足 1≤i,j≤n1\\leq i,j\\leq n1≤i,j≤n 且 i=ji\\not = ji​=j。 最后你需要输出 finish res，其中 resresres 表示你的答案。 3≤n≤104,1≤k≤n,0≤ai≤1093\\leq n \\leq 10^4,1\\leq k\\leq n,0\\leq a_i\\leq 10^93≤n≤104,1≤k≤n,0≤ai​≤109。 首先有个结论：x+y=(xor⁡y)+(xand⁡y)x+y=(x\\operatorname{or} y)+(x\\operatorname{and}y)x+y=(xory)+(xandy)。 证明可以考虑每一位的贡献。 那么用 2n−22n-22n−2 次询问求出 a1+aia_1+a_ia1​+ai​，用两次询问求出 ai+aja_i+a_jai​+aj​ 即可解方程得到 a1a_1a1​，进而得出序列 aaa。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1556D Take a Guess 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1556d-take-a-guess-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":69000,"words":245,"minutes":2},"date":"2023-03-27 18:08:35","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>这是一道交互题。</p>\n<p>原来生命的意义是一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">2 \\leq n \\leq 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>) 的排列。 创造了世上所有生命的 Omkar 知道这个排列，他允许你在有限的询问次数内查询出这个排列是什么。</p>\n<p>每一次询问你可以给出一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1, a_2, \\ldots, a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_1,a_2,\\ldots,a_n \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>) 来对 Omkar 进行询问。 $ a $ 序列<strong>不一定</strong>要是一个排列。之后 Omkar 会逐个将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 与 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 相加得到一个新的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> ，即对于每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le j \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>) ，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub><mo>=</mo><msub><mi>p</mi><mi>j</mi></msub><mo>+</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_j = p_j + a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8694379999999999em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 。最后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 序列中可能会出现一些相同的数，你将读入 Omkar 告诉你的<strong>第一个出现相同数的位置</strong>。如果没有相同的数出现，你将读入数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 。</p>\n<p>你最多只能进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathdefault\">n</span></span></span></span> 次询问。</p>\n</blockquote>\n","content":" 这是一道交互题。 原来生命的意义是一个 nnn (2≤n≤1002 \\leq n \\leq 1002≤n≤100) 的排列。 创造了世上所有生命的 Omkar 知道这个排列，他允许你在有限的询问次数内查询出这个排列是什么。 每一次询问你可以给出一个序列 a1,a2,…,ana_1, a_2, \\ldots, a_na1​,a2​,…,an​ (1≤a1,a2,…,an≤n1\\le a_1,a_2,\\ldots,a_n \\le n1≤a1​,a2​,…,an​≤n) 来对 Omkar 进行询问。 $ a $ 序列不一定要是一个排列。之后 Omkar 会逐个将 aia_iai​ 与 pip_ipi​ 相加得到一个新的序列 sss ，即对于每个 jjj (1≤j≤n1\\le j \\le n1≤j≤n) ，sj=pj+ajs_j = p_j + a_jsj​=pj​+aj​ 。最后 sss 序列中可能会出现一些相同的数，你将读入 Omkar 告诉你的第一个出现相同数的位置。如果没有相同的数出现，你将读入数字 000 。 你最多只能进行 2n2n2n 次询问。 显然对于 ai=aja_i=a_jai​=aj​ 的两个位置 i,ji,ji,j，它们一定对答案没有贡献，那么考虑询问形如 {2,2,…,2,1,2,2…,2}\\{2,2,\\dots,2,1,2,2\\dots,2\\}{2,2,…,2,1,2,2…,2} 的第 iii 位为 111，其它位为 222 的序列 aaa。 记询问只有第 iii 位为 111 的 aaa 的答案为 res1ires1_ires1i​，那么 res1ires1_ires1i​ 显然有三种情况： res1i&lt;ires1_i&lt;ires1i​&lt;i，那么 pip_ipi​ 的前驱是 pres1ip_{res1_i}pres1i​​； res1i=ires1_i=ires1i​=i，那么 pip_ipi​ 的前驱在 [i+1,n][i+1,n][i+1,n] 中； res1i=0res1_i=0res1i​=0，那么 pi=1p_i=1pi​=1； 接下来考虑获取每个位置的后继以解决 pip_ipi​ 的前驱不确定的情况。类似的，考虑询问形如 {1,1,…,1,2,1,1…,1}\\{1,1,\\dots,1,2,1,1\\dots,1\\}{1,1,…,1,2,1,1…,1} 的第 iii 位为 222，其它位为 111 的序列 aaa。 记询问只有第 iii 位为 111 的 aaa 的答案为 res2ires2_ires2i​，那么 res2ires2_ires2i​ 显然也有三种情况： res2i&lt;ires2_i&lt;ires2i​&lt;i，那么 pip_ipi​ 的后继是 pres2ip_{res2_i}pres2i​​； res2i=ires2_i=ires2i​=i，那么 pip_ipi​ 的后继在 [i+1,n][i+1,n][i+1,n] 中； res2i=0res2_i=0res2i​=0，那么 pi=1p_i=1pi​=1； 这样我们就用 2n2n2n 次操作确定了每个 pip_ipi​ 的前驱后继，自然也确定了 ppp。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1583D Omkar and the Meaning of Life 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1583d-omkar-and-the-meaning-of-life-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":148000,"words":562,"minutes":3},"date":"2023-03-27 18:05:51","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>桌子上面摆着 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 张白纸，交互库会依次给你 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>c</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[1,c]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mclose\">]</span></span></span></span> 中的数，你每次可以把所获得的数写在一张纸上或者替换掉某一张纸上写的数，<strong>在你行动结束后交互库才会给你下一个数</strong>。任何时候，如果所有纸上都写了数字并且成非降序排列，你就赢了，直接结束程序。你要想办法赢交互库。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">2\\le n,m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le c\\le 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>⋅</mo><mo>⌈</mo><mfrac><mi>c</mi><mn>2</mn></mfrac><mo>⌉</mo><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\cdot \\lceil\\frac{c}{2}\\rceil\\le m\\le 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌉</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 桌子上面摆着 nnn 张白纸，交互库会依次给你 mmm 个 [1,c][1,c][1,c] 中的数，你每次可以把所获得的数写在一张纸上或者替换掉某一张纸上写的数，在你行动结束后交互库才会给你下一个数。任何时候，如果所有纸上都写了数字并且成非降序排列，你就赢了，直接结束程序。你要想办法赢交互库。 2≤n,m2\\le n,m2≤n,m，1≤c≤10001\\le c\\le 10001≤c≤1000，1≤n⋅⌈c2⌉≤m≤10001\\le n\\cdot \\lceil\\frac{c}{2}\\rceil\\le m\\le 10001≤n⋅⌈2c​⌉≤m≤1000。 首先给出构造方法： 若 x≤⌊c2⌋x\\le \\lfloor\\frac{c}{2}\\rfloorx≤⌊2c​⌋，那么从左到右找到第一个满足 ai=0a_i=0ai​=0 或 ai&gt;xa_i&gt;xai​&gt;x 的 iii 放入 xxx； 若 x&gt;⌊c2⌋x&gt;\\lfloor\\frac{c}{2}\\rfloorx&gt;⌊2c​⌋，那么从右到左找到第一个满足 ai=0a_i=0ai​=0 或 ai&lt;xa_i&lt;xai​&lt;x 的 iii 放入 xxx； 接下来证明这个构造方法，首先考虑这样一条引理： 若每次都从左到右找到第一个满足 ai=0a_i=0ai​=0 或 ai&gt;xa_i&gt;xai​&gt;x 的 iii 放入 xxx，那么最终的单调不降序列长度至少是 ⌈mc⌉\\lceil\\frac{m}{c}\\rceil⌈cm​⌉； 证明： 考虑这 mmm 个数中出现次数最多的数 vvv，由于值域大小为 ccc，所以根据抽屉原理，vvv 至少会出现 ⌈mc⌉\\lceil\\frac{m}{c}\\rceil⌈cm​⌉ 次。 把这 mmm 个数分成三部分考虑： 满足 u=vu=vu=v 的 uuu，这些 uuu 构成的单调不降序列长度至少是 ⌈mc⌉\\lceil\\frac{m}{c}\\rceil⌈cm​⌉； 满足 u&lt;vu&lt;vu&lt;v 的 uuu，显然这些 uuu 都出现在所有 vvv 之后是最坏情况，这时这些 uuu 均会被 vvv 代替； 满足 u&gt;vu&gt;vu&gt;v 的 uuu，显然这些 uuu 都出现在 vvv 之前是最坏情况，这时这些 uuu 均会被 vvv 代替； 所以最坏情况下最终的单调不降序列长度也是 ⌈mc⌉\\lceil\\frac{m}{c}\\rceil⌈cm​⌉，得证。 回到我们的构造方法，设满足 x≤⌊c2⌋x\\le \\lfloor\\frac{c}{2}\\rfloorx≤⌊2c​⌋ 的 xxx 有 ttt 个，那么满足 x&gt;⌊c2⌋x&gt;\\lfloor\\frac{c}{2}\\rfloorx&gt;⌊2c​⌋ 的 xxx 则有 m−tm-tm−t 个。根据引理，易得出满足 x≤⌊c2⌋x\\le \\lfloor\\frac{c}{2}\\rfloorx≤⌊2c​⌋ 的那 ttt 个 xxx 构成的单调不降序列长度至少是 ⌈2tc⌉\\lceil\\frac{2t}{c}\\rceil⌈c2t​⌉，其它的 xxx 构成的单调不降序列长度至少是 ⌈2(m−t)c⌉\\lceil\\frac{2(m-t)}{c}\\rceil⌈c2(m−t)​⌉，由于 ⌈2tc⌉+⌈2(m−t)c⌉≥⌈2mc⌉≥n\\lceil\\frac{2t}{c}\\rceil+\\lceil\\frac{2(m-t)}{c}\\rceil\\ge \\lceil\\frac{2m}{c}\\rceil\\ge n⌈c2t​⌉+⌈c2(m−t)​⌉≥⌈c2m​⌉≥n，所以得证。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF896B Ithea Plays With Chtholly 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf896b-ithea-plays-with-chtholly-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":185000,"words":694,"minutes":4},"date":"2023-03-27 18:03:17","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>这是一道交互题。</p>\n<p>有一场由 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 位选手组成的锦标赛。</p>\n<p>这个锦标赛的规则如下：第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 位选手与第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 位选手竞争，第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 位选手与第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span></span></span></span> 位选手竞争……以此类推，比赛结束时会只剩下一位参赛选手，这位参赛选手就是胜利者。</p>\n<p>你不知道比赛的结果，但你想通过询问评审团来得知最后谁赢了。</p>\n<p>每次询问评审团，你需要给定两个正整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 分别代指两位选手的编号。</p>\n<p>若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 选手 比 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 选手 赢的回合更多，评委团将报出数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>；如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 选手 比 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 选手 赢的回合更多，评审团将报出数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>；如果这两位选手赢的回合一样多，评审团会报出数字 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<p>你要做的是在不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌈</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo>⋅</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil \\frac{1}{3} \\cdot 2^{n+1} \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">⌉</span></span></span></span> 的次数内找到最后胜利的选手。此处 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌈</mo><mi>x</mi><mo>⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil x \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">⌉</span></span></span></span> 表示四舍五入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 到最近的整数。</p>\n<p>这场锦标赛已经过去很久了。所以保证有唯一解。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">1\\leq n\\leq 17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span></span></span></span>。</p>\n</blockquote>\n","content":" 这是一道交互题。 有一场由 2n2^n2n 位选手组成的锦标赛。 这个锦标赛的规则如下：第 111 位选手与第 222 位选手竞争，第 333 位选手与第 444 位选手竞争……以此类推，比赛结束时会只剩下一位参赛选手，这位参赛选手就是胜利者。 你不知道比赛的结果，但你想通过询问评审团来得知最后谁赢了。 每次询问评审团，你需要给定两个正整数 aaa 和 bbb，aaa 和 bbb 分别代指两位选手的编号。 若 aaa 选手 比 bbb 选手 赢的回合更多，评委团将报出数字 111；如果 bbb 选手 比 aaa 选手 赢的回合更多，评审团将报出数字 222；如果这两位选手赢的回合一样多，评审团会报出数字 000。 你要做的是在不超过 ⌈13⋅2n+1⌉\\lceil \\frac{1}{3} \\cdot 2^{n+1} \\rceil⌈31​⋅2n+1⌉ 的次数内找到最后胜利的选手。此处 ⌈x⌉\\lceil x \\rceil⌈x⌉ 表示四舍五入 xxx 到最近的整数。 这场锦标赛已经过去很久了。所以保证有唯一解。 1≤n≤171\\leq n\\leq 171≤n≤17。 首先显然可以耗费 2n−12^n-12n−1 次询问按照淘汰赛树一层一层询问。 发现 ⌊2n+13⌋=⌊23×2n⌋\\left\\lfloor\\dfrac{2^{n+1}}{3}\\right\\rfloor=\\left\\lfloor\\dfrac{2}{3}\\times 2^n\\right\\rfloor⌊32n+1​⌋=⌊32​×2n⌋，那么考虑用两次询问确定同层相邻四个节点中哪个赢得场数最多。也就是考虑用两次询问从 [1,2,3,4][1,2,3,4][1,2,3,4] 中找到下图中被红框框住的节点 333： 考虑询问 1,31,31,3： 若返回 111 即 111 赢得比 333 多，那么显然 333 和 222 都不可能是赢得最多的，接下来只用询问 1,41,41,4 即可找到赢得最多的； 若返回 222 即 333 赢得比 111 多，那么类比返回 111 的情况询问 3,23,23,2 即可； 若返回 000 即赢得一样多，那么显然他们两个都不可能是赢得最多的，接下来询问 2,42,42,4 即可。 所以我们每次这样处理一层的节点即可。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1713D Tournament Countdown 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1713d-tournament-countdown-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":134000,"words":569,"minutes":3},"date":"2023-03-27 17:59:56","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的矩阵。一次操作可以给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 然后交换所有的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{i,k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>k</mi><mo separator=\"true\">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{k,i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 。</p>\n<p>如图表示 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn><mo separator=\"true\">,</mo><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n=4,k=3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 的情况。</p>\n<figure data-type=\"image\" tabindex=\"1\"><img src=\"/../post-images/1679910985745.webp\" alt=\"\" loading=\"lazy\"></figure>\n<p>求若干次操作后字典序最小的矩阵。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding=\"application/x-tex\">1 \\leq n \\leq 1000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 n×nn\\times nn×n 的矩阵。一次操作可以给定一个 kkk 然后交换所有的 Ai,kA_{i,k}Ai,k​ 和 Ak,iA_{k,i}Ak,i​ 。 如图表示 n=4,k=3n=4,k=3n=4,k=3 的情况。 求若干次操作后字典序最小的矩阵。 1≤n≤10001 \\leq n \\leq 10001≤n≤1000。 显然一个位置 (x,y)(x,y)(x,y) 上的数只能被交换到 (y,x)(y,x)(y,x)，并且当且仅当 k=xk=xk=x 和 k=yk=yk=y 操作的执行状态不同才会被交换。 发现字典序最小肯定是尽量让前面的位置上的数更小，那么按照 x,yx,yx,y 升序的顺序遍历所有满足 x&lt;yx&lt;yx&lt;y 的位置 (x,y)(x,y)(x,y)，若 ax,y&lt;ay,xa_{x,y}&lt;a_{y,x}ax,y​&lt;ay,x​ 显然是让 k=xk=xk=x 和 k=yk=yk=y 操作的执行状态相同更优，否则不同更优。 考虑维护“两个操作的执行状态相同/不同”这个东西，显然可以考虑把 k=xk=xk=x 操作拆成两个点 xxx 和 x+nx+nx+n，用并查集维护。遍历到 (x,y)(x,y)(x,y) 时，若 k=xk=xk=x 和 k=yk=yk=y 操作的执行状态相同，那么合并 x,yx,yx,y 和 x+n,y+nx+n,y+nx+n,y+n 所处的集合，否则合并 x,y+nx,y+nx,y+n 和 x+n,yx+n,yx+n,y 所处的集合。注意若 xxx 和 y+ny+ny+n 处于一个集合即 k=xk=xk=x 和 k=yk=yk=y 操作的执行状态不同前面的更优那么就不能合并 x,yx,yx,y 和 x+n,y+nx+n,y+nx+n,y+n 所处的集合；xxx 和 yyy 处于一个集合同理。 最后再按照 x,yx,yx,y 升序的顺序遍历所有满足 x&lt;yx&lt;yx&lt;y 的位置 (x,y)(x,y)(x,y)，若 xxx 和 y+ny+ny+n 在同一个集合即 k=xk=xk=x 和 k=yk=yk=y 操作的执行状态不同那么交换 ax,ya_{x,y}ax,y​ 和 ay,xa_{y,x}ay,x​，即可找到答案。 ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF1713E Cross Swapping 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1713e-cross-swapping-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":146000,"words":541,"minutes":3},"date":"2023-03-27 17:54:23","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>未知一个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，让你每次猜两个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>，若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mtext> </mtext><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mi>a</mi><mo>)</mo><mo>≥</mo><mo>(</mo><mi>y</mi><mtext> </mtext><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x\\bmod a)\\ge (y\\bmod a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span></span></span></span> 返回 <code>x</code>，否则返回 <code>y</code>。让你猜测次数少于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>60</mn></mrow><annotation encoding=\"application/x-tex\">60</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span><span class=\"mord\">0</span></span></span></span> 次的时候猜出数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 未知一个数 aaa，让你每次猜两个数 xxx 和 yyy，若 (x mod a)≥(y mod a)(x\\bmod a)\\ge (y\\bmod a)(xmoda)≥(ymoda) 返回 x，否则返回 y。让你猜测次数少于 606060 次的时候猜出数 aaa。 1≤a≤1091\\le a\\le 10^91≤a≤109。 首先若 x≤ax\\le ax≤a 且 xmod⁡a≥2xmod⁡ax\\operatorname{mod} a\\ge 2x\\operatorname{mod} axmoda≥2xmoda，那么显然 x≤a≤2xx\\le a\\le2xx≤a≤2x。 那么若找到了一个这样的 xxx，就可以在 [x,2x][x,2x][x,2x] 中二分 aaa，若 midmod⁡a≥2midmod⁡amid\\operatorname{mod} a\\ge 2mid\\operatorname{mod} amidmoda≥2midmoda 则记下答案向上二分，否则向下二分。 考虑怎么找出这样的 xxx，考虑倍增，从 x=1x=1x=1 开始，若 xmod⁡a&lt;2xmod⁡ax\\operatorname{mod} a&lt; 2x\\operatorname{mod} axmoda&lt;2xmoda，那么让 x→2xx\\to 2xx→2x，直到找到满足条件的 xxx 为止。 倍增最多 303030 次，二分最多 292929 次。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1103B Game with modulo 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1103b-game-with-modulo-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":63000,"words":226,"minutes":2},"date":"2023-03-27 17:51:44","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>交互题，系统有两个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span>，你每次可以询问一组整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>c</mi><mo separator=\"true\">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(c,d)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mclose\">)</span></span></span></span>，系统会回答：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>c</mi><mo>&gt;</mo><mi>b</mi><mo>⊕</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">a\\oplus c&gt;b\\oplus d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>c</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">a\\oplus c=b\\oplus d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> 如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>c</mi><mo>&lt;</mo><mi>b</mi><mo>⊕</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">a\\oplus c&lt;b\\oplus d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span></li>\n</ul>\n<p>其中操作 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\oplus b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 表示 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 按位异或。</p>\n<p>你需要在询问不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>62</mn></mrow><annotation encoding=\"application/x-tex\">62</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span><span class=\"mord\">2</span></span></span></span> 次之后输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span> 的值，保证 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>&lt;</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le a, b &lt; 2^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 交互题，系统有两个整数 (a,b)(a,b)(a,b)，你每次可以询问一组整数 (c,d)(c,d)(c,d)，系统会回答： 111 如果 a⊕c&gt;b⊕da\\oplus c&gt;b\\oplus da⊕c&gt;b⊕d 000 如果 a⊕c=b⊕da\\oplus c=b\\oplus da⊕c=b⊕d −1-1−1 如果 a⊕c&lt;b⊕da\\oplus c&lt;b\\oplus da⊕c&lt;b⊕d 其中操作 a⊕ba\\oplus ba⊕b 表示 aaa 和 bbb 按位异或。 你需要在询问不超过 626262 次之后输出 (a,b)(a,b)(a,b) 的值，保证 0≤a,b&lt;2300\\le a, b &lt; 2^{30}0≤a,b&lt;230。 首先显然可以询问一次得到 a,ba,ba,b 的大小关系 fff，接下来分类讨论： 若 f=0f=0f=0，那么 aaa 和 bbb 相等，从高位向低位依次枚举，显然第 iii 位为 111 当且仅当 a&gt;(b⊕2i)a&gt;(b\\oplus 2^i)a&gt;(b⊕2i)。这样就可以用 303030 次询问确定 aaa 和 bbb； 若 f=0f\\not=0f​=0，那么从高位向低位依次枚举。枚举到第 iii 位时设当前（确定了前面的位的）答案为 AAA 和 BBB，a⊕Aa\\oplus Aa⊕A 和 b⊕Bb\\oplus Bb⊕B 的大小关系为 FFF。 显然刚开始 A=0,B=0,F=fA=0,B=0,F=fA=0,B=0,F=f。 枚举到第 iii 位时，询问 (a⊕A⊕2i)(a\\oplus A\\oplus 2^i)(a⊕A⊕2i) 和 (b⊕B⊕2i)(b\\oplus B\\oplus 2^i)(b⊕B⊕2i) 的大小关系，即询问两个数第 iii 位和更低位都异或上 2i2^i2i 的大小关系。设询问的结果为 EEE，分类讨论： 若 E=FE=FE=F，那么 aaa 和 bbb 的第 iii 位相等，这时若 (a⊕A)&gt;(b⊕B⊕2i)(a\\oplus A)&gt;(b\\oplus B\\oplus 2^i)(a⊕A)&gt;(b⊕B⊕2i) 那么 aaa 和 bbb 的第 iii 位为 111，因为 (a⊕A)(a\\oplus A)(a⊕A) 和 (b⊕B)(b\\oplus B)(b⊕B) 的最高位都是第 iii 位，这一位均为 111 那么异或 2i2^i2i 相当于消去最高位，显然会变得比另一个小； 若 E=FE\\not=FE​=F，那么 aaa 和 bbb 的第 iii 位不相等，这时若 F=1F=1F=1 那么 aaa 的第 iii 位为 111，否则 bbb 的第 iii 位为 111。更新完 AAA 和 BBB 之后再问一次 (a⊕A)(a\\oplus A)(a⊕A) 和 (b⊕B)(b\\oplus B)(b⊕B) 的大小关系来更新 FFF，注意若此时 FFF 更新成 000 那么剩下的位就要按照 f=0f=0f=0 情况的方法处理。 代码如下： // Problem: CF1088D Ehab and another another xor problem // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1088D // Memory Limit: 250 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N=29; int a,b; inline int que(int c,int d) { printf(&quot;? %d %d\\n&quot;,c,d); fflush(stdout); int x; scanf(&quot;%d&quot;,&amp;x); return x; } int main() { int f=que(0,0); int srt=N; if(f!=0) { for(int i=N;i&gt;=0;i--) { int val=1&lt;&lt;i; int pre=que(a^val,b^val); if(pre!=f) { if(f==1) a|=val; else b|=val; f=que(a,b); if(f==0) { srt=i-1; break; } } else if((f==1&amp;&amp;que(a^val,b)==-1)||(f==-1&amp;&amp;que(a,b^val)==1)) a|=val,b|=val; } } for(int i=srt;i&gt;=0;i--) { int val=1&lt;&lt;i; if(que(a,b^val)==1) a|=val,b|=val; } printf(&quot;! %d %d\\n&quot;,a,b); fflush(stdout); return 0; } ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1088D Ehab and another another xor problem 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1088d-ehab-and-another-another-xor-problem-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":244000,"words":813,"minutes":5},"date":"2023-03-27 17:49:19","dateFormat":"2023-03-27"},{"abstract":"","content":"楼房重建线段树是一种用于快速维护前/后缀最小/最大值以及其相关状态的特殊线段树。 楼房重建线段树的特殊之处主要体现在节点 uuu 的两个儿子合并更新节点 uuu 的数据上。 先看一道例题： CF1690G Count the Trains 单点修改，改完查询不同的前缀最小值个数。 1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105。 对原序列建出线段树，对应区间为 [l,r][l,r][l,r] 的节点 uuu 维护两个值： 区间中的最小值 mnumn_umnu​ 仅考虑这个区间时的答案 ansuans_uansu​，即不考虑 [1,l−1][1,l-1][1,l−1] 对 [l,r][l,r][l,r] 中的前缀最小值的影响时 [l,r][l,r][l,r] 中不同的前缀最小值的个数。 由于只有单点修改，所以考虑递归到底层再不断回溯更新答案即可。 考虑合并 uuu 的两个儿子的信息： mnumn_umnu​ 在两个儿子的最小值中取 min⁡\\minmin 即可。 ansuans_uansu​ 却不能直接取两个儿子的 ansansans 相加，因为左儿子的区间的最小值会对右儿子的区间的前缀最小值有影响。 考虑 ansuans_uansu​ 的求值，显然左儿子的答案可以直接加进 ansuans_uansu​，那么考虑左儿子的区间的最小值 val=mnlsval=mn_{ls}val=mnls​ 对右儿子的答案的影响。 考虑引入一个函数 calc(u,val)calc(u,val)calc(u,val)，它返回 uuu 考虑了前缀最小值 valvalval 的影响后的答案，代码如下： int calc(int u,int l,int r,int val) { if(l==r) return mx[u]&lt;val; int mid=l+r&gt;&gt;1; if(val&gt;mx[u&lt;&lt;1]) return calc(u&lt;&lt;1,l,mid,val)+ans[u]-ans[u&lt;&lt;1]; else return calc(u&lt;&lt;1|1,mid+1,r,val); } 其中 u&lt;&lt;1 和 u&lt;&lt;1|1 即为 uuu 的左右儿子。 考虑这样做的正确性： 当区间长度为 111 时，贡献直接暴力计算。 当区间长度大于 111 时： 若 val&gt;mnlsval&gt;mn_{ls}val&gt;mnls​，那么 valvalval 肯定不会对右子树的答案有影响，直接用 ansu−anslsans_u-ans_{ls}ansu​−ansls​ 算出右子树考虑了左子树影响后的答案，然后递归左子树即可； 否则左子树肯定不会产生任何贡献，直接递归右子树。 这样做的时间复杂度显然是 O(log⁡n)O(\\log n)O(logn) 的，因为每次会且仅会进入一个儿子的子树进行递归。 每次通过 uuu 的两个儿子的信息更新 uuu 的信息时直接 ansu→ansls+calc(rs,mnls)ans_u\\to ans_{ls}+calc(rs,mn_{ls})ansu​→ansls​+calc(rs,mnls​) 即可。 这样做还有一个小小的问题，若 ansansans 维护的东西不具有可减性，那么不能直接通过 ansu−anslsans_u-ans_{ls}ansu​−ansls​ 算出右子树考虑了左子树影响后的答案， 也不能在 calccalccalc 中同时递归两个子树。这时可以考虑每次合并两个儿子更新父亲的信息时记录右儿子的贡献。 完整代码如下： // Problem: CF1690G Count the Trains // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1690G // Memory Limit: 250 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; int n,m; int a[S]; int mx[S&lt;&lt;2],ans[S&lt;&lt;2]; int calc(int u,int l,int r,int val) { if(l==r) return mx[u]&lt;val; int mid=l+r&gt;&gt;1; if(val&gt;mx[u&lt;&lt;1]) return calc(u&lt;&lt;1,l,mid,val)+ans[u]-ans[u&lt;&lt;1]; else return calc(u&lt;&lt;1|1,mid+1,r,val); } void upda(int u,int l,int r) { mx[u]=min(mx[u&lt;&lt;1],mx[u&lt;&lt;1|1]); int mid=l+r&gt;&gt;1; ans[u]=ans[u&lt;&lt;1]+calc(u&lt;&lt;1|1,mid+1,r,mx[u&lt;&lt;1]); } void upd(int u,int l,int r,int pos,int val) { if(l==r) { mx[u]=val; ans[u]=1; return; } int mid=l+r&gt;&gt;1; if(pos&lt;=mid) upd(u&lt;&lt;1,l,mid,pos,val); else upd(u&lt;&lt;1|1,mid+1,r,pos,val); upda(u,l,r); } inline void slove() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),upd(1,1,n,i,a[i]); for(int i=1;i&lt;=m;i++) { int pos,val; scanf(&quot;%d%d&quot;,&amp;pos,&amp;val); upd(1,1,n,pos,a[pos]-=val); printf(&quot;%d &quot;,ans[1]); } printf(&quot;\\n&quot;); } int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) slove(); return 0; } 练习题目 P4198 楼房重建（维护不同的前缀最大值的个数） 区间： 问题描述 小 A 最近在研究数组，他认为如果数组的一个区间内不包含重复的元素，那么这个区间是一个优美的区间。 现在小 A 弄到了一个有趣的数组，他想知道这个数组有多少个优美的区间。当然，他有时候也会觉得这个数组不够优美，此时他会修改数组中的一个元素。 小 A 发现在修改之后他不会算有多少个优美的区间了，于是他来向你求助。 输入格式 第一行输入一个数 nnn，表示数组长度。 接下来一行输入 nnn 个整数，第 iii 个整数 aia_iai​ 是数组中的第 iii 个元素。 接下来一行输入一个数 qqq，表示操作数量。 接下来 qqq 行每行表示一次操作。如果某行第一个数为 000，则表示一次询问。否则后面输入两个数 xxx 和 yyy，表示将 axa_xax​ 修改为 yyy。 输出格式 对于每次询问，输出一行一个整数表示答案。 输入数据 1 3 1 2 3 3 0 1 1 2 0 输出数据 1 6 4 数据范围及约定 对于 40%40\\%40% 的数据，保证 n≤103n\\le 10^3n≤103。 对于 100%100\\%100% 的数据，保证 1≤n≤1051\\le n\\le 10^51≤n≤105，1≤q≤2n1\\le q\\le 2n1≤q≤2n，1≤ai≤n1\\le a_i\\le n1≤ai​≤n。 ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"楼房重建线段树学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/lou-fang-chong-jian-xian-duan-shu-xue-xi-bi-ji/","stats":{"text":"7 min read","time":402000,"words":1498,"minutes":7},"date":"2023-03-27 17:07:35","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>Ridbit 有一个隐藏的长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，Ashish 要去猜，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 的<strong>整数次幂</strong>。Ridbit 允许 Ashish 提出三种不同类型的查询。它们分别是：</p>\n<ul>\n<li>\n<p>AND <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>：求元素 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 每一位的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">and</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">1≤i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">j≤n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mi mathvariant=\"normal\">≠</mi><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i≠j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>）</p>\n</li>\n<li>\n<p>OR <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>：求元素 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 每一位的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">or</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">1≤i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">j≤n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mi mathvariant=\"normal\">≠</mi><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i≠j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>）</p>\n</li>\n<li>\n<p>XOR <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>：求元素 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 每一位的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">xor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">1≤i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">j≤n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mi mathvariant=\"normal\">≠</mi><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i≠j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>）</p>\n</li>\n</ul>\n<p>限制：</p>\n<ul>\n<li>Ashish 最多可以询问 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次（Hard Version）<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 次（Easy Version）。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le a_i \\le n - 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>。</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2^{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" Ridbit 有一个隐藏的长度为 nnn 的数组 aaa，Ashish 要去猜，nnn 是 222 的整数次幂。Ridbit 允许 Ashish 提出三种不同类型的查询。它们分别是： AND i,ji,ji,j：求元素 aia_iai​ 和 aja_jaj​ 每一位的 andandand（1≤i1≤i1≤i,j≤nj≤nj≤n,i≠ji≠ji​=j） OR i,ji,ji,j：求元素 aia_iai​ 和 aja_jaj​ 每一位的 ororor（1≤i1≤i1≤i,j≤nj≤nj≤n,i≠ji≠ji​=j） XOR i,ji,ji,j：求元素 aia_iai​ 和 aja_jaj​ 每一位的 xorxorxor（1≤i1≤i1≤i,j≤nj≤nj≤n,i≠ji≠ji​=j） 限制： Ashish 最多可以询问 n+1n + 1n+1 次（Hard Version）n+2n+2n+2 次（Easy Version）。 0≤ai≤n−20 \\le a_i \\le n - 20≤ai​≤n−2。 1≤n≤2161\\le n\\le 2^{16}1≤n≤216。 Easy Version 发现求出 a1a_1a1​ 就能通过异或求出剩下的数，那么考虑求 a1a_1a1​。 先用两次操作求出 a1⊕a2=xor12a_1\\oplus a_2=xor12a1​⊕a2​=xor12 和 a1&amp;a2=and12a_1\\&amp;a_2=and12a1​&amp;a2​=and12。显然对于某一个二进制位 iii，若 and12and12and12 的第 iii 位为 111，a1a_1a1​ 和 a2a_2a2​ 的第 iii 位也肯定为 111；若 xor12xor12xor12 的第 iii 位为 111，a1a_1a1​ 和 a2a_2a2​ 之间肯定有且仅有 一个数第 iii 位为 111。 考虑确定 xor12xor12xor12 二进制中的 111 哪些属于 a1a_1a1​，哪些属于 a2a_2a2​。显然可以再用两次操作求出 a2∣a3=or23a_2|a_3=or23a2​∣a3​=or23 和 a1&amp;a3=and13a_1\\&amp;a_3=and13a1​&amp;a3​=and13。 对于某一个满足 xor12xor12xor12 的第 iii 位为 111 的二进制位 iii，若 or23or23or23 的第 iii 位为 000，那么这个 111 显然属于 a1a_1a1​；否则若 and13and13and13 的第 iii 位为 111 那么这一个 111 属于 a1a_1a1​，否则这个 111 属于 a2a_2a2​。 这样我们就用 444 次操作求出了 a1a_1a1​ 和 a2a_2a2​，接下来用 n−2n-2n−2 次操作即可求出整个序列 aaa，总共花费了 n+2n+2n+2 次操作。 Hard Version 先对 2≤i≤n2\\le i\\le n2≤i≤n 的 iii 求出 bi=a1⊕aib_i=a_1\\oplus a_ibi​=a1​⊕ai​，耗费 n−1n-1n−1 次操作。 然后考虑用 222 次操作求出 a1a_1a1​： 显然若 bbb 中有相同的元素或者存在 bi=0b_i=0bi​=0 那么可以直接花费 111 次操作求出重复的元素，然后直接异或上 bib_ibi​ 求出 a1a_1a1​。 否则此时 aaa 中元素两两不同，那么显然一定有且仅有一个 bi=1b_i=1bi​=1，也有且仅有一个 bj=2b_j=2bj​=2，那么找出 i,ji,ji,j，询问 a1&amp;aia_1\\&amp; a_ia1​&amp;ai​ 即可确定 a1a_1a1​ 二进制中除了最后一位的其它位，询问 a1&amp;aja_1\\&amp;a_ja1​&amp;aj​ 即可确定 a1a_1a1​ 二进制中的最后一位。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1451E1&2 Bitwise Queries (Easy&Hard Version) 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1451e1and2-bitwise-queries-easyandhard-version-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":173000,"words":645,"minutes":3},"date":"2023-03-27 17:01:04","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>给定一个长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的不降序列，每次操作可以任选相邻的两个数，并将这两个数替换为两个数按位异或的结果，现在需要破坏序列的不降，求最少操作次数，无解输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\le n \\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le a_i \\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长为 nnn 的不降序列，每次操作可以任选相邻的两个数，并将这两个数替换为两个数按位异或的结果，现在需要破坏序列的不降，求最少操作次数，无解输出 −1-1−1。 2≤n≤1052 \\le n \\le 10^52≤n≤105，1≤ai≤1091 \\le a_i \\le 10^91≤ai​≤109。 首先，若序列中有三项的最高位相同（它们必定相邻），那么前两个异或起来就可以消去最高位，显然答案为 111。 否则序列中最高位为 2i2^i2i 的项最多只有两个，那么序列中最多有 606060 个数，直接暴力枚举 [l,k][l,k][l,k] 和 [k+1,r][k+1,r][k+1,r]，用前缀异或和判断能否破坏不降即可。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1415D XOR-gun 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1415d-xor-gun-zuo-ti-ji-lu/","stats":{"text":"1 min read","time":47000,"words":202,"minutes":1},"date":"2023-03-27 16:58:10","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>这是一道交互题</p>\n<p>有一个长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，你需要在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⌊</mo><mfrac><mrow><mn>3</mn><mi>n</mi></mrow><mn>2</mn></mfrac><mo>⌋</mo><mo>+</mo><mn>30</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor\\frac{3n}{2}\\rfloor + 30</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span></span></span></span> 次询问内找出排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 每一位所对应的数。</p>\n<p>有两种操作</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>:</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><msub><mi>p</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">t = 1 : max(min(x, p_i), min(x + 1, p_j))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>2</mn><mo>:</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo><mo separator=\"true\">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><msub><mi>p</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">t = 2 : min(max(x, p_i), max(x +1, p_j))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>t</mi><mo>≤</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>≤</mo><mi>n</mi><mo>(</mo><mi>i</mi><mi mathvariant=\"normal\">≠</mi><mi>j</mi><mo>)</mo><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le t \\le 2,1 \\le i,j \\le n(i \\ne j),1 \\le x \\le n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>T</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo separator=\"true\">,</mo><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo separator=\"true\">,</mo><mo>∑</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le T \\le 10^4,3 \\le n \\le 10^{4}, \\sum n \\le 2\\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064118em;vertical-align:-0.25001em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 这是一道交互题 有一个长为 nnn 的排列 ppp，你需要在 ⌊3n2⌋+30\\lfloor\\frac{3n}{2}\\rfloor + 30⌊23n​⌋+30 次询问内找出排列 ppp 每一位所对应的数。 有两种操作 t=1:max(min(x,pi),min(x+1,pj))t = 1 : max(min(x, p_i), min(x + 1, p_j))t=1:max(min(x,pi​),min(x+1,pj​)) t=2:min(max(x,pi),max(x+1,pj))t = 2 : min(max(x, p_i), max(x +1, p_j))t=2:min(max(x,pi​),max(x+1,pj​)) 1≤t≤2,1≤i,j≤n(i≠j),1≤x≤n−11 \\le t \\le 2,1 \\le i,j \\le n(i \\ne j),1 \\le x \\le n - 11≤t≤2,1≤i,j≤n(i​=j),1≤x≤n−1 1≤T≤104,3≤n≤104,∑n≤2×1041 \\le T \\le 10^4,3 \\le n \\le 10^{4}, \\sum n \\le 2\\times 10^41≤T≤104,3≤n≤104,∑n≤2×104 TTT 组询问 每次询问开始时会给出 ppp 的长度 nnn。 若知道了 pi=1p_i=1pi​=1 的 iii，那么可以通过 nnn 次询问来确定 ppp，每次询问 max⁡(min⁡(n−1,pi),min⁡(n,pj))\\max(\\min(n-1,p_i),\\min(n,p_j))max(min(n−1,pi​),min(n,pj​)) 即可确定 pjp_jpj​。 现在问题转化成了用 ⌊n2⌋+30\\left\\lfloor\\frac{n}{2}\\right\\rfloor+30⌊2n​⌋+30 次询问找到 pi=1p_i=1pi​=1 的 iii。 若每次询问相邻两个位置 pip_ipi​ 和 pi+1p_{i+1}pi+1​，取得 res=min⁡(max⁡(1,pi),max⁡(2,pi+1))res=\\min(\\max(1,p_i),\\max(2,p_{i+1}))res=min(max(1,pi​),max(2,pi+1​))，若 res=1res=1res=1 那么 pi=1p_i=1pi​=1，若 res=2res=2res=2 那么反过来问一次 min⁡(max⁡(1,pi+1),max⁡(2,pi))\\min(\\max(1,p_{i+1}),\\max(2,p_{i}))min(max(1,pi+1​),max(2,pi​)) 即可。 询问次数最多 ⌊n2⌋+2\\left\\lfloor\\frac{n}{2}\\right\\rfloor+2⌊2n​⌋+2。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1521C Nastia and a Hidden Permutation 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1521c-nastia-and-a-hidden-permutation-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":134000,"words":419,"minutes":3},"date":"2023-03-27 16:53:20","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 边的无向图里面选 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个点，满足与其它 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">n-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个点之间的连边条数为偶数，求方案数。</p>\n</blockquote>\n","content":" nnn 点 mmm 边的无向图里面选 kkk 个点，满足与其它 n−kn-kn−k 个点之间的连边条数为偶数，求方案数。 提示：考虑节点的度。 结论：度为偶数的点可以随便选，度为奇数的点选偶数个。 证明： 度为偶数的点 若这些点之间没有边相连，结论显然成立。 否则若 u,vu,vu,v 之间有边相连，显然若都选它们则度数都变为奇数，加起来还是偶数；若只选一个或者不选，则与情况 1 同理。 若更多的点之间有边相连，那么和情况 2 同理。 度为奇数的点 若这些点之间没有边相连，结论显然成立。 否则若 u,vu,vu,v 之间有边相连，显然若都选它们则度数都变为偶数，加起来还是偶数；若只选一个或者不选，则与情况 1 同理。 若更多的点之间有边相连，那么和情况 2 同理。 证毕。 赛时想了 1h。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ABC262E Red and Blue Graph 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc262e-red-and-blue-graph-zuo-ti-ji-lu/","stats":{"text":"1 min read","time":56000,"words":265,"minutes":1},"date":"2023-03-27 16:50:41","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>通信题，Alice 和 Bob 会收到同一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向图，Alice 会额外收到这个图的一个合法 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 染色。Alice 要向 Bob 发一个长度小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2.5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2.5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串，Bob 需要根据这个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串还原出任意一个合法的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 染色方案。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 通信题，Alice 和 Bob 会收到同一个 nnn 个点 mmm 条边的无向图，Alice 会额外收到这个图的一个合法 888 染色。Alice 要向 Bob 发一个长度小于等于 2.5×1052.5\\times 10^52.5×105 的 010101 串，Bob 需要根据这个 010101 串还原出任意一个合法的 888 染色方案。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤m≤5×1051\\le m\\le 5\\times 10^51≤m≤5×105。 考虑让 Alice 发送每个点颜色 mod⁡4\\operatorname{mod} 4mod4 的结果，然后 Bob 就可以通过对同色子图进行二分图染色来还原方案。 这样需要发送长 4×1054\\times 10^54×105 的 010101 串，考虑剪枝，不难发现度数 &lt;8&lt;8&lt;8 的点不用发，那么需要发的长度降到了 m8×2×2=m2=2.5×105\\frac{m}{8}\\times 2\\times 2=\\frac{m}{2}=2.5\\times 10^58m​×2×2=2m​=2.5×105，可以通过本题。 代码如下： Alice.cpp： #include &quot;Alice.h&quot; const int S=200005; std::vector&lt;int&gt; Alice(int N,int M,std::vector&lt;int&gt; U,std::vector&lt;int&gt; V,std::vector&lt;int&gt; C) { std::vector&lt;int&gt; res; std::vector&lt;std::vector&lt;int&gt;&gt; g; for(int i=0;i&lt;N;i++) g.push_back(std::vector&lt;int&gt;()); for(int i=0;i&lt;M;i++) g[U[i]].push_back(V[i]),g[V[i]].push_back(U[i]); for(int i=0;i&lt;N;i++) { if(g[i].size()&gt;=8) { int idx=C[i]&amp;3; res.push_back(idx&gt;&gt;1&amp;1); res.push_back(idx&amp;1); } } return res; } Bob.cpp： #include &quot;Bob.h&quot; #include &lt;cstdio&gt; #include &lt;queue&gt; std::vector&lt;int&gt; Bob(int N,int M,std::vector&lt;int&gt; U,std::vector&lt;int&gt; V,std::vector&lt;int&gt; X) { std::vector&lt;int&gt; res,flg; std::vector&lt;std::vector&lt;int&gt;&gt; g; for(int i=0;i&lt;N;i++) g.push_back(std::vector&lt;int&gt;()),flg.push_back(-1); for(int i=0;i&lt;N;i++) res.push_back(-1); for(int i=0;i&lt;M;i++) g[U[i]].push_back(V[i]),g[V[i]].push_back(U[i]); std::vector&lt;std::pair&lt;int,int&gt;&gt; val; for(int i=0,j=0;i&lt;N;i++) { if(g[i].size()&gt;=8) { int idx=0; idx=idx&lt;&lt;1|X[j++]; idx=idx&lt;&lt;1|X[j++]; flg[i]=idx; val.push_back(std::make_pair(i,idx)); } } for(int id=0;id&lt;=3;id++) { for(std::pair&lt;int,int&gt; u:val) { if(u.second==id&amp;&amp;res[u.first]==-1) { std::queue&lt;int&gt; q; q.push(u.first); res[u.first]=id; while(!q.empty()) { int u=q.front(); q.pop(); for(int v:g[u]) { if(flg[v]==id&amp;&amp;res[v]==-1) { res[v]=res[u]==id?4+id:id; q.push(v); } } } } } } for(int i=0;i&lt;N;i++) { if(g[i].size()&lt;8) { bool vis[8]; for(int j=0;j&lt;8;j++) vis[j]=false; for(int v:g[i]) if(res[v]!=-1) vis[res[v]]=true; for(int j=0;j&lt;8;j++) if(!vis[j]) res[i]=j; } } return res; } ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"POJ21677 / QOJ141 染色 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/poj21677-qoj141-ran-se-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":223000,"words":665,"minutes":4},"date":"2023-03-27 15:50:29","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>有一个无限大的平面，每个点上都有一盏灯。</p>\n<p>刚开始只有位于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>X</mi><mo separator=\"true\">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(X,0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> 的灯是亮起的，之后 Alice 会进行若干次操作，每次操作她会选择一个位置 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>，并同时改变 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x-1,y-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 这些灯的状态。</p>\n<p>最终一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 盏灯亮起了，给定这些灯的位置 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x_i,y_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，请你求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>17</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le |x_i|,|y_i|\\le 10^{17}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p>保证有解且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>17</mn></msup></mrow><annotation encoding=\"application/x-tex\">0\\le |X| \\le 10^{17}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 有一个无限大的平面，每个点上都有一盏灯。 刚开始只有位于 (X,0)(X,0)(X,0) 的灯是亮起的，之后 Alice 会进行若干次操作，每次操作她会选择一个位置 (x,y)(x,y)(x,y)，并同时改变 (x,y)(x,y)(x,y)、(x,y−1)(x,y-1)(x,y−1)、(x−1,y−1)(x-1,y-1)(x−1,y−1) 这些灯的状态。 最终一共有 nnn 盏灯亮起了，给定这些灯的位置 (xi,yi)(x_i,y_i)(xi​,yi​)，请你求出 XXX。 1≤n≤1051\\le n\\le 10^51≤n≤105，0≤∣xi∣,∣yi∣≤10170\\le |x_i|,|y_i|\\le 10^{17}0≤∣xi​∣,∣yi​∣≤1017。 保证有解且 0≤∣X∣≤10170\\le |X| \\le 10^{17}0≤∣X∣≤1017 由于操作可逆，所以考虑不断把亮着的灯往下移，对于一盏亮着的灯 (x,y)(x,y)(x,y)，可以操作一次 (x,y)(x,y)(x,y) 来让它灭掉，同时改变 (x,y−1)(x,y-1)(x,y−1) 和 (x−1,y−1)(x-1,y-1)(x−1,y−1) 的状态。 设 fx,yf_{x,y}fx,y​ 表示 (x,y)(x,y)(x,y) 这盏灯在通过以上操作灭掉 x′&gt;xx&#x27;&gt;xx′&gt;x 的灯时的状态，那么有 fx,y=fx,y+1⊕fx+1,y+1f_{x,y}=f_{x,y+1}\\oplus f_{x+1,y+1}fx,y​=fx,y+1​⊕fx+1,y+1​。不难发现 fx,y=(X−x0−y)mod⁡2f_{x,y}=\\binom{X-x}{0-y}\\operatorname{mod} 2fx,y​=(0−yX−x​)mod2。那么根据 Lucas 定理，有 fx,y=[X−x∈−y]f_{x,y}=[X-x\\in -y]fx,y​=[X−x∈−y]，其中 ∈\\in∈ 为二进制意义下的包含，即 X−xX-xX−x 按位与 −y-y−y 还是 X−xX-xX−x。 由于操作可逆，所以 Alice 的操作可以看作先把亮的灯往下移下的地方再把亮的灯往上移，所以对于一个足够小的 yyy，有 fx,y=⊕i=1n[xi−x∈yi−y]f_{x,y}=\\oplus_{i=1}^n [x_i-x\\in y_i-y]fx,y​=⊕i=1n​[xi​−x∈yi​−y]。 那么假如已经找到了一组 (p,y)(p,y)(p,y) 满足 fp,y=1f_{p,y}=1fp,y​=1，则可以得知 p−X∈−yp-X\\in -yp−X∈−y。那么可以从大往小枚举 kkk，若 fp−2k,y=1f_{p-2^k,y}=1fp−2k,y​=1 则让 p→p−2kp\\to p-2^kp→p−2k。这样最终会把 p−Xp-Xp−X 变成 000，得到 XXX。 而由于刚开始亮着的灯是 (X,0)(X,0)(X,0)，所以 f1017,−(260−1)f_{10^{17},-(2^{60}-1)}f1017,−(260−1)​ 一定为 111，那么令 p=1017p=10^{17}p=1017，y=−(260−1)y=-(2^{60}-1)y=−(260−1) 即可。 代码如下： // Problem: Triangular Lamps Easy // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_wtf19_c1 // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=100005; struct node { long long x,y; }a[S]; int n; inline bool chk(long long x,long long y) { bool res=false; for(int i=1;i&lt;=n;i++) res^=((a[i].y-y)&amp;(x-a[i].x))==x-a[i].x; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y); long long p=100000000000000000ll,y=-((1ll&lt;&lt;60)-1); printf(&quot;%d\\n&quot;,chk(p,y)); for(int i=59;i&gt;=0;i--) { if(chk(p-(1ll&lt;&lt;i),y)) p-=1ll&lt;&lt;i; } printf(&quot;%lld\\n&quot;,p); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【World tour final 2019 C1】Triangular Lamps Easy 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/world-tour-final-2019-c1-triangular-lamps-easy-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":247000,"words":802,"minutes":5},"date":"2023-03-27 14:56:51","dateFormat":"2023-03-27"},{"abstract":"","content":" 给定一棵树，求任意两点的 lca⁡\\operatorname{lca}lca，不需要支持带修。 这是一个十分常见的问题，这里总结一下目前常用的几种做法。 倍增（O(nlog⁡n+qlog⁡n)O(n\\log n+q\\log n)O(nlogn+qlogn)） 最常用的方法，用 upu,iup_{u,i}upu,i​ 记录 uuu 的第 2i2^i2i 级祖先，用 depudep_udepu​ 记录 uuu 的深度，显然这两个东西可以一遍 dfsdfsdfs 在 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度内求出来。 每次询问 lca⁡(x,y)\\operatorname{lca}(x,y)lca(x,y) 的时候先倍增让深度大的那个点跳到深度和另外一个点的深度相同的祖先，然后两个点一起倍增往上跳即可。 时间复杂度 O(nlog⁡n+qlog⁡n)O(n\\log n+q\\log n)O(nlogn+qlogn)。 代码如下： void dfs(int u,int fa) { dep[u]=dep[fa]+1; up[u][0]=fa; for(int i=1;i&lt;=25;i++) up[u][i]=up[up[u][i-1]][i-1]; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); } } inline int quelca(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); for(int i=25;i&gt;=0;i--) if(dep[up[x][i]]&gt;=dep[y]) x=up[x][i]; if(x==y) return x; for(int i=25;i&gt;=0;i--) if(up[x][i]!=up[y][i]) x=up[x][i],y=up[y][i]; return up[x][0]; } dfs 序 （O(nlog⁡n+q)O(n\\log n+q)O(nlogn+q)） 目前主流的还是欧拉序求 lca⁡\\operatorname{lca}lca，但是其实 dfs 序也可以，而且时间空间常数码量等等都吊打欧拉序。 思考欧拉序为什么能 rmq⁡\\operatorname{rmq}rmq 求 lca⁡\\operatorname{lca}lca，显然是因为 x,yx,yx,y 和 lca⁡(x,y)\\operatorname{lca}(x,y)lca(x,y) 映射到欧拉序之后 lca⁡(x,y)\\operatorname{lca}(x,y)lca(x,y) 一定在两点之间，而映射到 dfs 序之后却没有这个性质。 但是 dfs 序也有一个看似无用的性质：祖先一定出现在后代之前。 为了表述方便，设 posupos_uposu​ 表示节点 uuu 在 dfs 序中的位置，设 depudep_udepu​ 表示节点 uuu 的深度，并且下文假定 posx&lt;posypos_x&lt;pos_yposx​&lt;posy​。 接下来分情况讨论： xxx 不是 yyy 的祖先 设 lca⁡(x,y)=r\\operatorname{lca}(x,y)=rlca(x,y)=r，那么显然有 posr&lt;posxpos_r&lt;pos_xposr​&lt;posx​。显然此时 dfs 的顺序是从 rrr 下降到 xxx，再回到 rrr，下降到 yyy。 考虑 rrr 的 yyy 方向的儿子，即 rrr 的满足 yyy 在 uuu 子树内的儿子 uuu，那么由于需要先回到 rrr 才能在下降到 yyy 的过程中经过 uuu，所以一定有 posx&lt;posu≤posypos_x&lt;pos_u\\le pos_yposx​&lt;posu​≤posy​，也就是说在 dfs 序中 uuu 会出现在 xxx 和 yyy 中间。 那么找到 dfs 序 [posx,posy][pos_x,pos_y][posx​,posy​] 区间内深度最小的点的父亲即可。 xxx 是 yyy 的祖先 虽然这种情况可以很方便地特判掉，但是这样不够优美。 依旧考虑 xxx 的 yyy 方向的儿子 uuu，那么一定有 posx&lt;posu≤posypos_x&lt;pos_u\\le pos_yposx​&lt;posu​≤posy​，那么找到 dfs 序 [posx+1,posy][pos_x+1,pos_y][posx​+1,posy​] 区间内深度最小的点的父亲即可。 观察到就算 xxx 不是 yyy 的祖先，查询 [posx+1,posy][pos_x+1,pos_y][posx​+1,posy​] 区间内深度最小的点的父亲也可以得到 lca⁡(x,y)\\operatorname{lca}(x,y)lca(x,y)，所以直接对于所有情况都查询 [posx+1,posy][pos_x+1,pos_y][posx​+1,posy​] 区间内深度最小的点的父亲，唯一需要特判的情况只有 x=yx=yx=y。 那么解法就很显然了，用倍增 O(nlog⁡n)O(n\\log n)O(nlogn) 预处理 dfs 序某个区间中 depudep_udepu​ 最小的点 uuu 即可做到 O(nlog⁡n+q)O(n\\log n+q)O(nlogn+q)。 代码如下： int tot,dep[S],fat[S],a[S],pos[S]; int mylog[S],mn[S][30]; void dfs(int u,int fa) { dep[u]=dep[fa]+1; fat[u]=fa; a[++tot]=u; pos[u]=tot; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); } } inline void init(int rt) { dfs(rt,0); mylog[0]=-1; for(int i=1;i&lt;=n;i++) mylog[i]=mylog[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;i++) mn[i][0]=a[i]; for(int j=1;j&lt;=mylog[n];j++) { for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++) { mn[i][j]=dep[mn[i][j-1]]&lt;dep[mn[i+(1&lt;&lt;j-1)][j-1]]?mn[i][j-1]:mn[i+(1&lt;&lt;j-1)][j-1]; } } } inline int quelca(int x,int y) { if(x==y) return x; if(pos[x]&gt;pos[y]) swap(x,y); int l=pos[x]+1,r=pos[y]; int k=mylog[r-l+1]; int u=dep[mn[l][k]]&lt;dep[mn[r-(1&lt;&lt;k)+1][k]]?mn[l][k]:mn[r-(1&lt;&lt;k)+1][k]; return fat[u]; } 树链剖分（O(n+qlog⁡n)O(n+q\\log n)O(n+qlogn)，支持换根操作） 前置知识：树链剖分学习笔记 完成剖分之后每次暴力跳重链即可。 树链剖分还可以支持换根操作，具体详见：换根树剖学习笔记 时间复杂度 O(n+qlog⁡n)O(n+q\\log n)O(n+qlogn)。 Tarjan（O(n+q)O(n+q)O(n+q)，离线） 有些恶心的题目数据范围太大，带 log⁡\\loglog 的时间复杂度都过不去，那么此时就需要用 tarjan 来离线求 lca⁡\\operatorname{lca}lca。 考虑 xxx 和 yyy 和它们的 lca⁡(x,y)=d\\operatorname{lca}(x,y)=dlca(x,y)=d 在对整棵树进行 dfs 遍历时的访问顺序，显然是先从 ddd 下降到 x,yx,yx,y 中的某一个点，再回到 ddd，然后下降到另外一个点。 设一个点 uuu “完成了”当且仅当 uuu 的整棵子树都遍历完成了，若我们每次“完成”一个点之后就把它子树内的点集并入它的父亲的点集，那么显然 ddd 即为 xxx 和 yyy 都“完成”时“完成”得较早的那个点所处的集合内深度最小的那个点。 那么把询问离线下来，然后用并查集维护即可。 代码如下： int tot; int xs[S],ys[S],ans[S]; vector&lt;int&gt; ques[S]; int fa[S]; bool vis[S]; inline void quelca(int x,int y) { xs[++tot]=x; ys[tot]=y; ques[x].push_back(tot),ques[y].push_back(tot); } inline int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } inline void meg(int x,int y) { int rx=fnd(x),ry=fnd(y); fa[rx]=ry; } void dfs(int u,int fa) { for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); meg(v,u); } vis[u]=true; for(int qid:ques[u]) { int v=u==xs[qid]?ys[qid]:xs[qid]; if(vis[v]) ans[qid]=fnd(v); } } void flush(int rt) { for(int i=1;i&lt;=n;i++) fa[i]=i; dfs(rt,0); } 总结 &amp; 完整模板 一般情况下，倍增求 lca⁡\\operatorname{lca}lca 和 dfs 序求 lca⁡\\operatorname{lca}lca 已经足够。 在需要换根的情况下，只能用树剖求 lca⁡\\operatorname{lca}lca。 在需要卡常的情况下，若询问数较少，常数优秀的树剖求 lca⁡\\operatorname{lca}lca 比 Tarjan 求 lca⁡\\operatorname{lca}lca 还要快，但是若询问数非常多，那么 Tarjan 求 lca⁡\\operatorname{lca}lca 还是有必要的。 在强制在线并且要卡常的情况下，常数优秀的树剖求 lca⁡\\operatorname{lca}lca 是唯一的选择。 完整模板： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=1000005; int n,q,rot; int esum,to[S],nxt[S],h[S]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } namespace BZ { int dep[S],up[S][30]; void dfs(int u,int fa) { dep[u]=dep[fa]+1; up[u][0]=fa; for(int i=1;i&lt;=25;i++) up[u][i]=up[up[u][i-1]][i-1]; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); } } inline int quelca(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); for(int i=25;i&gt;=0;i--) if(dep[up[x][i]]&gt;=dep[y]) x=up[x][i]; if(x==y) return x; for(int i=25;i&gt;=0;i--) if(up[x][i]!=up[y][i]) x=up[x][i],y=up[y][i]; return up[x][0]; } } namespace DFS { int tot,dep[S],fat[S],a[S],pos[S]; int mylog[S],mn[S][30]; void dfs(int u,int fa) { dep[u]=dep[fa]+1; fat[u]=fa; a[++tot]=u; pos[u]=tot; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); } } inline void init(int rt) { dfs(rt,0); mylog[0]=-1; for(int i=1;i&lt;=n;i++) mylog[i]=mylog[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;i++) mn[i][0]=a[i]; for(int j=1;j&lt;=mylog[n];j++) { for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++) { mn[i][j]=dep[mn[i][j-1]]&lt;dep[mn[i+(1&lt;&lt;j-1)][j-1]]?mn[i][j-1]:mn[i+(1&lt;&lt;j-1)][j-1]; } } } inline int quelca(int x,int y) { if(x==y) return x; if(pos[x]&gt;pos[y]) swap(x,y); int l=pos[x]+1,r=pos[y]; int k=mylog[r-l+1]; int u=dep[mn[l][k]]&lt;dep[mn[r-(1&lt;&lt;k)+1][k]]?mn[l][k]:mn[r-(1&lt;&lt;k)+1][k]; return fat[u]; } } namespace TARJAN { int tot; int xs[S],ys[S],ans[S]; vector&lt;int&gt; ques[S]; int fa[S]; bool vis[S]; inline void quelca(int x,int y) { xs[++tot]=x; ys[tot]=y; ques[x].push_back(tot),ques[y].push_back(tot); } inline int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } inline void meg(int x,int y) { int rx=fnd(x),ry=fnd(y); fa[rx]=ry; } void dfs(int u,int fa) { for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); meg(v,u); } vis[u]=true; for(int qid:ques[u]) { int v=u==xs[qid]?ys[qid]:xs[qid]; if(vis[v]) ans[qid]=fnd(v); } } void flush(int rt) { for(int i=1;i&lt;=n;i++) fa[i]=i; dfs(rt,0); } } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;q,&amp;rot); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } // BZ::dfs(rot,0); // DFS::init(rot); while(q--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); // printf(&quot;%d\\n&quot;,BZ::quelca(x,y)); // printf(&quot;%d\\n&quot;,DFS::quelca(x,y)); TARJAN::quelca(x,y); } TARJAN::flush(rot); for(int i=1;i&lt;=TARJAN::tot;i++) printf(&quot;%d\\n&quot;,TARJAN::ans[i]); return 0; } ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"最近公共祖先（LCA）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zui-jin-gong-gong-zu-xian-lcaxue-xi-bi-ji/","stats":{"text":"13 min read","time":748000,"words":2434,"minutes":13},"date":"2023-03-27 11:21:24","dateFormat":"2023-03-27"},{"abstract":"","content":"Kruskal 重构树是一种常用于维护连通性的数据结构，用它可以快速维护一些点要联通的瓶颈边权之类的问题。 先看一道例题：CF1706E Qpwoeirut and Vertices。 给一张 nnn 个点 mmm 条边的无向连通图，qqq 次询问，每次询问给一个区间 [l,r][l,r][l,r]，求按照输入顺序加边，至少加到第几条边可以令编号在 [l,r][l,r][l,r] 内的点连通。 2≤n≤1052\\le n\\le 10^52≤n≤105，1≤m,q≤2×1051\\le m,q\\le 2\\times 10^51≤m,q≤2×105。 首先让所有点都单独自己一个连通块，并且让每个连通块的根节点都为连通块内的那个点本身。 然后按照边输入的顺序合并边两头的节点所在的连通块，处理到第 iii 条边时： 若这条边两头的节点已经连通，那么跳过这次操作； 设两个连通块的根节点分别是 rxrxrx 和 ryryry，那么就新建一个连向两个连通块的新点 r′r&#x27;r′，连接 r′→rxr&#x27;\\to rxr′→rx 和 r′→ryr&#x27;\\to ryr′→ry； 令 tmer′=itme_{r&#x27;}=itmer′​=i，即记录下 r′r&#x27;r′ 新建的时间点； 最后合并两个连通块，新的连通块的根节点即为 r′r&#x27;r′； 其实就是相当于把 Kruskal 求最小生成树时的合并操作表达成树。 容易发现，这样建出来的是一棵二叉树，并且有一些美妙的性质： 叶子节点就是原图中的每个点，新建出来的点代表原图的建边顺序最小生成树中的边； 对于所有满足 vvv 是 uuu 子树内的节点的 vvv，都有 tmev&lt;tmeutme_v&lt;tme_utmev​&lt;tmeu​ 原图中的一个点集 SSS 连通至少要加前 tmelca⁡(S)tme_{\\operatorname{lca}(S)}tmelca(S)​ 条边； 我们就把这样的二叉树叫做 Kruskal 重构树。那么本题直接用线段树维护 Kruskal 重构树上的区间 lca⁡\\operatorname{lca}lca 即可。 建树代码： for(int i=1;i&lt;=n*2-1;i++) fa[i]=i; for(int i=1;i&lt;=n*2-1;i++) ls[i]=rs[i]=tme[i]=0; int cnt=n; for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); int rx=fnd(x),ry=fnd(y); if(rx!=ry) { int u=++cnt; tme[u]=i; ls[u]=rx; rs[u]=ry; fa[rx]=fa[ry]=u; } } 练习题目 P4197 Peaks P7834 [ONTAK2010] Peaks 加强版 ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Kruskal 重构树学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kruskal-chong-gou-shu-xue-xi-bi-ji/","stats":{"text":"3 min read","time":156000,"words":616,"minutes":3},"date":"2023-03-27 11:18:35","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p><a href=\"https://www.luogu.com.cn/problem/P6545\">P6545 [CEOI2014] The Wall</a></p>\n</blockquote>\n","content":" P6545 [CEOI2014] The Wall 首先有个结论，筑的墙一定会把 (1,1)(1,1)(1,1) 到所有别的关键点的左上角的最短路都围进去。例如： 若当前墙包含的是深蓝色区域，而 (1,1)(1,1)(1,1) 到关键点 uuu 的左上角的最短路是绿色的线，那么显然把浅蓝色区域也包含进墙里是更优的，因为红色段肯定是比代替它的五小段绿色段的长度和要长的，因为绿色的线是最短路。 为什么是左上角？其实四个角都没关系，这个之后再证明。 求出了 (1,1)(1,1)(1,1) 到别的关键点的左上角的最短路之后，问题就转化为最小化筑墙的花费，使得筑出的墙可以圈住所有的最短路和关键点。 那么考虑把一个网格线的交点都拆成四个点，点之间顺时针连边权为 000 的有向边，属于不同交点的点之间连边权为原权值的有向边，但是要注意经过关键点和最短路的边都不能连： 容易发现，这样建好图之后，从网格左上角的交点拆出来的 111 号点出发，走到它的 333 号点，就能筑出合法的墙。那么花费最小的方案显然就是这两点之间的最短路。 最后说一下之前留下来的悬念： 为什么要走到左上角？？？为什么走到哪个角都没关系？？？ 不妨先钦定一定从左上角那个关键点的左上角出发，显然走到右上角的最短路一定“围着”走到左上角的最短路，即绿色的线不可能越过红色的线再回来，因为那样不优。 那么分两种情况讨论： 走到左上角的最短路是先走到右上角再往左走： 这时由于最后筑的墙要包含所有关键点，所以左上角和右上角之间的那条边不会被筑墙，也就是说，红线和绿线有用的部分是完全相等的，那么自然对答案没有任何影响； 走到左上角的最短路不是先走到右上角再往左走： 这时考虑最后跑的最短路，即筑的墙，用紫色的线标识。显然，由于走到左上角的最短路不是先走到右上角再往左走，所以走左上角和右上角的那条边一定是不优的；并且走红线和绿线中间也是不优的，因为红线和绿线是最短路。那么最终的墙只有可能是这样： 所以对最终的答案没有影响； 参考这样的证明方法，容易得出从哪个角出发，走到哪个角都是没有任何关系的。所以为了好写，干脆直接钦定从左上角开始和结束。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int S=5000005,MS=405; int n,m; int a[MS][MS]; long long dnval[MS][MS],rgval[MS][MS]; int esum,to[S],nxt[S],h[S]; long long c[S],dis[S]; bool vis[S]; bool dntag[MS][MS],rgtag[MS][MS]; inline int getid(int x,int y) { return (x-1)*(m+1)+y; } inline int getx(int id) { return (id-1)/(m+1)+1; } inline int gety(int id) { return (id-1)%(m+1)+1; } inline void add(int x,int y,long long w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } inline void dijkstra(int s) { memset(dis,127,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[s]=0; priority_queue&lt;pair&lt;long long,int&gt; &gt; q; q.push(make_pair(-dis[s],s)); while(!q.empty()) { int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=true; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; long long w=c[i]; if(dis[u]+w&lt;dis[v]) { dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); } } } } void dfs(int u) { vis[u]=true; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; long long w=c[i]; if(dis[u]==dis[v]+w) { int ux=getx(u),uy=gety(u),vx=getx(v),vy=gety(v); if(vx!=ux) dntag[min(ux,vx)][uy]=true; else rgtag[ux][min(uy,vy)]=true; if(!vis[v]) dfs(v); break; } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m+1;j++) { scanf(&quot;%lld&quot;,&amp;dnval[i][j]); int idu=getid(i,j),idv=getid(i+1,j); add(idu,idv,dnval[i][j]); add(idv,idu,dnval[i][j]); } } for(int i=1;i&lt;=n+1;i++) { for(int j=1;j&lt;=m;j++) { scanf(&quot;%lld&quot;,&amp;rgval[i][j]); int idu=getid(i,j),idv=getid(i,j+1); add(idu,idv,rgval[i][j]); add(idv,idu,rgval[i][j]); } } dijkstra(getid(1,1)); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(a[i][j]==1&amp;&amp;!vis[getid(i,j)]) dfs(getid(i,j)); esum=0; memset(h,0,sizeof(h)); for(int i=1;i&lt;=n+1;i++) { for(int j=1;j&lt;=m+1;j++) { int bg=(getid(i,j)-1)*4; int _0=bg+1,_1=bg+2,_2=bg+3,_3=bg+4; if(!dntag[i-1][j]&amp;&amp;a[i-1][j-1]==0&amp;&amp;a[i-1][j]==0) add(_0,_1,0); if(!rgtag[i][j]&amp;&amp;a[i-1][j]==0&amp;&amp;a[i][j]==0) add(_1,_2,0); if(!dntag[i][j]&amp;&amp;a[i][j]==0&amp;&amp;a[i][j-1]==0) add(_2,_3,0); if(!rgtag[i][j-1]&amp;&amp;a[i][j-1]==0&amp;&amp;a[i-1][j-1]==0) add(_3,_0,0); if(i&gt;1) { int ubg=(getid(i-1,j)-1)*4; int u2=ubg+3,u3=ubg+4; add(u2,_1,dnval[i-1][j]); add(_0,u3,dnval[i-1][j]); } if(j&gt;1) { int lbg=(getid(i,j-1)-1)*4; int l1=lbg+2,l2=lbg+3; add(l1,_0,rgval[i][j-1]); add(_3,l2,rgval[i][j-1]); } } } dijkstra(2); printf(&quot;%lld\\n&quot;,dis[4]); return 0; } ","tags":[{"name":"最短路","slug":"Jmuy2BzYo","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Jmuy2BzYo/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"P6545 [CEOI2014] The Wall 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p6545-ceoi2014-the-wall-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":402000,"words":1417,"minutes":7},"date":"2023-03-27 09:27:37","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>房子一共住了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人，这 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个人每个人有一个重要程度。</p>\n<p>房门上可以装有若干把锁，每把锁有一种唯一的钥匙与之对应。</p>\n<p>每一种钥匙可以复制若干份，并且可以发给任意多个居民。每个人都可以持有若干钥匙，也可以不持有钥匙。</p>\n<p>如果若干名居民钥匙的并集是全集，他们都在场时就能打开房门，否则不能打开房门。</p>\n<p>现在规定，一组居民都在场时能打开房门当且仅当他们的重要度之和大于等于为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>。</p>\n<p>问至少需要给房门装多少把锁。即，求最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，使得存在一种分配钥匙的方案，满足任意一组重要度之和小于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的居民持有的钥匙的并集不能打开所有房门且任意一组重要度之和大于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的居民持有的钥匙的并集能打开所有房门。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le m\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le a_i \\le m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>。</p>\n</blockquote>\n","content":" 房子一共住了 nnn 个人，这 nnn 个人每个人有一个重要程度。 房门上可以装有若干把锁，每把锁有一种唯一的钥匙与之对应。 每一种钥匙可以复制若干份，并且可以发给任意多个居民。每个人都可以持有若干钥匙，也可以不持有钥匙。 如果若干名居民钥匙的并集是全集，他们都在场时就能打开房门，否则不能打开房门。 现在规定，一组居民都在场时能打开房门当且仅当他们的重要度之和大于等于为 mmm。 问至少需要给房门装多少把锁。即，求最小的 kkk，使得存在一种分配钥匙的方案，满足任意一组重要度之和小于 mmm 的居民持有的钥匙的并集不能打开所有房门且任意一组重要度之和大于等于 mmm 的居民持有的钥匙的并集能打开所有房门。 1≤n≤201\\le n\\le201≤n≤20，1≤m≤1091\\le m\\le 10^91≤m≤109，1≤ai≤m1 \\le a_i \\le m1≤ai​≤m。 一道神奇的结论题。 首先摆出结论：答案即为不同的非空集合 SSS 个数 xxx，满足 SSS 里面的人的重要度之和小于 mmm，但是 SSS 任意再加上一个人的重要度之和就大于等于 mmm。 证明： 证明锁的个数小于 xxx 都不可行：考虑反证，设 l&lt;xl&lt;xl&lt;x 且有 lll 个锁的情况是可行的，那么由于一共有 xxx 个满足条件的 SSS 且 x&gt;lx&gt;lx&gt;l，所以必定有两个满足条件的集合 XXX 和 YYY 缺同一把钥匙。那么 XXX 和 YYY 并起来也还是缺那一把钥匙，而此时的重要度之和肯定要大于等于 mmm，却开不了门，不合法。 证明锁的个数等于 xxx 可行：有这样的一种构造方法，每个人持有所有代表的集合不包含他的锁的钥匙。 最后记得特判 ∑ai&lt;m\\sum a_i&lt;m∑ai​&lt;m 的情况，这时只需要一个任何人都没有钥匙的锁即可。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022NOI模拟赛7T1】锁 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022noi-mo-ni-sai-7t1-suo-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":125000,"words":563,"minutes":3},"date":"2023-03-27 09:23:58","dateFormat":"2023-03-27"},{"abstract":"","content":"线性基是一种经常用于解决集合异或问题的数据结构。其实与其说它是数据结构，说它是一种巧妙的构造算法更恰当。 定义 非负整数集合 SSS 的线性基 AAA 满足一些美妙的性质： AAA 是一个集合； SSS 能异或出来的所有非负整数，AAA 都能异或出来，但 AAA 的所有真子集都不能完全异或出来，也就是说 AAA 是极小的； 记 SSS 能异或出来的所有非负整数集合为 TTT，那么 TTT 中的每一个元素都仅可以被 AAA 中的某个特定子集 BBB 异或出来； 简单来说，线性基就是一个关于非负整数集合 SSS 的特殊的集合，它很小但又可以异或出 SSS 能异或出来的所有值。 构造 考虑线性基的构造，可以构造一种特殊的线性基使得： AAA 是一个有序序列； 对于每个 iii： 要么 AAA 中有且仅有 AiA_iAi​ 的二进制第 iii 位为 111，且 AiA_iAi​ 的二进制最高的为 111 的位是第 iii 位； 要么 Ai=0A_i=0Ai​=0 且只有所有满足 j&gt;ij&gt;ij&gt;i 的 AjA_jAj​ 二进制的第 iii 位为可能为 111； ∣A∣|A|∣A∣ 最大为 log⁡V\\log VlogV，其中 VVV 是值域； 具体方法是，先让 A={0,0,…,0}A=\\{0,0,\\dots,0\\}A={0,0,…,0}，然后不断的把 SSS 中的元素插入 AAA。一次插入的流程如下：（设插入的非负整数为 xxx） 从高位到低位枚举，假设枚举到第 iii 位，显然若 xxx 的二进制中第 iii 位为 000 则 xxx 不可能插入此处，直接跳过即可。否则： 若 Ai=0A_i\\not=0Ai​​=0，那么此时 xxx 肯定无法插入此处。由于要保证性质 2.1 中关于最高位的性质，所以需要删掉 xxx 的第 iii 位。又由于要满足线性基的性质 2，所以我们不能直接让 xxx 减去 2i2^i2i，而是应该让 x→xxor⁡Aix\\to x\\operatorname{xor} A_ix→xxorAi​，因为这样可以保证最终插入 AAA 的 xxx 异或上 AiA_iAi​ 还可以表示原来插入的 xxx，这样也不会让 AAA 中的元素能异或出其它的值或让 AAA 不再是极小的； 若 Ai=0A_i=0Ai​=0，那么： 让 xxx 异或上所有满足 j&lt;ij&lt;ij&lt;i 且 xxx 的二进制中第 jjj 位为 111 的 AjA_jAj​，这样做是为了保证性质 2.1 中有且仅有 AjA_jAj​ 的二进制第 jjj 位可能为 111 的性质，所以要通过异或操作把 xxx（未来的 AiA_iAi​） 的这些位删掉，不直接减去 2j2^j2j 的原因同上。 让 Ai→xA_i\\to xAi​→x； 让所有满足 j&gt;ij&gt;ij&gt;i 的 AjA_jAj​ 都异或上 AiA_iAi​，这样做同样是为了保证性质 2.1 中有且仅有 AjA_jAj​ 的二进制第 jjj 位可能为 111 的性质； 结束插入； 执行完插入流程后，若 x=0x\\not=0x​=0 那么插入就成功了，否则就表明当前的线性基中的元素已经能异或出 xxx，无需插入。但是若 x=0x=0x=0 就表明插入失败，即线性基已经能异或出 xxx 了。 插入代码如下： long long a[65]; bool has0; inline void ins(long long x) { for(int i=60;i&gt;=0&amp;&amp;x&gt;0;i--) // 注意一定要倒序枚举！因为要消掉 x 的二进制高位的 1，并且需要对 x 的二进制的低位造成影响 { if((x&gt;&gt;i)&amp;1) // x 的二进制这一位为 1 { if(a[i]==0) // 可以插入 { for(int j=i-1;j&gt;=0;j--) if((x&gt;&gt;j)&amp;1) x^=a[j]; // 这个循环的顺序不重要 // 因为所有满足 j&lt;i 的不为 0 的 A[j] 都不会影响到其它不为 0 的 A[j] a[i]=x; // 插入 for(int j=i+1;j&lt;=60;j++) if((a[j]&gt;&gt;i)&amp;1) a[j]^=a[i]; // 把所有满足 j&gt;i 且 A[j] 的二进制第 i 位为一的 A[j] 的二进制第 i 位消去 break; // 记得结束插入过程 } else x^=a[i]; // 不能插入，消去这一位 } } if(x==0) has0=true; } 查询 把非负整数集合 SSS 的元素都插入线性基后，线性基能支持几种关于异或的查询。 求 SSS 有多少个不同的子集异或和为 xxx 首先检查是否能异或出 xxx，若可以，那么 xxx 异或上线性基外的任意几个数得到的 x′x&#x27;x′ 都可以被线性基异或出来，所以答案为 2n−siz2^{n-siz}2n−siz，其中 siz=∑[Ai=0]siz=\\sum [A_i\\not=0]siz=∑[Ai​​=0]。 求 SSS 的子集的最大异或和 由于构造出来的线性基满足有且仅有 AiA_iAi​ 的二进制中第 iii 位为 111，所以 AiA_iAi​ 中参与异或运算的元素越多结果就越大，让所有 AiA_iAi​ 异或起来的结果 xsumxsumxsum 肯定是 AiA_iAi​ 的所有子序列的异或和中最大的。又由于线性基可以异或出 SSS 能异或出的所有值，所以 xsumxsumxsum 就是 SSS 的子集的最大异或和。 代码如下： inline long long quemx() { long long res=0; for(int i=0;i&lt;=60;i++) res^=a[i]; return res; } 求 SSS 的子集的最小异或和 由于 AiA_iAi​ 中参与异或运算的元素越多结果就越大，所以最优的情况显然是只让 AAA 中的一个元素参与异或运算，所以返回 AAA 中的最小值即可。不过要特判 000 的情况。 代码如下： inline long long quemn() { if(has0) return 0; long long mn=2e18; for(int i=0;i&lt;=60;i++) mn=min(mn,a[i]); return mn; } 求 SSS 的子集的第 kkk 小异或和 首先线性基中的元素是异或不出 000 的，所以若 SSS 可以异或出 000，即 has0=truehas0=truehas0=true，那么就需要让 k→k−1k\\to k-1k→k−1。 由于 AAA 中只有不为 000 的元素才对异或和有贡献，所以不妨用一个数组 BBB 依次记录下 AAA 中不为 000 的值。 显然，由于线性基可以异或出 SSS 能异或出的所有值，所以 2∣B∣−12^{|B|}-12∣B∣−1 种 BBB 的非空子序列都可以异或出互不相同的值，所以若 k&gt;2∣B∣−1k&gt;2^{|B|}-1k&gt;2∣B∣−1 就无解。 由于构造出来的线性基满足有且仅有 AiA_iAi​ 的二进制中第 iii 位为 111，所以对于任意一个 0≤i≤∣B∣0\\le i\\le |B|0≤i≤∣B∣ 的非负整数 iii，任意一个非负整数异或上 BiB_iBi​ 得到的结果都它比依次异或上 B1,B2,B3,…Bi−1B_1,B_2,B_3,\\dots B_{i-1}B1​,B2​,B3​,…Bi−1​ 小，这和二进制很像。 那么解法就很明显了，把所有满足 kkk 的二进制中第 iii 位为 111 的 BiB_iBi​ 异或起来，我们就能得到 SSS 的子集的第 kkk 小异或和。 代码如下： long long b[65]; inline long long kth(long long k) { if(has0) k--; int len=-1; for(int i=0;i&lt;=60;i++) if(a[i]!=0) b[++len]=a[i]; long long ans=0; for(int i=0;i&lt;=len;i++) if((k&gt;&gt;i)&amp;1) ans^=b[i],k^=1ll&lt;&lt;i; return k&gt;0?-1:ans; } 额外的操作 线性基还支持一些其它的操作。 合并 两个线性基合并，只需要暴力把一个线性基中的所有元素插入到另一个线性基中即可。容易证明插入完成的线性基还是满足所有性质的。 可持久化 由于线性基数组 AAA 很短，所以可以用二维数组来实现可持久化，时间和空间复杂度都是 O(qlog⁡V)O(q\\log V)O(qlogV) 的。其中 qqq 为操作次数，VVV 则表示值域大小。 ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"线性基学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/xian-xing-ji-xue-xi-bi-ji/","stats":{"text":"9 min read","time":484000,"words":1974,"minutes":9},"date":"2023-03-27 09:22:35","dateFormat":"2023-03-27"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{[1,n]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\">n</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>，现在要将其重排。</p>\n<p>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 于重排前在第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个位置，现在移动到了第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 个位置，那么对答案的贡献就是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>j</mi><mo>−</mo><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mo>×</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">|j-i|\\times a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<p>输出所有重排方案中最大的答案。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">2 \\leq N \\leq 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>A</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq A_i \\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n</blockquote>\n","content":" 给定 nnn 个数 a[1,n]a_{[1,n]}a[1,n]​，现在要将其重排。 如果 aia_iai​ 于重排前在第 iii 个位置，现在移动到了第 jjj 个位置，那么对答案的贡献就是 ∣j−i∣×ai|j-i|\\times a_i∣j−i∣×ai​。 输出所有重排方案中最大的答案。 2≤N≤20002 \\leq N \\leq 20002≤N≤2000 1≤Ai≤1091 \\leq A_i \\leq 10^91≤Ai​≤109 首先不难发现最大值一定是放在 111 或者 nnn，但是会出现放在 111 和 nnn 时价值相同的情况，所以不能直接贪心。 那么考虑设 dpl,rdp_{l,r}dpl,r​ 表示重新排列 a[l,r]a_{[l,r]}a[l,r]​ 后这段区间对答案的最大贡献，但是似乎不太好转移。 继续挖掘性质，不难发现原来的顺序并不重要，考虑从小到大填数。设 dpl,rdp_{l,r}dpl,r​ 表示前 r−l+1r-l+1r−l+1 小的数填入 [l,r][l,r][l,r] 后对答案的最大贡献，转移： dp[l,r]=max⁡(dp[l,r−1]+∣posr−l+1−r∣×valr−l+1,dp[l+1,r]+∣posr−l+1−l∣×valr−l+1)dp_{[l,r]}=\\max(dp_{[l,r-1]}+|pos_{r-l+1}-r|\\times val_{r-l+1},dp_{[l+1,r]}+|pos_{r-l+1}-l|\\times val_{r-l+1}) dp[l,r]​=max(dp[l,r−1]​+∣posr−l+1​−r∣×valr−l+1​,dp[l+1,r]​+∣posr−l+1​−l∣×valr−l+1​) 其中 posipos_iposi​ 和 valival_ivali​ 分别表示 aaa 中第 iii 小的数的位置和数值。 边界为 dpi,i−1=0dp_{i,i-1}=0dpi,i−1​=0，答案为 dp1,ndp_{1,n}dp1,n​。 代码如下： // Problem: [ABC163E] Active Infants // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT_abc163_e // Memory Limit: 1 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int S=2005; int n,a[S]; int id[S]; long long dp[S][S]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),id[i]=i; sort(id+1,id+n+1,[&amp;](int x,int y){return a[x]&lt;a[y];}); for(int len=1;len&lt;=n;len++) { for(int l=1;l&lt;=n-len+1;l++) { int r=l+len-1; dp[l][r]=max( dp[l][r-1]+1ll*abs(id[r-l+1]-r)*a[id[r-l+1]], dp[l+1][r]+1ll*abs(id[r-l+1]-l)*a[id[r-l+1]] ); } } printf(&quot;%lld\\n&quot;,dp[1][n]); return 0; } ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ABC163E Active Infants 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc163e-active-infants-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":174000,"words":561,"minutes":3},"date":"2023-03-26 17:28:36","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定一个长度为奇数的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1, a_2, \\dots, a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，你需要构造一组长度不超过的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mn>5</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\frac 52 n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathdefault\">n</span></span></span></span> 的操作序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_1, s_2, \\dots, s_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，使得：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>s</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le s_i \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为奇数；</li>\n<li>按从前往后的顺序，对于每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，反转排列的前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 项，最后得到的排列中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">a_i = i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>。</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2021</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2021</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长度为奇数的排列 a1,a2,…,ana_1, a_2, \\dots, a_na1​,a2​,…,an​，你需要构造一组长度不超过的 52n\\frac 52 n25​n 的操作序列 s1,s2,…,sks_1, s_2, \\dots, s_ks1​,s2​,…,sk​，使得： 1≤si≤n1 \\le s_i \\le n1≤si​≤n，sis_isi​ 为奇数； 按从前往后的顺序，对于每个 sis_isi​，反转排列的前 sis_isi​ 项，最后得到的排列中 ai=ia_i = iai​=i。 1≤n≤20211\\le n\\le 20211≤n≤2021，1≤ai≤n1\\le a_i\\le n1≤ai​≤n。 首先由于每次翻转的长度都是奇数，所以并不会改变奇偶性，那么若 aia_iai​ 和 iii 奇偶性不相同就是无解。 否则假设有解，考虑让 iii 和 i+1i+1i+1 在一起（iii 是奇数），然后丢到后面来不对别的数造成影响，最后再整体翻转一次。由于操作次数是 52n\\frac{5}{2}n25​n，所以不难想到给每一对数 555 次操作来还原。 这里给出一种构造方案： 用一次操作把 iii 换到第一位； 用一次操作把 iii 换到和 i+1i+1i+1 相邻的位置； 把 i+1i+1i+1 换到第二个位置，这时 iii 在第三个位置； 交换前三个位置，这样就可以让序列的前两个位置分别为 iii 和 i+1i+1i+1； 把它们两个放到最后即可。 这样做每次只需要 555 次操作即可把 iii 和 i+1i+1i+1 换好。 最后整体倒过来就行，总操作次数刚好是 52n\\dfrac{5}{2}n25​n。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1558C Bottom-Tier Reversals 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1558c-bottom-tier-reversals-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":94000,"words":385,"minutes":2},"date":"2023-03-26 11:28:03","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>对于一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串，下标从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。定义两种类型的操作:</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 类型:选择一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，将序列循环右移 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 位，也就是新序列的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>x</mi><mo>)</mo><mspace></mspace><mspace width=\"0.6666666666666666em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(i+x)\\mod\\ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">n</span></span></span></span> 位对应原序列的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 位。例如：对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">x=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0110001100</mn></mrow><annotation encoding=\"application/x-tex\">0110001100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> 将会变成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1000110001</mn></mrow><annotation encoding=\"application/x-tex\">1000110001</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 类型:选择一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，满足序列的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 个位置为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，且第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo><mspace></mspace><mspace width=\"0.6666666666666666em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(x+1)\\mod\\ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">n</span></span></span></span> 位置不为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，交换序列的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 个位置和第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo><mspace></mspace><mspace width=\"0.6666666666666666em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(x+1)\\mod\\ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">n</span></span></span></span> 个位置的字符。</p>\n<p>对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0101101011</mn></mrow><annotation encoding=\"application/x-tex\">0101101011</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x= 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">x =3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 均是不合法的，而 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">x = 4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span></span></span></span> 是合法的，操作后序列变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1101011010</mn></mrow><annotation encoding=\"application/x-tex\">1101011010</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>。</p>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">n,k,l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span>。请构造一个由 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding=\"application/x-tex\">01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 串构成的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">s[]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mopen\">[</span><span class=\"mclose\">]</span></span></span></span>，下标从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 开始。使得序列中每个串恰好有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。且对于所有满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">0\\le i&lt;l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">s[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span></span></span></span> 既可以通过一次 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 类型的操作，也可以通过一次 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 类型的操作，变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">s[i+1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>。</p>\n<p>举个例子，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>001001</mn></mrow><annotation encoding=\"application/x-tex\">001001</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span></span></span></span> 既可以通过一种 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 类型的操作也可以通过一种 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 类型的操作变为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>100100</mn></mrow><annotation encoding=\"application/x-tex\">100100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>：对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 类型可以设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 类型可以设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">x = 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 组数据。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>l</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">2\\le n,l\\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">0\\le k\\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>T</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">1\\le T\\le 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 对于一个长度为 nnn 的 010101 串，下标从 000 到 n−1n-1n−1。定义两种类型的操作: AAA 类型:选择一个 xxx，将序列循环右移 xxx 位，也就是新序列的第 (i+x)mod n(i+x)\\mod\\ n(i+x)mod n 位对应原序列的第 iii 位。例如：对于 x=2x=2x=2，011000110001100011000110001100 将会变成 100011000110001100011000110001。 BBB 类型:选择一个 xxx，满足序列的第 xxx 个位置为 111，且第 (x+1)mod n(x+1)\\mod\\ n(x+1)mod n 位置不为 111，交换序列的第 xxx 个位置和第 (x+1)mod n(x+1)\\mod\\ n(x+1)mod n 个位置的字符。 对于 010110101101011010110101101011，x=0x= 0x=0 和 x=3x =3x=3 均是不合法的，而 x=4x = 4x=4 是合法的，操作后序列变为 110101101011010110101101011010。 给定 n,k,ln,k,ln,k,l。请构造一个由 lll 个长度为 nnn 的 010101 串构成的序列 s[]s[]s[]，下标从 000 开始。使得序列中每个串恰好有 kkk 个 111。且对于所有满足 0≤i&lt;l0\\le i&lt;l0≤i&lt;l 的 iii，s[i]s[i]s[i] 既可以通过一次 AAA 类型的操作，也可以通过一次 BBB 类型的操作，变为 s[i+1]s[i+1]s[i+1]。 举个例子，001001001001001001 既可以通过一种 AAA 类型的操作也可以通过一种 BBB 类型的操作变为 100100100100100100：对于 AAA 类型可以设 x=1x = 1x=1，对于 BBB 类型可以设 x=2x = 2x=2。 TTT 组数据。 2≤n,l≤1002\\le n,l\\le 1002≤n,l≤100，0≤k≤n0\\le k\\le n0≤k≤n，1≤T≤101\\le T\\le 101≤T≤10。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=105; int n,k,l; int a[S],b[S]; inline int gcd(int x,int y) { if(y==0) return 0; int t=x%y; while(t!=0) x=y,y=t,t=x%y; return y; } // 首先不难发现，只要求出 s[0] 即第一个字符串， // 后面的就可以通过暴力枚举交换的位置哈希判断来得到， // 那么考虑构造一个满足条件的 s[0] void dfs(int n,int k) // 递归构造 n，k 时的 s[0] { if(k==1) { a[1]=1; return; } // 若此时 n 和 k 互质，那么 n 一定不是 k 的倍数。考虑这 k 个 1 之间的 k 个间隔 // 由于这 k 个间隔的总和一定是 n，所以 // 显然有 k-n%k 个 floor(n/k) 和 n%k 个 ceil(n/k) 即 floor(n/k)+1。 // // 考虑操作 B 的本质，其实就是让 a[i]--，a[i+1]++， // 而这样也会让位置 i 上原本的 1 距离上一个 1 的距离增加 1， // 而位置 i 之后最近的那个 1 距离它之前的 1 的距离会减去 1。 // // 也就是说，若设 b[i] 为第 i 个 1 距离第 i-1 个 1 的距离，也就是它们的位置之差， // 特别的，b[1] 表示第 1 个 1 距离第 k 个 1 的距离，那么操作 B 相当于让 b[i]++，b[i+1]--。 // // 那么把等于 floor(n/k) 的 b[i] 都看成 1，把等于 floor(n/k)+1 的 b[i] 看成 0， // 递归处理 n=k，k=k-n%k 的情况即可。 // 若 n 和 k 不互质，那么 ceil(n/k) 显然是不可能恰好等于 floor(n/k)+1 的，此时便无解， // 因为 b[i] 怎么加减都会出现新的未出现过的数值，不可能和原来的 b 循环同构。 dfs(k,k-n%k); int val0=n/k+1,val1=n/k; for(int i=1;i&lt;=k;i++) b[i]=a[i]==0?val0:val1; for(int i=1;i&lt;=n;i++) a[i]=0; int pos=n; // 钦定最后一位为 1，因为 s[0] 是循环同构的 for(int i=k;i&gt;=1;i--) a[pos]=1,pos=(pos-b[i]-1+n)%n+1; } set&lt;__int128_t&gt; st; // 把 01 序列当作二进制数进行哈希 inline __int128_t calc(int a[]) // 计算哈希 { __int128_t pw2=1,has=0; for(int i=1;i&lt;=n;i++) { has+=a[i]*pw2; pw2*=2; } return has; } inline void slove() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;l); if(gcd(n,k)!=1) // 无解情况：n 和 k 不互质 { puts(&quot;NO&quot;); return; } st.clear(); puts(&quot;YES&quot;); for(int i=1;i&lt;=n;i++) a[i]=0; dfs(n,k); st.insert(calc(a)); for(int i=1;i&lt;=n;i++) // 预处理好和 s[0] 循环同构的字符串 { for(int j=1;j&lt;=n;j++) b[(j+i-1)%n+1]=a[j]; st.insert(calc(b)); } for(int i=1;i&lt;=l;i++) { for(int j=1;j&lt;=n;j++) printf(&quot;%d&quot;,a[j]); printf(&quot;\\n&quot;); for(int j=1;j&lt;=n;j++) // 暴力找下一个 { for(int k=1;k&lt;=n;k++) b[k]=a[k]; if(b[j]==1&amp;&amp;b[j%n+1]==0) { b[j]=0; b[j%n+1]=1; if(st.count(calc(b))) { for(int k=1;k&lt;=n;k++) a[k]=b[k]; break; } } } } } int main() { int T=1; scanf(&quot;%d&quot;,&amp;T); while(T--&gt;0) { slove(); } return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2022NOI模拟赛3T1】环 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022noi-mo-ni-sai-3t1-huan-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":344000,"words":1190,"minutes":6},"date":"2023-03-26 11:24:36","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>这是一道交互题。</p>\n<p>在文本编辑器里有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个单词，其中第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个单词的长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">l_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le l_i \\le 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>)。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 仅对测评机可见。</p>\n<p>文本编辑器一行一行展示文本，以空格分开相邻的两个单词，但是行末不一定有空格，即单词可以直接作为某一行的末尾。定义文本的高度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> 为文本展示需要的行数。对于给定的屏幕宽度，编辑器会以高度最小的方式显示。</p>\n<p>更正式地，设文本编辑器的宽度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 。设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> 是一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的序列，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>a</mi><mn>2</mn></msub><mo>&lt;</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>&lt;</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1 = a_1 &lt; a_2 &lt; ... &lt; a_{k+1} = n + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> 是一个合法的序列当且仅当，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi><mo separator=\"true\">,</mo><msub><mi>l</mi><msub><mi>a</mi><mi>i</mi></msub></msub><mo>+</mo><mn>1</mn><mo>+</mo><msub><mi>l</mi><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msub><mo>+</mo><mn>1</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mn>1</mn><mo>+</mo><msub><mi>l</mi><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mn>1</mn></mrow></msub><mo>≤</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">\\forall 1 \\le i \\le k, l_{a_i} + 1 + l_{a_{i + 1}} + 1 + \\dots + 1 + l_{a_{i+1} - 1} \\le w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">∀</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9445399999999999em;vertical-align:-0.2501em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.986205em;vertical-align:-0.291765em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32808571428571426em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20252142857142857em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.291765em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.986205em;vertical-align:-0.291765em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32808571428571426em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20252142857142857em;\"><span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.291765em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span>。 那么，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> 就是所有合法的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> 中最小的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>.。</p>\n<p>注意，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>w</mi><mo>≤</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><msub><mi>l</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">w \\le \\max(l_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，那么文本编辑器将不能显示所有的文字并且崩溃，此时 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>h</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">h = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<p>你可以做 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>30</mn></mrow><annotation encoding=\"application/x-tex\">n + 30</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span></span></span></span> 次询问。每次询问中，输出宽度 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span> . 测评机将返回 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>h</mi><mi>w</mi></msub></mrow><annotation encoding=\"application/x-tex\">h_w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，即当宽度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 的最小高度。</p>\n<p>请找到文本编辑器的最小面积，即求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>w</mi><mo>×</mo><msub><mi>h</mi><mi>w</mi></msub><mi mathvariant=\"normal\">∣</mi><mn>1</mn><mo>≤</mo><mi>w</mi><mo>≤</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">min(w\\times h_w | 1 \\le w \\le n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n</blockquote>\n","content":" 这是一道交互题。 在文本编辑器里有 nnn 个单词，其中第 iii 个单词的长度为 lil_ili​ (1≤li≤20001 \\le l_i \\le 20001≤li​≤2000)。lll 仅对测评机可见。 文本编辑器一行一行展示文本，以空格分开相邻的两个单词，但是行末不一定有空格，即单词可以直接作为某一行的末尾。定义文本的高度 hhh 为文本展示需要的行数。对于给定的屏幕宽度，编辑器会以高度最小的方式显示。 更正式地，设文本编辑器的宽度为 www 。设 aaa 是一个长度为 k+1k + 1k+1 的序列，其中 1=a1&lt;a2&lt;...&lt;ak+1=n+11 = a_1 &lt; a_2 &lt; ... &lt; a_{k+1} = n + 11=a1​&lt;a2​&lt;...&lt;ak+1​=n+1. {an}\\{a_n\\}{an​} 是一个合法的序列当且仅当，∀1≤i≤k,lai+1+lai+1+1+⋯+1+lai+1−1≤w\\forall 1 \\le i \\le k, l_{a_i} + 1 + l_{a_{i + 1}} + 1 + \\dots + 1 + l_{a_{i+1} - 1} \\le w∀1≤i≤k,lai​​+1+lai+1​​+1+⋯+1+lai+1​−1​≤w。 那么，hhh 就是所有合法的 {an}\\{a_n\\}{an​} 中最小的 kkk.。 注意，如果 w≤max⁡(li)w \\le \\max(l_i)w≤max(li​)，那么文本编辑器将不能显示所有的文字并且崩溃，此时 h=0h = 0h=0。 你可以做 n+30n + 30n+30 次询问。每次询问中，输出宽度 www . 测评机将返回 hwh_whw​ ，即当宽度为 www 的最小高度。 请找到文本编辑器的最小面积，即求 min(w×hw∣1≤w≤n)min(w\\times h_w | 1 \\le w \\le n)min(w×hw​∣1≤w≤n)。 看到 n+30n+30n+30 次询问，容易猜到应该是用 303030 次操作求一个关于值域的东西，剩下 nnn 次操作求出答案。 考虑 303030 次操作能求出什么，显然可以二分求出： 最长的单词长度 mxlenmxlenmxlen； h=1h=1h=1 时最小的 www，即所有单词的长度和加上 n−1n-1n−1，设它为 LLL。 mxlenmxlenmxlen 好像没什么用，那么考虑 LLL 的用途。 若 h=ih=ih=i 且此时更优秀，那么 www 的最大的情况只能是 ⌊Li⌋\\lfloor\\frac{L}{i}\\rfloor⌊iL​⌋，并且由于 h=ih=ih=i 时最多只能比 h=1h=1h=1 节省 i−1i-1i−1 个空格，所以 w=⌊Li⌋−1w=\\lfloor\\frac{L}{i}\\rfloor-1w=⌊iL​⌋−1 是不可能成立的。 所以 h=ih=ih=i 且更优秀时的 www 一定为 ⌊Li⌋\\lfloor\\frac{L}{i}\\rfloor⌊iL​⌋。 那么求出 LLL 之后枚举 hhh 即可。 ","tags":[{"name":"交互、通信","slug":"AZHW-uP7J","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/AZHW-uP7J/"},{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1672E notepad.exe 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1672e-notepadexe-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":162000,"words":621,"minutes":3},"date":"2023-03-26 11:23:02","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">n(1\\le n\\le 1000)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> ，仅由前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span></span></span></span> 个英文小写字母和问号组成的字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>。</p>\n<p>多次询问，每次给出一个由前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span></span></span></span> 个英文小写字母组成的字符集 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> ，你可以将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 中的问号任意替换成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 中的字母，求你能得到多少个不同的回文子串</p>\n<p>答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998144353</mn></mrow><annotation encoding=\"application/x-tex\">998144353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n</blockquote>\n","content":" 给定一个长度为 n(1≤n≤1000)n(1\\le n\\le 1000)n(1≤n≤1000) ，仅由前 171717 个英文小写字母和问号组成的字符串 sss。 多次询问，每次给出一个由前 171717 个英文小写字母组成的字符集 AAA ，你可以将 sss 中的问号任意替换成 AAA 中的字母，求你能得到多少个不同的回文子串 答案对 998144353998144353998144353 取模。 观察到字符集很小，所以考虑预处理出每个字符集的答案，询问的时候快速回答。 设 dpi,jdp_{i,j}dpi,j​ 表示字符集为 iii（iii 的二进制位表示对应字符有/没有），字符集大小为 jjj 的答案，allallall 为整个字符串中 ? 的个数。 这里新增一维存储字符集大小是因为转移的时候 dpidp_idpi​ 会统计上 j∈ij\\in ij∈i 的 dpjdp_jdpj​，而在统计答案的时候会用到字符集大小的乘方，无法化简。 不难发现，可以枚举回文中心，然后不停往两边拓展，扩展途中记录下当前子串内部的 ? 个数 cntcntcnt： 若遇到两个不为 ? 且不同的字符或者超出字符串边界，那么停止拓展； 若遇到一边为 ? 另一边不为 ?，那么字符集 stastasta 加上不为 ? 的那个字符且让 cnt→cnt+1cnt\\to cnt+1cnt→cnt+1； 若遇到两边都为 ?，那么让 cnt→cnt+1cnt\\to cnt+1cnt→cnt+1； 初始子串为空串，每拓展一次，就把 dpsta,jdp_{sta,j}dpsta,j​ 加上 jall−cntj^{all-cnt}jall−cnt。 处理完所有子串之后，需要让 dpidp_idpi​ 统计上所有 j∈ij\\in ij∈i 的 dpjdp_jdpj​，那么仿照 CF449D Jzzhu and Numbers 的思路，转移的时候先按位枚举，再枚举那一位为 111 的 iii 来转移 dpidp_idpi​，这样就可以避免算重。 int n,q; char s[S],str[S]; int dp[1&lt;&lt;17][25]; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } inline void slove() { cin&gt;&gt;n; cin&gt;&gt;(s+1); int all=0; for(int i=1;i&lt;=n;i++) all+=s[i]=='?'; for(int i=1;i&lt;=n;i++) { int l=i+1,r=i-1; int sta=0,cnt=0; while(l&gt;1&amp;&amp;r&lt;n&amp;&amp;(s[l-1]==s[r+1]||s[l-1]=='?'||s[r+1]=='?')) { l--,r++; if(s[l]=='?'&amp;&amp;s[r]!='?') sta|=1&lt;&lt;s[r]-'a'; if(s[l]!='?'&amp;&amp;s[r]=='?') sta|=1&lt;&lt;s[l]-'a'; if(l!=r&amp;&amp;(s[l]=='?'||s[r]=='?')) cnt++; for(int j=1;j&lt;=17;j++) dp[sta][j]=(dp[sta][j]+qpow(j,all-cnt))%p; } l=i+1,r=i; sta=0,cnt=0; while(l&gt;1&amp;&amp;r&lt;n&amp;&amp;(s[l-1]==s[r+1]||s[l-1]=='?'||s[r+1]=='?')) { l--,r++; if(s[l]=='?'&amp;&amp;s[r]!='?') sta|=1&lt;&lt;s[r]-'a'; if(s[l]!='?'&amp;&amp;s[r]=='?') sta|=1&lt;&lt;s[l]-'a'; if(s[l]=='?'||s[r]=='?') cnt++; for(int j=1;j&lt;=17;j++) dp[sta][j]=(dp[sta][j]+qpow(j,all-cnt))%p; } } for(int j=0;j&lt;=16;j++) for(int i=0;i&lt;=(1&lt;&lt;17)-1;i++) if((i&gt;&gt;j)&amp;1) for(int k=1;k&lt;=17;k++) dp[i][k]=(dp[i][k]+dp[i^(1&lt;&lt;j)][k])%p; cin&gt;&gt;q; while(q--&gt;0) { cin&gt;&gt;(str+1); int len=strlen(str+1),sta=0; for(int i=1;i&lt;=len;i++) sta|=1&lt;&lt;str[i]-'a'; cin&lt;&lt;dp[sta][len]&lt;&lt;endl; } } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"CF1679E Typical Party in Dorm 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1679e-typical-party-in-dorm-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":241000,"words":823,"minutes":5},"date":"2023-03-26 11:19:09","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>本题是多组数据。</p>\n<p>对于每组数据，给出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数字，求有多少种排列方式，使得排列后的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个数字首尾相接形成的数字能被 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>11</mn></mrow><annotation encoding=\"application/x-tex\">11</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">1</span></span></span></span> 整除。答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 本题是多组数据。 对于每组数据，给出 nnn 个数字，求有多少种排列方式，使得排列后的 nnn 个数字首尾相接形成的数字能被 111111 整除。答案对 998244353998244353998244353 取模 1≤n≤20001\\le n\\le 20001≤n≤2000，1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109。 发现一个数能被 111111 整除当且仅当它奇数位的和和偶数位的和相等，也就是奇数位的和减去偶数位的和等于 000。 那么预处理出每一个数字的奇数位减偶数位的结果 aia_iai​，与每一个数字的位数 lenilen_ileni​。不难发现，若 lenilen_ileni​ 为奇数，那么它插入序列之后它后面的差会取反，lenilen_ileni​ 为偶数则可以随便插入而对后面没有影响。所以不妨先让所有 lenilen_ileni​ 为奇数的 aia_iai​ 确定好位置，再让 lenilen_ileni​ 为偶数 aia_iai​ 的插入进去。 所以设 dpi,j,kdp_{i,j,k}dpi,j,k​ 为前 iii 个 lenilen_ileni​ 为奇数的 aia_iai​，有 jjj 个 aia_iai​ 贡献为负，总和 mod⁡11=k\\operatorname{mod} 11=kmod11=k 的方案数（不考虑顺序）。那么有转移： dpi,j,k=dpi−1,j,k−ai+dpi−1,j−1,k+aidp_{i,j,k}=dp_{i-1,j,k-a_i}+dp_{i-1,j-1,k+a_i} dpi,j,k​=dpi−1,j,k−ai​​+dpi−1,j−1,k+ai​​ 也就是相当于挑出一些 lenilen_ileni​ 为奇数的 aia_iai​，让它们贡献为负数，另外一些贡献为正数。由于并没有考虑顺序，所以最后 lenilen_ileni​ 为奇数的 aia_iai​ 构成总和为 kkk 的序列个数为 ⌊cnt12⌋!(cnt1−⌊cnt12⌋)!dpcnt1,⌊cnt12⌋,k\\lfloor\\frac{cnt_1}{2}\\rfloor!(cnt_1-\\lfloor\\frac{cnt_1}{2}\\rfloor)!dp_{cnt_1,\\lfloor\\frac{cnt_1}{2}\\rfloor,k}⌊2cnt1​​⌋!(cnt1​−⌊2cnt1​​⌋)!dpcnt1​,⌊2cnt1​​⌋,k​，其中 cnt1cnt_1cnt1​ 为 lenilen_ileni​ 为奇数的 aia_iai​ 个数。 考虑 lenilen_ileni​ 为偶数的 aia_iai​ 插入的方案，仿照 lenilen_ileni​ 为奇数的 aia_iai​ 的思路，设 pdi,j,kpd_{i,j,k}pdi,j,k​ 表示前 iii 个 lenilen_ileni​ 为偶数的 aia_iai​，有 jjj 个 aia_iai​ 贡献为负，总和 mod⁡11=k\\operatorname{mod} 11=kmod11=k 的方案数（不考虑顺序）。那么有转移： pdi,j,k=pdi−1,j,k−ai+pdi−1,j−1,k+aipd_{i,j,k}=pd_{i-1,j,k-a_i}+pd_{i-1,j-1,k+a_i} pdi,j,k​=pdi−1,j,k−ai​​+pdi−1,j−1,k+ai​​ 那么枚举 lenilen_ileni​ 为偶数的 aia_iai​ 和 lenilen_ileni​ 为奇数的 aia_iai​ 对总和的贡献即可，答案为：（其中 cnt0cnt_0cnt0​ 表示 lenilen_ileni​ 为偶数的 aia_iai​ 个数，cnt1cnt_1cnt1​ 表示 lenilen_ileni​ 为奇数的 aia_iai​ 个数） ∑i=010⌊cnt12⌋!⌈cnt12⌉!dpcnt1,⌊cnt12⌋,i∑j=0cnt0j!(j+⌊cnt1+12⌋−1⌊cnt1+12⌋−1)(cnt0−j)!(cnt0−j+⌈cnt1+12⌉−1⌈cnt1+12⌉−1)pdcnt0,j,11−i\\sum\\limits_{i=0}^{10}\\lfloor\\frac{cnt_1}{2}\\rfloor!\\lceil\\frac{cnt_1}{2}\\rceil!dp_{cnt_1,\\lfloor\\frac{cnt_1}{2}\\rfloor,i}\\sum\\limits_{j=0}^{cnt_0}j!\\binom{j+\\lfloor\\frac{cnt_1+1}{2}\\rfloor-1}{\\lfloor\\frac{cnt_1+1}{2}\\rfloor-1}(cnt_0-j)!\\binom{cnt_0-j+\\lceil\\frac{cnt_1+1}{2}\\rceil-1}{\\lceil\\frac{cnt_1+1}{2}\\rceil-1}pd_{cnt_0,j,11-i} i=0∑10​⌊2cnt1​​⌋!⌈2cnt1​​⌉!dpcnt1​,⌊2cnt1​​⌋,i​j=0∑cnt0​​j!(⌊2cnt1​+1​⌋−1j+⌊2cnt1​+1​⌋−1​)(cnt0​−j)!(⌈2cnt1​+1​⌉−1cnt0​−j+⌈2cnt1​+1​⌉−1​)pdcnt0​,j,11−i​ 细节较多，代码如下： int fra[S*2],C[S*2][S*2]; int n,a[S],b[S]; int cnt0,cnt1,id0[S],id1[S]; int dp[2][S][11],pd[2][S][11]; inline int calc(int n,int m) { if(m==0) return n==0; return 1ll*fra[n]*C[n+m-1][m-1]%p; } inline void slove() { cin&gt;&gt;n; cnt0=cnt1=0; for(int i=1;i&lt;=n;i++) a[i]=0; for(int i=1;i&lt;=n;i++) { long long x; cin&gt;&gt;x; long long tmp=x; int tot=0; do b[++tot]=tmp%10,tmp/=10; while(tmp&gt;0); if(tot&amp;1) id1[++cnt1]=i; else id0[++cnt0]=i; bool odd=true; while(tot&gt;0) a[i]=(a[i]+(odd?1:-1)*b[tot--]+11)%11,odd=!odd; } for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=n;j++) for(int k=0;k&lt;11;k++) dp[i][j][k]=pd[i][j][k]=0; dp[0][0][0]=1; for(int i=1;i&lt;=cnt1;i++) { int u=i&amp;1,v=i-1&amp;1; for(int j=0;j&lt;=i;j++) for(int k=0;k&lt;11;k++) dp[u][j][k]=(dp[v][j][(k-a[id1[i]]+11)%11]+(j&gt;0?dp[v][j-1][(k+a[id1[i]])%11]:0))%p; } pd[0][0][0]=1; for(int i=1;i&lt;=cnt0;i++) { int u=i&amp;1,v=i-1&amp;1; for(int j=0;j&lt;=i;j++) for(int k=0;k&lt;11;k++) pd[u][j][k]=(pd[v][j][(k-a[id0[i]]+11)%11]+(j&gt;0?pd[v][j-1][(k+a[id0[i]])%11]:0))%p; } int ans=0; for(int i=0;i&lt;11;i++) { int ndel=cnt1/2+1,nadd=cnt1-cnt1/2; int mul=1ll*fra[cnt1/2]*fra[cnt1-cnt1/2]%p*dp[cnt1&amp;1][cnt1/2][i]%p,sum=0; for(int j=0;j&lt;=cnt0;j++) sum=(sum+1ll*calc(j,ndel)*calc(cnt0-j,nadd)%p*pd[cnt0&amp;1][j][(11-i)%11]%p)%p; ans=(ans+1ll*mul*sum%p)%p; } cout&lt;&lt;ans&lt;&lt;endl; } int main() { fra[0]=1; for(int i=1;i&lt;=S*2-2;i++) fra[i]=1ll*fra[i-1]*i%p; C[0][0]=1; for(int i=1;i&lt;=S*2-2;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } int T=1; cin&gt;&gt;T; while(T--&gt;0) { slove(); } return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF856C Eleventh Birthday 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf856c-eleventh-birthday-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":384000,"words":1213,"minutes":7},"date":"2023-03-26 11:16:04","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>棋盘大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>h</mi><mo>×</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">h \\times w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span>，有一个王在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(1,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。每一步可以走到八连通的格子之一。构造一种方案，使得王经过所有格子，并停在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>h</mi><mo separator=\"true\">,</mo><mi>w</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le h,w \\le100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 棋盘大小为 h×wh \\times wh×w，有一个王在 (1,1)(1,1)(1,1)。每一步可以走到八连通的格子之一。构造一种方案，使得王经过所有格子，并停在 (a,b)(a,b)(a,b)。 1≤h,w≤1001 \\le h,w \\le1001≤h,w≤100。 (1) 若 H=2H=2H=2，那么可以这样走： (2) 若 H&gt;2H&gt;2H&gt;2 且 W=2W=2W=2，那么可以交换行列，变成情况 (1)。 (3) 若 H&gt;2H&gt;2H&gt;2 且 W&gt;2W&gt;2W&gt;2，那么可以这样走： 这样可以消掉第一列，递归处理 H,W−1,H−A+1,B−1H,W-1,H-A+1,B-1H,W−1,H−A+1,B−1。 但是有一些特殊情况，若 B=1B=1B=1 或者 B=2B=2B=2 且 A=HA=HA=H 即终点在浅绿色的格子里，那么就不能这样消去一行，需要转换行列之后消去第一列。 部分代码： typedef pair&lt;int,int&gt; P; int n,m,a,b; vector&lt;P&gt; dfs(int n,int m,int a,int b) { vector&lt;P&gt; res; if(m==2) { vector&lt;P&gt; tmp=dfs(m,n,b,a); for(P u:tmp) res.push_back(P(u.second,u.first)); return res; } if(n==2) { fo(i,1,b-1) res.push_back(P(1,i)),res.push_back(P(2,i)); fo(i,b,m) res.push_back(P(a==1?2:1,i)); df(i,m,b) res.push_back(P(a,i)); return res; } if(a==1||(b==m&amp;&amp;a==2)) { vector&lt;P&gt; tmp=dfs(m,n,b,a); for(P u:tmp) res.push_back(P(u.second,u.first)); } else { fo(i,1,m) res.push_back(P(1,i)); vector&lt;P&gt; tmp=dfs(n-1,m,a-1,m-b+1); for(P u:tmp) res.push_back(P(u.first+1,m-u.second+1)); } return res; } inline void slove() { rd(n),rd(m),rd(a),rd(b); vector&lt;P&gt; ans=dfs(n,m,a,b); for(P u:ans) wrt(u.first),spe(),wrt(u.second),edl(); } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ABC232H King's Tour 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc232h-kings-tour-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":138000,"words":434,"minutes":3},"date":"2023-03-26 11:12:54","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定平面上的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点的坐标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x_i,y_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> ， <strong>其中没有两点有相同的坐标</strong> 。定义点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 间的距离为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>j</mi></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">d(i,j)=|x_i-x_j|+|y_i-y_j|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span> 。</p>\n<p>现用 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 种颜色对这些点进行染色，求满足以下条件的方案数：</p>\n<ul>\n<li>\n<p>每种相同颜色的点两两间距离相等</p>\n</li>\n<li>\n<p>每个点到具有不同颜色的点的距离总 <strong>大于</strong> 与其颜色相同的其他点（若存在）的距离。</p>\n</li>\n</ul>\n<p>答案取模 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 100,0\\le x_i,y_i\\le 10^8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定平面上的 nnn 个点的坐标 (xi,yi)(x_i,y_i)(xi​,yi​) ， 其中没有两点有相同的坐标 。定义点 i,ji,ji,j 间的距离为 d(i,j)=∣xi−xj∣+∣yi−yj∣d(i,j)=|x_i-x_j|+|y_i-y_j|d(i,j)=∣xi​−xj​∣+∣yi​−yj​∣ 。 现用 nnn 种颜色对这些点进行染色，求满足以下条件的方案数： 每种相同颜色的点两两间距离相等 每个点到具有不同颜色的点的距离总 大于 与其颜色相同的其他点（若存在）的距离。 答案取模 998244353998244353998244353 。 2≤n≤100,0≤xi,yi≤1082\\le n\\le 100,0\\le x_i,y_i\\le 10^82≤n≤100,0≤xi​,yi​≤108 一个重要的结论： 如果 uuu 不是单独一个颜色，那么它一定与且仅与所有离它最近的点颜色相同。 证明很显然，因为每个点到具有不同颜色的点的距离需要大于与它颜色相同的点，所以与它颜色相同的点一定是离它最近的。 那么预处理出所有颜色可以相同且至少有两个点的点的集合，再设 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个集合，用了 jjj 种颜色，转移考虑每个集合的点颜色相同或者不相同即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=105; const int p=998244353; struct node { int x,y; }a[S]; int n; int C[S][S],fra[S]; int fdis[S]; vector&lt;int&gt; fri[S]; bool vis[S],tmp[S]; int cnt[S]; int tot,siz[S]; int dp[S][S]; inline int getdis(node x,node y) { return abs(x.x-y.x)+abs(x.y-y.y); } int main() { scanf(&quot;%d&quot;,&amp;n); C[0][0]=1; fra[0]=1; for(int i=1;i&lt;=n;i++) { fra[i]=1ll*fra[i-1]*i%p; C[i][0]=1; for(int j=1;j&lt;=i;j++) { C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; } } for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); } for(int i=1;i&lt;=n;i++) { int mn=1e9; for(int j=1;j&lt;=n;j++) { if(j==i) { continue; } mn=min(mn,getdis(a[i],a[j])); } fdis[i]=mn; for(int j=1;j&lt;=n;j++) { if(getdis(a[i],a[j])==mn) { fri[i].push_back(j); } } } int sm=n; for(int i=1;i&lt;=n;i++) { if(!vis[i]) { bool fl=false; for(int u:fri[i]) { if(vis[u]) { fl=true; break; } } if(fl) { continue; } int pre=fri[i].size(); tmp[i]=true; cnt[i]=0; for(int u:fri[i]) { tmp[u]=true; cnt[u]=1; } bool f=true; for(int u:fri[i]) { if(fdis[u]!=fdis[i]) { f=false; break; } for(int v:fri[u]) { if(!tmp[v]) { f=false; break; } cnt[v]++; } if(!f) { break; } } f&amp;=cnt[i]==pre; for(int u:fri[i]) { f&amp;=cnt[u]==pre; } tmp[i]=false; vis[i]=f; for(int u:fri[i]) { tmp[u]=false; vis[u]=f; } if(f) { siz[++tot]=pre+1; sm-=pre+1; } } } dp[0][0]=1; for(int i=1;i&lt;=tot;i++) { for(int j=1;j&lt;=n-sm;j++) { dp[i][j]=(1ll*dp[i-1][j-1]*j%p+(j&gt;=siz[i]?1ll*dp[i-1][j-siz[i]]*C[j][siz[i]]%p*fra[siz[i]]%p:0))%p; } } int ans=0; for(int i=0;i&lt;=n-sm;i++) { ans=(ans+1ll*C[n][i+sm]*C[i+sm][i]%p*dp[tot][i]%p*fra[sm]%p)%p; } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1697E Coloring 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1697e-coloring-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":239000,"words":760,"minutes":4},"date":"2023-03-26 11:09:54","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给你一个字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，由 <code>Y</code> 和 <code>.</code> 构成。</p>\n<p>现在你可以最多进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次操作，每次可以交换两个相邻的字符。</p>\n<p>请你求出最多 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次操作后，最长连续字符 <code>Y</code> 的长度。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\leq |S| \\leq 2 \\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">0 \\leq K \\leq 10^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n</blockquote>\n","content":" 给你一个字符串 SSS，由 Y 和 . 构成。 现在你可以最多进行 kkk 次操作，每次可以交换两个相邻的字符。 请你求出最多 kkk 次操作后，最长连续字符 Y 的长度。 2≤∣S∣≤2×1052 \\leq |S| \\leq 2 \\times 10^52≤∣S∣≤2×105 0≤K≤10120 \\leq K \\leq 10^{12}0≤K≤1012 设 AAA 为 SSS 中 Y 的位置从小到大构成的序列，令 Bi=Ai−iB_i=A_i-iBi​=Ai​−i，那么问题就转化为： 每次操作可以选择一个 iii，让 Bi→Bi+1B_i\\to B_i+1Bi​→Bi​+1 或者 Bi→Bi−1B_i\\to B_i-1Bi​→Bi​−1，最多进行 kkk 次操作，求操作之后最长的 BiB_iBi​ 相同的连续段。 考虑尺取，假设当前区间为 [l,r][l,r][l,r]，那么最少需要的操作次数显然就相当于这个函数的最小值： f(x)=∑i=lr∣Bi−x∣f(x)=\\sum\\limits_{i=l}^r|B_i-x| f(x)=i=l∑r​∣Bi​−x∣ 不难发现这是个小学奥数题，显然 x=Bi+⌊r−l+12⌋x=B_{i+\\lfloor\\frac{r-l+1}{2}\\rfloor}x=Bi+⌊2r−l+1​⌋​ 即最中间时 f(x)f(x)f(x) 是最小的，那么只要判断 f(Bi+⌊r−l+12⌋)f(B_{i+\\lfloor\\frac{r-l+1}{2}\\rfloor})f(Bi+⌊2r−l+1​⌋​) 小于等于 kkk 即可。 ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"ABC229G Longest Y 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc229g-longest-y-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":87000,"words":318,"minutes":2},"date":"2023-03-26 11:07:19","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无向图，第  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个点的点权初始值为  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>,所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 互不相同。</p>\n<p>接下来进行 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次操作，分为两类：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"monospace\">1</mn><mtext> </mtext><mi mathvariant=\"monospace\">v</mi></mrow><annotation encoding=\"application/x-tex\">\\tt 1\\ v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">1</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">v</span></span></span></span></span> 查询与  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 连通的点中， <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 最大的点  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 并输出  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，然后让  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>u</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">p_u=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"monospace\">2</mn><mtext> </mtext><mi mathvariant=\"monospace\">i</mi></mrow><annotation encoding=\"application/x-tex\">\\tt 2\\ i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">2</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">i</span></span></span></span></span> 将第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 条边删掉。</li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 2 \\cdot 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>3</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le m \\le 3 \\cdot 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>5</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le q \\le 5 \\cdot 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 个点 mmm 条边的无向图，第 iii 个点的点权初始值为 pip_ipi​,所有 pip_ipi​ 互不相同。 接下来进行 qqq 次操作，分为两类： 1 v\\tt 1\\ v1 v 查询与 vvv 连通的点中， pup_upu​ 最大的点 uuu 并输出 pup_upu​，然后让 pu=0p_u=0pu​=0。 2 i\\tt 2\\ i2 i 将第 iii 条边删掉。 1≤n≤2⋅1051 \\le n \\le 2 \\cdot 10^51≤n≤2⋅105，1≤m≤3⋅1051 \\le m \\le 3 \\cdot 10^51≤m≤3⋅105，1≤q≤5⋅1051 \\le q \\le 5 \\cdot 10^51≤q≤5⋅105。 这是一道比较有趣的“启发式分裂”题。 首先容易发现，每次删边之后大小较小的那部分的大小至少减半，那么参照启发式合并的思路，考虑每次断边之后在大小较小的部分上跑一次 dfs，求出上次断边到这次断边之间的询问的答案。 具体的： 首先对图上的每个连通块都跑一遍 dfs，求出它们内部节点按照权值从大到小排序之后的序列。并且把所有删边操作倒过来，变成加边操作，用并查集找到所有改变图的连通性的删边操作； 对于每一次询问操作，直接取对应连通块内权值最大的节点 uuu（权值序列中第一个节点），把它的权值变为 000 之后放到权值序列的末尾即可； 对于每一次删边操作，若这次操作不改变图的连通性，直接删掉它即可；否则删掉它之后在大小较小的那一部分上跑一次 dfs，求出它内部节点排序后的序列，根据这个序列和连通块分裂之前的序列就可以求出另一部分的序列。 用 set 维护连通块权值序列的时间复杂度是 O(log⁡V)O(\\log V)O(logV) 的，其中 VVV 是值域，又因为“启发式分裂”的时间复杂度是 (n+m)log⁡n(n+m)\\log n(n+m)logn 的，所以时间复杂度 O((n+m)log⁡2n+q)O((n+m)\\log^2 n+q)O((n+m)log2n+q)，卡一卡可以过。 代码如下：（卡常用的火车头省略了） #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; char buf[1&lt;&lt;23],*p1=buf,*p2=buf,obuf[1&lt;&lt;23],*O=obuf; #define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++) inline int rd() { int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-') f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+(ch^48),ch=getchar(); return x*f; } void print(int x) { if(x&gt;9) print(x/10); *O++=x%10|48; } const int MS=200005,S=300005,QS=500005; struct edge { int x,y; bool del; // 是否被删除 }ed[S]; struct opt { int tpe,id; // 操作类型，删边的编号/节点编号 bool imp; int mnx; // 删边之后属于大小较小的连通块的点 }que[QS]; int n,m,q,qdel; int a[MS]; vector&lt;int&gt; g[MS]; int fa[MS],siz[MS]; set&lt;pair&lt;int,int&gt; &gt; st[MS]; int cnt,uid[MS]; inline int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } void dfs(int u,int stid) { st[stid].erase(make_pair(-a[u],u)); st[uid[u]].insert(make_pair(-a[u],u)); for(int i:g[u]) { if(ed[i].del) continue; int v=ed[i].x==u?ed[i].y:ed[i].x; if(uid[v]==uid[u]) continue; uid[v]=uid[u]; dfs(v,stid); } } int main() { n=rd(); m=rd(); q=rd(); for(register int i=1;i&lt;=n;++i) a[i]=rd(); for(register int i=1;i&lt;=m;++i) { ed[i].x=rd(); ed[i].y=rd(); g[ed[i].x].push_back(i),g[ed[i].y].push_back(i); } for(register int i=1;i&lt;=q;++i) { que[i].tpe=rd(); que[i].id=rd(); if(que[i].tpe==2) ed[que[i].id].del=true; } for(register int i=1;i&lt;=n;++i) siz[i]=(fa[i]=i)==i; for(register int i=1;i&lt;=m;++i) { if(!ed[i].del) { int rx=fnd(ed[i].x),ry=fnd(ed[i].y); if(rx!=ry) fa[rx]=ry,siz[ry]+=siz[rx]; } } for(register int i=q;i&gt;=1;--i) { if(que[i].tpe==2) { int rx=fnd(ed[que[i].id].x),ry=fnd(ed[que[i].id].y); if(rx!=ry) { que[i].imp=true; if(siz[rx]&lt;siz[ry]) que[i].mnx=ed[que[i].id].x; else que[i].mnx=ed[que[i].id].y; fa[rx]=ry,siz[ry]+=siz[rx]; ed[que[i].id].del=false; } } } for(register int i=1;i&lt;=n;++i) if(fa[i]==i) uid[i]=++cnt; for(register int i=1;i&lt;=n;++i) st[uid[i]=uid[fnd(i)]].insert(make_pair(-a[i],i)); for(register int i=1;i&lt;=q;++i) { if(que[i].tpe==1) { int id=uid[que[i].id]; pair&lt;int,int&gt; fir=*st[id].begin(); print(-fir.first); *O++='\\n'; st[id].erase(fir); a[fir.second]=0; st[id].insert(make_pair(0,fir.second)); } else { ed[que[i].id].del=true; if(que[i].imp) { uid[que[i].mnx]=++cnt; int oth=uid[ed[que[i].id].x==que[i].mnx?ed[que[i].id].y:ed[que[i].id].x]; dfs(que[i].mnx,oth); } } if(O-obuf&gt;(1&lt;&lt;22)) fwrite(obuf,O-obuf,1,stdout),O=obuf; } fwrite(obuf,O-obuf,1,stdout); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"CF1416D Graph and Queries 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1416d-graph-and-queries-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":360000,"words":1188,"minutes":7},"date":"2023-03-26 11:05:37","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>求满足以下条件的排列个数：</p>\n<ul>\n<li>长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>。</li>\n<li>恰有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个数满足：所有包含这个数的区间中，不同的最大值的个数恰有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个。</li>\n</ul>\n<p>答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>p</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\le n \\le 100, 1 \\le m \\le n, 1 \\le k \\le n, 1 \\le p \\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 求满足以下条件的排列个数： 长度为 nnn。 恰有 kkk 个数满足：所有包含这个数的区间中，不同的最大值的个数恰有 mmm 个。 答案对 ppp 取模。 1≤n≤100,1≤m≤n,1≤k≤n,1≤p≤1091 \\le n \\le 100, 1 \\le m \\le n, 1 \\le k \\le n, 1 \\le p \\le 10^91≤n≤100,1≤m≤n,1≤k≤n,1≤p≤109。 首先定义 i−好数i-\\text{好数}i−好数 为所有包含这个数的区间中，不同的最大值恰好有 iii 个的数，问题就变成了求 m−好数m-\\text{好数}m−好数 恰好有 kkk 个的 nnn 的排列的个数。 设 dpi,j,kdp_{i,j,k}dpi,j,k​ 为满足恰好有 kkk 个 j−好数j-\\text{好数}j−好数 的 iii 的排列个数，那么可以通过枚举最大值的位置 ppp 和 ppp 左侧序列的 (j−1)−好数(j-1)-\\text{好数}(j−1)−好数 个数来转移： dpi,j,k=∑p=2i−1(i−1p−1)∑lft=0k−[j=1]dpp−1,j−1,lft×dpi−p,j−1,k−[j=1]−lftdp_{i,j,k}=\\sum\\limits_{p=2}^{i-1}\\dbinom{i-1}{p-1}\\sum\\limits_{lft=0}^{k-[j=1]}dp_{p-1,j-1,lft}\\times dp_{i-p,j-1,k-[j=1]-lft} dpi,j,k​=p=2∑i−1​(p−1i−1​)lft=0∑k−[j=1]​dpp−1,j−1,lft​×dpi−p,j−1,k−[j=1]−lft​ 注意边界 dp1,1,1=1dp_{1,1,1}=1dp1,1,1​=1 且 p=1p=1p=1 和 p=ip=ip=i 的情况要单独转移，并且 j&gt;ij&gt;ij&gt;i 或者 j&lt;1j&lt;1j&lt;1 的 dpi,j,0=i!dp_{i,j,0}=i!dpi,j,0​=i!。 转移的时候要注意卡常，有 000 就不做乘法。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1580B Mathematics Curriculum 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1580b-mathematics-curriculum-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":121000,"words":413,"minutes":3},"date":"2023-03-26 11:00:07","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p><a href=\"https://www.luogu.com.cn/problem/P5298\">P5298 [PKUWC2018]Minimax</a></p>\n</blockquote>\n","content":" P5298 [PKUWC2018]Minimax 首先有暴力转移： Du,i=Ds1,i((Pu∑j&lt;iDs2,j)+((1−Pu)∑j&gt;iDs2,j))+Ds2,i((Pu∑j&lt;iDs1,j)+((1−Pu)∑j&gt;iDs1,j))D_{u,i}=D_{s1,i}\\left(\\left(P_u\\sum\\limits_{j&lt;i}D_{s2,j}\\right)+\\left((1-P_u)\\sum\\limits_{j&gt;i}D_{s2,j}\\right)\\right)+D_{s2,i}\\left(\\left(P_u\\sum\\limits_{j&lt;i}D_{s1,j}\\right)+\\left((1-P_u)\\sum\\limits_{j&gt;i}D_{s1,j}\\right)\\right) Du,i​=Ds1,i​((Pu​j&lt;i∑​Ds2,j​)+((1−Pu​)j&gt;i∑​Ds2,j​))+Ds2,i​((Pu​j&lt;i∑​Ds1,j​)+((1−Pu​)j&gt;i∑​Ds1,j​)) 然后可以用线段树合并来转移。节点 uuu 的线段树的节点维护区间内 Du,iD_{u,i}Du,i​ 的和，合并的时候维护当前区间左边的和与当前区间右边的和，打上 lazytag 即可。 // Problem: P5298 [PKUWC2018]Minimax // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P5298 // Memory Limit: 500 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int MS=300005,S=5000005; const int p=998244353,inv=796898467; struct node { int sm,mu; int ls,rs; }tr[S]; int n,a[MS]; int m,b[MS]; int ls[MS],rs[MS]; int cnt,rt[MS]; inline void adtg(int u,int val) { tr[u].sm=1ll*tr[u].sm*val%p,tr[u].mu=1ll*tr[u].mu*val%p; } inline void dntg(int u) { adtg(tr[u].ls,tr[u].mu),adtg(tr[u].rs,tr[u].mu),tr[u].mu=1; } inline void upda(int u) { tr[u].sm=(tr[tr[u].ls].sm+tr[tr[u].rs].sm)%p; } void upd(int &amp;u,int l,int r,int pos,int val) { if(u==0) tr[u=++cnt]=(node){0,1,0,0}; if(l==r) { tr[u].sm=val; return; } dntg(u); int mid=l+r&gt;&gt;1; if(pos&lt;=mid) upd(tr[u].ls,l,mid,pos,val); else upd(tr[u].rs,mid+1,r,pos,val); upda(u); } int que(int u,int l,int r,int pos) { if(l==r) return tr[u].sm; dntg(u); int mid=l+r&gt;&gt;1; if(pos&lt;=mid) return que(tr[u].ls,l,mid,pos); else return que(tr[u].rs,mid+1,r,pos); } int meg(int x,int y,int lftx,int rigx,int lfty,int rigy,int u) { if(x==0&amp;&amp;y==0) return 0; if(y==0) { int val=(1ll*a[u]*lftx%p+1ll*(1-a[u]+p)*rigx%p)%p; return adtg(x,val),x; } if(x==0) { int val=(1ll*a[u]*lfty%p+1ll*(1-a[u]+p)*rigy%p)%p; return adtg(y,val),y; } dntg(x),dntg(y); int xlsm=tr[tr[x].ls].sm,xrsm=tr[tr[x].rs].sm; int ylsm=tr[tr[y].ls].sm,yrsm=tr[tr[y].rs].sm; tr[x].ls=meg(tr[x].ls,tr[y].ls,lftx,(rigx+yrsm)%p,lfty,(rigy+xrsm)%p,u); tr[x].rs=meg(tr[x].rs,tr[y].rs,(lftx+ylsm)%p,rigx,(lfty+xlsm)%p,rigy,u); upda(x); return x; } void dfs(int u) { if(ls[u]!=0) dfs(ls[u]); if(rs[u]!=0) dfs(rs[u]); if(ls[u]==0&amp;&amp;rs[u]==0) upd(rt[u],1,m,a[u],1); else if(ls[u]==0||rs[u]==0) rt[u]=rt[ls[u]]+rt[rs[u]]; else rt[u]=meg(rt[ls[u]],rt[rs[u]],0,0,0,0,u); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int fa; scanf(&quot;%d&quot;,&amp;fa); if(fa!=0) { if(ls[fa]==0) ls[fa]=i; else rs[fa]=i; } } for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); if(ls[i]!=0||rs[i]!=0) a[i]=1ll*a[i]*inv%p; else b[++m]=a[i]; } sort(b+1,b+m+1); for(int i=1;i&lt;=n;i++) if(ls[i]==0&amp;&amp;rs[i]==0) a[i]=lower_bound(b+1,b+m+1,a[i])-b; dfs(1); int ans=0; for(int i=1;i&lt;=m;i++) { int Di=que(rt[1],1,m,i); ans=(ans+1ll*i*b[i]%p*Di%p*Di%p)%p; } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"线段树合并","slug":"V6vz5Da7_","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/V6vz5Da7_/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"}],"title":"P5298 [PKUWC2018]Minimax 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p5298-pkuwc2018minimax-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":293000,"words":813,"minutes":5},"date":"2023-03-26 10:57:35","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>，我们定义一种将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 划分为若干段的方案的价值为每一段的最大值减去最小值的差的乘积，你需要求出所有划分方案的价值的总和，答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq N \\leq 3 \\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>A</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq A_i \\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n</blockquote>\n","content":" 给定长度为 NNN 的序列 AAA，我们定义一种将 AAA 划分为若干段的方案的价值为每一段的最大值减去最小值的差的乘积，你需要求出所有划分方案的价值的总和，答案对 998244353998244353998244353 取模。 1≤N≤3×1051 \\leq N \\leq 3 \\times 10^51≤N≤3×105 1≤Ai≤1091 \\leq A_i \\leq 10^91≤Ai​≤109 首先显然可以设 dpidp_idpi​ 表示前 iii 个数的和，通过枚举最后一段来转移，但是这样做是 O(n2)O(n^2)O(n2) 的。 考虑把最后一段的 max⁡\\maxmax 和 min⁡\\minmin 单独考虑，求出 max⁡\\maxmax 的贡献和 min⁡\\minmin 的贡献，再作差。可以用单调栈维护 max⁡\\maxmax 和 min⁡\\minmin 改变的位置，然后用前缀和来转移。 部分代码： int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } sm[0]=1; int sm0=0,sm1=0; for(int i=1;i&lt;=n;i++) { while(mxq[0]&gt;0&amp;&amp;a[mxq[mxq[0]]]&lt;=a[i]) sm1=(sm1-1ll*a[mxq[mxq[0]]]%p*(sm[mxq[mxq[0]]-1]-(mxq[0]&gt;1?sm[mxq[mxq[0]-1]-1]:0)+p)%p+p)%p,mxq[0]--; while(mnq[0]&gt;0&amp;&amp;a[mnq[mnq[0]]]&gt;=a[i]) sm0=(sm0-1ll*a[mnq[mnq[0]]]%p*(sm[mnq[mnq[0]]-1]-(mnq[0]&gt;1?sm[mnq[mnq[0]-1]-1]:0)+p)%p+p)%p,mnq[0]--; sm1=(sm1+1ll*a[i]%p*(sm[i-1]-(mxq[0]&gt;0?sm[mxq[mxq[0]]-1]:0)+p)%p)%p; sm0=(sm0+1ll*a[i]%p*(sm[i-1]-(mnq[0]&gt;0?sm[mnq[mnq[0]]-1]:0)+p)%p)%p; mxq[++mxq[0]]=i; mnq[++mnq[0]]=i; int dpi=(sm1-sm0+p)%p; sm[i]=(sm[i-1]+dpi)%p; if(i==n) printf(&quot;%d\\n&quot;,dpi%p); } return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ABC234G Divide a Sequence 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc234g-divide-a-sequence-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":125000,"words":404,"minutes":3},"date":"2023-03-26 10:55:04","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 组数据，每组数据有一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"monospace\">01</mn></mrow><annotation encoding=\"application/x-tex\">\\tt 01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">0</span><span class=\"mord mathtt\">1</span></span></span></span></span> 字符串，求构造一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个结点的树满足每个结点的度数的奇偶性符合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn mathvariant=\"monospace\">01</mn></mrow><annotation encoding=\"application/x-tex\">\\tt 01</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">0</span><span class=\"mord mathtt\">1</span></span></span></span></span> 串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span>，且将这些点依次排列到一个环上，任意两条边不在非端点处相交。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 2\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 TTT 组数据，每组数据有一个长度为 nnn 的 01\\tt 0101 字符串，求构造一个 nnn 个结点的树满足每个结点的度数的奇偶性符合 01\\tt 0101 串 sss，且将这些点依次排列到一个环上，任意两条边不在非端点处相交。 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105。 VP 的时候想到了一大堆奇奇怪怪的做法，有些是对的，但是都否定了。 首先发现因为每条边都会贡献两个度数，又有 n−1n-1n−1 条边，所以若度数总和是奇数那么就不行。 由于需要构成一棵树，而树的叶子节点一定只有一个度，所以若度数全都是偶数也不行。 对于其它情况，考虑构造解： 若度数都是奇数，那么此时 nnn 必定为偶数，把 111 当作根，其它点向 111 连边组成菊花图即可； 否则考虑构造一些链，把整个序列看作一个环，把环断成 kkk 段 [0,0,0,…,1][0,0,0,\\dots,1][0,0,0,…,1] 这样的序列，每一段序列都依次串起来，这样我们就获得了一些”趴在边上“的链。考虑如何把这些链连起来，显然由于度数是偶数，kkk 一定是也偶数，所以拿一条链的开头当作根把这些链接上即可。 ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF1682D Circular Spanning Tree 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1682d-circular-spanning-tree-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":80000,"words":363,"minutes":2},"date":"2023-03-26 10:51:49","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 和长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>，找到满足以下条件的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 的个数对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模后的结果：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 的每个元素都是正奇数</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">\\sum X_i=S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span></li>\n<li>设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">Y_i=\\sum\\limits_{j=1}^iX_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.625446em;vertical-align:-1.113777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5116690000000004em;\"><span style=\"top:-2.122331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0000050000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.950005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.113777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，那么对于所有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le |X|,1\\le j\\le N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>，都满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">Y_i\\not=A_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le N\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>A</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>A</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>A</mi><mi>N</mi></msub><mo>&lt;</mo><mi>S</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le A_1&lt;A_2&lt;\\dots&lt;A_N&lt;S\\le10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定 NNN、SSS 和长度为 NNN 的序列 AAA，找到满足以下条件的序列 XXX 的个数对 998244353998244353998244353 取模后的结果： XXX 的每个元素都是正奇数 ∑Xi=S\\sum X_i=S∑Xi​=S 设 Yi=∑j=1iXjY_i=\\sum\\limits_{j=1}^iX_jYi​=j=1∑i​Xj​，那么对于所有 1≤i≤∣X∣,1≤j≤N1\\le i\\le |X|,1\\le j\\le N1≤i≤∣X∣,1≤j≤N 的 i,ji,ji,j，都满足 Yi=AjY_i\\not=A_jYi​​=Aj​ 1≤N≤1051\\le N\\le 10^51≤N≤105 1≤A1&lt;A2&lt;⋯&lt;AN&lt;S≤10181\\le A_1&lt;A_2&lt;\\dots&lt;A_N&lt;S\\le10^{18}1≤A1​&lt;A2​&lt;⋯&lt;AN​&lt;S≤1018 发现 YiY_iYi​ 的奇偶性和 iii 的奇偶性相同，设 dpidp_{i}dpi​ 表示总和为 iii 的 XXX 的个数，那么有转移： dpi={∑0≤j≤i−1,j≡i(mod2)dpj∄Aj=i0∃Aj=idp_{i}=\\begin{cases}\\sum\\limits_{0\\le j\\le i-1,j\\not\\equiv i\\pmod 2}dp_j&amp;\\nexists A_j=i\\\\0&amp;\\exists A_j=i\\end{cases} dpi​=⎩⎨⎧​0≤j≤i−1,j​≡i(mod2)∑​dpj​0​∄Aj​=i∃Aj​=i​ 这样做时间复杂度是 O(S)O(S)O(S) 的，完美爆炸。考虑换一下 dpdpdp 的定义，设 dp0/1,idp_{0/1,i}dp0/1,i​ 为总和是奇数/偶数，并且小于等于 iii 的方案数，那么有转移： {dp0,i=dp0,i−1+[imod⁡2=0∧∄Aj=i]dp1,i−1dp1,i=dp1,i−1+[imod⁡2=1∧∄Aj=i]dp0,i−1\\begin{cases} dp_{0,i}=dp_{0,i-1}+[i\\operatorname{mod}2=0\\land\\nexists A_j=i]dp_{1,i-1}\\\\ dp_{1,i}=dp_{1,i-1}+[i\\operatorname{mod}2=1\\land\\nexists A_j=i]dp_{0,i-1}\\\\ \\end{cases} {dp0,i​=dp0,i−1​+[imod2=0∧∄Aj​=i]dp1,i−1​dp1,i​=dp1,i−1​+[imod2=1∧∄Aj​=i]dp0,i−1​​ 观察到对于所有满足 Aj&lt;i&lt;Aj+1A_j&lt; i&lt; A_{j+1}Aj​&lt;i&lt;Aj+1​ 的 iii，dp0/1,idp_{0/1,i}dp0/1,i​ 的转移是完全不受到 [∄Aj=i][\\nexists A_j=i][∄Aj​=i] 的影响的，这时有： {[dp0,i−1,dp1,i−1]×[1,10,1]=[dp0,i,dp1,i]imod⁡2=1[dp0,i−1,dp1,i−1]×[1,01,1]=[dp0,i,dp1,i]imod⁡2=0\\begin{cases} \\begin{bmatrix}dp_{0,i-1},dp_{1,i-1}\\end{bmatrix}\\times \\begin{bmatrix}1,1\\\\0,1\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&amp;i\\operatorname{mod}2=1\\\\ \\begin{bmatrix}dp_{0,i-1},dp_{1,i-1}\\end{bmatrix}\\times \\begin{bmatrix}1,0\\\\1,1\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&amp;i\\operatorname{mod}2=0 \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​[dp0,i−1​,dp1,i−1​​]×[1,10,1​]=[dp0,i​,dp1,i​​][dp0,i−1​,dp1,i−1​​]×[1,01,1​]=[dp0,i​,dp1,i​​]​imod2=1imod2=0​ 考虑把两次转移合并，有： {[dp0,i−2,dp1,i−2]×[1,11,2]=[dp0,i,dp1,i](i−2)mod⁡2=1[dp0,i−2,dp1,i−2]×[2,11,1]=[dp0,i,dp1,i](i−2)mod⁡2=0\\begin{cases} \\begin{bmatrix}dp_{0,i-2},dp_{1,i-2}\\end{bmatrix}\\times \\begin{bmatrix}1,1\\\\1,2\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&amp;(i-2)\\operatorname{mod}2=1\\\\ \\begin{bmatrix}dp_{0,i-2},dp_{1,i-2}\\end{bmatrix}\\times \\begin{bmatrix}2,1\\\\1,1\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&amp;(i-2)\\operatorname{mod}2=0\\\\ \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​[dp0,i−2​,dp1,i−2​​]×[1,11,2​]=[dp0,i​,dp1,i​​][dp0,i−2​,dp1,i−2​​]×[2,11,1​]=[dp0,i​,dp1,i​​]​(i−2)mod2=1(i−2)mod2=0​ 那么可以枚举 jjj，手动做一次转移，用矩阵乘法做 Aj+1−Aj−1A_{j+1}-A_j-1Aj+1​−Aj​−1 次转移，再手动做一次转移即可。 时间复杂度 O(Nlog⁡S)O(N\\log S)O(NlogS)。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ABC258Ex Odd Steps 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc258ex-odd-steps-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":270000,"words":813,"minutes":5},"date":"2023-03-26 10:49:44","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>给定仅存在小写英文字母的字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo separator=\"true\">,</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">S, T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>。你需要将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 分割成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 的前缀（或着说用 $ S $ 的若干个前缀组成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>），最小化 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，输出最小值。若 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 不存在输出 <code>-1</code>。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∣</mi><mi>T</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq |S|,|T| \\leq 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n","content":" 给定仅存在小写英文字母的字符串 S,TS, TS,T。你需要将 TTT 分割成 kkk 个 SSS 的前缀（或着说用 $ S $ 的若干个前缀组成 TTT），最小化 kkk，输出最小值。若 kkk 不存在输出 -1。 1≤∣S∣,∣T∣≤5×1051 \\leq |S|,|T| \\leq 5\\times 10^51≤∣S∣,∣T∣≤5×105 首先有个结论，每次从 TTT 末尾删除最长的 SSS 的前缀是最优的，因为假设 TTT 是由这些蓝色的 SSS 的前缀构成的： 若红色这一段是 SSS 的前缀，那它完全可以代替最后那三段 SSS 的前缀和第一段 SSS 的前缀的后面一段，因为前缀减去末尾的一段依然是前缀： 而若想让组成 TTT 的前缀数尽可能少，每个前缀就要尽可能长，所以每次贪心地从 TTT 末尾删掉最长的一段 SSS 的前缀是最优的。 考虑快速求出 TTT 中以 TiT_iTi​ 结尾的最长的 SSS 的前缀，当然可以用后缀数组/后缀自动机来做，但是观察到这个定义和 kmp 数组的定义很像： kmpikmp_ikmpi​ 为 s[1,i]s_{[1,i]}s[1,i]​ 的最长的是后缀的前缀长度。 那么可以令 RRR 为 S+TS+TS+T 即 SSS 拼上 TTT 的字符串，求出 RRR 的 kmpikmp_ikmpi​，然后贪心即可。 ","tags":[{"name":"贪心","slug":"PR_0Eh8tb","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/PR_0Eh8tb/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"}],"title":"ABC257G Prefix Concatenation 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc257g-prefix-concatenation-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":79000,"words":341,"minutes":2},"date":"2023-03-26 10:47:51","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>有三种不同颜色的球，分别有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A,B,C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 个。（相同颜色的球之间不区分）</p>\n<p>将球放入 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个不同的盒子中，要求：</p>\n<ul>\n<li>\n<p>每个盒子至少放了一个球</p>\n</li>\n<li>\n<p>每个盒子不能存在两个相同颜色的球</p>\n</li>\n<li>\n<p>可以不放完所有的球</p>\n</li>\n</ul>\n<p>求放置方案数对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1 \\leq N \\leq 5 \\times 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">0 \\leq A,B,C \\leq N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span></p>\n</blockquote>\n","content":" 有三种不同颜色的球，分别有 A,B,CA,B,CA,B,C 个。（相同颜色的球之间不区分） 将球放入 NNN 个不同的盒子中，要求： 每个盒子至少放了一个球 每个盒子不能存在两个相同颜色的球 可以不放完所有的球 求放置方案数对 998244353998244353998244353 取模的结果。 1≤N≤5×1061 \\leq N \\leq 5 \\times 10^61≤N≤5×106，0≤A,B,C≤N0 \\leq A,B,C \\leq N0≤A,B,C≤N 考虑枚举有多少个花圃种了花，然后容斥，有： ans=∑i=1n(−1)n−i(ni)∑j=0A,i(ij)∑j=0B,i(ij)∑j=0C,i(ij)ans=\\sum\\limits_{i=1}^{n}(-1)^{n-i}\\dbinom{n}{i}\\sum\\limits_{j=0}^{A,i}\\dbinom{i}{j}\\sum\\limits_{j=0}^{B,i}\\dbinom{i}{j}\\sum\\limits_{j=0}^{C,i}\\dbinom{i}{j} ans=i=1∑n​(−1)n−i(in​)j=0∑A,i​(ji​)j=0∑B,i​(ji​)j=0∑C,i​(ji​) 发现后面那三个求和形式都是 ∑j=0m,n(nj)\\sum\\limits_{j=0}^{m,n}\\dbinom{n}{j}j=0∑m,n​(jn​)，那么不妨设 dpn,m=∑j=0m,n(nj)dp_{n,m}=\\sum\\limits_{j=0}^{m,n}\\dbinom{n}{j}dpn,m​=j=0∑m,n​(jn​)，显然若 n≤mn\\le mn≤m 那么 dpn,m=2ndp_{n,m}=2^ndpn,m​=2n，否则考虑这样一个网格图： 显然 dpn,mdp_{n,m}dpn,m​ 就相当于从 (0,0)(0,0)(0,0) 向上向右走到 (n,0),(n−1,1),(n−2,2),…,(n−m,m)(n,0),(n-1,1),(n-2,2),\\dots,(n-m,m)(n,0),(n−1,1),(n−2,2),…,(n−m,m) 的方案数。那么考虑从 dpn−1,mdp_{n-1,m}dpn−1,m​ 递推到 dpn,mdp_{n,m}dpn,m​，也就是从所有橙色的点向上向右走到蓝色的点的方案数。 观察到除了最后一个点，其它点向上或者向右都能走到蓝色的点，最后一个点却只能向上走走到蓝色的点。那么不妨让所有点都能向上向右走，求出方案数，再减去走到最后一个点再向右走的方案数。显然第一部分的方案数是 2dpn−1,m2dp_{n-1,m}2dpn−1,m​，而减掉的方案数是 (n−1m)\\dbinom{n-1}{m}(mn−1​)。 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ABC235G Gardens 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc235g-gardens-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":152000,"words":541,"minutes":3},"date":"2023-03-26 10:06:55","dateFormat":"2023-03-26"},{"abstract":"<blockquote>\n<p>有一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的有向图 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>，对于所有的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\le i, j \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mpadded width=\"0px\"><mo></mo></mpadded><mo>=</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i \\not= j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>，都有一条权值为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>j</mi></msub><mo>)</mo><mtext> </mtext><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">(a_i + b_j) \\bmod m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的边连接 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>，请你求出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> 从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的最短路。</p>\n</blockquote>\n","content":" 有一个 nnn 个节点的有向图 GGG，对于所有的 1≤i,j≤n1 \\le i, j \\le n1≤i,j≤n 且 i=ji \\not= ji​=j，都有一条权值为 (ai+bj) mod m(a_i + b_j) \\bmod m(ai​+bj​)modm 的边连接 iii 和 jjj，请你求出 GGG 从 111 到 nnn 的最短路。 发现取模不好处理，那么考虑构造一个”取模装置“：建立 mmm 个点 0′,1′,2′,3′,…,(m−1)′0&#x27;,1&#x27;,2&#x27;,3&#x27;,\\dots,(m-1)&#x27;0′,1′,2′,3′,…,(m−1)′，i′→(i+1)′i&#x27;\\to (i+1)&#x27;i′→(i+1)′ 连一条权值为 111 的边，特别的，(m−1)′→0′(m-1)&#x27;\\to0&#x27;(m−1)′→0′ 连一条权值为 111 的边。 然后建出原来的 nnn 个节点，但是这个”取模装置“只能处理减法的取模，考虑用一个式子把加法转换成减法： (x+y)mod⁡m=y−(m−x)mod⁡m(x+y)\\operatorname{mod}m=y-(m-x)\\operatorname{mod} m (x+y)modm=y−(m−x)modm 所以可以 i→(m−ai)′i\\to(m-a_i)&#x27;i→(m−ai​)′ 连一条长度为 000 的边，bi′→ib_i&#x27;\\to ibi′​→i 连一条长度为 000 的边，跑 111 到 nnn 的最短路即可。 但是 mmm 是 10910^9109 级别的，把”取模装置“建完肯定空间和时间都会爆炸。观察到”取模装置“上的点有很多都是没有原来的节点与之相连的，这些点就可以直接缩掉，像这样： 缩点操作可以使用离散化来实现，建好图之后跑一边 dijkstra 即可。 ","tags":[{"name":"最短路","slug":"Jmuy2BzYo","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Jmuy2BzYo/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"}],"title":"ABC232G Modulo Shortest Path 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc232g-modulo-shortest-path-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":99000,"words":377,"minutes":2},"date":"2023-03-26 09:38:50","dateFormat":"2023-03-26"},{"abstract":"","content":"组合恒等式的推导证明一般可以考虑等号两边的组合意义、杨辉三角、二项式定理或者直接硬上组合定义式。 (nm)=(n−1m)+(n−1m−1)\\binom{n}{m}=\\binom{n-1}{m}+\\binom{n-1}{m-1} (mn​)=(mn−1​)+(m−1n−1​) 考虑最后一个元素有没有选。 ∑i=0n(ni)=2n\\sum\\limits_{i=0}^n\\binom{n}{i}=2^n i=0∑n​(in​)=2n 枚举在 nnn 个元素的集合中选多少个元素，再枚举选出的是那些元素，等于枚举每个元素有没有选。 ∑i=0n(−1)i(ni)=0\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}=0 i=0∑n​(−1)i(in​)=0 二项式定理： (−1+1)n=∑i=0n(−1)i1i(ni)=∑i=0n(−1)i(ni)=0(-1+1)^n=\\sum\\limits_{i=0}^n(-1)^i1^i\\binom{n}{i}=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}=0(−1+1)n=i=0∑n​(−1)i1i(in​)=i=0∑n​(−1)i(in​)=0 ∑i=nm(in)=(m+1n+1)\\sum\\limits_{i=n}^m\\binom{i}{n}=\\binom{m+1}{n+1} i=n∑m​(ni​)=(n+1m+1​) 考虑杨辉三角： ∑i=0m(n+ii)=(m+1n+m)\\sum\\limits_{i=0}^m\\binom{n+i}{i}=\\binom{m+1}{n+m} i=0∑m​(in+i​)=(n+mm+1​) 依旧是考虑杨辉三角： (nm)=n−m+1m(nm−1)\\binom{n}{m}=\\frac{n-m+1}{m}\\binom{n}{m-1} (mn​)=mn−m+1​(m−1n​) (nm)=k(nm−1)\\binom{n}{m}=k\\binom{n}{m-1}(mn​)=k(m−1n​) k=(nm)(nm−1)=n!m!(n−m)!n!(m−1)!(n−m+1)!=(m−1)!(n−m+1)!m!(n−m)!=n−m+1mk=\\frac{\\binom{n}{m}}{\\binom{n}{m-1}}=\\frac{\\frac{n!}{m!(n-m)!}}{\\frac{n!}{(m-1)!(n-m+1)!}}=\\frac{(m-1)!(n-m+1)!}{m!(n-m)!}=\\frac{n-m+1}{m}k=(m−1n​)(mn​)​=(m−1)!(n−m+1)!n!​m!(n−m)!n!​​=m!(n−m)!(m−1)!(n−m+1)!​=mn−m+1​ ∑i=0k(ni)(mk−i)=(n+mk)\\sum\\limits_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k} i=0∑k​(in​)(k−im​)=(kn+m​) 著名的范德蒙德卷积，组合意义是从两个没有重复元素的集合中选择 kkk 个元素可以通过枚举每个集合中选了几个来计算。 xy=(x+y2)−(x2)−(y2)xy=\\binom{x+y}{2}-\\binom{x}{2}-\\binom{y}{2} xy=(2x+y​)−(2x​)−(2y​) 从 xxx 个各不相同的小球中选出一个，再从 yyy 个各不相同的小球中选出一个的方案数，等于从这 x+yx+yx+y 个小球中选出 222 个的方案数减去两个球都是从某一边选出的方案数。 ∑i=kn2n−i(m+im+k)=∑i=m+k+1m+n+1(m+n+1i)\\sum\\limits_{i=k}^n 2^{n-i}\\binom{m+i}{m+k}=\\sum\\limits_{i=m+k+1}^{m+n+1}\\binom{m+n+1}{i} i=k∑n​2n−i(m+km+i​)=i=m+k+1∑m+n+1​(im+n+1​) ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"组合恒等式学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zu-he-heng-deng-shi-xue-xi-bi-ji/","stats":{"text":"4 min read","time":204000,"words":654,"minutes":4},"date":"2023-03-25 22:16:56","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p><a href=\"https://www.luogu.com.cn/problem/P1758\">P1758 [NOI2009] 管道取珠</a></p>\n</blockquote>\n","content":" P1758 [NOI2009] 管道取珠 方案数的平方可以看做是两个人分别操作，操作到同一种结果的方案数。 直接 dp 一下即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=505,p=1024523; int n,m; int a[S],b[S]; int dp[2][S][S]; inline void add(int &amp;x,int y) { x+=y; if(x&gt;=p) x-=p; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot; %c&quot;,&amp;a[i]),a[i]-='A'; for(int i=1;i&lt;=m;i++) scanf(&quot; %c&quot;,&amp;b[i]),b[i]-='A'; for(int i=1;i&lt;=n/2;i++) swap(a[i],a[n-i+1]); for(int i=1;i&lt;=m/2;i++) swap(b[i],b[m-i+1]); dp[0][0][0]=1; for(int i=0;i&lt;=n+m;i++) { int u=i&amp;1,v=i&amp;1^1; for(int j=0;j&lt;=i-1&amp;&amp;j&lt;=n;j++) for(int k=0;k&lt;=i-1&amp;&amp;k&lt;=n;k++) dp[v][j][k]=0; for(int j=0;j&lt;=i&amp;&amp;j&lt;=n;j++) { for(int k=0;k&lt;=i&amp;&amp;k&lt;=n;k++) { if(dp[u][j][k]==0) continue; int jb=i-j,kb=i-k; if(j&lt;n&amp;&amp;k&lt;n&amp;&amp;a[j+1]==a[k+1]) add(dp[v][j+1][k+1],dp[u][j][k]); if(jb&lt;m&amp;&amp;k&lt;n&amp;&amp;b[jb+1]==a[k+1]) add(dp[v][j][k+1],dp[u][j][k]); if(j&lt;n&amp;&amp;kb&lt;m&amp;&amp;a[j+1]==b[kb+1]) add(dp[v][j+1][k],dp[u][j][k]); if(jb&lt;m&amp;&amp;kb&lt;m&amp;&amp;b[jb+1]==b[kb+1]) add(dp[v][j][k],dp[u][j][k]); } } } printf(&quot;%d\\n&quot;,dp[n+m&amp;1][n][n]); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P1758 [NOI2009] 管道取珠 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p1758-noi2009-guan-dao-qu-zhu-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":138000,"words":391,"minutes":3},"date":"2023-03-25 22:12:57","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>考虑一个字符集合<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>中元素互不相同）和一个长度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>的字符串<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，其中<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>中的字符都属于集合<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>。</p>\n<p>给你一个包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个整数的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>  (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>b</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_1&lt;b_2&lt;\\dots&lt;b_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>)。你可以对字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 作以下的操作：</p>\n<p>1.选择一个合法的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> ,并且令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">k=b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ;</p>\n<p>2.取出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个字符 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><msub><mi>r</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">Pr_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ;</p>\n<p>3.取出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个字符<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><msub><mi>u</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">Su_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ;</p>\n<p>4.将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中前 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个字符替换成翻转后的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><msub><mi>u</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">Su_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ;</p>\n<p>5.将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中后 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个字符替换成翻转后的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><msub><mi>r</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">Pr_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ;</p>\n<p>举个例子，我们令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">S=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span> &quot;abcdefghi&quot;，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">k=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 。这时<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><msub><mi>r</mi><mn>2</mn></msub><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">Pr_2=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span> &quot;ab&quot;，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">Su_2=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span> &quot;hi&quot;，翻转后有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><msub><mi>r</mi><mn>2</mn></msub><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">Pr_2=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span> &quot;ba&quot;，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">Su_2=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\"><span class=\"mord mathdefault\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span> &quot;ih&quot;，那么最终得到的字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 就是 &quot;ihcdefgba&quot;。</p>\n<p>这个操作可以被执行许多次（可能是零次），任何一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 也可以被使用多次。</p>\n<p>我们将字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 称为相等的字符串，当且仅当存在一个操作序列，将字符串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 变成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>。对于上面的例子来说，&quot;abcdefghi&quot; 和 &quot;ihcdefgba&quot; 是相等的。注意到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 和它自己也是相等的。</p>\n<p>你的任务很简单，数出互不相同的字符串的个数。</p>\n<p>最终的答案可能会非常大，因此你只需要输出答案 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mod</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">d</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 \\leq n \\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo separator=\"true\">,</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">1 \\leq m \\leq min(\\frac{n}{2},2 * 10^5)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>A</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\leq |A|\\leq 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">A</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 考虑一个字符集合AAA（AAA中元素互不相同）和一个长度为nnn的字符串SSS，其中SSS中的字符都属于集合AAA。 给你一个包含 mmm 个整数的序列 bbb (b1&lt;b2&lt;⋯&lt;bmb_1&lt;b_2&lt;\\dots&lt;b_mb1​&lt;b2​&lt;⋯&lt;bm​)。你可以对字符串 SSS 作以下的操作： 1.选择一个合法的 iii ,并且令 k=bik=b_ik=bi​ ; 2.取出 SSS 中前 kkk 个字符 PrkPr_kPrk​ ; 3.取出 SSS 中后 kkk 个字符SukSu_kSuk​ ; 4.将 SSS 中前 kkk 个字符替换成翻转后的 SukSu_kSuk​ ; 5.将 SSS 中后 kkk 个字符替换成翻转后的 PrkPr_kPrk​ ; 举个例子，我们令 S=S=S= &quot;abcdefghi&quot;，k=2k=2k=2 。这时Pr2=Pr_2=Pr2​= &quot;ab&quot;，Su2=Su_2=Su2​= &quot;hi&quot;，翻转后有 Pr2=Pr_2=Pr2​= &quot;ba&quot;，Su2=Su_2=Su2​= &quot;ih&quot;，那么最终得到的字符串 SSS 就是 &quot;ihcdefgba&quot;。 这个操作可以被执行许多次（可能是零次），任何一个 iii 也可以被使用多次。 我们将字符串 SSS 和 TTT 称为相等的字符串，当且仅当存在一个操作序列，将字符串 SSS 变成 TTT。对于上面的例子来说，&quot;abcdefghi&quot; 和 &quot;ihcdefgba&quot; 是相等的。注意到 SSS 和它自己也是相等的。 你的任务很简单，数出互不相同的字符串的个数。 最终的答案可能会非常大，因此你只需要输出答案 modmodmod 998244353998244353998244353 的结果。 2≤n≤1092 \\leq n \\leq 10^92≤n≤109，1≤m≤min(n2,2∗105)1 \\leq m \\leq min(\\frac{n}{2},2 * 10^5)1≤m≤min(2n​,2∗105)，1≤∣A∣≤1091\\leq |A|\\leq 10^91≤∣A∣≤109。 记字符集大小为 VVV。 观察到一次操作相当于是把 SSS 的前 kkk 位和 SSS 的后 kkk 位按位交换，即 swap⁡i=1k(Si,Sn−i+1)\\operatorname{swap}_{i=1}^k(S_i,S_{n-i+1}) swapi=1k​(Si​,Sn−i+1​) 那么考虑把 SSS “对折”，问题就变成了有两个长度为 ⌊n2⌋\\lfloor\\frac{n}{2}\\rfloor⌊2n​⌋ 的字符串 AAA 和 BBB，每次操作可以选一个 k∈{bi}k\\in \\{b_i\\}k∈{bi​}，交换 A[1,k]A_{[1,k]}A[1,k]​ 和 B[1,k]B_{[1,k]}B[1,k]​，问有多少种本质不同的 ABABAB（AAA 和 BBB 拼起来的字符串）。特别的，如果 nnn 是奇数，那么中间那个位置永远不会被操作到，可以单独处理。 不难发现，由于操作中的 kkk 一定是序列 bbb 中的某个数，并且同一个 kkk 最多只会操作一次。所以我们关心的只是 A[bi−1+1,bi]A_{[b_{i-1}+1,b_i]}A[bi−1​+1,bi​]​ 是否等于 B[bi−1+1,bi]B_{[b_{i-1}+1,b_i]}B[bi−1​+1,bi​]​。因为若不等则交换后结果不一样，否则结果一样。为了表述方便，不妨记它们为 A[i]A_{[i]}A[i]​ 和 B[i]B_{[i]}B[i]​。 下面的部分瞟了一眼题解才会。 考虑枚举每一个 iii： A[i]=B[i]A_{[i]}=B_{[i]}A[i]​=B[i]​ 的情况：共有 V∣A[i]∣V^{|A_{[i]}|}V∣A[i]​∣ 种方案； A[i]=B[i]A_{[i]}\\not=B_{[i]}A[i]​​=B[i]​ 的情况：共有 V∣A[i]∣(V∣B[i]∣−1)2\\dfrac{V^{|A_{[i]}|}(V^{|B_{[i]}|}-1)}{2}2V∣A[i]​∣(V∣B[i]​∣−1)​ 种方案，除以 222 是因为交换后的也枚举过。 这两种情况的方案数加起来，再乘起来，最后永远不会被操作到的单独处理即可。 部分代码： int ans=1; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;b[i]); int eq=qpow(v,b[i]-b[i-1]); int neq=1ll*qpow(v,b[i]-b[i-1])*(qpow(v,b[i]-b[i-1])-1)%p*qpow(2,p-2)%p; ans=1ll*ans*(eq+neq)%p; } ans=1ll*ans*qpow(v,n-b[m]-b[m])%p; ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1065E Side Transmutations 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1065e-side-transmutations-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":253000,"words":932,"minutes":5},"date":"2023-03-25 22:06:12","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个箱子和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 个小球，初始时第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个箱子有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 个小球。每次操作可以将<strong>一个</strong>小球移到相邻的箱子里。求要使得最终数组 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_i\\ge a_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 的最小操作次数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>250</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 250</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 有 nnn 个箱子和 mmm 个小球，初始时第 iii 个箱子有 aia_iai​ 个小球。每次操作可以将一个小球移到相邻的箱子里。求要使得最终数组 ai≥ai+1a_i\\ge a_{i+1}ai​≥ai+1​ 的最小操作次数。 1≤n,m≤2501\\le n,m\\le 2501≤n,m≤250。 把 aaa 反过来，问题变成了让 ai≥ai−1a_i\\ge a_{i-1}ai​≥ai−1​ 的最小操作次数。 考虑设 dpi,j,kdp_{i,j,k}dpi,j,k​ 为前 i−1i-1i−1 个满足条件，ai=ja_i=jai​=j 且 ai−ai−1=ka_i-a_{i-1}=kai​−ai−1​=k 的最小操作次数，并且 iii 后面的位置没有改动。这么设置状态是因为 aia_iai​ 不会影响到 ai−2a_{i-2}ai−2​，而 ai−1a_{i-1}ai−1​ 对 ai−2a_{i-2}ai−2​ 的影响已经算过了，实现了无后效性。 显然有 dp1,a1,a1=0dp_{1,a_1,a_1}=0dp1,a1​,a1​​=0。 考虑转移，按 jjj 和 aia_iai​ 的大小关系分类： j&gt;aij&gt;a_ij&gt;ai​：多出来的只可能是 ai−1a_{i-1}ai−1​ 给的，此时 aia_iai​ 肯定没给 ai−1a_{i-1}ai−1​，所以 dpi,j,k=j−ai+min⁡l=j−aimdpi−1,j−k+j−ai,ldp_{i,j,k}=j-a_i+\\min\\limits_{l=j-a_i}^{m}dp_{i-1,j-k+j-a_i,l}dpi,j,k​=j−ai​+l=j−ai​minm​dpi−1,j−k+j−ai​,l​； j&lt;aij&lt;a_ij&lt;ai​：少掉的只可能是给了 ai−1a_{i-1}ai−1​，此时 ai−1a_{i-1}ai−1​ 肯定没给 aia_iai​。并且注意到因为给了 ai−1a_{i-1}ai−1​ 一些，所以 ai−1a_{i-1}ai−1​ 在没给之前可以比 ai−2a_{i-2}ai−2​ 小，也就是说 dpi,j,k=ai−j+min⁡l=j−aim−ai+jdpi−1,j−k−ai+j,ldp_{i,j,k}=a_i-j+\\min\\limits_{l=j-a_i}^{m-a_i+j} dp_{i-1,j-k-a_i+j,l}dpi,j,k​=ai​−j+l=j−ai​minm−ai​+j​dpi−1,j−k−ai​+j,l​； j=aij=a_ij=ai​：谁也没给谁，dpi,j,k=min⁡l=0mdpi−1,j−k,ldp_{i,j,k}=\\min\\limits_{l=0}^{m}dp_{i-1,j-k,l}dpi,j,k​=l=0minm​dpi−1,j−k,l​。 最后答案即为 min⁡i=0mmin⁡j=0idpn,i,j\\min\\limits_{i=0}^m\\min\\limits_{j=0}^idp_{n,i,j}i=0minm​j=0mini​dpn,i,j​。 注意到转移中的 min⁡\\minmin 可以用后缀 min⁡\\minmin 来优化到 O(1)O(1)O(1)，那么可以在 O(nm2)O(nm^2)O(nm2) 的时间复杂度内解决此题。 完整代码： // Problem: CF1675G Sorting Pancakes // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1675G // Memory Limit: 250 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const long long MS=255; const int mov=252,mov2=502; int n,m,a[MS]; int dp[2][MS*3][MS*3],mn[2][MS*3][MS*3]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=1;i&lt;=n/2;i++) { swap(a[i],a[n-i+1]); } memset(dp,127,sizeof(dp)); memset(mn,127,sizeof(mn)); dp[1][a[1]+mov][a[1]+mov2]=0; for(int i=m;i&gt;=-m*2;i--) { int id1=a[1]+mov; int id2=i+mov2; mn[1][id1][id2]=min(mn[1][id1][id2+1],dp[1][id1][id2]); } for(int i=2;i&lt;=n;i++) { int u=i&amp;1; int v=u^1; memset(dp[u],127,sizeof(dp[u])); memset(mn[u],127,sizeof(mn[u])); for(int j=-m;j&lt;=m;j++) { int idj=j+mov; for(int k=j-m;k&lt;=j;k++) { int idk=k+mov2; if(j&gt;a[i]) { dp[u][idj][idk]=j-a[i]+mn[v][j-k+j-a[i]+mov][j-a[i]+mov2]; } else if(j&lt;a[i]) { dp[u][idj][idk]=a[i]-j+mn[v][j-k+j-a[i]+mov][j-a[i]+mov2]; } else { dp[u][idj][idk]=mn[v][j-k+mov][mov2]; } } for(int k=m;k&gt;=-m*2;k--) { int idk=k+mov2; mn[u][idj][idk]=min(mn[u][idj][idk+1],dp[u][idj][idk]); } } } int ans=1e8; for(int i=0;i&lt;=m;i++) { ans=min(ans,mn[n&amp;1][i+mov][mov2]); } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF1675G Sorting Pancakes 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf1675g-sorting-pancakes-zuo-ti-ji-lu/","stats":{"text":"6 min read","time":306000,"words":934,"minutes":6},"date":"2023-03-25 22:04:18","dateFormat":"2023-03-25"},{"abstract":"","content":"需要求 n,m≤limn,m\\le limn,m≤lim 的一些 CnmC_n^mCnm​ 模 ppp 的结果，但是递推预处理组合数时间复杂度无法接受时，该怎么办呢？ 0x0 普通方法 最基础的方法是预处理出阶乘和阶乘的逆元，直接套公式计算： inline void init() { fra[0]=1; for(int i=1;i&lt;=lim;i++) { fra[i]=1ll*fra[i-1]*i%p; } inv[lim]=qpow(fra[lim],p-2); for(int i=lim;i&gt;=1;i--) { inv[i-1]=1ll*inv[i]*i%p; } } inline int C(int n,int m) { return n&lt;m?0:1ll*fra[n]*fra[n-m]%p*fra[m]%p; } 这样做的话单次时间复杂度是 O(1)O(1)O(1) 的，预处理时间复杂度则是 O(lim)O(lim)O(lim)。 1x0 特殊手段 普通方法已经能满足大多数情况，但是有两种特殊情况除外。 1x1 lim≥plim\\ge plim≥p，但 ppp 是质数的情况（Lucas） 当 lim≥plim\\ge plim≥p 时，所有 i≥pi\\ge pi≥p 的 i!i!i! 都不与 ppp 互质，没有模 ppp 意义下的逆元，普通方法就行不通了。 这时可以借助 Lucas 定理： Cnm≡Cnmod⁡pmmod⁡p⋅C⌊np⌋⌊mp⌋(modp)C_n^m\\equiv C_{n\\operatorname{mod}p}^{m\\operatorname{mod} p}\\cdot C_{\\lfloor\\frac{n}{p}\\rfloor}^{\\lfloor\\frac{m}{p}\\rfloor}\\pmod p Cnm​≡Cnmodpmmodp​⋅C⌊pn​⌋⌊pm​⌋​(modp) 来实现递归求解： inline void init() { int lim2=min(lim,p-1); fra[0]=1; for(int i=1;i&lt;=lim2;i++) { fra[i]=1ll*fra[i-1]*i%p; } inv[lim2]=qpow(fra[lim2],p-2); for(int i=lim2;i&gt;=1;i--) { inv[i-1]=1ll*inv[i]*i%p; } } inline int C(int n,int m) { return n&lt;m?0:1ll*fra[n]*inv[m]%p*inv[n-m]%p; } int lucas(int n,int m) { return m==0?1:1ll*C(n%p,m%p)*lucas(n/p,m/p)%p; } 这样做的话单次时间复杂度是 O(log⁡pm)O(\\log_p m)O(logp​m) 的，预处理时间复杂度则是 O(min⁡(lim,p))O(\\min(lim,p))O(min(lim,p))。 定理证明： 【引理 1】 对于任意一个满足 1≤x&lt;p1\\le x&lt;p1≤x&lt;p 的正整数 xxx，均有 Cpx≡0(modp)C_p^x\\equiv0\\pmod pCpx​≡0(modp)，证明如下： Cpx≡p!x!(p−x)!(modp)≡p⋅(p−1)!x!(p−x)!(modp)≡0(modp)\\begin{aligned}C_p^x&amp;\\equiv\\dfrac{p!}{x!(p-x)!}\\pmod p\\\\&amp;\\equiv p\\cdot\\dfrac{(p-1)!}{x!(p-x)!}\\pmod p\\\\&amp;\\equiv 0\\pmod p\\end{aligned} Cpx​​≡x!(p−x)!p!​(modp)≡p⋅x!(p−x)!(p−1)!​(modp)≡0(modp)​ 【引理 2】 (a+b)p≡ap+bp(modp)(a+b)^p\\equiv a^p+b^p\\pmod p(a+b)p≡ap+bp(modp)，证明如下： 根据二项式定理： (a+b)p≡∑i=0pCpi⋅ai⋅bp−i(modp)≡ap+bp+∑i=1p−1Cpi⋅ai⋅bp−i(modp)≡ap+bp(modp)（由引理 1 得）\\begin{aligned}(a+b)^p&amp;\\equiv\\sum\\limits_{i=0}^pC_p^i\\cdot a^i\\cdot b^{p-i}\\pmod p\\\\&amp;\\equiv a^p+b^p+\\sum\\limits_{i=1}^{p-1}C_p^i\\cdot a^i\\cdot b^{p-i}\\pmod p\\\\&amp;\\equiv a^p+b^p\\pmod p\\text{（由引理 1 得）}\\end{aligned} (a+b)p​≡i=0∑p​Cpi​⋅ai⋅bp−i(modp)≡ap+bp+i=1∑p−1​Cpi​⋅ai⋅bp−i(modp)≡ap+bp(modp)（由引理 1 得）​ 【定理 1（Lucas 定理）】 Cnm≡Cnmod⁡pmmod⁡p⋅C⌊np⌋⌊mp⌋(modp)C_n^m\\equiv C_{n\\operatorname{mod}p}^{m\\operatorname{mod} p}\\cdot C_{\\lfloor\\frac{n}{p}\\rfloor}^{\\lfloor\\frac{m}{p}\\rfloor}\\pmod pCnm​≡Cnmodpmmodp​⋅C⌊pn​⌋⌊pm​⌋​(modp)，证明如下： 设 xxx 为一个满足 1≤x&lt;p1\\le x&lt;p1≤x&lt;p 的正整数，由二项式定理得：(1+x)n≡∑i=0nCnixi(1+x)^n\\equiv \\sum\\limits_{i=0}^n C_n^ix^i(1+x)n≡i=0∑n​Cni​xi。 令 pn=⌊np⌋,pm=⌊mp⌋,rn=nmod⁡p,rm=mmod⁡pp_n=\\lfloor\\frac{n}{p}\\rfloor,p_m=\\lfloor\\frac{m}{p}\\rfloor,r_n=n\\operatorname{mod}p,r_m=m\\operatorname{mod} ppn​=⌊pn​⌋,pm​=⌊pm​⌋,rn​=nmodp,rm​=mmodp，那么有： (1+x)n≡(1+x)p⋅pn+rn(modp)≡[(1+x)p]pn⋅(1+x)rn(modp)≡(1+xp)pn⋅(1+x)rn(modp)≡∑i=0pn∑j=0rnCpni⋅Crnj⋅xip+j(modp)（根据二项式定理）≡∑i=0nCpn⌊ip⌋⋅Crnimod⁡p⋅xi(modp)\\begin{aligned}(1+x)^n&amp;\\equiv (1+x)^{p\\cdot p_n+r_n}\\pmod p\\\\&amp;\\equiv [(1+x)^p]^{p_n}\\cdot(1+x)^{r_n}\\pmod p\\\\&amp;\\equiv (1+x^p)^{p_n}\\cdot (1+x)^{r_n}\\pmod p\\\\&amp;\\equiv \\sum\\limits_{i=0}^{p_n}\\sum\\limits_{j=0}^{r_n}C_{p_n}^i\\cdot C_{r_n}^j\\cdot x^{ip+j}\\pmod p\\text{（根据二项式定理）}\\\\&amp;\\equiv\\sum\\limits_{i=0}^nC_{p_n}^{\\lfloor\\frac{i}{p}\\rfloor}\\cdot C_{r_n}^{i\\operatorname{mod} p}\\cdot x^i\\pmod p\\end{aligned} (1+x)n​≡(1+x)p⋅pn​+rn​(modp)≡[(1+x)p]pn​⋅(1+x)rn​(modp)≡(1+xp)pn​⋅(1+x)rn​(modp)≡i=0∑pn​​j=0∑rn​​Cpn​i​⋅Crn​j​⋅xip+j(modp)（根据二项式定理）≡i=0∑n​Cpn​⌊pi​⌋​⋅Crn​imodp​⋅xi(modp)​ 所以： ∑i=0nCnixi≡∑i=0nCpn⌊ip⌋⋅Crnimod⁡p⋅xi(modp)\\sum\\limits_{i=0}^n C_n^ix^i\\equiv\\sum\\limits_{i=0}^nC_{p_n}^{\\lfloor\\frac{i}{p}\\rfloor}\\cdot C_{r_n}^{i\\operatorname{mod} p}\\cdot x^i\\pmod p i=0∑n​Cni​xi≡i=0∑n​Cpn​⌊pi​⌋​⋅Crn​imodp​⋅xi(modp) Cnm≡Cpnpm⋅Crnrm(modp)C_n^m\\equiv C_{p_n}^{p_m}\\cdot C_{r_n}^{r_m}\\pmod p Cnm​≡Cpn​pm​​⋅Crn​rm​​(modp) 证毕。 练习：P3773 [CTSC2017]吉夫特 1x2 ppp 不是质数的情况（exLucas） 未完待续。 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"组合数取模（Lucas 定理 & exLucas 定理）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zu-he-shu-qu-mo-lucas-ding-li-and-exlucas-ding-li-xue-xi-bi-ji/","stats":{"text":"7 min read","time":384000,"words":1171,"minutes":7},"date":"2023-03-25 21:59:48","dateFormat":"2023-03-25"},{"abstract":"","content":"0x0 基本原理 0x01 加法原理 若做 AAA 有 nnn 种方法，做 BBB 有 mmm 种方法，并且它们互不干涉，那么做 AAA 或 BBB 中的恰好一个有 n+mn+mn+m 种方法。 0x02 乘法原理 若做 AAA 有 nnn 种方法，做 BBB 有 mmm 种方法，并且它们互不干涉，那么做 AAA 并且做 BBB 有 n×mn\\times mn×m 种方法。 0x1 排列组合 0x11 排列 从 nnn 个各不相同的元素中有顺序地取出 mmm 个元素的方法数，记为 AnmA_n^mAnm​，即为排列数。 考虑 AnmA_n^mAnm​ 的具体求法。考虑每一次选出的元素，第一次选择有 nnn 种方法，第二次选择有 n−1n-1n−1 种方法，…\\dots…，第 mmm 次选择有 n−m+1n-m+1n−m+1 种方法。由于每次选择事件互不干涉，所以根据乘法原理： Anm=n(n−1)(n−2)…(n−m+1)=n!(n−m)!A_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\dfrac{n!}{(n-m)!} Anm​=n(n−1)(n−2)…(n−m+1)=(n−m)!n!​ 0x12 组合 从 nnn 个各不相同的元素中无顺序地取出 mmm 个元素的方法数，记为 CnmC_n^mCnm​ 或 (nm)\\dbinom{n}{m}(mn​)，即为组合数。 考虑 CnmC_n^mCnm​ 的具体求法。无顺序地取出可以看作是有顺序地取出后去掉顺序，那么由于 mmm 个各不相同的元素有 m!m!m! 种排列方式，所以： Cnm=Anmm!=n!(n−m)!m!C_n^m=\\dfrac{A_n^m}{m!}=\\dfrac{n!}{(n-m)!m!} Cnm​=m!Anm​​=(n−m)!m!n!​ 0x13 排列数与组合数的求法 在实际应用中，排列数和组合数都可以通过预处理阶乘的方法来求出。 但是组合数有 O(nm)O(nm)O(nm) 的预处理方法（nnn 是元素个数上限，mmm 是选出的元素数量上限）： Cnm=Cn−1m−1+Cmn−1C^m_n=C^{m-1}_{n-1}+C^{n-1}_m Cnm​=Cn−1m−1​+Cmn−1​ 证明： 首先把 nnn 个物品分成两组，第一组有 n−1n-1n−1 个，第二组有 111 个。 那么我们可以从第一组里选 m−1m-1m−1 个并从第二组里选一个，或者从第一组里选 mmm 个。 预处理组合数的代码：（对 ppp 取模） C[0][0]=1; for(int i=1;i&lt;=n;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) { C[i][j]=(C[i-1][j-1]+C[i-1][j])%p; } } 另外，关于组合数的取模问题，可以看组合数取模（Lucas 定理 &amp; exLucas 定理）学习笔记。 0x14 一些技巧 0x141 整体考虑 有时候元素会分成很多个组，组之间有顺序关系，组内也有顺序关系，那么就可以考虑每一组单独排列组合，再把每一组当成单个元素来排列组合。 0x142 插板法 nnn 个相同的物品放到 mmm 个不同的盒子内，不允许空盒子，有多少种方法？ 可以考虑在 nnn 个物品中间放 m−1m-1m−1 个“隔板”，把所有物品分隔成 mmm 组，那么方案数就是 Cn−1m−1C_{n-1}^{m-1}Cn−1m−1​。 插板法还有个变形，即允许空盒子： nnn 个相同的物品放到 mmm 个不同的盒子内，不允许空盒子，有多少种方法？ 可以考虑增加 mmm 个物品，那么盒子里放一个物品就相当于是没有放，放两个就相当于是放了一个，依此类推。所以方案数即为 Cn+m−1m−1C_{n+m-1}^{m-1}Cn+m−1m−1​。 0x143 贡献有次方的处理 权值为 xxx 的方案贡献为 xkx^kxk 的时候，可以考虑运用二项式定理拆开次方，也可以考虑组合意义：nnn 个对象，kkk 个人各选一个的方案数。 例题：P1758 [NOI2009] 管道取珠 | 题解 0x144 组合恒等式 详见组合恒等式学习笔记。 0x145 格路计数 详见格路计数入门。 1x0 二项式定理 (a+b)n=∑i=0n(ni)aibn−i(a+b)^n=\\sum\\limits_{i=0}^n\\dbinom{n}{i}a^ib^{n-i} (a+b)n=i=0∑n​(in​)aibn−i 证明： 首先考虑把 (a+b)n(a+b)^n(a+b)n 的幂拆开： (a+b)n=(a+b)(a+b)(a+b)…(a+b)⎵n个(a+b)(a+b)^n=\\begin{matrix}\\underbrace{(a+b)(a+b)(a+b)\\dots(a+b)}\\\\n\\text{个}(a+b)\\end{matrix} (a+b)n=(a+b)(a+b)(a+b)…(a+b)​n个(a+b)​ 接下来拆括号，考虑选 iii 个 aaa 出来，那么就会有 n−in-in−i 个 bbb 和它配对，即 aibn−ia^ib^{n-i}aibn−i，选 aaa 出来的方案数是 (ni)\\dbinom{n}{i}(in​)，所以原式成立。 1x1 容斥原理 1x11 基础容斥 设有一些元素和一些条件 R={P1,P2,P3,… }R=\\{P_1,P_2,P_3,\\dots\\}R={P1​,P2​,P3​,…}，令 f(S)f(S)f(S) 表示满足 SSS 中所有条件的元素个数。那么至少满足 RRR 中一个条件的元素个数为： ∑T⊆R,T=∅(−1)∣T∣−1f(T)\\sum\\limits_{T\\subseteq R,T\\not=\\varnothing}(-1)^{|T|-1}f(T) T⊆R,T​=∅∑​(−1)∣T∣−1f(T) 可以靠维恩图来理解： 至少满足一个条件的元素个数可以看作是维恩图中不是空白的部分的面积，是 ∣A∣+∣B∣+∣A∣−∣AC∣−∣AB∣−∣BC∣+∣ABC∣|A|+|B|+|A|-|AC|-|AB|-|BC|+|ABC| ∣A∣+∣B∣+∣A∣−∣AC∣−∣AB∣−∣BC∣+∣ABC∣ 仔细观察就会发现它与式子一致。 不满足 RRR 中任意一个条件的元素个数为： ∑T⊆R(−1)∣T∣f(T)\\sum\\limits_{T\\subseteq R}(-1)^{|T|}f(T) T⊆R∑​(−1)∣T∣f(T) 依旧是靠之前那一张维恩图来理解，不满足任意一个条件的元素个数可以看作维恩图中空白部分的面积，是 元素个数−∣A∣−∣B∣−∣C∣+∣AC∣+∣AB∣+∣BC∣−∣ABC∣\\text{元素个数}-|A|-|B|-|C|+|AC|+|AB|+|BC|-|ABC| 元素个数−∣A∣−∣B∣−∣C∣+∣AC∣+∣AB∣+∣BC∣−∣ABC∣ 而元素个数就是 f(∅)f(\\varnothing)f(∅)，这也是求和里的 TTT 可以等于 ∅\\varnothing∅ 的原因。 1x12 基础容斥扩展 依旧是有一些元素和一些条件 R={P1,P2,P3,… }R=\\{P_1,P_2,P_3,\\dots\\}R={P1​,P2​,P3​,…}，f(S)f(S)f(S) 依旧表示满足 SSS 中所有条件的元素个数。令 g(S)g(S)g(S) 表示满足且仅满足 SSS 中所有条件的元素个数，那么有： g(S)=∑S⊆T(−1)∣T∣−∣S∣f(T)g(S)=\\sum\\limits_{S\\subseteq T}(-1)^{|T|-|S|}f(T) g(S)=S⊆T∑​(−1)∣T∣−∣S∣f(T) 还是靠维恩图理解： 满足且仅满足某个集合中的条件的元素个数可以看成是一块颜色的面积。假设要求 g(A)g(A)g(A) 也就是维恩图中黄色那块的面积。那么显然它是 ∣A∣−∣AC∣−∣AB∣+∣ABC∣|A|-|AC|-|AB|+|ABC| ∣A∣−∣AC∣−∣AB∣+∣ABC∣ 仔细观察就会发现它与式子一致。 2x0 各种常见数列 2x01 卡特兰数 有 nnn 个左括号和 nnn 个右括号的合法括号序列有多少个？ 把左括号记为 111，右括号记为 −1-1−1，不难发现一个括号序列合法当且仅当其前缀和均 ≥0\\ge0≥0。 直接计算不好做，考虑寻找映射关系。对于每个不合法的括号序列，考虑把其前缀和中第一个 &lt;0&lt;0&lt;0 的位置和其之前的括号都翻转。由于翻转之前这个位置的前缀和一定为 −1-1−1，所以翻转后的序列共有 n+1n+1n+1 个 111 和 n−1n-1n−1 个 −1-1−1。 不难发现，每个有 n+1n+1n+1 个 111 和 n−1n-1n−1 个 −1-1−1 的序列都对应一个不合法序列，只要把其前缀和中第一个 &gt;0&gt;0&gt;0 的位置和其之前的括号都翻转即可还原出一个不合法序列，并且是一一对应的，所以不合法的括号序列总共有 (2nn−1)\\binom{2n}{n-1}(n−12n​) 个。 由于总共的括号序列有 (2nn)\\binom{2n}{n}(n2n​)，所以合法括号序列有 (2nn)−(2nn−1)=(2n)!n!2−(2n)!(n−1)!(n+1)!=(2n)!(n+1)−n(2n)!n!2(n+1)=(2nn)n+1\\binom{2n}{n}-\\binom{2n}{n-1}=\\frac{(2n)!}{n!^2}-\\frac{(2n)!}{(n-1)!(n+1)!}=\\frac{(2n)!(n+1)-n(2n)!}{n!^2(n+1)}=\\frac{\\binom{2n}{n}}{n+1}(n2n​)−(n−12n​)=n!2(2n)!​−(n−1)!(n+1)!(2n)!​=n!2(n+1)(2n)!(n+1)−n(2n)!​=n+1(n2n​)​。 这就是卡特兰数的通项公式，不妨记 Cn=(2nn)n+1C_n=\\frac{\\binom{2n}{n}}{n+1}Cn​=n+1(n2n​)​，那么有 Cn+1=∑i=0nCiCn−iC_{n+1}=\\sum\\limits_{i=0}^{n}C_iC_{n-i}Cn+1​=i=0∑n​Ci​Cn−i​。 证明： 假设最后一个右括号和第 i+1i+1i+1 个左括号匹配，那么这对括号中间和这对括号外面的部分是互相独立的，所以此时的合法括号序列个数为 CiCn−iC_iC_{n-i}Ci​Cn−i​。 一些运用： 有 nnn 个点的有根二叉树的个数？ 设 fnf_nfn​ 表示问题的答案，那么有 fn=∑i=0n−1fifn−1−if_n=\\sum\\limits_{i=0}^{n-1}f_{i}f_{n-1-i}fn​=i=0∑n−1​fi​fn−1−i​ 且 f0=f1=1f_0=f_1=1f0​=f1​=1，和卡特兰数的递推式一致，所以有 fn=Cnf_n=C_nfn​=Cn​。 有 nnn 个点的所有有根二叉树的叶子的总数？ 对于每棵 nnn 个点的二叉树，设它有 kkk 个叶子，那么把这 kkk 个叶子分别删去就能得到 kkk 棵 n−1n-1n−1 个点的二叉树。 由于每一颗 n−1n-1n−1 个点的二叉树都能悬挂 nnn 个新的叶子，所以每一棵 n−1n-1n−1 个点的二叉树都会被上面的过程得到 nnn 次。 由于 nnn 个点的有根二叉树有 CnC_nCn​ 种，所以 nnn 个点的所有二叉树总共有 nCn−1=(2n−2n−1)nC_{n-1}=\\binom{2n-2}{n-1}nCn−1​=(n−12n−2​) 个叶子。 2x03 第二类斯特林数 2x02 第一类斯特林数 2x04 分拆数 ","tags":[],"title":"组合计数入门","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zu-he-ji-shu-ru-fen/","stats":{"text":"11 min read","time":638000,"words":2459,"minutes":11},"date":"2023-03-25 21:57:33","dateFormat":"2023-03-25"},{"abstract":"","content":"这些都是近来我 VP CF 遇到的奇奇妙妙的题。 构造 这一类题通常需要大胆猜结论/经验积累。 CF1514B AND 0, Sum Big 首先因为与运算和为 000，所以每一位上都至少有一个数这一位为 000。 然后因为元素的和要尽量大，所以肯定不存在两个数同一位为 000。 那么每一位都需要让 a1∼na_{1\\sim n}a1∼n​ 中的恰好一个在这一位为 000，所以答案即为 nkn^knk。 CF1630A And Matching 首先来看三个性质： i&amp;(n−1−i)=0i\\&amp;(n-1-i)=0i&amp;(n−1−i)=0，因为 iii 和 n−1−in-1-in−1−i 的二进制是“错开”的； i&amp;(n−1)=ii\\&amp;(n-1)=ii&amp;(n−1)=i，因为 n−1n-1n−1 的二进制全是 111； i&amp;0=0i\\&amp;0=0i&amp;0=0，显然。 接下来分类讨论： 若 k=n−1k\\not=n-1k​=n−1： 可以先构造出 k&amp;(n−1)=kk\\&amp;(n-1)=kk&amp;(n−1)=k 和 (n−1−k)&amp;0=0(n-1-k)\\&amp;0=0(n−1−k)&amp;0=0，然后对于每个 1≤i≤n−11\\le i\\le n-11≤i≤n−1 且 i=ki\\not=ki​=k 且 i=n−1−ki\\not=n-1-ki​=n−1−k 的 iii 构造出 i&amp;(n−1−i)=0i\\&amp;(n-1-i)=0i&amp;(n−1−i)=0。 注意特判 k=0k=0k=0，这时不需要构造 (n−1−k)&amp;0=0(n-1-k)\\&amp;0=0(n−1−k)&amp;0=0。 若 k=n−1k=n-1k=n−1 这时容易发现让其中一对与为 kkk 的办法行不通了，所以我们要另辟蹊径，让两对的与加起来为 kkk。 显然 (n−1)&amp;(n−2)=n−2(n-1)\\&amp;(n-2)=n-2(n−1)&amp;(n−2)=n−2，1&amp;(n−3)=11\\&amp;(n-3)=11&amp;(n−3)=1，那么先构造这两对即可。 接下来发现 n−1−(n−1)=0n-1-(n-1)=0n−1−(n−1)=0，n−1−(n−3)=2n-1-(n-3)=2n−1−(n−3)=2，n−1−(n−2)=1n-1-(n-2)=1n−1−(n−2)=1 也就是说 000 和 222 不能组成 i&amp;(n−1−i)=0i\\&amp;(n-1-i)=0i&amp;(n−1−i)=0 了，那么让它们单独组，构造 0&amp;2=00\\&amp;2=00&amp;2=0。 接下来构造 i&amp;(n−1−i)=0i\\&amp;(n-1-i)=0i&amp;(n−1−i)=0 即可。 注意到若 n≤4n\\le 4n≤4 则 n−1n-1n−1、n−2n-2n−2、n−3n-3n−3、000、111、222 会重叠，这时是无解的。 CF1659D Reverse Sort Sum 不难发现，由于每个 111 对 ∑C\\sum C∑C 都有且仅有 nnn 的贡献，所以 AAA 中 111 的个数即为 ∑Cn\\dfrac{\\sum C}{n}n∑C​。 接下来，我们很容易发现 An=1A_n=1An​=1 当且仅当 Cn=nC_n=nCn​=n，因为 An=1A_n=1An​=1 时 Bi,nB_{i,n}Bi,n​ 一定为 111。 有了这个性质的启示，不难想到可以通过减掉 BnB_nBn​ 对 CCC 的贡献来实现缩小问题的规模，令 nnn 变为 n−1n-1n−1。实际上实现起来也并不难，因为我们已经取得了 AAA 中 111 的个数 mmm，BnB_nBn​ 一定只会对 [n−m+1,n][n-m+1,n][n−m+1,n] 有 111 的贡献，那么用差分来实现快速区间减法即可。 CF1658D2 388535 (Hard Version) 首先肯定有一个 aia_iai​ 满足 aixor⁡l=xa_i\\operatorname{xor} l=xai​xorl=x，即它本来是 lll。那么我们枚举每个 aia_iai​，判断它原来是不是 lll 即可。 接下来思考判断的方法。不难发现，由于 aia_iai​ 原来是不重复的一个排列，所以异或后的 aia_iai​ 也是不重复的一个排列，所以只要 aia_iai​ 满足 r=max⁡xor⁡(aixor⁡l)r=\\max\\operatorname{xor}(a_i\\operatorname{xor} l)r=maxxor(ai​xorl) 就说明 aia_iai​ 原来是 lll。 这个东西用 trie 维护即可。 CF1592C Bakry and Partitioning 从每一部分的异或和相同出发，设分割后每一部分的异或和都为 kkk，所有 aia_iai​ 的异或和为 sumsumsum。不难发现要么 sum=0sum=0sum=0 即最后是偶数个 kkk 异或起来，要么 sum=ksum=ksum=k 即最后是奇数个 kkk 异或起来。 若 sum=0sum=0sum=0，我们割断任意一条边都一定合法。因为割出来的两部分只有异或和相同它们异或起来的结果 sumsumsum 才为 000。 若 sum=ksum=ksum=k，那么割断两条边，分割出三个异或和为 kkk 的连通块显然是最优的。所以考虑找到两个异或和都为 kkk 的连通块，剩下那一块异或和就自然为 kkk。因为肯定有一个满足条件的连通块是一棵子树，减掉它的贡献后又会有一个满足条件的连通块是一棵子树，所以跑一次 dfsdfsdfs，求出每个节点子树去掉异或和为的 kkk 子树后的异或和 dpu=xor⁡v 是 u 的儿子[dpv=k]dpvdp_u=\\operatorname{xor}_{v\\text{ 是 }u\\text{ 的儿子}}[dp_v\\not=k]dp_vdpu​=xorv 是 u 的儿子​[dpv​​=k]dpv​ 即可。最后若 ∑u[dpu=k]≥2\\sum\\limits_{u} [dp_u=k]\\ge2u∑​[dpu​=k]≥2 就说明有解。 部分代码如下： void dfs(int u,int fa,long long val) { dp[u]=a[u]; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs(v,u,val); if(dp[v]!=val) { dp[u]^=dp[v]; } } } inline void slove() { esum=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); long long sm=0; for(int i=1;i&lt;=n;i++) { h[i]=0; dp[i]=0; scanf(&quot;%lld&quot;,&amp;a[i]); sm^=a[i]; } for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } if(sm==0) { puts(&quot;YES&quot;); return; } if(k==2) { puts(&quot;NO&quot;); return; } dfs(1,0,sm); int cnt=0; for(int i=1;i&lt;=n;i++) { cnt+=dp[i]==sm; } puts(cnt&gt;=2?&quot;YES&quot;:&quot;NO&quot;); } 交互 这一类题通常需要程序和交互库互动，思维难度较高。 CF1503B 3-Coloring 用 111 和 222 交替着填，实在不行用 333 即可。 CF1592D Hemose in ICPC 首先由于 gcd⁡\\gcdgcd 里的数越多，结果就越小，所以最大的 DistDistDist 一定是一条边的边权。 那么我们先询问所有节点求出最大的 Dist=valDist=valDist=val，然后二分所有的边。 考虑如何二分，显然需要把树“拍扁”，用类似 dfsdfsdfs 序的东西来解决。具体的，考虑节点 uuu 和它的所有儿子 vi{v_i}vi​，显然 u→viu\\to v_iu→vi​ 都有一条边，那么先往序列里加入 uuu，再在 dfsdfsdfs 完每个 viv_ivi​ 后都加入 uuu 即可。 CF1634D Finding Zero 考虑从 444 个可能的下标 b1,b2,b3,b4b_1,b_2,b_3,b_4b1​,b2​,b3​,b4​ 中去掉一些不可能的下标。 显然一次询问的结果是三个数的极差。记 q1,q2,q3,q4q_1,q_2,q_3,q_4q1​,q2​,q3​,q4​ 为询问四个下标里分别除去 b1,b2,b3,b4b_1,b_2,b_3,b_4b1​,b2​,b3​,b4​ 的结果，即 q1q_1q1​ 为询问 b2,b3,b4b_2,b_3,b_4b2​,b3​,b4​ 的结果。那么显然 m=max⁡(q1,q2,q3,q4)m=\\max(q_1,q_2,q_3,q_4)m=max(q1​,q2​,q3​,q4​) 就是 ab1,ab2,ab3,ab4a_{b_1},a_{b_2},a_{b_3},a_{b_4}ab1​​,ab2​​,ab3​​,ab4​​ 的极差。 不难发现，若 qi=mq_i=mqi​=m，那么 bib_ibi​ 一定不可能为 000。因为去掉 000 后三个数的极差一定不是这四个数的极差。 这样每排除一次至少可以去掉至少两个不可能的下标，总共需要的次数上限就是 4n2=2n\\dfrac{4n}{2}=2n24n​=2n，足以通过此题。 特别的，若剩下三个下标未排除，拿一个排除过的下标和它们组队即可。 杂题 最后给两道匕匕车交女少白勺杂题。 CF1632D New Year Concert 不难发现，当区间 [l,r][l,r][l,r] 的右端点 rrr 固定不动，左端点 lll 减小时，gcd⁡(al,al+1,al+2,…,ar)\\gcd(a_l,a_{l+1},a_{l+2},\\dots,a_r)gcd(al​,al+1​,al+2​,…,ar​) 是单调不增的，而 r−l+1r-l+1r−l+1 则是单调递增的，这造成了它们最多只会有一个交点。也就是说，对于一个固定的 rrr，最多有一个 lll 满足 gcd⁡(al,al+1,al+2,…,ar)=r−l+1\\gcd(a_l,a_{l+1},a_{l+2},\\dots,a_r)=r-l+1gcd(al​,al+1​,al+2​,…,ar​)=r−l+1。 那么用倍增实现 O(nlog⁡nlog⁡v)O(n\\log n\\log v)O(nlognlogv) 预处理 O(1)O(1)O(1) 查询 gcd⁡\\gcdgcd，然后枚举 rrr，每次找满足条件的 lll，如果有那么答案加一并且把 ala_lal​ 改为 111 即可。 部分代码如下： int ans=0,lb=1; for(int i=1;i&lt;=n;i++) { while(lb&lt;i&amp;&amp;que(lb,i)&lt;i-lb+1) { lb++; } if(que(lb,i)==i-lb+1) { ans++; lb=i+1; } printf(&quot;%d &quot;,ans); } printf(&quot;\\n&quot;); CF1594D The Number of Imposters 并查集拆点模板题，建议先看一下我的博客。 每个人拆两个点 iii 和 i+ni+ni+n，分别表示这个人是好人和坏人的情况，统计答案的时候对每个集合的“帮主”是好人/坏人的情况下的好人的数量取最大值，加起来即可。 CF1685B Linguistics 贪心。 题意显然可以转化为把 aaa 个 A\\texttt{A}A、bbb 个 B\\texttt{B}B、ccc 个 AB\\texttt{A}\\texttt{B}AB 和 ddd 个 BA\\texttt{B}\\texttt{A}BA 不重叠地放进字符串 sss 中，使得对应位相等。 首先若放的 A\\texttt{\\texttt{A}}A、B\\texttt{B}B 的个数和 sss 中 A\\texttt{A}A、B\\texttt{B}B 的个数不同，那么就是不行的。接下来考虑让所有放单个 A\\texttt{A}A 和 B\\texttt{B}B 的操作都挪到最后进行，那么问题就转化为判断能否把 ccc 个 AB\\texttt{A}\\texttt{B}AB 和 ddd 个 BA\\texttt{B}\\texttt{A}BA 都放进 sss 里面。 考虑一段形如 ABABABAB\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}ABABABAB 这样 AB\\texttt{A}\\texttt{B}AB 相间的极长子串，设它的长度为 cntcntcnt，那么分类讨论： 若 cntcntcnt 是奇数，那么这一段可以放 ⌊cnt2⌋\\lfloor\\frac{cnt}{2}\\rfloor⌊2cnt​⌋ 个 AB\\texttt{A}\\texttt{B}AB 或 BA\\texttt{B}\\texttt{A}BA； 若 cntcntcnt 是偶数，那么： 若这一段以 B\\texttt{B}B 结尾，即形如 ABAB\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}ABAB，那么可以放 ⌊cnt2⌋−1\\lfloor\\frac{cnt}{2}\\rfloor-1⌊2cnt​⌋−1 个 AB\\texttt{A}\\texttt{B}AB 或 BA\\texttt{B}\\texttt{A}BA，或者可以放 ⌊cnt2⌋\\lfloor\\frac{cnt}{2}\\rfloor⌊2cnt​⌋ 个 AB\\texttt{A}\\texttt{B}AB； 若这一段以 A\\texttt{A}A 结尾，即形如 BABA\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{A}BABA，那么可以放 ⌊cnt2⌋−1\\lfloor\\frac{cnt}{2}\\rfloor-1⌊2cnt​⌋−1 个 AB\\texttt{A}\\texttt{B}AB 或 BA\\texttt{B}\\texttt{A}BA，或者可以放 ⌊cnt2⌋\\lfloor\\frac{cnt}{2}\\rfloor⌊2cnt​⌋ 个 BA\\texttt{B}\\texttt{A}BA； 不难发现，当 cntcntcnt 为奇数时这一段对 AB\\texttt{A}\\texttt{B}AB 和 BA\\texttt{B}\\texttt{A}BA 都是公平的，即它们放的上限都是 ⌊cnt2⌋\\lfloor\\frac{cnt}{2}\\rfloor⌊2cnt​⌋，并且对放多少个 AB\\texttt{A}\\texttt{B}AB 和多少个 BA\\texttt{B}\\texttt{A}BA 没有限制，只要它们数量加起来不超过 ⌊cnt2⌋\\lfloor\\frac{cnt}{2}\\rfloor⌊2cnt​⌋ 就可以了。 所以可以令 bot=∑cntmod⁡2=1⌊cnt2⌋bot=\\sum\\limits_{cnt\\operatorname{mod}2=1}\\lfloor\\frac{cnt}{2}\\rfloorbot=cntmod2=1∑​⌊2cnt​⌋ 即奇数段最多可以放的 AB\\texttt{A}\\texttt{B}AB 和 BA\\texttt{B}\\texttt{A}BA 的数量。 若 cntcntcnt 为偶数，那么这一段对 AB\\texttt{A}\\texttt{B}AB 和 BA\\texttt{B}\\texttt{A}BA 是不公平的，即它们放的上限一个多，一个少。为了减少位置的浪费，不妨先钦定这一段都放上限多的那种字符串，再用两个数组 valavalavala 和 valbvalbvalb 存偏心 AB\\texttt{A}\\texttt{B}AB 或者 BA\\texttt{B}\\texttt{A}BA 即能放更多 AB\\texttt{A}\\texttt{B}AB 或 BA\\texttt{B}\\texttt{A}BA 的偶数段中两种字符串放置的上限。 最后若每一段偶数段都放上限多的字符串时 ccc 或 ddd 还是大于 000，那么就让偏心另一种字符串的偶数段分一些位置放这种字符串即可。不难发现由于没分之前偶数段总共能放 ⌊cnt2⌋\\lfloor\\frac{cnt}{2}\\rfloor⌊2cnt​⌋ 个字符串，分了之后只能放 ⌊cnt2⌋−1\\lfloor\\frac{cnt}{2}\\rfloor-1⌊2cnt​⌋−1 个，所以分的段数肯定是越少越好。那么按段的长度从大到小分即可。 代码如下： // Problem: D. Linguistics // Contest: Codeforces Round #794 (Div. 2) // URL: https://codeforces.com/contest/1686/problem/D // Memory Limit: 256 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std; const int S=1919810; struct node { int x,y; }vala[S],valb[S]; int n,a,b,c,d; char str[S]; inline bool cmp(node x,node y) { return x.y&gt;y.y; } inline void slove() { cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;(str+1); n=strlen(str+1); int cnta=0,cntb=0; for(int i=1;i&lt;=n;i++) { cnta+=str[i]=='A'; cntb+=str[i]=='B'; } if(cnta-c-d!=a||cntb-c-d!=b) // A 或 B 的数量不符合的情况 { cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return; } int m1=0,m2=0,bot=0; str[n+1]=str[n]; for(int i=1,cnt=0;i&lt;=n+1;i++) { if(str[i]!=str[i-1]) { cnt++; } else { if(cnt&gt;1) { if(cnt&amp;1) // 公平的奇数段 { bot+=cnt/2; } else { if(str[i-1]=='B') { vala[++m1]=(node){cnt/2,cnt/2-1}; // 偏心 AB c-=cnt/2; } else { valb[++m2]=(node){cnt/2,cnt/2-1}; // 偏心 BA d-=cnt/2; } } } cnt=1; } } if(d&gt;0) { sort(vala+1,vala+m1+1,cmp); for(int i=1;i&lt;=m1;i++) { if(c+vala[i].x&lt;=0) { c+=vala[i].x; d-=vala[i].y; } else { int lft=vala[i].x+c; if(lft&gt;vala[i].y) { continue; } d-=vala[i].y-lft; c=0; } } } else { sort(valb+1,valb+m2+1,cmp); for(int i=1;i&lt;=m2;i++) { if(d+valb[i].x&lt;=0) { d+=valb[i].x; c-=valb[i].y; } else { int lft=valb[i].x+d; if(lft&gt;valb[i].y) { continue; } c-=valb[i].y-lft; d=0; } } } c=max(c,0); d=max(d,0); cout&lt;&lt;(c+d&lt;=bot?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl; } int main() { ios::sync_with_stdio(false); int _=1; cin&gt;&gt;_; while(_--) { slove(); } return 0; } ","tags":[{"name":"杂题选讲","slug":"xOzapvCGq","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOzapvCGq/"},{"name":2022,"slug":"GJvEuJsM-","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GJvEuJsM-/"}],"title":"2022 暑假杂题选讲","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022-shu-jia-za-ti-xuan-jiang/","stats":{"text":"17 min read","time":985000,"words":3465,"minutes":17},"date":"2023-03-25 21:56:01","dateFormat":"2023-03-25"},{"abstract":"","content":"有些时候，我们需要合并两棵动态开点线段树维护的信息，而一个个枚举插入又太慢了，这时就需要线段树合并的技巧。 假设现在要合并下图中蓝色的线段树和红色的线段树： 朴素的做法是一个一个叶节点插入，但是考虑同时在这两棵树上面 dfs： 两棵树的当前位置都有节点，所以继续往下递归： 两棵树的当前位置都有节点，继续往下递归： 发现蓝色线段树当前位置没有节点了，所以可以直接把红色线段树当前位置的节点拿来用，并回溯： 发现当前位置还没有递归处理完，往右递归： 发现红色线段树当前位置没有节点了，所以可以直接把蓝色线段树当前位置的节点拿来用，并回溯： 当前位置递归处理完了，新建一个节点来保存子树信息，并回溯： 发现当前位置还没有递归处理完，往右递归： 发现蓝色线段树当前位置没有节点了，所以可以直接把红色线段树当前位置的节点拿来用，并回溯： 当前位置递归处理完了，新建一个节点来保存子树信息，并回溯： 这样就完成了合并。 总结一下合并的规则： 同时在这两棵线段树上面 dfs； 若当前位置是叶节点，新建一个节点保存合并的信息，并回溯； 若两棵树的当前位置都有节点，继续往下递归； 若有一棵树当前位置没有节点了，直接把另一棵树当前位置的节点拿来用，并回溯； 当前位置递归处理完后，新建一个节点来保存子树信息，并回溯。 其中除了第二条，其它在图示里面都见过。第二条也很好理解，因为叶节点无需也没法继续递归下去。 将共有 nnn 个叶子节点的任意多棵线段树以任意顺序合并的时间复杂度是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。证明如下： 不难发现，每次 dfs 合并两个节点可以看成丢掉一个节点，由于总共只有 nlog⁡nn\\log nnlogn 个节点，所以时间复杂度就是 O(nlog⁡n)O(n\\log n)O(nlogn) 的。 具体代码实现如下： struct node { int lson,rson; int val; }tree[500005]; int cnt; // 节点数量（用于动态开点） int meg(int x,int y) { if(x==0||y==0) return x+y; if(tree[x].lson==0&amp;&amp;tree[x].rson==0) { int res=++cnt; tree[res]=tree[x]; tree[res].val+=tree[y].val; return res; } else { int res=++cnt; tree[res].lson=meg(tree[x].lson,tree[y].lson); tree[res].rson=meg(tree[x].rson,tree[y].rson); upd(res); return res; } } 有些时候空间卡得紧，我们在合并的时候可以不新建节点，代价是破坏某棵线段树的结构： struct node { int lson,rson; int val; }tree[500005]; int cnt; // 节点数量（用于动态开点） int meg(int x,int y) { if(x==0||y==0) return x+y; if(tree[x].lson==0&amp;&amp;tree[x].rson==0) { tree[x].val+=tree[y].val; return x; } else { tree[x].lson=meg(tree[x].lson,tree[y].lson); tree[x].rson=meg(tree[x].rson,tree[y].rson); upd(x); return x; } } 练习题目 P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并 ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"线段树合并学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/xian-duan-shu-he-bing-xue-xi-bi-ji/","stats":{"text":"4 min read","time":202000,"words":858,"minutes":4},"date":"2023-03-25 21:51:55","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>给定一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>，求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个节点的<strong>有标号有根树</strong>的个数，满足这棵树的<strong>先序遍历结果是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span></strong>。先序遍历定义如下：对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 的子树，先输出 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span>，然后<strong>按照编号从小到大</strong>遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">u</span></span></span></span> 的孩子。答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 500</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个 nnn 的排列 ppp，求 nnn 个节点的有标号有根树的个数，满足这棵树的先序遍历结果是 ppp。先序遍历定义如下：对于 uuu 的子树，先输出 uuu，然后按照编号从小到大遍历 uuu 的孩子。答案对 998244353998244353998244353 取模，1≤n≤5001\\le n\\le 5001≤n≤500。 赛时开题开错顺序了，应该先做这道题再做 F 的…… 可以设 dpl,rdp_{l,r}dpl,r​ 表示 [l,r][l,r][l,r] 构成一棵树的方案数，pdl,rpd_{l,r}pdl,r​ 表示 [l,r][l,r][l,r] 构成森林的方案数，那么森林可以通过森林加一棵树来转移，树可以通过一个点下面连森林来转移。 初始状态是 dpl,l=1dp_{l,l}=1dpl,l​=1，pdl,l=1pd_{l,l}=1pdl,l​=1，pdl+1,l=1pd_{l+1,l}=1pdl+1,l​=1。前两个很好理解，最后一个则是因为森林可以为空，方便森林包含树的情况。 转移如下： dpl,r=pdl+1,rdp_{l,r}=pd_{l+1,r}dpl,r​=pdl+1,r​ pdl,r=∑k=lr[pl&lt;pk+1∨k=r]×dpl,k×pdk+1,rpd_{l,r}=\\sum\\limits_{k=l}^r [p_l&lt;p_{k+1}\\lor k=r]\\times dp_{l,k}\\times pd_{k+1,r}pdl,r​=k=l∑r​[pl​&lt;pk+1​∨k=r]×dpl,k​×pdk+1,r​ 最后答案即为 dpl,rdp_{l,r}dpl,r​。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"ABC252G Pre-Order 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/abc252g-pre-order-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":93000,"words":338,"minutes":2},"date":"2023-03-25 21:43:31","dateFormat":"2023-03-25"},{"abstract":"","content":"Day -3 停课了，PKUSC 和 THUSC 的审核都过了，晚上纠结了一下还是选了 PKUSC。 Day -2 早上打了场模拟赛，听说是 PKU 的真题，结果 T2 数据锅了，T3 没数据 /hanx 赛后发现 T1 是神仙题/ll 晚上有 CF，B 读题没读到 A&lt;B&lt;CA&lt;B&lt;CA&lt;B&lt;C 分讨了 1h，做 C 的时候太紧张了写的很复杂导致了 FST…… 还好 D 想到了贪心才没掉青。 Day -1 早上继续打模拟赛，仍然似乎是 PKU 的真题，T1 是二分模板，T2 写了暴力，T3 写了个最小割树。 赛后看题解发现 T2 是线段树套线段树合并？ 毒瘤。 Day 1 早上试机社死了 /hanx 中午第一次在上学期间出学校吃饭。 T1 题意是两个 CF 号，每次打 rating 最少的那个，有 wiw_iwi​ 概率上 iii 分（i∈[−m,m]i\\in[-m,m]i∈[−m,m]），问 rating 最高的那个号至少有 nnn rating 期望打多少场。1≤n≤103,1≤m≤501\\le n\\le 10^3,1\\le m\\le 501≤n≤103,1≤m≤50。 推了 1.5h，发现可以设 dpi,jdp_{i,j}dpi,j​ 为 rating 最高的号 rating 为 iii，另一个号为 jjj 的期望，然后行之间没有后效性，所以只需要在一行之内消元。线性消元的话可以 O(n2m)O(n^2m)O(n2m)。 后来想了 0.5h 消元的办法，结果没想出来。发现时间有点不太够于是去骗 T2 的部分分。 赛后发现我的做法没错……如果再想最多 0.5h 就能 A…… T2 题意是给 nnn 条 xxx 单调递增，yyy 单调递减的线段 ((a,b),(c,d))((a,b),(c,d))((a,b),(c,d))，即满足 a&lt;c,b&gt;da&lt;c,b&gt;da&lt;c,b&gt;d。然后 qqq 次询问左下角为 (−inf,−inf)(-inf,-inf)(−inf,−inf)，右上角为 (x,y)(x,y)(x,y) 的矩形内线段的长度。1≤n,q≤3×1051\\le n,q\\le 3\\times10^51≤n,q≤3×105。 这道题是用丰厚的 O(n2)O(n^2)O(n2) 部分分吸引我来骗的。 但是用一次函数解析式一直出精度问题，怒调 1.5h/ll 赛后才知道有简洁且精度损失更低的相似三角形解法…… T3 没看。 最后的 0.5h 手推 T1 的暴力高斯消元，结果没推完/dk 得分：0+0+0=00+0+0=00+0+0=0。 心态有毒…… ","tags":[{"name":"PKU","slug":"Jt9rN7EEz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Jt9rN7EEz/"},{"name":2022,"slug":"GJvEuJsM-","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GJvEuJsM-/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"}],"title":"PKUSC 2022 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/pkusc-2022-you-ji/","stats":{"text":"3 min read","time":156000,"words":616,"minutes":3},"date":"2023-03-25 21:35:58","dateFormat":"2023-03-25"},{"abstract":"","content":"启发式合并是一种神奇的暴力，它经常用于合并两个只能一个个元素插入的集合。 假设我们要合并两个集合 SSS 和 TTT，那么显然小的集合里元素一个个插入大的集合是更优的。所以启发式合并就是将小集合中元素插入大集合来合并。 这样做看起来很暴力，但因为一个元素 uuu 所属的集合比另一个集合小的话 uuu 才会被枚举插入，所以 uuu 被枚举插入集合一次以后，它所在的集合大小至少翻倍。 所以启发式合并的时间复杂度是 O(tnlog⁡n)O(tn\\log n)O(tnlogn) 的，其中 ttt 是插入集合的时间复杂度。 练习题目 P3302 [SDOI2013] 森林 P3201 [HNOI2009] 梦幻布丁 ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"启发式合并学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/qi-fa-shi-he-bing-xue-xi-bi-ji/","stats":{"text":"1 min read","time":45000,"words":213,"minutes":1},"date":"2023-03-25 21:34:38","dateFormat":"2023-03-25"},{"abstract":"","content":"首先不难发现一条路径可以分成深度递减的一段和深度递增的一段： 为了方便下文描述，我们称深度递减的那一段为”上升链“，深度递增的那一段为”下降链“。 不难发现，对于路径 a→ba\\to ba→b，若 aaa 和 bbb 不是子孙关系，那么它的上升链为 a→lca⁡(a,b)a\\to \\operatorname{lca}(a,b)a→lca(a,b)，下降链为 lca⁡(a,b)→b\\operatorname{lca}(a,b) \\to blca(a,b)→b，否则就只有上升链或下降链 a→ba\\to ba→b。 那么考虑对上升链和下降链分别计算答案，最后加起来：（定义 depudep_udepu​ 为节点 uuu 的深度） 对于上升链： 因为起点为 vvv 的上升链能被 uuu 观察到当且仅当 depv−depu=wudep_v-dep_u=w_udepv​−depu​=wu​，移项得 depv=wu+depudep_v=w_u+dep_udepv​=wu​+depu​； 所以可以在 dfs 的同时用 cnticnt_icnti​ 表示满足 depv=idep_v=idepv​=i 且这条上升链经过 uuu 的上升链的起点 vvv 的个数； 那么上升链对 uuu 的贡献即为 cntwu+depucnt_{w_u+dep_u}cntwu​+depu​​。 对于下降链： 令 stmevstme_vstmev​ 表示这条下降链的开始时间，因为一个人要跑完上升链才会去跑下降链； 因为起点为 vvv 的下降链能被 uuu 观察到当且仅当 depu−depv=wu−stmevdep_u-dep_v=w_u-stme_vdepu​−depv​=wu​−stmev​，移项得 stmev−depv=wu−depustme_v-dep_v=w_u-dep_ustmev​−depv​=wu​−depu​； 所以可以在 dfs 的同时用 cnt2icnt2_icnt2i​ 表示满足 stmev−depv=istme_v-dep_v=istmev​−depv​=i 且这条下降链经过 uuu 的下降链的起点 vvv 的个数； 那么下降链对 uuu 的贡献即为 cnt2wu−depucnt2_{w_u-dep_u}cnt2wu​−depu​​ 但是有个问题就是路径 a→ba\\to ba→b 的 lca⁡(a,b)\\operatorname{lca}(a,b)lca(a,b) 可能会被计算两次，所以若 a→ba\\to ba→b 既有上升链又有下降链我们就要规定 lca⁡(a,b)\\operatorname{lca}(a,b)lca(a,b) 包含且仅包含在上升链中。 还有一个问题就是 cnt2cnt2cnt2 的下标可能是负数，那么让下标整体加上一个大整数即可。 计算答案的过程还有一个细节，为了防止其它子树的贡献影响到 uuu 的子树，所以需要这样写： void dfs2(int u,int fa) { int tmp=cnt[w[u]+dep[u]],tmp2=cnt2[w[u]-dep[u]+mov]; // 记录下其它子树的贡献 for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs2(v,u); } for(int val:st[0][u]) { cnt[val]++; } for(int val:st[1][u]) { cnt[val]--; } for(int val:st2[0][u]) { cnt2[val+mov]++; } for(int val:st2[1][u]) { cnt2[val+mov]--; } ans[u]=cnt[w[u]+dep[u]]-tmp+cnt2[w[u]-dep[u]+mov]-tmp2; // 容斥获得 u 子树的贡献 } ","tags":[{"name":"杂题","slug":"IgZHugXcl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/IgZHugXcl/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"P1600 [NOIP2016 提高组] 天天爱跑步 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p1600-noip2016-ti-gao-zu-tian-tian-ai-pao-bu-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":175000,"words":674,"minutes":3},"date":"2023-03-25 20:58:32","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>给定一棵树，多组询问，每次询问给定四个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo separator=\"true\">,</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">a,b,c,d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span>，求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mo>→</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">c\\to d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">d</span></span></span></span> 这两条路径是否有交。</p>\n</blockquote>\n","content":" 给定一棵树，多组询问，每次询问给定四个点 a,b,c,da,b,c,da,b,c,d，求 a→ba\\to ba→b 和 c→dc\\to dc→d 这两条路径是否有交。 有个结论：若树上两条路径 a→ba\\to ba→b 和 c→dc\\to dc→d 有交，那么令 lca⁡(a,b)=x,lca⁡(c,d)=y\\operatorname{lca}(a,b)=x,\\operatorname{lca}(c,d)=ylca(a,b)=x,lca(c,d)=y，要么 xxx 在 c→dc\\to dc→d 上，要么 yyy 在 a→ba\\to ba→b 上。 证明如下： 把 a,b,xa,b,xa,b,x 画出来：（写文章时图论编辑器上不去……） 容易发现，xxx 把它的子树“堵住”了，想要进去就必须经过它。但 a→ba\\to ba→b 肯定在 xxx 的子树内，所以子树外面的链想和 a→ba\\to ba→b 相交就一定要经过 xxx。 还有一种可能就是 c→dc\\to dc→d 在 xxx 的子树内，不难发现此时的情况相当于把 a→ba\\to ba→b 和 c→dc\\to dc→d 这两条路径交换。 综上，得证。 所以根据结论判断即可。判断一个节点是否在链上可以用这个节点到链两端的长度是否等于链的长度来做。 ","tags":[{"name":"结论","slug":"qErN0WkdA","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/qErN0WkdA/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"P3398 仓鼠找 sugar 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p3398-cang-shu-zhao-sugar-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":79000,"words":308,"minutes":2},"date":"2023-03-25 20:10:44","dateFormat":"2023-03-25"},{"abstract":"","content":"这篇学习笔记整理了一些小技巧。 树上差分 假设要让 a→ba\\to ba→b 的路径上的点都加上一个权值，那么可以通过维护每个节点到根的权值和 sis_isi​，每次询问就在 sas_asa​ 和 sbs_bsb​ 都加上权值，slca⁡(a,b)s_{\\operatorname{lca}(a,b)}slca(a,b)​ 和 sfa⁡(lca⁡(a,b))s_{\\operatorname{fa}(\\operatorname{lca}(a,b))}sfa(lca(a,b))​ 减掉权值，最后 dfs 计算一遍即可。 这个技巧有诸多变形，可以通过练习题深入学习。 练习题目 P3128 [USACO15DEC]Max Flow P P3258 [JLOI2014]松鼠的新家 P8201 生活在树上（hard version） P1600 [NOIP2016 提高组] 天天爱跑步 两条路径的交 有个结论：若树上两条路径 a→ba\\to ba→b 和 c→dc\\to dc→d 有交，那么令 lca⁡(a,b)=x,lca⁡(c,d)=y\\operatorname{lca}(a,b)=x,\\operatorname{lca}(c,d)=ylca(a,b)=x,lca(c,d)=y，要么 xxx 在 c→dc\\to dc→d 上，要么 yyy 在 a→ba\\to ba→b 上。 证明如下： 把 a,b,xa,b,xa,b,x 画出来：（写文章时图论编辑器上不去……） 容易发现，xxx 把它的子树“堵住”了，想要进去就必须经过它。但 a→ba\\to ba→b 肯定在 xxx 的子树内，所以子树外面的链想和 a→ba\\to ba→b 相交就一定要经过 xxx。 还有一种可能就是 c→dc\\to dc→d 在 xxx 的子树内，不难发现此时的情况相当于把 a→ba\\to ba→b 和 c→dc\\to dc→d 这两条路径交换。 综上，得证。 练习题目 P3398 仓鼠找 sugar ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"一些树上问题的小技巧","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/yi-xie-shu-shang-wen-ti-de-xiao-ji-qiao/","stats":{"text":"2 min read","time":102000,"words":396,"minutes":2},"date":"2023-03-25 19:58:42","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">1\\le i\\le 7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span>），每次从所有未选的数中等概率随机选出一个，接在最后面，求连续 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 个互不相同的数的组数的期望。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\sum a_i\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有 aia_iai​ 个 iii（1≤i≤71\\le i\\le 71≤i≤7），每次从所有未选的数中等概率随机选出一个，接在最后面，求连续 777 个互不相同的数的组数的期望。 1≤ai≤1091\\le a_i\\le 10^91≤ai​≤109，∑ai≤109\\sum a_i\\le 10^9∑ai​≤109。 看了一下题解才会…… 首先设 S=∑i=17aiS=\\sum\\limits_{i=1}^7a_iS=i=1∑7​ai​，那么前 777 次施法按顺序触发技能的概率为： a1S×a2S−1×a3S−2×a4S−3×a5S−4×a6S−5×a7S−6\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}Sa1​​×S−1a2​​×S−2a3​​×S−3a4​​×S−4a5​​×S−5a6​​×S−6a7​​ 不过顺序是不重要的，因为从 SSS 个元素中选 777 个不同的元素的概率是一样的。 所以前 777 次施法触发技能的概率为： 7!×a1S×a2S−1×a3S−2×a4S−3×a5S−4×a6S−5×a7S−67!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}7!×Sa1​​×S−1a2​​×S−2a3​​×S−3a4​​×S−4a5​​×S−5a6​​×S−6a7​​ 考虑前 777 次触发技能后的第 888 次施法，可以枚举第一次施的魔法类型，那么第 888 次施法也触发技能的概率为： 7!×a1S×a2S−1×a3S−2×a4S−3×a5S−4×a6S−5×a7S−6×∑i=17ai−1S−77!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}\\times\\sum\\limits_{i=1}^7\\dfrac{a_i-1}{S-7}7!×Sa1​​×S−1a2​​×S−2a3​​×S−3a4​​×S−4a5​​×S−5a6​​×S−6a7​​×i=1∑7​S−7ai​−1​ 容易发现最后那个求和的值为 111，也就是说概率不变。 那么答案即为： (S−6)×7!×a1S×a2S−1×a3S−2×a4S−3×a5S−4×a6S−5×a7S−6(S-6)\\times7!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}(S−6)×7!×Sa1​​×S−1a2​​×S−2a3​​×S−3a4​​×S−4a5​​×S−5a6​​×S−6a7​​ 也就是： 7!×a1S×a2S−1×a3S−2×a4S−3×a5S−4×a6S−5×a77!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times a_77!×Sa1​​×S−1a2​​×S−2a3​​×S−3a4​​×S−4a5​​×S−5a6​​×a7​ ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P3802 小魔女帕琪 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p3802-xiao-mo-nu-pa-qi-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":179000,"words":566,"minutes":3},"date":"2023-03-25 16:45:49","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>求字典序第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 小的对任意一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2\\le i\\le n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>&gt;</mo><msub><mi>p</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">p_{i-1}&gt;p_i&lt;p_{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.747431em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 或 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>&lt;</mo><msub><mi>p</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">p_{i-1}&lt;p_i&gt;p_{i+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.747431em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>20</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mtext>满足条件的排列数量</mtext></mrow><annotation encoding=\"application/x-tex\">1\\le n\\le 20,1\\le k\\le \\text{满足条件的排列数量}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">满足条件的排列数量</span></span></span></span></span></p>\n</blockquote>\n","content":" 求字典序第 kkk 小的对任意一个 2≤i≤n−12\\le i\\le n-12≤i≤n−1 的 iii 满足 pi−1&gt;pi&lt;pi−1p_{i-1}&gt;p_i&lt;p_{i-1}pi−1​&gt;pi​&lt;pi−1​ 或 pi−1&lt;pi&gt;pi+1p_{i-1}&lt;p_i&gt;p_{i+1}pi−1​&lt;pi​&gt;pi+1​ 的 nnn 的排列 ppp。1≤n≤20,1≤k≤满足条件的排列数量1\\le n\\le 20,1\\le k\\le \\text{满足条件的排列数量}1≤n≤20,1≤k≤满足条件的排列数量 考虑是先上后下还是先下后上，设 dpn,idp_{n,i}dpn,i​ 为先上后下，长度为 nnn，p1=ip_1=ip1​=i 的方案数；pdn,ipd_{n,i}pdn,i​ 为先下后上，长度为 nnn，p1=ip_1=ip1​=i 的方案数。 那么有转移： dpn,i=∑j=in−1pdn−1,jdp_{n,i}=\\sum\\limits_{j=i}^{n-1}pd_{n-1,j}dpn,i​=j=i∑n−1​pdn−1,j​ pdn,i=∑j=1i−1dpn−1,jpd_{n,i}=\\sum\\limits_{j=1}^{i-1}dp_{n-1,j}pdn,i​=j=1∑i−1​dpn−1,j​ 即考虑在前面插入数 iii。 考虑构造答案，显然若 p1p_1p1​ 相同，那么先下后上是更优的。 那么从前往后考虑构造答案即可，不过构造时要注意编号的变换。 记得开 long long。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P7690 [CEOI2002] A decorative fence 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p7690-ceoi2002-a-decorative-fence-zuo-ti-ji-lu/","stats":{"text":"2 min read","time":90000,"words":312,"minutes":2},"date":"2023-03-25 16:44:51","dateFormat":"2023-03-25"},{"abstract":"<blockquote>\n<p>给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，同时你有一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">b_i=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span>，设 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>o</mi><mi>p</mi><mo>=</mo><mo>{</mo><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo><mi mathvariant=\"normal\">∣</mi><mn>1</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>x</mi><mi mathvariant=\"normal\">≠</mi><mi>y</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">op=\\{(x,y)|1\\le x&lt;y\\le n,x\\neq y\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}</span></span></span></span>。你需要重新排列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 的元素，满足依次交换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><msub><mi>x</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">b_{x_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9445399999999999em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><msub><mi>y</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">b_{y_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 后有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b=a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">2\\le n\\le 10^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长度为 nnn 的排列 aaa，同时你有一个长度为 nnn 的排列 bi=ib_i=ibi​=i，设 op={(x,y)∣1≤x&lt;y≤n,x≠y}op=\\{(x,y)|1\\le x&lt;y\\le n,x\\neq y\\}op={(x,y)∣1≤x&lt;y≤n,x​=y}。你需要重新排列 bbb 的元素，满足依次交换 bxib_{x_i}bxi​​ 和 byib_{y_i}byi​​ 后有 b=ab=ab=a。 2≤n≤1032\\le n\\le 10^32≤n≤103。 首先有一个结论，交换 bxb_xbx​ 和 byb_yby​（x≠yx\\neq yx​=y）后一定会改变 bbb 的逆序对个数的奇偶性，证明： i&lt;xi&lt;xi&lt;x 和 i&gt;yi&gt;yi&gt;y 的 iii 参与构成的逆序对显然没有影响； x&lt;i&lt;yx&lt;i&lt;yx&lt;i&lt;y 的 iii： 设有 sxsxsx 个 bib_ibi​ 满足 x&lt;i&lt;yx&lt;i&lt;yx&lt;i&lt;y 且 bi&lt;bxb_i&lt;b_xbi​&lt;bx​，有 bxbxbx 个 bib_ibi​ 满足 x&lt;i&lt;yx&lt;i&lt;yx&lt;i&lt;y 且 bi&gt;bxb_i&gt;b_xbi​&gt;bx​； 有 sysysy 个 bib_ibi​ 满足 x&lt;i&lt;yx&lt;i&lt;yx&lt;i&lt;y 且 bi&lt;byb_i&lt;b_ybi​&lt;by​，有 bybyby 个 bib_ibi​ 满足 x&lt;i&lt;yx&lt;i&lt;yx&lt;i&lt;y 且 bi&gt;byb_i&gt;b_ybi​&gt;by​； 那么交换之前 [x,y][x,y][x,y] 中的逆序对个数显然是 bx+sy+[bx&gt;by]bx+sy+[b_x&gt;b_y]bx+sy+[bx​&gt;by​]，交换之后是 sx+by+[bx&lt;by]sx+by+[b_x&lt;b_y]sx+by+[bx​&lt;by​]，由于 sx+bx=sy+bysx+bx=sy+bysx+bx=sy+by 所以 bx+sybx+sybx+sy 和 sx+bysx+bysx+by 奇偶性一样，而 [bx&gt;by]≠[bx&lt;by][b_x&gt;b_y]\\neq [b_x&lt;b_y][bx​&gt;by​]​=[bx​&lt;by​]，所以逆序对个数的奇偶性一定会被改变。 那么 aaa 的逆序对个数的奇偶性和 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​ 的奇偶性不一样则无解，接下来考虑通过构造来证明其他情况一定有解。 考虑先把所有 bi≠aib_i\\neq a_ibi​​=ai​ 的 iii 通过不断交换满足 bj≠aib_j\\neq a_ibj​​=ai​ 的 bib_ibi​ 和 bjb_jbj​，最后再交换满足 bj=aib_j=a_ibj​=ai​ 的 bib_ibi​ 和 bjb_jbj​，这样就可以消掉 iii，把问题转化为大小为 n−1n-1n−1 的子问题。 那么现在问题就变成了要让进行完所有交换之后 bi=ib_i=ibi​=i。 不难发现，由于逆序对个数（000）和 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​ 的奇偶性相同，那么此时的 nnn 一定满足 nmod⁡4∈{0,1}n\\operatorname{mod} 4\\in\\{0,1\\}nmod4∈{0,1}，所以考虑不断消掉四个位置来把问题转化为 n−4n-4n−4 的子问题。 考虑这样的过程，其中 ststst 是剩下的位置（不包含 xxx 和 yyy）： inline void slove(int x,int y) { auto p=st.begin(); while(p!=st.end()) swp(x,*p++); swp(x,y); p=st.end(); while(p!=st.begin()) swp(y,*--p); } 不难发现这样就可以把 xxx 和 yyy 消掉且交换 bxb_xbx​ 和 byb_yby​，那么考虑四个位置 x,y,z,wx,y,z,wx,y,z,w，可以这样把它们消掉： st.erase(x); st.erase(y); st.erase(z); st.erase(w); slove(x,y); slove(z,w); swp(x,z),swp(y,w); swp(x,w),swp(y,z); 那么不断执行以上操作，直到 n≤1n\\le 1n≤1 即可。 时间复杂度 O(n2)O(n^2)O(n2)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; using namespace std; const int S=1005; struct node { int x,y; }ans[S*S]; int n,a[S],b[S]; int tr[S]; int tot; set&lt;int&gt; st; inline void add(int pos,int x) { for(int i=pos;i&lt;=n;i+=i&amp;-i) tr[i]+=x; } inline int que(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=tr[i]; return res; } inline void swp(int x,int y) { swap(b[x],b[y]); ans[++tot]=(node){min(x,y),max(x,y)}; } inline void slove(int x,int y) { auto p=st.begin(); while(p!=st.end()) swp(x,*p++); swp(x,y); p=st.end(); while(p!=st.begin()) swp(y,*--p); } int main() { freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); freopen(&quot;c.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=i; int tmp=n*(n-1)/2&amp;1; for(int i=n;i&gt;=1;i--) tmp^=que(a[i])&amp;1,add(a[i],1); if(tmp!=0) return puts(&quot;NO&quot;),0; else puts(&quot;YES&quot;); for(int i=1;i&lt;=n;i++) st.insert(i); while(1) { int pos=-1; for(int i=1;i&lt;=n;i++) if(b[i]!=a[i]) pos=i; if(pos==-1) break; for(int i=1;i&lt;=n;i++) if(i!=pos&amp;&amp;b[i]!=a[pos]&amp;&amp;st.count(i)) swp(pos,i); for(int i=1;i&lt;=n;i++) { if(b[i]==a[pos]) { swp(pos,i); break; } } st.erase(pos); } while(st.size()&gt;=4) { int x=*st.begin();st.erase(x); int y=*st.begin();st.erase(y); int z=*st.begin();st.erase(z); int w=*st.begin();st.erase(w); slove(x,y); slove(z,w); swp(x,z),swp(y,w); swp(x,w),swp(y,z); } for(int i=1;i&lt;=tot;i++) printf(&quot;%d %d\\n&quot;,ans[i].x,ans[i].y); return 0; } ","tags":[{"name":"构造","slug":"Kb6MJqy9f","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Kb6MJqy9f/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"【2023NOI模拟赛15】不见不散 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2023noi-mo-ni-sai-15-bu-jian-bu-san-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":378000,"words":1192,"minutes":7},"date":"2023-03-24 19:23:58","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>在无向连通图中，若一条边被删除后，图会分成不连通的两部分，则称该边为割边。</p>\n<p>求满足如下条件的无向连通图的数量：</p>\n<ol>\n<li>由 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个结点构成，结点有标号。</li>\n<li>割边不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条。</li>\n<li>没有重边和自环。</li>\n</ol>\n<p>答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^{9}+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50</mn><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">2≤n≤50,0≤m≤\\dfrac{n(n-1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></p>\n</blockquote>\n","content":" 在无向连通图中，若一条边被删除后，图会分成不连通的两部分，则称该边为割边。 求满足如下条件的无向连通图的数量： 由 nnn 个结点构成，结点有标号。 割边不超过 mmm 条。 没有重边和自环。 答案对 109+710^{9}+7109+7 取模。 2≤n≤50,0≤m≤n(n−1)22≤n≤50,0≤m≤\\dfrac{n(n-1)}{2}2≤n≤50,0≤m≤2n(n−1)​ 设 dpn,mdp_{n,m}dpn,m​ 表示 nnn 个点，mmm 条割边的连通有标号无向图的数量，那么可以考虑枚举 nnn 所在的强连通分量来转移。 发现直接转移不好转，所以加一个辅助数组 pdn,m,kpd_{n,m,k}pdn,m,k​ 表示 nnn 个点，mmm 条割边，kkk 个连通块的有标号无向图的数量，那么 dpn,mdp_{n,m}dpn,m​ 的转移就可以枚举 nnn 所在的强连通分量，然后和其它的连通块都连一条边。显然和其它连通块的每条连边都可以贡献一条割边。 那么有转移： dpn,m=∑i=1n−1(n−1i−1)dpi,0∑j=1min⁡(n−i,m)pdn−i,m−j,j×ijdp_{n,m}=\\sum\\limits_{i=1}^{n-1}\\dbinom{n-1}{i-1}dp_{i,0}\\sum\\limits_{j=1}^{\\min(n-i,m)}pd_{n-i,m-j,j}\\times i^j dpn,m​=i=1∑n−1​(i−1n−1​)dpi,0​j=1∑min(n−i,m)​pdn−i,m−j,j​×ij 最后那个 iji^jij 表示从 nnn 所在的强连通分量连向 jjj 个连通块的方案数，注意在这里我们把这 jjj 个连通块的大小当成了 111。 接下来考虑 pdn,m,kpd_{n,m,k}pdn,m,k​ 的转移，可以枚举 nnn 所在的连通块，然后枚举这个连通块里的割边数量： pdn,m,k=∑i=1n∑j=0m(n−1i−1)dpi,j×pdn−i,m−j,k−1×ipd_{n,m,k}=\\sum\\limits_{i=1}^n\\sum\\limits_{j=0}^m\\dbinom{n-1}{i-1}dp_{i,j}\\times pd_{n-i,m-j,k-1}\\times i pdn,m,k​=i=1∑n​j=0∑m​(i−1n−1​)dpi,j​×pdn−i,m−j,k−1​×i 最后的 ×i\\times i×i 是因为之前在转移 dpdpdp 时我们把连通块大小当成了 111。 不过还有个问题，dpn,0dp_{n,0}dpn,0​ 无法转移，所以需要计算出所有有标号无向连通图的数量再减去有割边的有标号无向连通图的数量，即设 cntucnt_ucntu​ 为有标号无向连通图的数量，那么 dpn,0=cntu−∑i=1n−1dpu,idp_{n,0}=cnt_u-\\sum\\limits_{i=1}^{n-1}dp_{u,i}dpn,0​=cntu​−i=1∑n−1​dpu,i​。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P6596 How Many of Them 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p6596-how-many-of-them-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":175000,"words":646,"minutes":3},"date":"2023-03-24 16:35:49","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>一天，他问了小 H 和小 W 这样一个问题：</p>\n<p>如果在一个圆上有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个不同的点，依次标号为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，有多少种方案能把它们连成一棵树？</p>\n<p>小 H &amp; 小 W：这不是sb题吗？</p>\n<p>小 L：那如果<strong>连边不能相交</strong>呢？</p>\n<p>小 H &amp; 小 W：这不是sb题吗？</p>\n<p>小 L：那如果把「树」换成「图」呢呢？</p>\n<p>小 H &amp; 小 W：这不是sb题吗？</p>\n<p>小 L：那如果给每个点一个权值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，连接 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的边权值为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>×</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i\\times a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，求<strong>满足上面</strong>的图的<strong>期望所有边权值之和</strong>呢？</p>\n<p>小 H &amp; 小 W：这不是sb题吗？</p>\n<p>小 L 见自己辛苦做了许久都没写出的题目被 dalao 轻松秒杀后十分郁闷。为了安慰他，你需要帮他做出这个问题。</p>\n<p><strong>注意</strong></p>\n<ol>\n<li>两条边在端点处<strong>不视作相交</strong>。</li>\n<li><strong>没有边的图（即只有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点，之间没有边相连）也合法</strong></li>\n<li>点<strong>按顺时针从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span></strong> 编号。</li>\n<li>图中<strong>不能有自环和重边</strong></li>\n</ol>\n</blockquote>\n","content":" 一天，他问了小 H 和小 W 这样一个问题： 如果在一个圆上有 nnn 个不同的点，依次标号为 111 到 nnn，有多少种方案能把它们连成一棵树？ 小 H &amp; 小 W：这不是sb题吗？ 小 L：那如果连边不能相交呢？ 小 H &amp; 小 W：这不是sb题吗？ 小 L：那如果把「树」换成「图」呢呢？ 小 H &amp; 小 W：这不是sb题吗？ 小 L：那如果给每个点一个权值 aia_iai​，连接 (i,j)(i,j)(i,j) 的边权值为 ai×aja_i\\times a_jai​×aj​，求满足上面的图的期望所有边权值之和呢？ 小 H &amp; 小 W：这不是sb题吗？ 小 L 见自己辛苦做了许久都没写出的题目被 dalao 轻松秒杀后十分郁闷。为了安慰他，你需要帮他做出这个问题。 注意 两条边在端点处不视作相交。 没有边的图（即只有 nnn 个点，之间没有边相连）也合法 点按顺时针从 111 到 nnn 编号。 图中不能有自环和重边 设 fif_ifi​ 表示有 iii 个点的方案，gig_igi​ 表示 iii 个点并且 111 和 iii 之间有连边的方案。显然 fi=2gif_i=2g_ifi​=2gi​ 因为在 fif_ifi​ 里 111 和 iii 之间那一条边可以连也可以不连。那么答案就是： ∑i=1n∑j=i+1naiajgj−i+1gn−j+i+1fn\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n a_ia_j\\dfrac{g_{j-i+1}g_{n-j+i+1}}{f_n}i=1∑n​j=i+1∑n​ai​aj​fn​gj−i+1​gn−j+i+1​​ =∑i=1n∑j=i+1naiajfj−i+1fn−j+i+14fn=\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n a_ia_j\\dfrac{f_{j-i+1}f_{n-j+i+1}}{4f_n}=i=1∑n​j=i+1∑n​ai​aj​4fn​fj−i+1​fn−j+i+1​​ =∑i=1n∑j=i+1naiajfj−i+1fn−j+i+14fn=\\dfrac{\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n a_ia_jf_{j-i+1}f_{n-j+i+1}}{4f_n}=4fn​i=1∑n​j=i+1∑n​ai​aj​fj−i+1​fn−j+i+1​​ 令 ti=fi+2fn−it_i=f_{i+2}f_{n-i}ti​=fi+2​fn−i​，那么： =∑j=1naj∑i=1j−1aitj−1−i4fn=\\dfrac{\\sum\\limits_{j=1}^na_j\\sum\\limits_{i=1}^{j-1} a_it_{j-1-i}}{4f_n}=4fn​j=1∑n​aj​i=1∑j−1​ai​tj−1−i​​ 注意到 a0=0a_0=0a0​=0，那么： =∑j=1naj∑i=0j−1aitj−1−i4fn=\\dfrac{\\sum\\limits_{j=1}^na_j\\sum\\limits_{i=0}^{j-1} a_it_{j-1-i}}{4f_n}=4fn​j=1∑n​aj​i=0∑j−1​ai​tj−1−i​​ 是个卷积的形式，不难求。重点就变成了怎么求 fff，显然边界是 f1=1f_1=1f1​=1。 假设当前知道了 f1…i−1f_{1\\dots i-1}f1…i−1​，要求 fif_ifi​，那么令 jjj 表示 iii 连到的最小编号的点，不难发现 iii 到 jjj 这条边把图分成了两个相对独立的部分，所以： fi=fi−1+∑j=1i−1gi−j+1fjf_{i}=f_{i-1}+\\sum\\limits_{j=1}^{i-1}g_{i-j+1}f_jfi​=fi−1​+j=1∑i−1​gi−j+1​fj​ （注意这里是 gi−j+1fjg_{i-j+1}f_{j}gi−j+1​fj​ 因为另一部分不能包含 iii） =fi−1+∑j=1i−1fi−j+1fj2=f_{i-1}+\\dfrac{\\sum\\limits_{j=1}^{i-1}f_{i-j+1}f_j}{2}=fi−1​+2j=1∑i−1​fi−j+1​fj​​ =2fi−1+∑j=2i−1fi−j+1fj=2f_{i-1}+\\sum\\limits_{j=2}^{i-1}f_{i-j+1}f_j=2fi−1​+j=2∑i−1​fi−j+1​fj​（把 fif12\\dfrac{f_if_1}{2}2fi​f1​​ 移到左边再同时乘 222） 是个卷积的形式！但是朴素是 O(n2log⁡n)O(n^2\\log n)O(n2logn) 的，TLE。 考虑让这个卷积变得更加标准，设 hi=fi+1h_i=f_{i+1}hi​=fi+1​，那么有： hi−1=2hi−2+∑j=2i−1hi−jhj−1h_{i-1}=2h_{i-2}+\\sum\\limits_{j=2}^{i-1}h_{i-j}h_{j-1}hi−1​=2hi−2​+j=2∑i−1​hi−j​hj−1​ hi=2hi−1+∑j=2ihi+1−jhj−1h_i=2h_{i-1}+\\sum\\limits_{j=2}^ih_{i+1-j}h_{j-1}hi​=2hi−1​+j=2∑i​hi+1−j​hj−1​ =2hi−1+∑j=1i−1hi−jhj=2h_{i-1}+\\sum\\limits_{j=1}^{i-1}h_{i-j}h_j=2hi−1​+j=1∑i−1​hi−j​hj​ 如果能带上 h0h_0h0​ 就完美了！ 2hi=2hi−1+∑j=0i−1hi−jhj2h_i=2h_{i-1}+\\sum\\limits_{j=0}^{i-1}h_{i-j}h_j2hi​=2hi−1​+j=0∑i−1​hi−j​hj​ 3hi=2hi−1+∑i=0ihi−jhj3h_i=2h_{i-1}+\\sum\\limits_{i=0}^ih_{i-j}h_j3hi​=2hi−1​+i=0∑i​hi−j​hj​（因为 h0=f1=1h_0=f_1=1h0​=f1​=1） hi=23hi−1+13∑j=0ihi−jhjh_i=\\dfrac{2}{3}h_{i-1}+\\dfrac{1}{3}\\sum\\limits_{j=0}^ih_{i-j}h_jhi​=32​hi−1​+31​j=0∑i​hi−j​hj​ 设 H(x)=∑i=0inf⁡hixiH(x)=\\sum\\limits_{i=0}^{\\inf}h_ix^iH(x)=i=0∑inf​hi​xi 即 hhh 的生成函数，那么有： H=13H2+23xH+23H=\\dfrac{1}{3}H^2+\\dfrac{2}{3}xH+\\dfrac{2}{3}H=31​H2+32​xH+32​（加上 23\\dfrac{2}{3}32​ 是因为 h0h_0h0​） 13H2+(23x−1)H+23=0\\dfrac{1}{3}H^2+\\left(\\dfrac{2}{3}x-1\\right)H+\\dfrac{2}{3}=031​H2+(32​x−1)H+32​=0 H=1−23x±49x2−43x+1−8923H=\\dfrac{1-\\frac{2}{3}x\\pm\\sqrt{\\frac{4}{9}x^2-\\frac{4}{3}x+1-\\frac{8}{9}}}{\\frac{2}{3}}H=32​1−32​x±94​x2−34​x+1−98​​​ =3−2x±4x2−12x+12=\\dfrac{3-2x\\pm\\sqrt{4x^2-12x+1}}{2}=23−2x±4x2−12x+1​​ 因为 H(0)=1H(0)=1H(0)=1，所以显然取减号。 H=3−2x−4x2−12x+12H=\\dfrac{3-2x-\\sqrt{4x^2-12x+1}}{2}H=23−2x−4x2−12x+1​​ 考虑拆掉根号，我们可以设 q(x)=4x2−12x+1,Q(x)=q(x)12q(x)=4x^2-12x+1,Q(x)=q(x)^{\\frac{1}{2}}q(x)=4x2−12x+1,Q(x)=q(x)21​，那么有： Q′(x)=12q(x)−12q′(x)Q&#x27;(x)=\\dfrac{1}{2}q(x)^{-\\frac{1}{2}}q&#x27;(x)Q′(x)=21​q(x)−21​q′(x)（注意链式法则） Q′(x)q(x)=12q(x)12q′(x)=12Q(x)q′(x)Q&#x27;(x)q(x)=\\dfrac{1}{2}q(x)^{\\frac{1}{2}}q&#x27;(x)=\\dfrac{1}{2}Q(x)q&#x27;(x)Q′(x)q(x)=21​q(x)21​q′(x)=21​Q(x)q′(x) 那么设 Q(x)=∑i=0inf⁡bixi,Q′(x)=∑i=0inf⁡bi+1(i+1)xiQ(x)=\\sum\\limits_{i=0}^{\\inf} b_ix^i,Q&#x27;(x)=\\sum\\limits_{i=0}^{\\inf}b_{i+1}(i+1)x^iQ(x)=i=0∑inf​bi​xi,Q′(x)=i=0∑inf​bi+1​(i+1)xi，然后因为 q(x)=4x2−12x+1q(x)=4x^2-12x+1q(x)=4x2−12x+1，所以 q′(x)=8x−12q&#x27;(x)=8x-12q′(x)=8x−12，也即是说： Q′(x)q(x)=(∑i=0inf⁡bi+1(i+1)xi)4x2−12x+1Q&#x27;(x)q(x)=\\left(\\sum\\limits_{i=0}^{\\inf}b_{i+1}(i+1)x^i\\right)4x^2-12x+1Q′(x)q(x)=(i=0∑inf​bi+1​(i+1)xi)4x2−12x+1 =∑i=0inf⁡bi+1(i+1)xi−12bi+1(i+1)xi+1+4bi+1(i+1)xi+2=\\sum\\limits_{i=0}^{\\inf}b_{i+1}(i+1)x^i-12b_{i+1}(i+1)x^{i+1}+4b_{i+1}(i+1)x^{i+2}=i=0∑inf​bi+1​(i+1)xi−12bi+1​(i+1)xi+1+4bi+1​(i+1)xi+2 =∑i=0inf⁡(bi+1(i+1)−12bii+4bi−1(i−1))xi=\\sum\\limits_{i=0}^{\\inf}(b_{i+1}(i+1)-12b_{i}i+4b_{i-1}(i-1))x^i=i=0∑inf​(bi+1​(i+1)−12bi​i+4bi−1​(i−1))xi（假设 b−1=0b_{-1}=0b−1​=0） 12Q(x)q′(x)=12(∑i=0inf⁡bixi)8x−12\\dfrac{1}{2}Q(x)q&#x27;(x)=\\dfrac{1}{2}\\left(\\sum\\limits_{i=0}^{\\inf}b_ix^i\\right)8x-1221​Q(x)q′(x)=21​(i=0∑inf​bi​xi)8x−12 =∑i=0inf⁡4bixi+1−6bixi=\\sum\\limits_{i=0}^{\\inf}4b_ix^{i+1}-6b_ix^i=i=0∑inf​4bi​xi+1−6bi​xi =∑i=0inf⁡(4bi−1−6bi)xi=\\sum\\limits_{i=0}^{\\inf}(4b_{i-1}-6b_i)x^i=i=0∑inf​(4bi−1​−6bi​)xi（假设 b−1=0b_{-1}=0b−1​=0） ∵Q′(x)q(x)=12Q(x)q′(x)\\because Q&#x27;(x)q(x)=\\dfrac{1}{2}Q(x)q&#x27;(x)∵Q′(x)q(x)=21​Q(x)q′(x) ∴∑i=0inf⁡(bi+1(i+1)−12bii+4bi−1(i−1))xi=∑i=0inf⁡(4bi−1−6bi)xi\\therefore \\sum\\limits_{i=0}^{\\inf}(b_{i+1}(i+1)-12b_{i}i+4b_{i-1}(i-1))x^i=\\sum\\limits_{i=0}^{\\inf}(4b_{i-1}-6b_i)x^i∴i=0∑inf​(bi+1​(i+1)−12bi​i+4bi−1​(i−1))xi=i=0∑inf​(4bi−1​−6bi​)xi ∴bi+1(i+1)−12bii+4bi−1(i−1)=4bi−1−6bi\\therefore b_{i+1}(i+1)-12b_{i}i+4b_{i-1}(i-1)=4b_{i-1}-6b_i∴bi+1​(i+1)−12bi​i+4bi−1​(i−1)=4bi−1​−6bi​ 解得 bi+1=(8−4i)bi−1+(12i−6)bii+1b_{i+1}=\\dfrac{(8-4i)b_{i-1}+(12i-6)b_i}{i+1}bi+1​=i+1(8−4i)bi−1​+(12i−6)bi​​，显然边界时 b0=1,b1=−6b_0=1,b_1=-6b0​=1,b1​=−6，那么我们就成功去掉了根号。 看回 H=3−2x−4x2−12x+12H=\\dfrac{3-2x-\\sqrt{4x^2-12x+1}}{2}H=23−2x−4x2−12x+1​​ 这条柿子，现在我们知道它等于 3−2x−∑i=0inf⁡bixi2\\dfrac{3-2x-\\sum\\limits_{i=0}^{\\inf} b_ix^i}{2}23−2x−i=0∑inf​bi​xi​，那么我们只需要将 bbb 全部负过来，b0→b0+3b_0\\to b_0+3b0​→b0​+3，b1→b1−2b_1\\to b_1-2b1​→b1​−2，然后对所有 bbb 除以 222，bbb 就变成了 hhh，我们就求得了 fff。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P6694 强迫症 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p6694-qiang-po-zheng-zuo-ti-ji-lu/","stats":{"text":"12 min read","time":683000,"words":2079,"minutes":12},"date":"2023-03-24 16:07:02","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>这个背包最多可以装 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span> 大小的东西</p>\n<p>付公主有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 种商品，她要准备出摊了</p>\n<p>每种商品体积为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，都有无限件</p>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span>，对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">s\\in [1,m]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mclose\">]</span></span></span></span>，请你回答用这些商品恰好装 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">s</span></span></span></span> 体积的方案数。</p>\n</blockquote>\n","content":" 这个背包最多可以装 10510^5105 大小的东西 付公主有 nnn 种商品，她要准备出摊了 每种商品体积为 viv_ivi​，都有无限件 给定 mmm，对于 s∈[1,m]s\\in [1,m]s∈[1,m]，请你回答用这些商品恰好装 sss 体积的方案数。 朴素的做法是 nnn 个长度为 mmm 的多项式相乘，时间复杂度为 O(nmlog⁡m)O(nm\\log m)O(nmlogm)，显然会 TLE 考虑一个物品的生成函数： f(x)=∑i=0inf⁡[i≡0(modv)]xif(x)=\\sum\\limits_{i=0}^{\\inf}[i\\equiv 0\\pmod v]x^if(x)=i=0∑inf​[i≡0(modv)]xi =∑i=0inf⁡xiv=\\sum\\limits_{i=0}^{\\inf}x^{iv}=i=0∑inf​xiv 显然这个式子当且仅当 −1&lt;x&lt;1-1&lt;x&lt;1−1&lt;x&lt;1 时收敛，所以我们考虑令 0&lt;x&lt;10&lt;x&lt;10&lt;x&lt;1： ∑i=0inf⁡xiv=lim⁡n→inf⁡xnv−1xv−1\\sum\\limits_{i=0}^{\\inf}x^{iv}=\\lim\\limits_{n\\to\\inf}\\dfrac{x^{nv}-1}{x^v-1}i=0∑inf​xiv=n→inflim​xv−1xnv−1​ 由于当 nnn 无限大时 xnvx^{nv}xnv 无限趋近于 000，所以： lim⁡n→inf⁡xnv−1xv−1=−1xv−1=11−xv\\lim\\limits_{n\\to\\inf}\\dfrac{x^{nv}-1}{x^v-1}=\\dfrac{-1}{x^v-1}=\\dfrac{1}{1-x^v}n→inflim​xv−1xnv−1​=xv−1−1​=1−xv1​ 也就是说 f(x)=11−xvf(x)=\\dfrac{1}{1-x^v}f(x)=1−xv1​ 我们要求很多个 fff 的乘积，那么考虑化乘为加，给 f(x)f(x)f(x) 取个 ln⁡\\lnln，求： ln⁡f(x)=ln⁡(11−xv)\\ln f(x)=\\ln(\\dfrac{1}{1-x^v})lnf(x)=ln(1−xv1​) =−ln⁡(1−xv)=-\\ln(1-x^v)=−ln(1−xv) 这个东西不太好求，考虑求导： −ln⁡′(1−xv)=−(1−xv)′1−xv-\\ln&#x27;(1-x^v)=-\\dfrac{(1-x^v)&#x27;}{1-x^v}−ln′(1−xv)=−1−xv(1−xv)′​ =−1′−(xv)′1−xv=-\\dfrac{1&#x27;-(x^v)&#x27;}{1-x^v}=−1−xv1′−(xv)′​ =−−vxv−11−xv=-\\dfrac{-vx^{v-1}}{1-x^v}=−1−xv−vxv−1​ =vxv−111−xv=vx^{v-1}\\dfrac{1}{1-x^v}=vxv−11−xv1​ 注意到 11−xv=∑i=0inf⁡xiv\\dfrac{1}{1-x^v}=\\sum\\limits_{i=0}^{\\inf}x^{iv}1−xv1​=i=0∑inf​xiv，所以： =vxv−1∑i=0inf⁡xiv=vx^{v-1}\\sum\\limits_{i=0}^{\\inf}x^{iv}=vxv−1i=0∑inf​xiv =∑i=0inf⁡vx(i+1)v−1=\\sum\\limits_{i=0}^{\\inf}vx^{(i+1)v-1}=i=0∑inf​vx(i+1)v−1 =∑i=1inf⁡vxiv−1=\\sum\\limits_{i=1}^{\\inf}vx^{iv-1}=i=1∑inf​vxiv−1 积分回来： ln⁡f(x)=∑i=1inf⁡∫vxiv−1dx\\ln f(x)=\\sum\\limits_{i=1}^{\\inf}\\int vx^{iv-1}dxlnf(x)=i=1∑inf​∫vxiv−1dx =∑i=1inf⁡∫1iivxiv−1dx=\\sum\\limits_{i=1}^{\\inf}\\int \\dfrac{1}{i}ivx^{iv-1} dx=i=1∑inf​∫i1​ivxiv−1dx =∑i=1inf⁡1ixiv=\\sum\\limits_{i=1}^{\\inf}\\dfrac{1}{i}x^{iv}=i=1∑inf​i1​xiv 好了，我们终于求得了 f(x)=∑i=1inf⁡1ixivf(x)=\\sum\\limits_{i=1}^{\\inf}\\dfrac{1}{i}x^{iv}f(x)=i=1∑inf​i1​xiv。 接下来把它们相加，求 exp⁡\\expexp 即可。 具体的做法是，开一个桶 tit_iti​ 存 v=iv=iv=i 的多项式有多少个，然后调和级数搞即可。 ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P4389 付公主的背包 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p4389-fu-gong-zhu-de-bei-bao-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":228000,"words":716,"minutes":4},"date":"2023-03-24 16:05:12","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>小C有一个集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，里面的元素都是小于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的数列，数列中的每个数都属于集合 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span>。</p>\n<p>小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，求所有可以生成出的，且满足数列中所有数的乘积 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext> </mtext><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">\\bmod \\ m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mspace\"> </span><span class=\"mord mathdefault\">m</span></span></span></span> 的值等于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 的不同的数列的有多少个。</p>\n<p>小C认为，两个数列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 不同，当且仅当 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>i</mi><mtext> s.t. </mtext><msub><mi>A</mi><mi>i</mi></msub><mi mathvariant=\"normal\">≠</mi><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\exists i \\text{ s.t. } A_i \\neq B_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathdefault\">i</span><span class=\"mord text\"><span class=\"mord\"> s.t. </span></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1004535809</mn></mrow><annotation encoding=\"application/x-tex\">1004535809</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">4</span><span class=\"mord\">5</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">8</span><span class=\"mord\">0</span><span class=\"mord\">9</span></span></span></span> 取模的值就可以了。</p>\n</blockquote>\n","content":" 小C有一个集合 SSS，里面的元素都是小于 mmm 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 nnn 的数列，数列中的每个数都属于集合 SSS。 小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 xxx，求所有可以生成出的，且满足数列中所有数的乘积 mod m\\bmod \\ mmod m 的值等于 xxx 的不同的数列的有多少个。 小C认为，两个数列 AAA 和 BBB 不同，当且仅当 ∃i s.t. Ai≠Bi\\exists i \\text{ s.t. } A_i \\neq B_i∃i s.t. Ai​​=Bi​。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 100453580910045358091004535809 取模的值就可以了。 我们设 dpi,xdp_{i,x}dpi,x​ 表示长度为 iii，mod⁡m\\operatorname{mod} mmodm 的值为 xxx 的不同序列的个数。那么有转移： dpi,x=∑abmod m=x,b∈Sdpi−1,adp_{i,x}=\\sum\\limits_{ab\\mod m=x,b\\in S}dp_{i-1,a}dpi,x​=abmodm=x,b∈S∑​dpi−1,a​ =∑b∈Sdpi−1,xb=\\sum\\limits_{b\\in S}dp_{i-1,\\frac{x}{b}}=b∈S∑​dpi−1,bx​​ 设 S′S&#x27;S′ 为 SSS 中所有元素的乘法逆元组成的集合，那么： =∑b∈S′dpi−1,bx=\\sum\\limits_{b\\in S&#x27;}dp_{i-1,bx}=b∈S′∑​dpi−1,bx​ 发现很难求解，此路不通。 注意到”拦路虎“其实是乘法。我们并不会计算多项式的乘法卷积，只会计算多项式的加法卷积，那么我们不妨化乘法为加法，令 S′={log⁡g(u)∣u∈S}S&#x27;=\\{\\log_g(u)|u\\in S\\}S′={logg​(u)∣u∈S}（其中 ggg 是 mmm 的一个原根）即可，那么有: dpi,x=∑b∈S′dpi−1,x−bmod pdp_{i,x}=\\sum\\limits_{b\\in S&#x27;}dp_{i-1,x-b\\mod p}dpi,x​=b∈S′∑​dpi−1,x−bmodp​ 设 Fi=[i∈S′]F_i=[i\\in S&#x27;]Fi​=[i∈S′]，那么： =∑i=0xFidpi−1,x−imod p=\\sum\\limits_{i=0}^xF_idp_{i-1,x-i\\mod p}=i=0∑x​Fi​dpi−1,x−imodp​ 变成了卷积的形式！写得抽象点就是： dpi=F∗dpi−1dp_i=F*dp_{i-1}dpi​=F∗dpi−1​ =Fi−1∗dp1=F^{i-1}*dp_1=Fi−1∗dp1​ =Fi=F^i=Fi 那么多项式快速幂即可，不过注意到 FFF 的长度很小，所以 O(log⁡2)O(\\log^2)O(log2) 算法也可以被接受。 最后答案即为 dpn,log⁡g(x)dp_{n,\\log_g(x)}dpn,logg​(x)​，有一个细节就是算完卷积后要把后半部分加到前半部分，因为这是循环卷积。并且多项式的长度是 m−1m-1m−1。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"P3321 [SDOI2015]序列统计 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/p3321-sdoi2015xu-lie-tong-ji-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":178000,"words":660,"minutes":3},"date":"2023-03-24 16:03:31","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>黑板上有一个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>，初始时它的值为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span> 中的某一个整数，其中为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的概率是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>每一轮你可以将 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 完全随机地替换成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,x]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">]</span></span></span></span> 中的一个数。</p>\n<p>求 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 轮后，对于每个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">i\\in[0,n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">]</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">x=i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 的概率。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">n \\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">m \\le 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding=\"application/x-tex\">998244353</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord\">9</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">4</span><span class=\"mord\">3</span><span class=\"mord\">5</span><span class=\"mord\">3</span></span></span></span> 取模。</p>\n</blockquote>\n","content":" 黑板上有一个整数 xxx，初始时它的值为 [0,n][0,n][0,n] 中的某一个整数，其中为 iii 的概率是 pip_ipi​ 每一轮你可以将 xxx 完全随机地替换成 [0,x][0,x][0,x] 中的一个数。 求 mmm 轮后，对于每个 i∈[0,n]i\\in[0,n]i∈[0,n]，x=ix=ix=i 的概率。 n≤105n \\le 10^5n≤105，m≤1018m \\le 10^{18}m≤1018，答案对 998244353998244353998244353 取模。 设 fm(x)f_m(x)fm​(x) 表示 mmm 轮之后数为 xxx 的答案，Fm(x)=∑i=0nfm(i)xiF_m(x)=\\sum\\limits_{i=0}^n f_m(i)x^iFm​(x)=i=0∑n​fm​(i)xi 也就是 fff 的生成函数，那么有： ∵fm(x)=∑i=xnfm−1(i)i+1\\because f_m(x)=\\sum\\limits_{i=x}^n \\dfrac{f_{m-1}(i)}{i+1}∵fm​(x)=i=x∑n​i+1fm−1​(i)​ ∴Fm(x)=∑i=0nxi∑j=infm−1(j)j+1\\therefore F_m(x)=\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=i}^n\\dfrac{f_{m-1}(j)}{j+1}∴Fm​(x)=i=0∑n​xij=i∑n​j+1fm−1​(j)​ =∑i=0nfm−1(i)i+1∑j=0ixj=\\sum\\limits_{i=0}^n \\dfrac{f_{m-1}(i)}{i+1}\\sum\\limits_{j=0}^i x^j=i=0∑n​i+1fm−1​(i)​j=0∑i​xj =∑i=0nfm−1(i)i+1xi+1−1x−1=\\sum\\limits_{i=0}^n \\dfrac{f_{m-1}(i)}{i+1}\\dfrac{x^{i+1}-1}{x-1}=i=0∑n​i+1fm−1​(i)​x−1xi+1−1​ =1x−1∑i=0nfm−1(i)xi+1−1i+1=\\dfrac{1}{x-1}\\sum\\limits_{i=0}^nf_{m-1}(i)\\dfrac{x^{i+1}-1}{i+1}=x−11​i=0∑n​fm−1​(i)i+1xi+1−1​ 注意到 ∫xidx=xi+1i+1\\int x^i dx=\\dfrac{x^{i+1}}{i+1}∫xidx=i+1xi+1​，那么： =1x−1∑i=0nfm−1(i)∫1xtidt=\\dfrac{1}{x-1}\\sum\\limits_{i=0}^nf_{m-1}(i)\\int_1^xt^idt=x−11​i=0∑n​fm−1​(i)∫1x​tidt =1x−1∑i=0n∫1xfm−1(i)tidt=\\dfrac{1}{x-1}\\sum\\limits_{i=0}^n\\int_1^xf_{m-1}(i)t^idt=x−11​i=0∑n​∫1x​fm−1​(i)tidt =1x−1∫1xFm−1(t)dt=\\dfrac{1}{x-1}\\int_1^xF_{m-1}(t)dt=x−11​∫1x​Fm−1​(t)dt 发现这个定积分很烦，那么考虑设 Gm(x)=fm(x+1)=∑i=0ngm(i)xiG_m(x)=f_m(x+1)=\\sum\\limits_{i=0}^ng_m(i)x^iGm​(x)=fm​(x+1)=i=0∑n​gm​(i)xi，那么有： Gm(x)=1x∫1x+1Fm−1(t)dtG_m(x)=\\dfrac{1}{x}\\int_1^{x+1}F_{m-1}(t)dtGm​(x)=x1​∫1x+1​Fm−1​(t)dt =0x∫0xFm−1(t+1)d(t+1)=\\dfrac{0}{x}\\int_0^xF_{m-1}(t+1)d(t+1)=x0​∫0x​Fm−1​(t+1)d(t+1) =1x∫0xGm−1(t)dt=\\dfrac{1}{x}\\int_0^xG_{m-1}(t)dt=x1​∫0x​Gm−1​(t)dt =1x∫0xGm−1(t)dt=\\dfrac{1}{x}\\int_0^xG_{m-1}(t)dt=x1​∫0x​Gm−1​(t)dt =1x∑i=0ngm−1(i)i+1xi+1=\\dfrac{1}{x}\\sum\\limits_{i=0}^n\\dfrac{g_{m-1}(i)}{i+1}x^{i+1}=x1​i=0∑n​i+1gm−1​(i)​xi+1 =∑i=0ngm−1(i)i+1xi=\\sum\\limits_{i=0}^n\\dfrac{g_{m-1}(i)}{i+1}x^{i}=i=0∑n​i+1gm−1​(i)​xi 即 gm(i)=gm−1(i)i+1=g1(i)(i+1)m−1g_m(i)=\\dfrac{g_{m-1}(i)}{i+1}=\\dfrac{g_1(i)}{(i+1)^{m-1}}gm​(i)=i+1gm−1​(i)​=(i+1)m−1g1​(i)​，接下来问题就转变为快速求出 g1(i)g_1(i)g1​(i)，然后根据 gm(i)g_m(i)gm​(i) 快速求出 fm(i)f_m(i)fm​(i)。 先考虑快速求出 g1(i)g_1(i)g1​(i)： ∵G1(x)=F1(x+1)\\because G_{1}(x)=F_1(x+1)∵G1​(x)=F1​(x+1) ∴G1(x)=∑i=0nf1(i)(x+1)i\\therefore G_1(x)=\\sum\\limits_{i=0}^nf_1(i)(x+1)^i∴G1​(x)=i=0∑n​f1​(i)(x+1)i 注意到 f1(i)=pif_1(i)=p_if1​(i)=pi​： =∑i=0npi(x+1)i=\\sum\\limits_{i=0}^n p_i(x+1)^i=i=0∑n​pi​(x+1)i 根据二项式定理展开整理： =∑i=0npi∑j=0i(ij)xj=\\sum\\limits_{i=0}^np_i\\sum\\limits_{j=0}^i\\dbinom{i}{j}x^j=i=0∑n​pi​j=0∑i​(ji​)xj =∑i=0nxj∑j=in(ji)pj=\\sum\\limits_{i=0}^nx^j\\sum\\limits_{j=i}^n\\dbinom{j}{i}p_j=i=0∑n​xjj=i∑n​(ij​)pj​ 也就是说： g1(i)=∑j=in(ji)pjg_1(i)=\\sum\\limits_{j=i}^n\\dbinom{j}{i}p_jg1​(i)=j=i∑n​(ij​)pj​ =∑j=inpjj!i!(j−i)!=\\sum\\limits_{j=i}^n\\dfrac{p_jj!}{i!(j-i)!}=j=i∑n​i!(j−i)!pj​j!​ =1i!∑j=inpjj!(j−i)!=\\dfrac{1}{i!}\\sum\\limits_{j=i}^n\\dfrac{p_jj!}{(j-i)!}=i!1​j=i∑n​(j−i)!pj​j!​ 根据老套路，我们把 ppp 反过来，设 pj′=pn−jp&#x27;_j=p_{n-j}pj′​=pn−j​，那么有： =1i!∑j=0n−ipj′(n−j)!(n−i−j)!=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}\\dfrac{p&#x27;_j(n-j)!}{(n-i-j)!}=i!1​j=0∑n−i​(n−i−j)!pj′​(n−j)!​ 显然可以用卷积快速做。 接下来考虑根据 gm(i)g_m(i)gm​(i) 求出 fm(i)f_m(i)fm​(i)，与上面十分类似： ∵Gm(x)=Fm(x+1)\\because G_m(x)=F_m(x+1)∵Gm​(x)=Fm​(x+1) ∴Fm(x)=∑i=0ngm(i)(x−1)i\\therefore F_m(x)=\\sum\\limits_{i=0}^ng_m(i)(x-1)^i∴Fm​(x)=i=0∑n​gm​(i)(x−1)i =∑i=0ngm(i)∑j=0i(ij)xj(−1)i−j=\\sum\\limits_{i=0}^ng_m(i)\\sum\\limits_{j=0}^i\\dbinom{i}{j}x^j(-1)^{i-j}=i=0∑n​gm​(i)j=0∑i​(ji​)xj(−1)i−j =∑i=0nxi∑j=ingm(j)(ji)(−1)j−i=\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=i}^ng_m(j)\\dbinom{j}{i}(-1)^{j-i}=i=0∑n​xij=i∑n​gm​(j)(ij​)(−1)j−i 即： fm(i)=∑j=ingm(j)(ji)(−1)j−if_m(i)=\\sum\\limits_{j=i}^ng_m(j)\\dbinom{j}{i}(-1)^{j-i}fm​(i)=j=i∑n​gm​(j)(ij​)(−1)j−i =∑j=ingm(j)(−1)j−ij!i!(j−i)!=\\sum\\limits_{j=i}^n\\dfrac{g_m(j)(-1)^{j-i}j!}{i!(j-i)!}=j=i∑n​i!(j−i)!gm​(j)(−1)j−ij!​ =1i!∑j=ingm(j)j!(−1)j−i(j−i)!=\\dfrac{1}{i!}\\sum\\limits_{j=i}^ng_m(j)j!\\dfrac{(-1)^{j-i}}{(j-i)!}=i!1​j=i∑n​gm​(j)j!(j−i)!(−1)j−i​ 设 gi′=gn−ig&#x27;_i=g_{n-i}gi′​=gn−i​： =1i!∑j=0n−igm′(j)(n−j)!(−1)n−i−j(n−i−j)!=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}g&#x27;_m(j)(n-j)!\\dfrac{(-1)^{n-i-j}}{(n-i-j)!}=i!1​j=0∑n−i​gm′​(j)(n−j)!(n−i−j)!(−1)n−i−j​ 显然可以用卷积快速做。 总结一下，首先通过 p′p&#x27;p′ 求出 g1(i)g_1(i)g1​(i)： g1(i)=1i!∑j=0n−ipj′(n−j)!(n−i−j)!g_1(i)=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}\\dfrac{p&#x27;_j(n-j)!}{(n-i-j)!}g1​(i)=i!1​j=0∑n−i​(n−i−j)!pj′​(n−j)!​ 然后根据 g1(i)g_1(i)g1​(i) 求出 gm(i)g_m(i)gm​(i)： gm(i)=g1(i)(i+1)m−1g_m(i)=\\dfrac{g_1(i)}{(i+1)^{m-1}}gm​(i)=(i+1)m−1g1​(i)​ 最后根据 g’m(i)g’_m(i)g’m​(i) 求出 fm(i)f_m(i)fm​(i)： fm(i)=1i!∑j=0n−igm′(j)(n−j)!(−1)n−i−j(n−i−j)!f_m(i)=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}g&#x27;_m(j)(n-j)!\\dfrac{(-1)^{n-i-j}}{(n-i-j)!}fm​(i)=i!1​j=0∑n−i​gm′​(j)(n−j)!(n−i−j)!(−1)n−i−j​ ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF923E Perpetual Subtraction 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf923e-perpetual-subtraction-zuo-ti-ji-lu/","stats":{"text":"10 min read","time":557000,"words":1594,"minutes":10},"date":"2023-03-24 16:00:43","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>生成测试数据并非简单的任务！生成大的随机数据通常不能够完全保证解法的正确性。</p>\n<p>举个例子，考虑以前 Codeforces round 的一道题。它的输入格式如下：</p>\n<blockquote>\n<p>第一行是一个整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">n(1\\leq n \\leq max_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 表示集合的大小，第二行包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个互不相同的整数 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>(</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>a</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\dots,a_n(1\\leq a_i\\leq max_a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 表示集合中的元素，升序排列。</p>\n</blockquote>\n<p>如果你不注意题目的解法，看起来生成一个好的测试数据是非常容易的。令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">n=max_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">1\\sim max_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 中生成 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个不相同的数，并排序。但是马上你就会知道这不那么简单。</p>\n<p>下面是这道题目的真实解法。令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2,\\dots,a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的最大公约数，令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mi mathvariant=\"normal\">/</mi><mi>g</mi><mo>−</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">x=a_n/g-n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 是奇数输出 <code>Alice</code>，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 是偶数输出 <code>Bob</code></p>\n<p>考虑这道题两个错误的解法，它们与正解只在计算 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 中不同。</p>\n<p>第一个解法令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mi mathvariant=\"normal\">/</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">x = a_n/g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span> （不减去 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>）</p>\n<p>第二个解法令 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mo>−</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">x=a_n-n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>（不除以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span>）</p>\n<p>如果一个测试数据令这两个解法<strong>都</strong>输出错误的答案，称这个数据是有趣的。</p>\n<p>给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub><mo separator=\"true\">,</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>a</mi></msub><mo separator=\"true\">,</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">max_n, max_a, q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 求满足限制且有趣的测试数据的数量对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 取模的结果。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><mn>30000</mn><mo separator=\"true\">,</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>a</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator=\"true\">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>+</mo><mn>129</mn></mrow><annotation encoding=\"application/x-tex\">1\\leq max_n\\leq 30000, max_n\\leq max_a\\leq 10^9, 10^4\\leq q\\leq 10^5+129</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">9</span></span></span></span></p>\n</blockquote>\n","content":" 生成测试数据并非简单的任务！生成大的随机数据通常不能够完全保证解法的正确性。 举个例子，考虑以前 Codeforces round 的一道题。它的输入格式如下： 第一行是一个整数 n(1≤n≤maxn)n(1\\leq n \\leq max_n)n(1≤n≤maxn​) 表示集合的大小，第二行包含 nnn 个互不相同的整数 a1,a2,…,an(1≤ai≤maxa)a_1,a_2,\\dots,a_n(1\\leq a_i\\leq max_a)a1​,a2​,…,an​(1≤ai​≤maxa​) 表示集合中的元素，升序排列。 如果你不注意题目的解法，看起来生成一个好的测试数据是非常容易的。令 n=maxnn=max_nn=maxn​，从 1∼maxa1\\sim max_a1∼maxa​ 中生成 nnn 个不相同的数，并排序。但是马上你就会知道这不那么简单。 下面是这道题目的真实解法。令 ggg 为 a1,a2,…,ana_1,a_2,\\dots,a_na1​,a2​,…,an​ 的最大公约数，令 x=an/g−nx=a_n/g-nx=an​/g−n，如果 xxx 是奇数输出 Alice，如果 xxx 是偶数输出 Bob 考虑这道题两个错误的解法，它们与正解只在计算 xxx 中不同。 第一个解法令 x=an/gx = a_n/gx=an​/g （不减去 nnn） 第二个解法令 x=an−nx=a_n-nx=an​−n（不除以 ggg） 如果一个测试数据令这两个解法都输出错误的答案，称这个数据是有趣的。 给定 maxn,maxa,qmax_n, max_a, qmaxn​,maxa​,q 求满足限制且有趣的测试数据的数量对 qqq 取模的结果。 1≤maxn≤30000,maxn≤maxa≤109,104≤q≤105+1291\\leq max_n\\leq 30000, max_n\\leq max_a\\leq 10^9, 10^4\\leq q\\leq 10^5+1291≤maxn​≤30000,maxn​≤maxa​≤109,104≤q≤105+129 多项式和最大公因数又有什么关系呢？ 哦，目标显然是让 nnn 为奇数且 ggg 包含了 ana_nan​ 的所有因子 222，并且 ana_nan​ 是偶数。 那么可以枚举 ggg 的因子 222 的个数，假设 ggg 有 kkk 个因子 222，问题就变为求 ai≤⌊maxa2k⌋a_i\\le \\left\\lfloor\\dfrac{max_a}{2^k}\\right\\rfloorai​≤⌊2kmaxa​​⌋，nnn 为奇数且 ana_nan​ 为奇数的方案数。 设 fi,jf_{i,j}fi,j​ 表示 n=jn=jn=j，aaa 的取值范围为 [1,i][1,i][1,i] 且 aja_jaj​ 为偶数的方案数；gi,jg_{i,j}gi,j​ 表示 n=jn=jn=j，aaa 的取值范围为 [1,i][1,i][1,i] 且 aja_jaj​ 为奇数的方案数。那么我们只要求出 fff 的转移方法就能类似地推出 ggg 的转移方法了。 显然有转移： fi,j=fi−1,j+[imod⁡2=0](fi−1,j−1+gi−1,j−1)f_{i,j}=f_{i-1,j}+[i\\operatorname{mod}2=0](f_{i-1,j-1}+g_{i-1,j-1})fi,j​=fi−1,j​+[imod2=0](fi−1,j−1​+gi−1,j−1​) 意思是，我们可以让 aj&lt;ia_j&lt;iaj​&lt;i 或者让 aj=ia_j=iaj​=i。 然后换一种转移方式，考虑从取值范围 [1,x][1,x][1,x] 和取值范围 [1,y][1,y][1,y] 转移到取值范围 [1,x+y][1,x+y][1,x+y]： fx+y,i=∑j=0i−1(fx,j+gx,j)([xmod⁡2=0]fy,i−j+[xmod⁡2=1]gy,i−j)f_{x+y,i}=\\sum\\limits_{j=0}^{i-1}(f_{x,j}+g_{x,j})([x\\operatorname{mod}2=0]f_{y,i-j}+[x\\operatorname{mod}2=1]g_{y,i-j})fx+y,i​=j=0∑i−1​(fx,j​+gx,j​)([xmod2=0]fy,i−j​+[xmod2=1]gy,i−j​) 意思是，前 jjj 个数满足 1≤ai≤x1\\le a_i\\le x1≤ai​≤x，后 i−ji-ji−j 个数满足 x+1≤ai≤x+yx+1\\le a_i\\le x+yx+1≤ai​≤x+y 且最后一个数是偶数。 边界条件是 f1,1=0f_{1,1}=0f1,1​=0。 总结一下： {f1,1=0fi,j=fi−1,j+[imod⁡2=0](fi−1,j−1+gi−1,j−1+[j=1])f2i,j=fi,j+∑k=0j−1(fi,k+gi,k)([imod⁡2=0]fi,j−k+[imod⁡2=1]gi,j−k)\\begin{cases}f_{1,1}=0\\\\f_{i,j}=f_{i-1,j}+[i\\operatorname{mod}2=0](f_{i-1,j-1}+g_{i-1,j-1}+[j=1])\\\\f_{2i,j}=f_{i,j}+\\sum\\limits_{k=0}^{j-1}(f_{i,k}+g_{i,k})([i\\operatorname{mod}2=0]f_{i,j-k}+[i\\operatorname{mod}2=1]g_{i,j-k})\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​f1,1​=0fi,j​=fi−1,j​+[imod2=0](fi−1,j−1​+gi−1,j−1​+[j=1])f2i,j​=fi,j​+k=0∑j−1​(fi,k​+gi,k​)([imod2=0]fi,j−k​+[imod2=1]gi,j−k​)​ 类似地： {g1,1=1gi,j=gi−1,j+[imod⁡2=1](fi−1,j−1+gi−1,j−1+[j=1])g2i,j=gi,j+∑k=0j−1(fi,k+gi,k)([imod⁡2=1]fi,j−k+[imod⁡2=0]gi,j−k)\\begin{cases}g_{1,1}=1\\\\g_{i,j}=g_{i-1,j}+[i\\operatorname{mod}2=1](f_{i-1,j-1}+g_{i-1,j-1}+[j=1])\\\\g_{2i,j}=g_{i,j}+\\sum\\limits_{k=0}^{j-1}(f_{i,k}+g_{i,k})([i\\operatorname{mod}2=1]f_{i,j-k}+[i\\operatorname{mod}2=0]g_{i,j-k})\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​g1,1​=1gi,j​=gi−1,j​+[imod2=1](fi−1,j−1​+gi−1,j−1​+[j=1])g2i,j​=gi,j​+k=0∑j−1​(fi,k​+gi,k​)([imod2=1]fi,j−k​+[imod2=0]gi,j−k​)​ 然后就可以倍增地边求 fff 边求 ggg，求出答案了。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF773F Test Data Generation 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf773f-test-data-generation-zuo-ti-ji-lu/","stats":{"text":"7 min read","time":366000,"words":1217,"minutes":7},"date":"2023-03-24 15:28:37","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>有一排 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个球，定义一个组可以只包含一个球或者包含两个相邻的球。现在一个球只能分到一个组中，求从这些球中取出  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 组的方案数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">n\\le 10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding=\"application/x-tex\">k&lt;2^{15}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 有一排 nnn 个球，定义一个组可以只包含一个球或者包含两个相邻的球。现在一个球只能分到一个组中，求从这些球中取出 kkk 组的方案数。 n≤109n\\le 10^9n≤109，k&lt;215k&lt;2^{15}k&lt;215。 dpn,k=dpn−1,k+dpn−1,k−1+dpn−2,k−1dp_{n,k}=dp_{n-1,k}+dp_{n-1,k-1}+dp_{n-2,k-1} dpn,k​=dpn−1,k​+dpn−1,k−1​+dpn−2,k−1​ dpa+b,k=(∑i=0kdpa,idpb,k−i)+(∑i=0k−1dpa−1,i+dpb−1,k−1−i)dp_{a+b,k}=\\left(\\sum\\limits_{i=0}^k dp_{a,i}dp_{b,k-i}\\right)+\\left(\\sum\\limits_{i=0}^{k-1}dp_{a-1,i}+dp_{b-1,k-1-i}\\right) dpa+b,k​=(i=0∑k​dpa,i​dpb,k−i​)+(i=0∑k−1​dpa−1,i​+dpb−1,k−1−i​) 设 Fn(x)∑k=0inf⁡xkdpn,kF_n(x)\\sum\\limits_{k=0}^{\\inf}x^kdp_{n,k}Fn​(x)k=0∑inf​xkdpn,k​，那么： Fn(x)=Fn−1(x)+xFn−1(x)+xFn−2(x)F_n(x)=F_{n-1}(x)+xF_{n-1}(x)+xF_{n-2}(x) Fn​(x)=Fn−1​(x)+xFn−1​(x)+xFn−2​(x) Fa+b(x)=(Fa∗Fb)(x)+x(Fa−1∗Fb−1)(x)F_{a+b}(x)=(F_a*F_b)(x)+x(F_{a-1}*F_{b-1})(x) Fa+b​(x)=(Fa​∗Fb​)(x)+x(Fa−1​∗Fb−1​)(x) 那么： Fn(x)=Fn−1(x)+xFn−1(x)+xFn−2(x)F_n(x)=F_{n-1}(x)+xF_{n-1}(x)+xF_{n-2}(x) Fn​(x)=Fn−1​(x)+xFn−1​(x)+xFn−2​(x) F2n(x)=Fn2(x)+xFn−12(x)F_{2n}(x)=F_n^2(x)+xF_{n-1}^2(x) F2n​(x)=Fn2​(x)+xFn−12​(x) F2n−1(x)=(Fn∗Fn−1)(x)+x(Fn−1∗Fn−2)(x)F_{2n-1}(x)=(F_n*F_{n-1})(x)+x(F_{n-1}*F_{n-2})(x) F2n−1​(x)=(Fn​∗Fn−1​)(x)+x(Fn−1​∗Fn−2​)(x) F2n−2(x)=Fn−12(x)+xFn−22(x)F_{2n-2}(x)=F_{n-1}^2(x)+xF_{n-2}^2(x) F2n−2​(x)=Fn−12​(x)+xFn−22​(x) ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF755G PolandBall and Many Other Balls 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf755g-polandball-and-many-other-balls-zuo-ti-ji-lu/","stats":{"text":"3 min read","time":150000,"words":429,"minutes":3},"date":"2023-03-24 15:22:25","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>对于一个整数序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_1, a_2, \\ldots, a_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>，我们定义它的变换为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{b_1, b_2, \\ldots, b_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>…</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i = a_1 | a_2 | \\ldots | a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span></span></span></span> 表示二进制按位或运算。</p>\n<p>现在求有多少个长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1\\leq a_i \\leq 2^k - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.932438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，使得它的变换 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 是<strong>严格单调递增</strong>的，对 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span> 取模。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\leq n \\leq 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\leq k \\leq 3 \\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 对于一个整数序列 {a1,a2,…,an}\\{a_1, a_2, \\ldots, a_n\\}{a1​,a2​,…,an​}，我们定义它的变换为 {b1,b2,…,bn}\\{b_1, b_2, \\ldots, b_n\\}{b1​,b2​,…,bn​}，其中 bi=a1∣a2∣…∣aib_i = a_1 | a_2 | \\ldots | a_ibi​=a1​∣a2​∣…∣ai​，其中 ∣|∣ 表示二进制按位或运算。 现在求有多少个长为 nnn 的序列 aaa，满足 1≤ai≤2k−11\\leq a_i \\leq 2^k - 11≤ai​≤2k−1，使得它的变换 bbb 是严格单调递增的，对 109+710^9+7109+7 取模。 1≤n≤10181\\leq n \\leq 10^{18}1≤n≤1018，1≤k≤3×1041\\leq k \\leq 3 \\times 10^41≤k≤3×104。 我们设 dpi,j,0/1dp_{i,j,0/1}dpi,j,0/1​ 表示序列有 iii 个数，当前或和第 jjj 位（二进制）是 0/10/10/1 的方案数 好难转移啊/ll 如果设 dpi,jdp_{i,j}dpi,j​ 表示序列有 iii 个数，当前或和为 jjj 的方案数呢？ 那么我们可以枚举 jjj 的二进制中 111 的个数来转移！ 所以说正确的状态应该是 dpi,jdp_{i,j}dpi,j​ 表示序列有 iii 个数，当前或和二进制有 jjj 个 111。 推一下柿子： dpi,j=∑l=0j(jl)dpi−1,l2ldp_{i,j}=\\sum\\limits_{l=0}^j\\dbinom{j}{l}dp_{i-1,l}2^ldpi,j​=l=0∑j​(lj​)dpi−1,l​2l 这个柿子的意思是，枚举前 i−1i-1i−1 项的或和有多少个 111 和这些 111 在哪里，然后第 iii 项的剩下 j−lj-lj−l 个 111 的位置必须是 111，但是 lll 个 111 的位置可以是 000 也可以是 111。 拆组合数： dpi,j=j!∑l=0jdpi−1,l2ll!1(j−l)!dp_{i,j}=j!\\sum\\limits_{l=0}^j\\dfrac{dp_{i-1,l}2^l}{l!}\\dfrac{1}{(j-l)!}dpi,j​=j!l=0∑j​l!dpi−1,l​2l​(j−l)!1​ 考虑换一种转移方式，有： dpa+b,j=∑l=0j(jl)dpa,ldpb,j−l2bldp_{a+b,j}=\\sum\\limits_{l=0}^j \\dbinom{j}{l}dp_{a,l}dp_{b,j-l}2^{bl}dpa+b,j​=l=0∑j​(lj​)dpa,l​dpb,j−l​2bl 这个柿子的意思是，枚举前 aaa 项的或和有多少个 111 和这些 111 在哪里，然后剩下 bbb 项补足前 aaa 项没有的 111，并且这 bbb 项的被前 aaa 项占用的那些位置可以填 0/10/10/1。 然后拆一下组合数： dpa+b,j=j!∑l=0j2bldpa,ll!dpb,j−l(j−l)!dp_{a+b,j}=j!\\sum\\limits_{l=0}^j\\dfrac{2^{bl}dp_{a,l}}{l!}\\dfrac{dp_{b,j-l}}{(j-l)!}dpa+b,j​=j!l=0∑j​l!2bldpa,l​​(j−l)!dpb,j−l​​ 也就是说，我们可以这样倍增转移： {dpn,i=i!∑j=0idpn−1,j2jj!1(i−j)!dp2n,i=i!∑j=0i2njdpn,jj!dpn,i−j(i−j)!\\begin{cases}dp_{n,i}=i!\\sum\\limits_{j=0}^i\\dfrac{dp_{n-1,j}2^j}{j!}\\dfrac{1}{(i-j)!}\\\\dp_{2n,i}=i!\\sum\\limits_{j=0}^i\\dfrac{2^{nj}dp_{n,j}}{j!}\\dfrac{dp_{n,i-j}}{(i-j)!}\\end{cases}⎩⎪⎪⎨⎪⎪⎧​dpn,i​=i!j=0∑i​j!dpn−1,j​2j​(i−j)!1​dp2n,i​=i!j=0∑i​j!2njdpn,j​​(i−j)!dpn,i−j​​​ 好了，用 MTT 优化就行。 ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF623E Transforming Sequence 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf623e-transforming-sequence-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":217000,"words":726,"minutes":4},"date":"2023-03-24 14:35:23","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>给定一张 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 个点 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span> 条边的无重边无自环的有向图，你要从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 号点到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 号点去。</p>\n<p>如果你在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> 时刻之后到达 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 号点，你要交 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> 元的罚款。</p>\n<p>每条边从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">b_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，走过它需要花费 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 元，多次走过同一条边需要多次花费。</p>\n<p>走过每条边所需的时间是随机的，对于 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>t</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">k \\in [1,t]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mclose\">]</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><msub><mi>p</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msub><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{p_{i,k}}{10^5}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1594719999999998em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8144719999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\"><span class=\"mord mtight\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7463142857142857em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.51308em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29011428571428566em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 表示走过第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 条边需要时间 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的概率。因此如果多次走过同一条边，所需的时间也可能不同。</p>\n<p>你希望花费尽可能少的钱（花费与罚款之和）到达 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 号点，因此每到达一个点，你可能会更改原有的计划。</p>\n<p>求在最优决策下，你期望花费的钱数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">n \\le 50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">m \\le 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">t \\le 2 \\times 10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">x,c_i \\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></msubsup><msub><mi>p</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\sum_{k=1}^t p_{i,k} = 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.233166em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.933456em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>，答案精度误差 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\le 10^{-6}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一张 nnn 个点 mmm 条边的无重边无自环的有向图，你要从 111 号点到 nnn 号点去。 如果你在 ttt 时刻之后到达 nnn 号点，你要交 xxx 元的罚款。 每条边从 aia_iai​ 到 bib_ibi​，走过它需要花费 cic_ici​ 元，多次走过同一条边需要多次花费。 走过每条边所需的时间是随机的，对于 k∈[1,t]k \\in [1,t]k∈[1,t]，pi,k105\\frac{p_{i,k}}{10^5}105pi,k​​ 表示走过第 iii 条边需要时间 kkk 的概率。因此如果多次走过同一条边，所需的时间也可能不同。 你希望花费尽可能少的钱（花费与罚款之和）到达 nnn 号点，因此每到达一个点，你可能会更改原有的计划。 求在最优决策下，你期望花费的钱数。 n≤50n \\le 50n≤50，m≤100m \\le 100m≤100，t≤2×104t \\le 2 \\times 10^4t≤2×104，x,ci≤106x,c_i \\le 10^6x,ci​≤106，∑k=1tpi,k=105\\sum_{k=1}^t p_{i,k} = 10^5∑k=1t​pi,k​=105，答案精度误差 ≤10−6\\le 10^{-6}≤10−6。 首先设 dpi,jdp_{i,j}dpi,j​ 表示在 jjj 时刻开始，从 iii 走到 nnn 的最小花费，那么有： {dpn,i=0i≤tdpn,i=xi&gt;tdpu,i=min⁡u – j -&gt; vcj+∑k=1tpj,k105dpv,i+ku=n,i≤tdpu,i=dist⁡(u,n)+xu=n,i&gt;t\\begin{cases}dp_{n,i}=0&amp;i\\le t\\\\dp_{n,i}=x&amp;i&gt;t\\\\dp_{u,i}=\\min\\limits_{\\text{u -- j -&gt; v}}c_j+\\sum\\limits_{k=1}^t \\dfrac{p_{j,k}}{10^5}dp_{v,i+k}&amp;u\\not=n,i\\le t\\\\dp_{u,i}=\\operatorname{dist}(u,n)+x&amp;u\\not=n,i&gt;t\\end{cases}⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​dpn,i​=0dpn,i​=xdpu,i​=u – j -&gt; vmin​cj​+k=1∑t​105pj,k​​dpv,i+k​dpu,i​=dist(u,n)+x​i≤ti&gt;tu​=n,i≤tu​=n,i&gt;t​ 其中 dist⁡(x,y)\\operatorname{dist}(x,y)dist(x,y) 表示从 xxx 到 yyy 的最小花费（路程上的，不算罚款），我们最后需要 dp1,0dp_{1,0}dp1,0​。 由于这不一定是 DAG 而且 dijkstra 不好写所以需要 spfa，然而暴力跑 spfa 是 O(nmt2)O(nmt^2)O(nmt2) 的，显然不够优。 容易发现，令人讨厌的转移部分显然是 ∑k=1tpj,k105dpv,i+k\\sum\\limits_{k=1}^t \\dfrac{p_{j,k}}{10^5}dp_{v,i+k}k=1∑t​105pj,k​​dpv,i+k​，考虑优化这一部分。 令 p’j,t−k=pj,k105p’_{j,t-k}=\\dfrac{p_{j,k}}{10^5}p’j,t−k​=105pj,k​​，那么原式可化为： ∑k=1tpj,t−k′dpv,i+k\\sum\\limits_{k=1}^t p&#x27;_{j,t-k}dp_{v,i+k}k=1∑t​pj,t−k′​dpv,i+k​ 容易发现这是一个卷积的形式，下标和恒为 t−k+i+k=i+tt-k+i+k=i+tt−k+i+k=i+t，那么式子就变成了： (pj′∗dpv)i+t(p_j&#x27;*dp_v)_{i+t}(pj′​∗dpv​)i+t​ 所以优化后的转移为： {dpn,i=0i≤tdpn,i=xi&gt;tdpu,i=min⁡u – j -&gt; vcj+(pj′∗dpv)i+tu=n,i≤tdpu,i=dist⁡(u,n)+xu=n,i&gt;t\\begin{cases}dp_{n,i}=0&amp;i\\le t\\\\dp_{n,i}=x&amp;i&gt;t\\\\dp_{u,i}=\\min\\limits_{\\text{u -- j -&gt; v}}c_j+(p_j&#x27;*dp_v)_{i+t}&amp;u\\not=n,i\\le t\\\\dp_{u,i}=\\operatorname{dist}(u,n)+x&amp;u\\not=n,i&gt;t\\end{cases}⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​dpn,i​=0dpn,i​=xdpu,i​=u – j -&gt; vmin​cj​+(pj′​∗dpv​)i+t​dpu,i​=dist(u,n)+x​i≤ti&gt;tu​=n,i≤tu​=n,i&gt;t​ 跑 spfa 的话时间复杂度为 O(nmtlog⁡t)O(nmt\\log t)O(nmtlogt)，但是跑不满，而且有 8S，所以足够通过此题。 spfa 在反向图上跑即可，相当于倒着转移吧。 ","tags":[{"name":"概率、期望","slug":"zrK8Q1S2G","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/zrK8Q1S2G/"},{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF553E Kyoya and Train 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf553e-kyoya-and-train-zuo-ti-ji-lu/","stats":{"text":"5 min read","time":263000,"words":874,"minutes":5},"date":"2023-03-24 14:25:13","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>给出一个门限值 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 和两个只包含 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext mathvariant=\"monospace\">AGCT</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{AGCT}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">AGCT</span></span></span></span></span> 四种字符的基因串 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span>。现在你要找出在下列规则中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中出现了几次。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个位置中出现，当且仅当把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 的首字符和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 的第 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> 个字符对齐后，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 中的每一个字符能够在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中找到一个位置偏差不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的相同字符。</p>\n<p>即对于所有的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∣</mi><mi>T</mi><mi mathvariant=\"normal\">∣</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">j \\in[1,|T|]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">∣</span><span class=\"mclose\">]</span></span></span></span>，都存在一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∣</mi><mi>S</mi><mi mathvariant=\"normal\">∣</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">p \\in [1,|S|]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span><span class=\"mclose\">]</span></span></span></span> 使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>−</mo><mi>p</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">|(i+j-1)-p| \\leq k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo>=</mo><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_p=T_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 。</p>\n<p>例如 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext mathvariant=\"monospace\">ACAT</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{ACAT}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">ACAT</span></span></span></span></span> 出现在 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mtext mathvariant=\"monospace\">AGCAATTCAT</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{AGCAATTCAT}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">AGCAATTCAT</span></span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 号， <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 号和 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span></span></span></span> 号位置。 (编号从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 开始。)</p>\n</blockquote>\n","content":" 给出一个门限值 kkk 和两个只包含 AGCT\\texttt{AGCT}AGCT 四种字符的基因串 SSS 和 TTT。现在你要找出在下列规则中 TTT 在 SSS 中出现了几次。 TTT 在 SSS 的第 iii 个位置中出现，当且仅当把 TTT 的首字符和 SSS 的第 iii 个字符对齐后，TTT 中的每一个字符能够在 SSS 中找到一个位置偏差不超过 kkk 的相同字符。 即对于所有的 j∈[1,∣T∣]j \\in[1,|T|]j∈[1,∣T∣]，都存在一个 p∈[1,∣S∣]p \\in [1,|S|]p∈[1,∣S∣] 使得 ∣(i+j−1)−p∣≤k|(i+j-1)-p| \\leq k∣(i+j−1)−p∣≤k 且 Sp=TjS_p=T_jSp​=Tj​ 。 例如 k=1k=1k=1 时，ACAT\\texttt{ACAT}ACAT 出现在 AGCAATTCAT\\texttt{AGCAATTCAT}AGCAATTCAT 的 222 号， 333 号和 666 号位置。 (编号从 111 开始。) 考虑设 A,C,G,TA,C,G,TA,C,G,T 是四个 010101 序列，表示四种字母是否能在 SSS 的某一位上匹配；设 A∗,C∗,G∗,T∗A_*,C_*,G_*,T_*A∗​,C∗​,G∗​,T∗​ 是四个 010101 序列表示 TTT 的某一位上是否某种字母。 例如样例中： A={1,1,1,1,1,1,0,1,1,1}A=\\{1,1,1,1,1,1,0,1,1,1\\}A={1,1,1,1,1,1,0,1,1,1} C={0,1,1,1,0,0,1,1,1,0}C=\\{0,1,1,1,0,0,1,1,1,0\\}C={0,1,1,1,0,0,1,1,1,0} G={1,1,1,0,0,0,0,0,0,0}G=\\{1,1,1,0,0,0,0,0,0,0\\}G={1,1,1,0,0,0,0,0,0,0} T={0,0,0,0,1,1,1,1,1,1}T=\\{0,0,0,0,1,1,1,1,1,1\\}T={0,0,0,0,1,1,1,1,1,1} A∗={1,0,1,0}A_*=\\{1,0,1,0\\}A∗​={1,0,1,0} C∗={0,1,0,0}C_*=\\{0,1,0,0\\}C∗​={0,1,0,0} G∗={0,0,0,0}G_*=\\{0,0,0,0\\}G∗​={0,0,0,0} T∗={0,0,0,1}T_*=\\{0,0,0,1\\}T∗​={0,0,0,1} 若某个位置 SSS 和 TTT 对应的序列同时为 111，那么贡献 111，否则贡献 000，也就是做乘法。那么匹配当且仅当四种字符的贡献和是串长。 考虑怎么计算每种字符的贡献，显然把 AAA、CCC、GGG、TTT 倒过来和 A∗A_*A∗​、C∗C_*C∗​、G∗G_*G∗​、T∗T_*T∗​ 做卷积即可。 ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"}],"title":"CF528D Fuzzy Search 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf528d-fuzzy-search/","stats":{"text":"3 min read","time":166000,"words":561,"minutes":3},"date":"2023-03-24 12:44:25","dateFormat":"2023-03-24"},{"abstract":"","content":"0x00 基础知识 并查集是一种简单但又不简单的数据结构，它通常用来处理元素分组问题。 先看一道例题: nnn 个元素 mmm 个操作，初始时每个元素都属于独立的集合。每次操作为合并两个元素所在的集合或询问两个元素是否在一个集合内。 容易发现这道题最大的难点就在于表示元素所在的集合。不妨设 faufa_ufau​ 表示 uuu 的“帮主”，即为代表 uuu 所在的集合的元素。那么初始时显然 fau=ufa_u=ufau​=u。 合并 x,yx,yx,y 所在的集合时，我们似乎只需要让两位“帮主”打架，让 fax=fayfa_x=fa_yfax​=fay​。 不过手玩一下就会发现这样合并显然是错的。假设现在的情况是这样的： 合并 111 和 333 之后： 容易发现，此时 fa1fa_1fa1​ 并不是 111 所在集合真正的“帮主”。所以在找 uuu 所在的集合的“帮主”时我们需要不断让 u=fauu=fa_uu=fau​，即不停跳出“小帮派”，直到 fau=ufa_u=ufau​=u。 找“帮主”代码如下： int fa[200005]; int fnd(int x) { return fa[x]==x?x:fnd(fa[x]); } 但是这个找“帮主”算法太慢了，接下来介绍两种优化： 路径压缩 容易发现，我们在找“帮主”的过程中可以记录下 uuu 真正的“帮主”： int fa[200005]; int fnd(int x) { return fa[x]==x?x:fa[x]=fnd(fa[x]); } 这样优化之后找“帮主”算法的时间复杂度大概是 O(log⁡n)O(\\log n)O(logn) 的，证明可以看这里。 对于一般的题目，这个优化已经够用了。 按轶合并 若不能路径压缩，那么在合并两个集合时我们可以将“深度”大的集合合并到“深度”小的集合底下，其中“深度”表示属于这个集合的元素中找到“帮主”最多需要跳的次数。 启发式合并 可以保存集合的大小，每次让小的集合的“帮主”被大的集合的“帮主”打败，即让 fa小集合的“帮主”=大集合的“帮主”fa_{\\text{小集合的“帮主”}}=\\text{大集合的“帮主”}fa小集合的“帮主”​=大集合的“帮主”。 这个优化配合上路径压缩之后找“帮主”算法的时间复杂度将被优化到 α(n)\\alpha(n)α(n)，其中 α(n)\\alpha(n)α(n) 基本不会超过 444！ 例题代码如下：（远古代码，将就着看吧） #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;cstdio&gt; using namespace std; typedef long long lnt; const int maxn=1e4+5; int h[maxn]; int find(int a) { if(h[a]==a) { return a; } int root=find(h[a]); h[a]=root; return root; } int hb(int a,int b) { int ar,br; ar=find(a); br=find(b); h[br]=ar; } int is(int a,int b) { if(find(a)==find(b)) { return 1; } return 0; } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { h[i]=i; } for(int i=1;i&lt;=m;i++) { int x,y,z; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; if(z==1) { hb(x,y); } else if(z==2) { if(is(x,y)) { cout&lt;&lt;&quot;Y\\n&quot;; } else { cout&lt;&lt;&quot;N\\n&quot;; } } } return 0; } 0x01 小技巧 保存集合信息 有些题目需要我们维护集合的某些信息，例如大小，那么就可以让“帮主”带上这些信息。 边带权 有些时候，“帮主”对应着题目中某些特殊的元素，而我们要处理每个元素到它所对应的“帮主”的某些信息，那么我们就可以让并查集的边带上权值，在路径压缩的时候转移即可。 例如这道题，就可以维护 disudis_udisu​ 表示 uuu 到“帮主”（领队）的距离。 拆点 这个小技巧也是并查集的神奇所在。 有些题目中元素会有多种状态。若有 kkk 种，则可以把元素 iii 拆成 kkk 个元素：i,i+n,i+2n…i+(k−1)ni,i+n,i+2n\\dots i+(k-1)ni,i+n,i+2n…i+(k−1)n，这些元素分别代表状态为 1,2,3…k1,2,3\\dots k1,2,3…k 的 iii。 接下来，当得知 若 xxx 状态为 aaa，则 yyy 状态一定为 bbb；若 yyy 状态为 bbb，则 xxx 状态一定为 aaa 这种信息时，就可以把 x+(a−1)nx+(a-1)nx+(a−1)n 和 y+(b−1)ny+(b-1)ny+(b−1)n 合并到一个集合里，表示它们是同一种情况。 这样就可以通过已知条件求出所有可能的状态，并且若同一个元素的不同状态所代表的元素在一个集合里那么就说明无解。 例如 P2024 [NOI2001] 食物链 这题，就可以用 x,x+n,x+2nx,x+n,x+2nx,x+n,x+2n 分别表示 xxx 是 AAA、xxx 是 BBB 和 xxx 是 CCC 的情况。 0x02 练习题目 P1955 [NOI2015] 程序自动分析 P1196 [NOI2002] 银河英雄传说 P5937 [CEOI1999]Parity Game P1525 [NOIP2010 提高组] 关押罪犯 CF1594D The Number of Imposters CF1670C Where is the Pizza? ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"并查集学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/bing-cha-ji-xue-xi-bi-ji/","stats":{"text":"6 min read","time":321000,"words":1272,"minutes":6},"date":"2023-03-24 12:38:04","dateFormat":"2023-03-24"},{"abstract":"","content":"Day -1 虽然 NOIP 压线 1=，但是因为疫情所以参加不了提高组了/kk 只能参加普及组了。 Day 0 登录了一下系统，发现没问题。 尝试暴力破解压缩包密码，但是马上发现密码位数是十几位的，暴力跑要几万年…… 然后调试了一下录屏。 Day 1 洛谷运势大凶…… 一个小时想到了前三题： T1 模拟，但是题目好像没说 A=B=C=0A=B=C=0A=B=C=0 的情况怎么弄，不过测了一下好像没被 hack T2 贪心搞，目标是前缀异或和序列中没有 000 和重复的数字，操作是删掉一个前缀异或和序列中一个不在末尾的数。−1-1−1 的情况即为整个序列疑惑起来结果为 000 T3 二分答案，对于每一个 iii，求出分成最多 iii 个模块的 max⁡\\maxmax 的最小值 mnimn_imni​，然后答案就是 min⁡{i⋅mni}\\min\\{i\\cdot mn_i\\}min{i⋅mni​} T4 卡了好久，结果发现是乱搞题： T4 枚举公差，然后枚举这个公差构成的极长等差数列，然后乱搞。调和级数时间复杂度是 O(nlog⁡n)O(n\\log n)O(nlogn) 预计得分 100+100+100+100=400100+100+100+100=400100+100+100+100=400。 Day 2 T3 出题人 cbddl。 没有大样例的比赛 cbddl。 T1 可行的数 iii 满足 nmod⁡i=0n\\operatorname{mod} i\\not=0nmodi​=0，(n−1)mod⁡i=0(n-1)\\operatorname{mod} i\\not=0(n−1)modi​=0 和 (n−2)mod⁡i=0(n-2)\\operatorname{mod} i\\not=0(n−2)modi​=0，然后根号分解质因数用 set 维护就好 T2 题意奇奇怪怪，反正我写的是 n+叶子个数n+\\text{叶子个数}n+叶子个数 T3 大模拟，淦了 2h+ 才淦出来…… T4 堆优化广搜 最后几分钟才做完，wtcl！ 赛后出 Day 1 成绩了，竟然真的 AK 了。 赛后 T3 好像和别人拍过了？不排除同时错误的可能性…… T4 边界错了。太慌了所以有两个字符 1 写成了 0。 预计得分 100+100+100+0=300100+100+100+0=300100+100+100+0=300。 Day inf 成绩出了： Day 1：100+100+100+100=400 Day 2：100+100+5+100=305 总分：100+100+100+100+100+100+5+100=705 GDOI 普及组不给大样例体验太差了。 出 D2T3 这种垃圾题还省赛？？？没大样例的比赛还叫 OI？？？ cbddl。 2022/4/20 upd: 完了，造数据的时候发现 D1T3 我写的是 O(n2log⁡n)O(n^2\\log n)O(n2logn) 的假做法/qd 竟然过了。 ","tags":[{"name":2022,"slug":"GJvEuJsM-","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GJvEuJsM-/"},{"name":"GDOI","slug":"m_dUCQqMxF","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/m_dUCQqMxF/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"}],"title":"GDOI 2022 普及组游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/gdoi-2022-pu-ji-zu-you-ji/","stats":{"text":"3 min read","time":162000,"words":645,"minutes":3},"date":"2023-03-24 12:34:18","dateFormat":"2023-03-24"},{"abstract":"","content":"NTT 支持取模，没有精度问题，但是有模数限制。 FFT 支持取模，模数没有限制，但是有精度限制。 为了实现任意取模且几乎没有精度限制的多项式乘法，人们发明了 MTT。 模板题 基于 NTT 的实现 显然结果的实际值不超过 109×109×105=102310^9\\times 10^9\\times 10^5=10^{23}109×109×105=1023，那么我们可以求出结果模三个满足 ABC≥1023ABC\\ge 10^{23}ABC≥1023 的质数 AAA、BBB 和 CCC 的值，然后用中国剩余定理合并答案。 但是这种方法需要 999 次 NTT，常数极其巨大。 基于 FFT 的实现 既然 FFT 有精度限制，那么我们就要想办法降低运算所需要的精度。 不难想到，可以令 k=pk=\\sqrt pk=p​，F(x)=kA1(x)+B1(x)F(x)=kA_1(x)+B_1(x)F(x)=kA1​(x)+B1​(x)，G(x)=kA2(x)+B2(x)G(x)=kA_2(x)+B_2(x)G(x)=kA2​(x)+B2​(x)，那么有： F∗G=(kA1+B1)(kA2+B2)F*G=(kA_1+B_1)(kA_2+B_2) F∗G=(kA1​+B1​)(kA2​+B2​) =k2A1A2+k(A1B2+A2B1)+B1B2=k^2A_1A_2+k(A_1B_2+A_2B_1)+B_1B_2 =k2A1​A2​+k(A1​B2​+A2​B1​)+B1​B2​ DFT⁡(A1),DFT⁡(A2),DFT⁡(B1),DFT⁡(B2)\\operatorname{DFT}(A_1),\\operatorname{DFT}(A_2),\\operatorname{DFT}(B_1),\\operatorname{DFT}(B_2)DFT(A1​),DFT(A2​),DFT(B1​),DFT(B2​) 再 IDFT⁡(A1A2),IDFT⁡(A1B2+A2B1),DFT⁡(B1B2)\\operatorname{IDFT}(A_1A_2),\\operatorname{IDFT}(A_1B_2+A_2B_1),\\operatorname{DFT}(B_1B_2)IDFT(A1​A2​),IDFT(A1​B2​+A2​B1​),DFT(B1​B2​) 即可，共需 777 次 FFT。 可以再快点吗？ 当然可以！但是太过复杂不便于记忆，而且优化效果貌似不够明显，所以以后再补坑吧。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; const long long MS=500005; const long double PI=acos(-1); struct plex { long double x,y; plex(long double a=0,long double b=0) {x=a,y=b;} }; plex operator+(plex a,plex b) {return plex(a.x+b.x,a.y+b.y);} plex operator-(plex a,plex b) {return plex(a.x-b.x,a.y-b.y);} plex operator*(plex a,plex b) {return plex(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);} inline int getlen(int n) { int res=1; while(res&lt;n) res&lt;&lt;=1; return res; } int p_rev[MS],p_rev_lstn; inline void FFT(int n,plex a[],int tpe) { if(p_rev_lstn!=n) { p_rev_lstn=n; for(int i=0;i&lt;n;i++) p_rev[i]=(p_rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); } for(int i=0;i&lt;n;i++) if(p_rev[i]&lt;i) swap(a[p_rev[i]],a[i]); for(int mid=1;mid&lt;n;mid&lt;&lt;=1) { int len=mid&lt;&lt;1; plex Wn=plex(cos(2*PI/len),tpe*sin(2*PI/len)); for(int l=0;l&lt;n-len+1;l+=len) { plex Wk=plex(1,0); for(int k=0;k&lt;mid;k++,Wk=Wk*Wn) { plex x=a[l+k],y=Wk*a[l+mid+k]; a[l+k]=x+y,a[l+mid+k]=x-y; } } } } inline void DFT(int n,plex a[]) {FFT(n,a,1);} inline void IDFT(int n,plex a[]) { FFT(n,a,-1); for(int i=0;i&lt;n;i++) a[i].x/=n,a[i].y/=n; } plex A1[MS],B1[MS],A2[MS],B2[MS]; plex p_mul_tmp1[MS],p_mul_tmp2[MS],p_mul_tmp3[MS]; inline void PMUL(int n,int m,int resn,int F[],int G[],int res[],int p) { int len=getlen(n+m); int k=ceil(sqrt(p)); for(int i=0;i&lt;n;i++) A1[i].x=F[i]/k,B1[i].x=F[i]%k; for(int i=0;i&lt;m;i++) A2[i].x=G[i]/k,B2[i].x=G[i]%k; DFT(len,A1),DFT(len,A2),DFT(len,B1),DFT(len,B2); for(int i=0;i&lt;len;i++) p_mul_tmp1[i]=A1[i]*A2[i],p_mul_tmp2[i]=A1[i]*B2[i]+A2[i]*B1[i],p_mul_tmp3[i]=B1[i]*B2[i]; IDFT(len,p_mul_tmp1),IDFT(len,p_mul_tmp2),IDFT(len,p_mul_tmp3); for(int i=0;i&lt;resn;i++) { int x=(long long)(p_mul_tmp1[i].x+0.5)%p,y=(long long)(p_mul_tmp2[i].x+0.5)%p,z=(long long)(p_mul_tmp3[i].x+0.5)%p; res[i]=((1ll*k*k%p*x%p+1ll*k*y%p)%p+z)%p; } for(int i=0;i&lt;len;i++) A1[i]=A2[i]=B1[i]=B2[i]=p_mul_tmp1[i]=p_mul_tmp2[i]=p_mul_tmp3[i]=plex(); } int n,m,p; int F[MS],G[MS],res[MS]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); n++; m++; for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;F[i]); F[i]=(F[i]%p+p)%p; } for(int i=0;i&lt;m;i++) { scanf(&quot;%d&quot;,&amp;G[i]); G[i]=(G[i]%p+p)%p; } PMUL(n,m,n+m-1,F,G,res,p); for(int i=0;i&lt;n+m-1;i++) { printf(&quot;%d &quot;,res[i]); } printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"任意模数快速傅里叶变换（MTT）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ren-yi-mo-shu-kuai-su-fu-li-xie-bian-huan-mttxue-xi-bi-ji/","stats":{"text":"6 min read","time":337000,"words":1003,"minutes":6},"date":"2023-03-24 12:33:01","dateFormat":"2023-03-24"},{"abstract":"<blockquote>\n<p>给出一个长度为n的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1,a_2...a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。求构造出一个序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>i</mi><mn>2</mn></msub><mo>&lt;</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>&lt;</mo><msub><mi>i</mi><mi>k</mi></msub><mo>(</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">i_1 &lt; i_2 &lt; ... &lt; i_k(1\\le{k}\\le{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span></span><span class=\"mclose\">)</span></span></span></span> 使得 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mi mathvariant=\"normal\">&amp;</mi><msub><mi>a</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mi mathvariant=\"normal\">&amp;</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">&amp;</mi><msub><mi>a</mi><msub><mi>i</mi><mi>k</mi></msub></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a_{i_1}\\&amp;a_{i_2}\\&amp;...\\&amp;a_{i_k}=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9502999999999999em;vertical-align:-0.25586em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mord\">&amp;</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mord\">&amp;</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">&amp;</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15122857142857138em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25586em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。求方案数模 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">10^9+7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span>。</p>\n<p>也就是从<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msub><mi>a</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_i\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> 里面选出一个非空子集使这些数按位与起来为0。</p>\n</blockquote>\n","content":" 给出一个长度为n的序列 a1,a2...ana_1,a_2...a_na1​,a2​...an​。求构造出一个序列 i1&lt;i2&lt;...&lt;ik(1≤k≤n)i_1 &lt; i_2 &lt; ... &lt; i_k(1\\le{k}\\le{n})i1​&lt;i2​&lt;...&lt;ik​(1≤k≤n) 使得 ai1&amp;ai2&amp;...&amp;aik=0a_{i_1}\\&amp;a_{i_2}\\&amp;...\\&amp;a_{i_k}=0ai1​​&amp;ai2​​&amp;...&amp;aik​​=0。求方案数模 109+710^9+7109+7。 也就是从{ai}\\{a_i\\}{ai​} 里面选出一个非空子集使这些数按位与起来为0。 首先记 xxx“包含”yyy 当且仅当 x&amp;y=yx\\&amp;y=yx&amp;y=y，那么可以用 dpidp_idpi​ 表示按位与和包含 iii 的最长子序列长度，有转移 dpi−2j→dpi−2j+dpidp_{i-2^j}\\to dp_{i-2^j}+dp_{i}dpi−2j​→dpi−2j​+dpi​，其中 iii 包含 2j2^j2j。边界是 dpai=1dp_{a_i}=1dpai​​=1。 scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); dp[a[i]]++; } for(int j=0;j&lt;=25;j++) // 注意转移顺序，要先枚举 j 再枚举 i，要不然会算重 { for(int i=1;i&lt;=1000002;i++) { if((i&gt;&gt;j)&amp;1) { dp[i^(1&lt;&lt;j)]=dp[i^(1&lt;&lt;j)]+dp[i]; } } } 考虑答案的求解，令 pdipd_ipdi​ 表示与和包含 iii 的子序列个数，显然有 pdi=2dpi−1pd_i=2^{dp_i}-1pdi​=2dpi​−1。试着用容斥求出答案，令 gig_igi​ 表示所有满足 jjj 的二进制中有 iii 个 111 的 pdjpd_jpdj​ 的和，答案即为 g0−g1+g2−g3+g4−g5+…g_0-g_1+g_2-g_3+g_4-g_5+\\dotsg0​−g1​+g2​−g3​+g4​−g5​+… 完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int mod=1000000007; int n,a[1000005]; int bse[1000005],dp[1000005],g[30]; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); dp[a[i]]++; } for(int j=0;j&lt;=25;j++) // 注意转移顺序，要先枚举 j 再枚举 i，要不然会算重 { for(int i=1;i&lt;=1000002;i++) { if((i&gt;&gt;j)&amp;1) { dp[i^(1&lt;&lt;j)]=dp[i^(1&lt;&lt;j)]+dp[i]; } } } bse[0]=1; for(int i=1;i&lt;=n;i++) { bse[i]=2ll*bse[i-1]%mod; } for(int i=0;i&lt;=1000002;i++) { int cnt=0; for(int j=0;j&lt;=25;j++) { cnt+=(i&gt;&gt;j)&amp;1; } g[cnt]=((long long)g[cnt]+bse[dp[i]]-1+mod)%mod; // 长度为 dp[i] 的序列里取子序列有 2^dp[i]-1 种方案 } int ans=g[0]; for(int i=1;i&lt;=25;i++) { if(i&amp;1) { ans=(ans-g[i]+mod)%mod; } else { ans=(ans+g[i])%mod; } } printf(&quot;%d\\n&quot;,ans); return 0; } ","tags":[{"name":"DP","slug":"9IQfpBtLQ","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9IQfpBtLQ/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"}],"title":"CF449D Jzzhu and Numbers 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cf449d-jzzhu-and-numbers-zuo-ti-ji-lu/","stats":{"text":"4 min read","time":187000,"words":594,"minutes":4},"date":"2023-03-23 16:38:16","dateFormat":"2023-03-23"},{"abstract":"","content":"有了 NTT，就有了多项式全家桶…… 首先要感谢 @command_block 的文章《NTT 与多项式全家桶》以及 @Epsilon_Cube、@MoYuFang 和 @Diu 给予我的许多帮助。 因为板子在不断修 bug，所以代码最后统一放。 前置芝士 多项式的各种运算是怎么定义的 由于我们只知道多项式加法和多项式乘法，但是这已经够了。所以所有的多项式运算都是用多项式加法和乘法定义的。 次数界 很多时候我们只对多项式 fff 的前 nnn 项感兴趣（这时往往 fff 会有无限项），所以需要在 (modxn)\\pmod{x^n}(modxn) 的意义下运算。 由于多项式加法和多项式乘法的结果只会从低次项向高次项贡献，所以有： F(x)mod⁡xn+G(x)mod⁡xn≡F(x)+G(x)(modxn)F(x)mod⁡xn⋅G(x)mod⁡xn≡F(x)G(x)(modxn)\\begin{aligned} F(x)\\operatorname{mod}{x^n}+G(x)\\operatorname{mod}{x^n}&amp;\\equiv F(x)+G(x)&amp;\\pmod{x^n}\\\\ F(x)\\operatorname{mod}{x^n}\\cdot G(x)\\operatorname{mod}{x^n}&amp;\\equiv F(x)G(x)&amp;\\pmod{x^n}\\\\ \\end{aligned} F(x)modxn+G(x)modxnF(x)modxn⋅G(x)modxn​≡F(x)+G(x)≡F(x)G(x)​(modxn)(modxn)​ 即我们可以在有次数界的情况下定义所有多项式运算。 简单微积分 一些记号 [xi]F(x)[x^i]F(x)[xi]F(x)：多项式 F(x)F(x)F(x) 的 iii 次项的系数，即 xix^ixi 的系数； FR(x)F_R(x)FR​(x)：nnn 次多项式的翻转 FR(x)=xnF(1x)F_R(x)=x^nF(\\frac{1}{x})FR​(x)=xnF(x1​)，显然 FR(x)F_R(x)FR​(x) 的系数是 F(x)F(x)F(x) 的系数的翻转； F(n)(x)F^{(n)}(x)F(n)(x)：多项式 F(x)F(x)F(x) 的 nnn 阶导数，即对 F(x)F(x)F(x) 求导 nnn 次的结果； 多项式求导和积分 定义多项式的求导： F′(x)=∑i=0n−1ai+1(i+1)xiF^\\prime(x)=\\sum\\limits_{i=0}^{n-1} a_{i+1}(i+1)x^{i} F′(x)=i=0∑n−1​ai+1​(i+1)xi 定义多项式的积分（不定积分）： ∫F(x) dx=C+∑i=1nai−1xii\\int F(x)\\,dx=C+\\sum\\limits_{i=1}^{n} \\dfrac{a_{i-1}x^{i}}{i} ∫F(x)dx=C+i=1∑n​iai−1​xi​ 同样的，多项式求导和积分也是互为逆操作。 多项式牛顿迭代 这是一个比较重要的知识，有了它，就可以无脑推多项式各种操作的递推式了。 形式：已知函数 GGG 满足 G(F(x))=0G(F(x))=0G(F(x))=0，求 F(x)mod⁡xnF(x)\\operatorname{mod} x^nF(x)modxn。 实践中 GGG 一般较为手动构造的简单函数。 结论：F(x)≡F∗(x)−G(F∗(x))G′(F∗(x))(modxn)F(x)\\equiv F_*(x)-\\dfrac{G(F_*(x))}{G&#x27;(F_*(x))}\\pmod{x^n}F(x)≡F∗​(x)−G′(F∗​(x))G(F∗​(x))​(modxn)，其中 F∗(x)≡F(x)(modxn2)F_*(x)\\equiv F(x)\\pmod{x^{\\frac{n}{2}}}F∗​(x)≡F(x)(modx2n​)，注意 [x0]G(F(x))=0[x^0]G(F(x))=0[x0]G(F(x))=0 的解要单独求出。 和一般的牛迭十分相似，但是次数每次翻倍。证明如下： 假设目前已经求出了 F∗(x)F_*(x)F∗​(x)，考虑 G(F(x))G(F(x))G(F(x))在 F∗(x)F_*(x)F∗​(x) 处的泰勒展开： ∑i=0∞G(i)(F∗(x))i!(F(x)−F∗(x))i≡0(modxn)\\sum\\limits_{i=0}^{\\infin} \\frac{G^{(i)}(F_*(x))}{i!}(F(x)-F_*(x))^i\\equiv0\\pmod{x^n} i=0∑∞​i!G(i)(F∗​(x))​(F(x)−F∗​(x))i≡0(modxn) 注意到 F(x)−F∗(x)F(x)-F_*(x)F(x)−F∗​(x) 的最低系数非 000 项至少是 xn2x^{\\frac{n}{2}}x2n​，那么对于所有 i≥2i\\ge2i≥2 的 iii 都有 (F(x)−F∗(x))i≡0(modxn)(F(x)-F_*(x))^i\\equiv 0\\pmod{x^n}(F(x)−F∗​(x))i≡0(modxn)，所以： G(F∗(x))+G′(F∗(x))(F(x)−F∗(x))≡0(modxn)F(x)≡F∗(x)−G(F∗(x))G′(F∗(x))(modxn)\\begin{aligned} G(F_*(x))+G&#x27;(F_*(x))(F(x)-F_*(x))&amp;\\equiv0&amp;\\pmod{x^n}\\\\ F(x)&amp;\\equiv F_*(x)-\\frac{G(F_*(x))}{G&#x27;(F_*(x))}&amp;\\pmod{x^n}\\\\ \\end{aligned} G(F∗​(x))+G′(F∗​(x))(F(x)−F∗​(x))F(x)​≡0≡F∗​(x)−G′(F∗​(x))G(F∗​(x))​​(modxn)(modxn)​ 证毕。 多项式乘法逆 P4238 【模板】多项式乘法逆 假设已经求出了 B∗(x)F(x)≡1(modxn2)B_*(x)F(x)\\equiv 1\\pmod{x^{\\frac{n}{2}}}B∗​(x)F(x)≡1(modx2n​)，现在要求 B(x)F(x)≡1(modxn)B(x)F(x)\\equiv1\\pmod{x^n}B(x)F(x)≡1(modxn)，那么有： G(B(x))=1B(x)−F(x)≡0(modxn)\\begin{aligned} G(B(x))=\\frac{1}{B(x)}-F(x)\\equiv 0\\pmod{x^n} \\end{aligned} G(B(x))=B(x)1​−F(x)≡0(modxn)​ 则可以直接套牛顿迭代： B(x)≡B∗(x)−G(B∗(x))G′(B∗(x))(modxn)B(x)≡B∗(x)−1B∗(x)−F(x)−1B∗2(x)(modxn)B(x)≡B∗(x)+B∗(x)−B∗2F(x)(modxn)B(x)≡2B∗(x)−B∗2F(x)(modxn)\\begin{aligned} B(x)&amp;\\equiv B_*(x)-\\frac{G(B_*(x))}{G&#x27;(B_*(x))}&amp;\\pmod{x^n}\\\\ B(x)&amp;\\equiv B_*(x)-\\frac{\\frac{1}{B_*(x)}-F(x)}{-\\frac{1}{B_*^2(x)}}&amp;\\pmod{x^n}\\\\ B(x)&amp;\\equiv B_*(x)+B_*(x)-B_*^2F(x)&amp;\\pmod{x^n}\\\\ B(x)&amp;\\equiv 2B_*(x)-B_*^2F(x)&amp;\\pmod{x^n}\\\\ \\end{aligned} B(x)B(x)B(x)B(x)​≡B∗​(x)−G′(B∗​(x))G(B∗​(x))​≡B∗​(x)−−B∗2​(x)1​B∗​(x)1​−F(x)​≡B∗​(x)+B∗​(x)−B∗2​F(x)≡2B∗​(x)−B∗2​F(x)​(modxn)(modxn)(modxn)(modxn)​ 那么就可以做了，[x0]B(x)[x^0]B(x)[x0]B(x) 需要求一次乘法逆元，时间复杂度为 T(n)=T(n2)+O(nlog⁡n)=O(nlog⁡n)T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)T(n)=T(2n​)+O(nlogn)=O(nlogn)。 不过还有个优化，注意到 NTT 的过程代入的是单位根，所以求的实际上是循环卷积： F(x)G(x)=∑k=0mxk∑i+jmod m=kfigjF(x)G(x)=\\sum\\limits_{k=0}^mx^k\\sum\\limits_{i+j\\mod m=k} f_ig_j F(x)G(x)=k=0∑m​xki+jmodm=k∑​fi​gj​ 观察倍增式子： B(x)≡2B∗(x)−B∗2(x)F(x)(modxn)B(x)\\equiv 2B_*(x)-B_*^2(x)F(x)\\pmod{x^n} B(x)≡2B∗​(x)−B∗2​(x)F(x)(modxn) 需要用到乘法的只有 B∗2(x)F(x)B_*^2(x)F(x)B∗2​(x)F(x)。 先计算 B∗(x)F(x)B_*(x)F(x)B∗​(x)F(x)，它们的次数分别是 len2\\dfrac{len}{2}2len​ 和 lenlenlen。 由于结果的第一项为 111，这个 111 后面的 len2−1\\dfrac{len}{2}-12len​−1 项都为 000，所以长度为 lenlenlen 的循环卷积只会破坏前面的 111 和 000。 最后乘上一个 B∗(x)B_*(x)B∗​(x) 即可，此时循环卷积只会破坏前 len2\\dfrac{len}{2}2len​ 项。 多项式开根 P5205 【模板】多项式开根 P5277 【模板】多项式开根（加强版） 假设已经求出了 B∗2(x)≡F(x)(modxn2)B_*^2(x)\\equiv F(x)\\pmod{x^{\\frac{n}{2}}}B∗2​(x)≡F(x)(modx2n​)，现在要求 B(x)2≡F(x)(modxn)B(x)^2\\equiv F(x)\\pmod{x^n}B(x)2≡F(x)(modxn)，那么有： G(B(x))=B2(x)−F(x)≡0(modxn)G(B(x))=B^2(x)-F(x)\\equiv 0\\pmod{x^n} G(B(x))=B2(x)−F(x)≡0(modxn) 直接套牛迭： B(x)≡B∗(x)−G(B∗(x))G′(B∗(x))(mod2n)B(x)≡B∗(x)−B∗2(x)−F(x)2B∗(x)(mod2n)B(x)≡2B∗(x)2−B∗2(x)+F(x)2B∗(x)(mod2n)B(x)≡B∗2(x)+F(x)2B∗(x)(mod2n)\\begin{aligned} B(x)&amp;\\equiv B_*(x)-\\frac{G(B_*(x))}{G&#x27;(B_*(x))}&amp;\\pmod{2^n}\\\\ B(x)&amp;\\equiv B_*(x)-\\frac{B_*^2(x)-F(x)}{2B_*(x)}&amp;\\pmod{2^n}\\\\ B(x)&amp;\\equiv \\frac{2B_*(x)^2-B_*^2(x)+F(x)}{2B_*(x)}&amp;\\pmod{2^n}\\\\ B(x)&amp;\\equiv \\frac{B_*^2(x)+F(x)}{2B_*(x)}&amp;\\pmod{2^n}\\\\ \\end{aligned} B(x)B(x)B(x)B(x)​≡B∗​(x)−G′(B∗​(x))G(B∗​(x))​≡B∗​(x)−2B∗​(x)B∗2​(x)−F(x)​≡2B∗​(x)2B∗​(x)2−B∗2​(x)+F(x)​≡2B∗​(x)B∗2​(x)+F(x)​​(mod2n)(mod2n)(mod2n)(mod2n)​ 最后 [x0]B(x)[x^0]B(x)[x0]B(x) 需要求一次二次剩余，可以用 BSGS/exBSGS 求单位根的高次同余方程来求解，再加上一个求逆，一个乘法，一个加法就做完了。 时间复杂度为 T(n)=T(n2)+O(nlog⁡n)=O(nlog⁡n)T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)T(n)=T(2n​)+O(nlogn)=O(nlogn)。 多项式 ln⁡\\lnln P4725 【模板】多项式对数函数（多项式 ln） ln⁡(A(x))≡B(x)(modxn)\\ln(A(x))\\equiv B(x)\\pmod{x^n} ln(A(x))≡B(x)(modxn) 两边同时求导，得： ln⁡′(A(x))A′(x)≡B′(x)(modxn)\\ln&#x27;(A(x))A&#x27;(x)\\equiv B&#x27;(x)\\pmod{x^n} ln′(A(x))A′(x)≡B′(x)(modxn) 注意到 ln⁡′(x)=1x\\ln&#x27;(x)=\\dfrac{1}{x}ln′(x)=x1​，所以： A′(x)A(x)≡B′(x)(modxn)\\dfrac{A&#x27;(x)}{A(x)}\\equiv B&#x27;(x)\\pmod{x^n} A(x)A′(x)​≡B′(x)(modxn) 再积分回来： B(x)≡∫A′(x)A(x)dx(modxn)B(x)\\equiv \\int \\dfrac{A&#x27;(x)}{A(x)}dx\\pmod{x^n} B(x)≡∫A(x)A′(x)​dx(modxn) 所以一个求导，一个逆元，一个乘法，一个积分即可。 注意由于 [x0]A(x)=1[x^0]A(x)=1[x0]A(x)=1，所以有 [x0]B(x)=0[x^0]B(x)=0[x0]B(x)=0。并且若 [x0]A(x)=1[x^0]A(x)\\not=1[x0]A(x)​=1 则无法求 ln⁡\\lnln 因为求不出模意义下的 ln⁡([x0]A(x))\\ln([x^0]A(x))ln([x0]A(x))。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 多项式 exp⁡\\expexp P4726 【模板】多项式指数函数（多项式 exp） B(x)≡exp⁡(A(x))(modxn)B(x)\\equiv \\exp(A(x))\\pmod{x^n} B(x)≡exp(A(x))(modxn) 我们设 G(F(x))=ln⁡(F(x))−A(x)G(F(x))=\\ln(F(x))-A(x)G(F(x))=ln(F(x))−A(x)，那么显然 G(B(x))≡0(modxn)G(B(x))\\equiv0\\pmod{x^n}G(B(x))≡0(modxn)，可以使用牛顿迭代了。 回忆牛迭式子：F(x)≡F∗(x)−G(F∗(x))G′(F∗(x))(modxn)F(x)\\equiv F_*(x)-\\dfrac{G(F_*(x))}{G&#x27;(F_*(x))}\\pmod{x^n}F(x)≡F∗​(x)−G′(F∗​(x))G(F∗​(x))​(modxn) 显然，这里的 G′(F(x))=1F(X)G&#x27;(F(x))=\\dfrac{1}{F(X)}G′(F(x))=F(X)1​，那么假设我们已经求出了 B∗(x)≡exp⁡(A(x))(modxn2)B_*(x)\\equiv \\exp(A(x))\\pmod{x^{\\frac{n}{2}}}B∗​(x)≡exp(A(x))(modx2n​)，有： B(x)≡B∗(x)−G(B∗(x))B∗(x)(modxn)B(x)≡B∗(x)−(ln⁡(B∗(x))−A(x))B∗(x)(modxn)B(x)≡(1−ln⁡(B∗(x))+A(x))B∗(x)(modxn)\\begin{aligned} B(x)&amp;\\equiv B_*(x)-G(B_*(x))B_*(x)&amp;\\pmod{x^n}\\\\ B(x)&amp;\\equiv B_*(x)-(\\ln(B_*(x))-A(x))B_*(x)&amp;\\pmod{x^n}\\\\ B(x)&amp;\\equiv (1-\\ln(B_*(x))+A(x))B_*(x)&amp;\\pmod{x^n}\\\\ \\end{aligned} B(x)B(x)B(x)​≡B∗​(x)−G(B∗​(x))B∗​(x)≡B∗​(x)−(ln(B∗​(x))−A(x))B∗​(x)≡(1−ln(B∗​(x))+A(x))B∗​(x)​(modxn)(modxn)(modxn)​ 所以倍增求即可。 注意由于 [x0]A(x)=0[x^0]A(x)=0[x0]A(x)=0，所以有 [x0]B(x)=1[x^0]B(x)=1[x0]B(x)=1。并且若 [x0]A(x)=0[x^0]A(x)\\not=0[x0]A(x)​=0 则无法求 exp⁡\\expexp 因为求不出模意义下的 exp⁡([x0]A(x))\\exp([x^0]A(x))exp([x0]A(x))。 时间复杂度为 T(n)=T(n2)+O(nlog⁡n)=O(nlog⁡n)T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)T(n)=T(2n​)+O(nlogn)=O(nlogn)。 多项式快速幂 P5245 【模板】多项式快速幂 观察到 (A(x))k=exp⁡(kln⁡(A(x)))(A(x))^k=\\exp(k\\ln(A(x)))(A(x))k=exp(kln(A(x)))，所以一个 ln⁡\\lnln，一个逐项乘法，一个 exp⁡\\expexp 就做完了。 P5273 【模板】多项式幂函数（加强版） 这题和上一题的区别在于有 A0=1A_0\\not=1A0​​=1 的情况，这时我们就没办法求 ln⁡\\lnln 和 exp⁡\\expexp 了。 但是 A0=1A_0\\not=1A0​​=1 没关系，我们可以让所有项都乘上 1A0\\dfrac{1}{A_0}A0​1​，最后再都乘上 A0kA_0^kA0k​ 即可。 遇到 A0=0A_0=0A0​=0 的情况也没关系，把系数往前移，求出答案后再移回去即可。不过要注意原来前面 cntcntcnt 个 000 在做幂运算后会变成 cnt×kcnt\\times kcnt×k 个 000。 多项式带余除法 P4512 【模板】多项式除法 发现余数很烦，所以我们想办法去掉它。 舍弃多项式的项的方法是一般是加上次数界，但注意到次数界只能舍弃高次，所以考虑把多项式的系数反过来搞。 那么回到题目的式子： F(x)=Q(x)G(x)+R(x)F(x)=Q(x)G(x)+R(x) F(x)=Q(x)G(x)+R(x) 其中 FFF 是 nnn 次多项式（已知），GGG 是 mmm 次多项式（已知），QQQ 是 n−mn-mn−m 次多项式（未知），RRR 是 m−1m-1m−1 次多项式（未知）。 换元，有： F(1x)=Q(1x)G(1x)+R(1x)F(\\frac{1}{x})=Q(\\frac{1}{x})G(\\frac{1}{x})+R(\\frac{1}{x}) F(x1​)=Q(x1​)G(x1​)+R(x1​) 同乘 xnx^nxn，有: xnF(1x)=xnQ(1x)G(1x)+xnR(1x)x^nF(\\frac{1}{x})=x^nQ(\\frac{1}{x})G(\\frac{1}{x})+x^nR(\\frac{1}{x}) xnF(x1​)=xnQ(x1​)G(x1​)+xnR(x1​) 发现 xnF(1x)=FR(x)x^nF(\\frac{1}{x})=F_R(x)xnF(x1​)=FR​(x)，xnQ(1x)G(1x)=QR(x)GR(x)x^nQ(\\frac{1}{x})G(\\frac{1}{x})=Q_R(x)G_R(x)xnQ(x1​)G(x1​)=QR​(x)GR​(x)，xnR(1x)=xn−m+1RR(x)x^nR(\\frac{1}{x})=x^{n-m+1}R_R(x)xnR(x1​)=xn−m+1RR​(x)，所以有： FR(x)=QR(x)GR(x)+xn−m+1RR(x)F_R(x)=Q_R(x)G_R(x)+x^{n-m+1}R_R(x) FR​(x)=QR​(x)GR​(x)+xn−m+1RR​(x) 那么我们机智地加上次数界，mod⁡\\operatorname{mod}mod 上 xn−m+1x^{n-m+1}xn−m+1，就有： FR(x)≡QR(x)GR(x)(modxn−m+1)F_R(x)\\equiv Q_R(x)G_R(x)\\pmod{x^{n-m+1}} FR​(x)≡QR​(x)GR​(x)(modxn−m+1) 那么就可以求出 QR(x)Q_R(x)QR​(x) 了，系数反过来就是 Q(x)Q(x)Q(x)，然后即可用乘法和减法求出 R(x)R(x)R(x)，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 完整模板 展开 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;map&gt; #include &lt;cmath&gt; using namespace std; const long long MS=5000005; const int p=998244353,ginv=332748118; inline int read(bool mo=false) { int s=0,w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=mo?(10ll*s+ch-48)%p:10*s+ch-48,ch=getchar(); return s*w; } void writen(int x) { if(x&gt;9) writen(x/10); putchar(x%10|48); } inline int gcd(int a,int b) { int t=a%b; while(t!=0) a=b,b=t,t=a%b; return b; } inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1) res=((y&amp;1)?1ll*res*x%p:res),x=1ll*x*x%p; return res; } inline int exBSGS(int a,int b,int p) { a%=p,b%=p; if(b==1||p==1) return 0; int cnt=0,val=1; while(1) { int d=gcd(a,p); if(d==1) break; if(b%d!=0) return -1; p/=d; b/=d; val=1ll*val*(a/d)%p; cnt++; if(val==b) return cnt; } map&lt;int,int&gt; mp; int val2=1,t=sqrt(p)+1; for(int B=1;B&lt;=t;B++) { val2=1ll*val2*a%p; mp[1ll*b*val2%p]=B; } int cur=val; for(int A=1;A&lt;=t;A++) { cur=1ll*cur*val2%p; if(mp.find(cur)!=mp.end()) return A*t-mp[cur]+cnt; } return -1; } inline int mosqrt(int x) { int bse=exBSGS(3,x,p); if(bse==-1||(bse&amp;1)) return -1; return qpow(3,bse/2); } inline int getlen(int n) { int res=1; while(res&lt;n) res&lt;&lt;=1; return res; } int p_rev[MS],p_rev_lstn; inline void NTT(int n,int a[],int tpe) { if(p_rev_lstn!=n) { p_rev_lstn=n; for(int i=0;i&lt;n;i++) p_rev[i]=(p_rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); } for(int i=0;i&lt;n;i++) if(p_rev[i]&lt;i) swap(a[p_rev[i]],a[i]); int g=tpe==1?3:ginv; for(int mid=1;mid&lt;n;mid&lt;&lt;=1) { int len=mid&lt;&lt;1,Wn=qpow(g,(p-1)/len); for(int l=0;l&lt;n-len+1;l+=len) { for(int k=0,Wk=1;k&lt;mid;k++,Wk=1ll*Wk*Wn%p) { int x=a[l+k],y=1ll*Wk*a[l+mid+k]%p; a[l+k]=(x+y)%p,a[l+mid+k]=(x-y+p)%p; } } } } inline void DFT(int n,int a[]){NTT(n,a,1);} inline void IDFT(int n,int a[]) { NTT(n,a,-1); int inv=qpow(n,p-2); for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*inv%p; } int p_tmp[MS],p_tmp2[MS],p_tmp3[MS],p_tmp4[MS],p_tmp5[MS],p_tmp6[MS],p_tmp7[MS],p_tmp8[MS],p_tmpinv[MS]; inline void PDAO(int n,int a[],int res[]) { for(int i=1;i&lt;n;i++) res[i-1]=1ll*a[i]*i%p; res[n-1]=0; } inline void PJIFEN(int n,int a[],int res[]) { for(int i=1;i&lt;n;i++) if(p_tmpinv[i]==0) p_tmpinv[i]=(i==1?1:1ll*p_tmpinv[p%i]*(p-p/i)%p); for(int i=1;i&lt;n;i++) res[i]=1ll*a[i-1]*p_tmpinv[i]%p; res[0]=0; } inline void PINV(int n,int a[],int res[]) // used tmp1~2 { int m=getlen(n); for(int i=0;i&lt;m;i++) res[i]=0; res[0]=qpow(a[0],p-2); for(int len=2;len&lt;=m;len&lt;&lt;=1) { for(int i=0;i&lt;len;i++) p_tmp[i]=res[i],p_tmp2[i]=a[i]; DFT(len,p_tmp),DFT(len,p_tmp2); for(int i=0;i&lt;len;i++) p_tmp[i]=1ll*p_tmp[i]*p_tmp2[i]%p; IDFT(len,p_tmp); for(int i=0;i&lt;len&gt;&gt;1;i++) p_tmp[i]=0; p_tmp[0]=1; for(int i=0;i&lt;len;i++) p_tmp2[i]=res[i]; DFT(len,p_tmp),DFT(len,p_tmp2); for(int i=0;i&lt;len;i++) p_tmp[i]=1ll*p_tmp[i]*p_tmp2[i]%p; IDFT(len,p_tmp); for(int i=len&gt;&gt;1;i&lt;len;i++) res[i]=((res[i]&lt;&lt;1)-p_tmp[i]+p)%p; } for(int i=0;i&lt;m;i++) p_tmp[i]=p_tmp2[i]=0; for(int i=n;i&lt;m;i++) res[i]=0; } inline void PSQRT(int n,int a[],int res[]) // used tmp1~4 { res[0]=mosqrt(a[0]); if(res[0]==-1) return; int m=getlen(n)&lt;&lt;1,inv2=qpow(2,p-2); // 由于未知原因所以这里 m 要翻倍 for(int i=0;i&lt;m;i++) res[i]=0; for(int len=2;len&lt;=m;len&lt;&lt;=1) { PINV(len&gt;&gt;1,res,p_tmp3); for(int i=0;i&lt;len&gt;&gt;1;i++) p_tmp4[i]=a[i]; DFT(len,p_tmp3),DFT(len,p_tmp4); for(int i=0;i&lt;len;i++) p_tmp3[i]=1ll*p_tmp3[i]*p_tmp4[i]%p; IDFT(len,p_tmp3); for(int i=0;i&lt;len&gt;&gt;1;i++) p_tmp3[i]=(p_tmp3[i]+res[i])%p; for(int i=0;i&lt;len;i++) res[i]=1ll*p_tmp3[i]*inv2%p,p_tmp3[i]=p_tmp4[i]=0; } for(int i=0;i&lt;m;i++) p_tmp3[i]=p_tmp4[i]=0; for(int i=n;i&lt;m;i++) res[i]=0; } inline void PLN(int n,int a[],int res[]) // used tmp1~4 { for(int i=0;i&lt;n;i++) res[i]=0; PDAO(n,a,p_tmp3),PINV(n,a,p_tmp4); int lim=getlen(n+n); DFT(lim,p_tmp3),DFT(lim,p_tmp4); for(int i=0;i&lt;lim;i++) p_tmp3[i]=1ll*p_tmp3[i]*p_tmp4[i]%p; IDFT(lim,p_tmp3); PJIFEN(n,p_tmp3,res); for(int i=0;i&lt;lim;i++) p_tmp3[i]=p_tmp4[i]=0; } inline void PEXP(int n,int a[],int res[]) // used tmp1~6 { int m=getlen(n); for(int i=0;i&lt;m;i++) res[i]=0; res[0]=1; for(int len=2;len&lt;=m;len&lt;&lt;=1) { for(int i=0;i&lt;len;i++) p_tmp5[i]=res[i]; PLN(len,p_tmp5,p_tmp6); for(int i=0;i&lt;len;i++) p_tmp6[i]=(a[i]-p_tmp6[i]+p)%p; p_tmp6[0]=(p_tmp6[0]+1)%p; DFT(len&lt;&lt;1,p_tmp5),DFT(len&lt;&lt;1,p_tmp6); for(int i=0;i&lt;len&lt;&lt;1;i++) p_tmp5[i]=1ll*p_tmp5[i]*p_tmp6[i]%p; IDFT(len&lt;&lt;1,p_tmp5); for(int i=0;i&lt;len;i++) res[i]=p_tmp5[i]; } for(int i=0;i&lt;m&lt;&lt;1;i++) p_tmp5[i]=p_tmp6[i]=0; for(int i=n;i&lt;m;i++) res[i]=0; } inline void PPOW(int n,int k,int a[],int res[]) // used tmp1~7 { for(int i=0;i&lt;n;i++) res[i]=0; PLN(n,a,p_tmp7); for(int i=0;i&lt;n;i++) p_tmp7[i]=(1ll*p_tmp7[i]*k)%p; PEXP(n,p_tmp7,res); for(int i=0;i&lt;n;i++) p_tmp7[i]=0; } inline void PPOW2read(int &amp;k,int &amp;k2) { k=k2=0; int ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') { long long tmp=10ll*k+ch-48,tmp2=10ll*k2+ch-48; k=tmp%p; k2=tmp2%(p-1); if(tmp&gt;=p) k+=p; if(tmp2&gt;=p-1) k2+=p-1; ch=getchar(); } } inline void PPOW2(int n,int k,int k2,int a[],int res[]) // used tmp1~8 { for(int i=0;i&lt;n;i++) res[i]=0; int pos=0; while(pos&lt;n&amp;&amp;a[pos]==0) pos++; if(1ll*pos*k&gt;=n) return; int len0=pos*k; int len=n-len0,inv=qpow(a[pos],p-2),val=qpow(a[pos],k2); for(int i=0;i&lt;len;i++) p_tmp7[i]=1ll*a[pos+i]*inv%p; PLN(len,p_tmp7,p_tmp8); for(int i=0;i&lt;len;i++) p_tmp8[i]=1ll*p_tmp8[i]*k%p,p_tmp7[i]=0; PEXP(len,p_tmp8,p_tmp7); for(int i=0;i&lt;len0;i++) res[i]=0; for(int i=len0;i&lt;n;i++) res[i]=1ll*p_tmp7[i-len0]*val%p; for(int i=0;i&lt;len;i++) p_tmp7[i]=p_tmp8[i]=0; } inline void PDIV(int n,int m,int a[],int b[],int res[],int r[]) // used tmp1~4 { int len=n-m+1; for(int i=0;i&lt;min(len,m);i++) p_tmp3[i]=b[m-1-i]; // 反转 b PINV(len,p_tmp3,p_tmp4); // 求逆 for(int i=0;i&lt;len;i++) p_tmp3[i]=a[n-1-i]; // 反转 a int lim=getlen(len+len); DFT(lim,p_tmp3),DFT(lim,p_tmp4); for(int i=0;i&lt;lim;i++) p_tmp3[i]=1ll*p_tmp3[i]*p_tmp4[i]%p; // a 的反转乘上 b 的反转的逆 IDFT(lim,p_tmp3); for(int i=0;i&lt;len;i++) res[i]=p_tmp3[len-1-i]; // 得出商 for(int i=0;i&lt;lim;i++) p_tmp3[i]=p_tmp4[i]=0; // 清空数组 for(int i=0;i&lt;m;i++) p_tmp3[i]=b[i]; for(int i=0;i&lt;len;i++) p_tmp4[i]=res[i]; lim=getlen(m+len); DFT(lim,p_tmp3),DFT(lim,p_tmp4); for(int i=0;i&lt;lim;i++) r[i]=1ll*p_tmp3[i]*p_tmp4[i]%p; // 除数乘上商，准备求余数 IDFT(lim,r); for(int i=0;i&lt;m-1;i++) r[i]=(a[i]-r[i]+p)%p; // 求余数 for(int i=m-1;i&lt;lim;i++) r[i]=0; // 清空数组 for(int i=0;i&lt;lim;i++) p_tmp3[i]=p_tmp4[i]=0; // 清空数组 } 更快的板子 展开 #include &lt;bits/stdc++.h&gt; using ull = unsigned long long; const int N = 280000; const int Mod = 998244353; typedef std::vector&lt;int&gt; Poly; namespace Pol { int pow(int a, int b, int ans = 1); int add(int a, int b) { return (a += b) &gt;= Mod ? a -= Mod : a; } int sub(int a, int b) { return (a -= b) &lt; 0 ? a += Mod : a; } void inc(int &amp;a, int b) { (a += b) &gt;= Mod ? a -= Mod : a; } void dec(int &amp;a, int b) { (a -= b) &lt; 0 ? a += Mod : a; } void init_Poly(int n = N); void DIT(int *A, int lim); void DIF(int *A, int lim); Poly inv(Poly A, int n); Poly mult(const Poly &amp;A, int n, const Poly &amp;B, int m); Poly operator*(const Poly &amp;A, const Poly &amp;B) { return mult(A, A.size(), B, B.size()); } Poly Tmul(const Poly &amp;A, int n, const Poly &amp;B, int m); Poly getv(Poly A, int n, const std::vector&lt;int&gt; &amp;f, int m); Poly drv(const Poly &amp;A, int n); Poly itg(const Poly &amp;A, int n); Poly ln(const Poly &amp;A, int n); Poly exp(Poly A, int n); int fac[N], ifac[N], iv[N]; Poly G[N &lt;&lt; 1]; ull tmp[N]; int gw[N]; } // namespace Pol int main() { Pol::init_Poly(); int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); Poly F(n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;F[i]); Poly G = Pol::ln(Pol::inv(Pol::exp(F, n), n), n); for (int i = 0; i &lt; n; ++i) printf(&quot;%d%c&quot;, G[i], &quot; \\n&quot;[i == n - 1]); std::vector&lt;int&gt; f(m); for (int i = 0; i &lt; m; ++i) scanf(&quot;%d&quot;, &amp;f[i]); G = Pol::getv(F, n, f, m); for (int i = 0; i &lt; m; ++i) printf(&quot;%d%c&quot;, G[i], &quot; \\n&quot;[i == m - 1]); return 0; } namespace Pol { void DIT(int *A, int lim) { for (int i = 0; i &lt; lim; ++i) tmp[i] = A[i]; for (int l = 1; l &lt; lim; l &lt;&lt;= 1) { ull *k = tmp; for (int *g = gw; k &lt; tmp + lim; k += (l &lt;&lt; 1), ++g) { for (ull *x = k; x &lt; k + l; ++x) { int o = x[l] % Mod; x[l] = 1ll * (*x + Mod - o) **g % Mod, *x += o; } } } int iv = pow(lim, Mod - 2); for (int i = 0; i &lt; lim; ++i) A[i] = 1ll * tmp[i] % Mod * iv % Mod; std::reverse(A + 1, A + lim); } void DIF(int *A, int lim) { for (int i = 0; i &lt; lim; ++i) tmp[i] = A[i]; for (int l = lim / 2; l &gt;= 1; l &gt;&gt;= 1) { ull *k = tmp; for (int *g = gw; k &lt; tmp + lim; k += (l &lt;&lt; 1), ++g) { for (ull *x = k; x &lt; k + l; ++x) { int o = 1ll * x[l] **g % Mod; x[l] = *x + Mod - o, *x += o; } } } for (int i = 0; i &lt; lim; ++i) A[i] = tmp[i] % Mod; } Poly mult(const Poly &amp;A, int n, const Poly &amp;B, int m) { if (n + m &lt; 255) { Poly ans(n + m - 1); std::fill(tmp, tmp + n + m, 0); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) tmp[i + j] += 1ll * A[i] * B[j] % Mod; for (int i = 0; i &lt; n + m - 1; ++i) ans[i] = tmp[i] % Mod; return ans; } int lim = 1; while (lim &lt; (n + m - 1)) lim &lt;&lt;= 1; static int tA[N], tB[N]; std::copy_n(A.begin(), n, tA), std::fill(tA + n, tA + lim, 0); std::copy_n(B.begin(), m, tB), std::fill(tB + m, tB + lim, 0); DIF(tA, lim), DIF(tB, lim); for (int i = 0; i &lt; lim; ++i) tA[i] = 1ll * tA[i] * tB[i] % Mod; DIT(tA, lim); Poly ans(n + m - 1); std::copy_n(tA, n + m - 1, ans.begin()); return ans; } Poly Tmul(const Poly &amp;A, int n, const Poly &amp;B, int m) { if (n + m &lt; 255) { Poly ans(m - n + 1); std::fill(tmp, tmp + m - n + 2, 0); for (int i = 0; i &lt; m; ++i) for (int j = i; j &lt; n; ++j) tmp[j - i] += 1ll * B[i] * A[j] % Mod; for (int i = 0; i &lt; m - n + 1; ++i) ans[i] = tmp[i] % Mod; } int lim = 1; while (lim &lt; m) lim &lt;&lt;= 1; static int tA[N], tB[N]; std::reverse_copy(A.begin(), A.begin() + n, tA), std::fill(tA + n, tA + lim, 0); std::copy_n(B.begin(), m, tB), std::fill(tB + m, tB + lim, 0); DIF(tA, lim), DIF(tB, lim); for (int i = 0; i &lt; lim; ++i) tA[i] = 1ll * tA[i] * tB[i] % Mod; DIT(tA, lim); Poly ans(m - n + 1); std::copy_n(tA + n - 1, m - n + 1, ans.begin()); return ans; } Poly inv(Poly A, int n) { int lim = 1; while (lim &lt; (n &lt;&lt; 1)) lim &lt;&lt;= 1; Poly F(lim), G(lim); A.resize(lim); G[0] = pow(A[0], Mod - 2); int now = 1; static int tA[N], tB[N]; while (now &lt; n) { std::copy_n(A.begin(), now &lt;&lt; 1, F.begin()); int lim = now &lt;&lt; 2; std::copy_n(G.begin(), lim, tA); std::copy_n(F.begin(), lim, tB); DIF(tA, lim), DIF(tB, lim); for (int i = 0; i &lt; lim; ++i) tA[i] = 1ll * sub(2, 1ll * tA[i] * tB[i] % Mod) * tA[i] % Mod; DIT(tA, lim); std::copy_n(tA, now &lt;&lt; 1, G.begin()); now &lt;&lt;= 1; } G.resize(n); return G; } Poly drv(const Poly &amp;A, int n) { Poly ans(n - 1); for (int i = 0; i &lt; n - 1; ++i) ans[i] = 1ll * A[i + 1] * (i + 1) % Mod; return ans; } Poly itg(const Poly &amp;A, int n) { Poly ans(n + 1); for (int i = 0; i &lt; n; ++i) ans[i + 1] = 1ll * A[i] * iv[i + 1] % Mod; return ans; } Poly ln(const Poly &amp;A, int n) { Poly F = drv(A, n), G = inv(A, n); F = mult(F, n - 1, G, n); F.resize(n - 1); F = itg(F, n - 1); return F; } Poly exp(Poly A, int n) { int lim = 1; while (lim &lt; (n &lt;&lt; 1)) lim &lt;&lt;= 1; A.resize(lim); Poly L(lim); int now = 1; static int tF[N], tG[N], tL[N]; std::fill(tG, tG + lim, 0), std::fill(tF, tF + lim, 0); tG[0] = 1; while (now &lt; n) { int lim = now &lt;&lt; 2; std::copy_n(tG, now, L.begin()); L = ln(L, std::min(now &lt;&lt; 1, n)); L.resize(lim); std::copy_n(A.begin(), now &lt;&lt; 1, tF); std::copy_n(L.begin(), lim, tL); DIF(tF, lim), DIF(tG, lim), DIF(tL, lim); for (int i = 0; i &lt; lim; ++i) tG[i] = 1ll * tG[i] * sub(add(1, tF[i]), tL[i]) % Mod; DIT(tG, lim); std::fill(tG + (now &lt;&lt; 1), tG + lim, 0); now &lt;&lt;= 1; } Poly G(n); std::copy_n(tG, n, G.begin()); return G; } void getg(int x, int xl, int xr, const Poly &amp;f, int m) { if (xl == xr) { G[x].resize(2); G[x][0] = 1; if (xl &gt;= m) G[x][1] = 0; else G[x][1] = Mod - f[xl]; return; } int xm = (xl + xr) &gt;&gt; 1; getg(x &lt;&lt; 1, xl, xm, f, m), getg(x &lt;&lt; 1 | 1, xm + 1, xr, f, m); G[x] = mult(G[x &lt;&lt; 1], xm - xl + 2, G[x &lt;&lt; 1 | 1], xr - xm + 1); } void getans(int x, int xl, int xr, Poly &amp;ans, int m, const Poly &amp;h) { if (xl &gt;= m) return; if (xl == xr) return void(ans[xl] = h[0]); int xm = (xl + xr) &gt;&gt; 1; Poly hl = Tmul(G[x &lt;&lt; 1 | 1], xr - xm + 1, h, xr - xl + 1); getans(x &lt;&lt; 1, xl, xm, ans, m, hl); Poly hr = Tmul(G[x &lt;&lt; 1], xm - xl + 2, h, xr - xl + 1); getans(x &lt;&lt; 1 | 1, xm + 1, xr, ans, m, hr); } Poly getv(Poly A, int n, const std::vector&lt;int&gt; &amp;f, int m) { n = std::max(n, m); A.resize(n); getg(1, 0, n - 1, f, m); Poly now = inv(G[1], n); std::reverse(now.begin(), now.begin() + n); Poly h = mult(now, n, A, n); for (int i = 0; i &lt; n; ++i) h[i] = h[i + n - 1]; h.resize(n); Poly ans(m); getans(1, 0, n - 1, ans, m, h); return ans; } void init_Poly(int n) { int t = 1; while ((1 &lt;&lt; t) &lt; n) ++t; t = std::min(t - 1, 21); gw[0] = 1, gw[1 &lt;&lt; t] = pow(31, 1 &lt;&lt; (21 - t)); for (int i = t; i; --i) gw[1 &lt;&lt; (i - 1)] = 1ll * gw[1 &lt;&lt; i] * gw[1 &lt;&lt; i] % Mod; for (int i = 1; i &lt; (1 &lt;&lt; t); ++i) gw[i] = 1ll * gw[i &amp; (i - 1)] * gw[i &amp; -i] % Mod; --n; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod; ifac[n] = Pol::pow(fac[n], Mod - 2); for (int i = n - 1; i &gt;= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod; for (int i = 1; i &lt;= n; ++i) iv[i] = 1ll * ifac[i] * fac[i - 1] % Mod; } int pow(int a, int b, int ans) { while (b) { if (b &amp; 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b &gt;&gt;= 1; } return ans; } } // namespace Pol ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"多项式全家桶学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/duo-xiang-shi-quan-jia-tong-xue-xi-bi-ji/","stats":{"text":"39 min read","time":2309000,"words":6759,"minutes":39},"date":"2023-03-23 16:32:09","dateFormat":"2023-03-23"},{"abstract":"","content":"BSGS 是一个用来求高次同余方程的暴力算法。 先看一道例题: 给定 a,b,pa,b,pa,b,p，保证 a,b,p≥2a,b,p\\ge2a,b,p≥2 且 gcd⁡(a,p)=1\\operatorname{gcd}(a,p)=1gcd(a,p)=1，求 ax≡b(modp)a^x\\equiv b\\pmod pax≡b(modp) 的最小自然数解 xxx。 显然，我们可以暴力从小到大枚举 xxx，判断每个 xxx 是否合法。根据欧拉的神奇定理，aφ(p)≡1(modp)a^{\\varphi(p)}\\equiv 1\\pmod paφ(p)≡1(modp)，我们只需要枚举到 φ(p)\\varphi(p)φ(p) 即可。时间复杂度 O(p)O(p)O(p)。 这样显然不够好，很多时候 ppp 都十分巨大。考虑优化，我们可以把 xxx 拆开，拆成 x=tA−Bx=tA-Bx=tA−B，其中 B≤tB\\le tB≤t。那么有： atA−B≡b(modp)a^{tA-B}\\equiv b\\pmod p atA−B≡b(modp) atA≡baB(modp)a^{tA}\\equiv ba^B\\pmod p atA≡baB(modp) 这样我们就可以用一个哈希表存每个 baBmod⁡pba^B\\operatorname{mod} pbaBmodp 对应的最大的 BBB，然后枚举 AAA，快速找到 atAa^{tA}atA 对应的 BBB，答案即为 x=tA−Bx=tA-Bx=tA−B。 显然，此时 ttt 取 ⌈p⌉\\left\\lceil\\sqrt p\\right\\rceil⌈p​⌉ 是最优的。此时时间复杂度为 O(⌈p⌉)O(\\left\\lceil\\sqrt p\\right\\rceil)O(⌈p​⌉)。如果用 map 来哈希的话时间复杂度会多只 log⁡\\loglog。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;map&gt; using namespace std; inline int BSGS(int a,int b,int p) { map&lt;int,int&gt; mp; int val=1,t=sqrt(p)+1; for(int B=1;B&lt;=t;B++) { val=1ll*val*a%p; mp[1ll*b*val%p]=B; } int cur=val; for(int A=1;A&lt;=t;A++) { if(mp.find(val)!=mp.end()) { return A*t-mp[val]; } val=1ll*val*cur%p; } return -1; } int main() { int p,a,b; scanf(&quot;%d%d%d&quot;,&amp;p,&amp;a,&amp;b); int x=BSGS(a,b,p); if(x==-1) { puts(&quot;no solution&quot;); return 0; } printf(&quot;%d\\n&quot;,x); return 0; } 但是有些时候，gcd⁡(a,p)=1\\gcd(a,p)\\not=1gcd(a,p)​=1，用不了 BSGS。这时候我们就需要 exBSGS 了。 例如这道题：P4195 【模板】扩展 BSGS/exBSGS 当 gcd⁡(a,p)=1\\gcd(a,p)\\not=1gcd(a,p)​=1 时，我们令 d=gcd⁡(a,p)d=\\gcd(a,p)d=gcd(a,p)，那么有： ax≡b(modp)a^x\\equiv b\\pmod p ax≡b(modp) adax−1≡bd(modpd)\\dfrac{a}{d}a^{x-1}\\equiv \\dfrac{b}{d}\\pmod{\\dfrac{p}{d}} da​ax−1≡db​(moddp​) 如果 gcd⁡(ad,pd)\\gcd(\\dfrac{a}{d},\\dfrac{p}{d})gcd(da​,dp​) 仍然不为 111，那么继续做下去，直到 gcd⁡(aD,pD)=1\\gcd(\\dfrac{a}{D},\\dfrac{p}{D})=1gcd(Da​,Dp​)=1 为止（DDD 为所有 ddd 的乘积）。 这时我们的方程变成了这样（cntcntcnt 是操作的次数）： acntDax−cnt≡bD(modpD)\\dfrac{a^{cnt}}{D}a^{x-cnt}\\equiv \\dfrac{b}{D}\\pmod{\\dfrac{p}{D}} Dacnt​ax−cnt≡Db​(modDp​) 就可以用 BSGS 计算答案了。 注意特判 x=0x=0x=0 和 x=cntx=cntx=cnt 的特殊情况。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;map&gt; #include &lt;cmath&gt; using namespace std; inline int gcd(int a,int b) { int t=a%b; while(t&gt;0) { a=b; b=t; t=a%b; } return b; } inline int exBSGS(int a,int b,int p) { a%=p; b%=p; if(b==1||p==1) { return 0; } int cnt=0,val=1; while(1) { int d=gcd(a,p); if(d==1) { break; } if(b%d!=0) { return -1; } cnt++; p/=d; b/=d; val=1ll*val*(a/d)%p; if(val==b) { return cnt; } } map&lt;int,int&gt; mp; int val2=1,t=sqrt(p)+1; for(int B=1;B&lt;=t;B++) { val2=1ll*val2*a%p; mp[1ll*b*val2%p]=B; } int cur=1ll*val2*val%p; for(int A=1;A&lt;=t;A++) { if(mp.find(cur)!=mp.end()) { return A*t-mp[cur]+cnt; } cur=1ll*cur*val2%p; } return -1; } int main() { int a,b,p; while(1) { scanf(&quot;%d%d%d&quot;,&amp;a,&amp;p,&amp;b); if(a==0&amp;&amp;b==0&amp;&amp;p==0) { break; } int res=exBSGS(a,b,p); if(res&lt;0) { puts(&quot;No Solution&quot;); } else { printf(&quot;%d\\n&quot;,res); } } return 0; } 练习题目 SP3105 MOD - Power Modulo Inverted UVA10225 Discrete Logging P2485 [SDOI2011]计算器 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"BSGS 和 exBSGS 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/bsgs-he-exbsgs-xue-xi-bi-ji/","stats":{"text":"6 min read","time":305000,"words":954,"minutes":6},"date":"2023-03-23 16:31:31","dateFormat":"2023-03-23"},{"abstract":"","content":"FFT 虽然奇妙，但是由于需要用浮点数，所以有精度问题。NTT 就是取模时 FFT 的一个完美替代品。 FFT 有精度问题的原因显然是涉及了本原单位根，它要用三角函数求，那么我们可以考虑找一个在模素数时的“本原单位根”。 原根 众所周知，在模 ppp 意义下只有 p−1p-1p−1 个能代入多项式的值（000 没用），所以我们只要找到一个能“遍历”这 p−1p-1p−1 个值的数，就能构成一个“单位圆”，也就能找到“本原单位根”了。 这个能构成“单位圆”的数就被称为原根 ggg。 形式化的，ggg 为模 ppp 的原根，当且仅当在模 ppp 意义下 g0=g1=g2=...=gp−2g^0\\not=g^1\\not=g^2\\not=...\\not=g^{p-2}g0​=g1​=g2​=...​=gp−2。 也就是说在模世界的幂运算这张纸上，原根 ggg 是一个圆。 容易发现 ggg 就是在模 ppp 意义下的 p−1p-1p−1 次本原单位根。 可以证明，在模素数 ppp 的意义下，ggg 总是存在的。所以 NTT 的模数必须要是素数。 我们考虑模 ppp 意义下的 nnn 次本原单位根 ωn\\omega_nωn​。由于 ggg 的次幂构成了“可以被分为 p−1p-1p−1 等分的单位圆”，所以 ωn=gp−1n\\omega_n=g^{\\frac{p-1}{n}}ωn​=gnp−1​。 显然，模 ppp 意义下的 ωn\\omega_nωn​ 存在当且仅当 n∣p−1n\\mid p-1n∣p−1。 NTT 如果 n=2kn=2^kn=2k，那么我们可以把 FFT 中的虚数本原单位根都替换成模素数 ppp 意义下的本原单位根，来实现 NTT。 但因为必须满足 2k=n∣p−12^k=n\\mid p-12k=n∣p−1，所以 NTT 对模数有特殊限制。 NTT 可用的模数 ppp 需要满足： ppp 是个质数 p=a⋅2b+1p=a\\cdot2^b+1p=a⋅2b+1 例如 998244353998244353998244353 就是合法的，因为 998244353=7⋅17⋅223+1998244353=7\\cdot17\\cdot2^{23}+1998244353=7⋅17⋅223+1。它的一个原根是 g=3g=3g=3。 还有 167772161167772161167772161 和 104857601104857601104857601 也是合法的，g=3g=3g=3 都是它们的原根。 模板题代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long MS=5000005; const int p=998244353,ginv=332748118; inline int qpow(int x,int y) { int res=1; for(;y&gt;0;y&gt;&gt;=1) res=((y&amp;1)?1ll*res*x%p:res),x=1ll*x*x%p; return res; } inline int getlen(int n) { int res=1; while(res&lt;n) res&lt;&lt;=1; return res; } int p_rev[MS],p_rev_lstn; inline void NTT(int n,int a[],int tpe) { if(p_rev_lstn!=n) { p_rev_lstn=n; for(int i=0;i&lt;n;i++) p_rev[i]=(p_rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); } for(int i=0;i&lt;n;i++) if(p_rev[i]&lt;i) swap(a[p_rev[i]],a[i]); int g=tpe==1?3:ginv; for(int mid=1;mid&lt;n;mid&lt;&lt;=1) { int len=mid&lt;&lt;1,Wn=qpow(g,(p-1)/len); for(int l=0;l&lt;n-len+1;l+=len) { for(int k=0,Wk=1;k&lt;mid;k++,Wk=1ll*Wk*Wn%p) { int x=a[l+k],y=1ll*Wk*a[l+mid+k]%p; a[l+k]=(x+y)%p,a[l+mid+k]=(x-y+p)%p; } } } } inline void DFT(int n,int a[]){NTT(n,a,1);} inline void IDFT(int n,int a[]) { NTT(n,a,-1); int inv=qpow(n,p-2); for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*inv%p; } int n,m,a[MS],b[MS]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=0;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;b[i]); } int len=getlen(n+m+1); DFT(len,a); DFT(len,b); for(int i=0;i&lt;len;i++) { a[i]=1ll*a[i]*b[i]%p; } IDFT(len,a); for(int i=0;i&lt;n+m+1;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"快速数论变换（NTT）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kuai-su-shu-lun-bian-huan-nttxue-xi-bi-ji/","stats":{"text":"5 min read","time":269000,"words":907,"minutes":5},"date":"2023-03-23 16:27:33","dateFormat":"2023-03-23"},{"abstract":"","content":"多项式 有 nnn 次多项式可以形式化的写为： f(x)=∑i=0naixif(x)=\\sum\\limits_{i=0}^{n}a_ix^i f(x)=i=0∑n​ai​xi 其中序列 aaa 可以叫做这个多项式的系数序列。 在下文，我们会用 fif_ifi​ 表示多项式 fff 的系数序列 aaa 的第 iii 项，即为 aia_iai​。 多项式的表示方法 系数表示法 显然，只要我们得知了系数序列，就可以唯一确定一个多项式。 点值表示法 对于一个 nnn 次多项式，代入 n+1n+1n+1 个互不相同的值 xix_ixi​，可以得到 n+1n+1n+1 个满足 yi=f(xi)y_i=f(x_i)yi​=f(xi​) 的 yiy_iyi​。这时，序列 xxx 和序列 yyy 可以唯一确定 fff。 因为有了 n+1n+1n+1 个点 (xi,yi)(x_i,y_i)(xi​,yi​)，就可以通过插值来确定 fff。 多项式的运算 设 f,gf,gf,g 是两个 nnn 次多项式，有： (f+g)(x)=∑i=0n(fi+gi)xi(f+g)(x)=\\sum\\limits_{i=0}^n(f_i+g_i)x^i (f+g)(x)=i=0∑n​(fi​+gi​)xi (f∗g)(x)=∑k=02nxk∑i≤n,j≤n,i+j=kfigj(f*g)(x)=\\sum\\limits_{k=0}^{2n}x^k\\sum\\limits_{i\\le n,j\\le n,i+j=k}f_ig_j (f∗g)(x)=k=0∑2n​xki≤n,j≤n,i+j=k∑​fi​gj​ 多项式除法可以使用多项式求逆做。 容易发现，在系数表示法下： 多项式加法是 O(n)O(n)O(n) 的，因为直接系数相加就行 多项式乘法是 O(n2)O(n^2)O(n2) 的，因为需要枚举 i,ji,ji,j 而在点值表示法下：（注意此时的运算需要满足序列 xxx 相同） 多项式加法是 O(n)O(n)O(n) 的，因为直接相加就行（乘法分配律） 多项式乘法是 O(n)O(n)O(n) 的，因为直接让 yyy 相乘就行 所以在点值表示法下做乘法运算是很优的！ 但是直接通过代入把系数表示法转换为点值表示法是 O(n2)O(n^2)O(n2) 的，而 FFT 就是把这一过程优化到了 O(nlog⁡n)O(n\\log n)O(nlogn)。 nnn 次本原单位根 FFT 能优化时间复杂度的一个重要原因是它代入的不是随随便便的 n+1n+1n+1 个不同的值，而是 nnn 次本原单位根的 000 次方、111 次方一直到 nnn 次方。 nnn 次单位根其实就是任意一个就是满足 xn=1x^n=1xn=1 的 xxx，这个东西在实数范围显然只有不多于两个，但是在虚数范围就有 nnn 个了。 而 nnn 次本原单位根则是一个特殊的 nnn 次单位根 ωn\\omega_nωn​，满足 ωn0=ωn1=ωn2=⋯=ωnn\\omega_n^0\\not=\\omega_n^1\\not=\\omega_n^2\\not=\\dots\\not=\\omega_n^nωn0​​=ωn1​​=ωn2​​=⋯​=ωnn​。 想要构造一个 nnn 次本原单位根，最好的方法就是把复平面上的单位圆平分成 nnn 份。例如六次本原单位根 ω6\\omega_6ω6​： 显然，nnn 次本原单位根 ωn=cos⁡(2πn)+sin⁡(2πn)i\\omega_n=\\operatorname{cos}(\\dfrac{2\\pi}{n})+\\operatorname{sin}(\\dfrac{2\\pi}{n})iωn​=cos(n2π​)+sin(n2π​)i。 我们考虑 ωn2\\omega_n^2ωn2​ 是什么。因为虚数的乘法法则是模相乘，辐角相加，而 ωn\\omega_nωn​ 的模是 111，所以 ωn2\\omega_n^2ωn2​ 相当于 ωn\\omega^nωn 转了一下： 所以 ωnk=ωnkmod n\\omega_n^k=\\omega_n^{k\\mod n}ωnk​=ωnkmodn​，相当于转一圈后会转回来。本原单位根会转是一个很重要的性质！（虽然暂时没有用 ） DFT 和 IDFT 现在我们可以把单位根们代入多项式求值了，这就是 DFT。设 fff 是一个 n−1n-1n−1 次多项式，那么有： f^k=∑i=0n−1fi⋅ωnki\\hat f_k=\\sum\\limits_{i=0}^{n-1}f_i\\cdot\\omega_n^{ki} f^​k​=i=0∑n−1​fi​⋅ωnki​ 下面让我们证明 DFT 的逆变换 IDFT： fk=1n∑i=0n−1f^i⋅ωn−kif_k=\\dfrac{1}{n}\\sum\\limits_{i=0}^{n-1}\\hat f_i\\cdot\\omega_n^{-ki} fk​=n1​i=0∑n−1​f^​i​⋅ωn−ki​ 将 DFT 的柿子代入： fk=1n∑i=0n−1ωn−ki∑j=0n−1fj⋅ωnijf_k=\\dfrac{1}{n}\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ki}\\sum\\limits_{j=0}^{n-1}f_j\\cdot\\omega_n^{ij} fk​=n1​i=0∑n−1​ωn−ki​j=0∑n−1​fj​⋅ωnij​ =1n∑j=0n−1fj∑i=0n−1ωn−ki⋅ωnij=\\dfrac{1}{n}\\sum\\limits_{j=0}^{n-1}f_j\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ki}\\cdot\\omega_n^{ij} =n1​j=0∑n−1​fj​i=0∑n−1​ωn−ki​⋅ωnij​ =1n∑j=0n−1fj∑i=0n−1ωni(j−k)=\\dfrac{1}{n}\\sum\\limits_{j=0}^{n-1}f_j\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)} =n1​j=0∑n−1​fj​i=0∑n−1​ωni(j−k)​ 考虑 ∑i=0n−1ωni(j−k)\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}i=0∑n−1​ωni(j−k)​ 这部分： 若 j=kj=kj=k，那么 ∑i=0n−1ωni(j−k)=∑i=0n−1ωn0=n\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}=\\sum\\limits_{i=0}^{n-1}\\omega_n^{0}=ni=0∑n−1​ωni(j−k)​=i=0∑n−1​ωn0​=n 若 j=kj\\not=kj​=k，那么因为 0≤j,k&lt;n0\\le j,k&lt;n0≤j,k&lt;n，所以 ∣j−k∣&lt;n,ωnj−k=0|j-k|&lt;n,\\omega_n^{j-k}\\not=0∣j−k∣&lt;n,ωnj−k​​=0，由等比数列求和公式得到： ∑i=0n−1ωni(j−k)=∑i=0n−1(ωnj−k)i\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}=\\sum\\limits_{i=0}^{n-1}(\\omega_n^{j-k})^i i=0∑n−1​ωni(j−k)​=i=0∑n−1​(ωnj−k​)i =1−(ωnj−k)n1−ωnj−k=\\dfrac{1-(\\omega_n^{j-k})^n}{1-\\omega_n^{j-k}} =1−ωnj−k​1−(ωnj−k​)n​ =1−(ωnn)j−k1−ωnj−k=\\dfrac{1-(\\omega_n^n)^{j-k}}{1-\\omega_n^{j-k}} =1−ωnj−k​1−(ωnn​)j−k​ =1−11−ωnj−k=\\dfrac{1-1}{1-\\omega_n^{j-k}} =1−ωnj−k​1−1​ =0=0 =0 所以 fk=1n∑j=0n−1fj⋅n⋅[j=k]f_k=\\dfrac{1}{n}\\sum\\limits_{j=0}^{n-1}f_j\\cdot n\\cdot[j=k] fk​=n1​j=0∑n−1​fj​⋅n⋅[j=k] =1n⋅n⋅fk=\\dfrac{1}{n}\\cdot n\\cdot f_k =n1​⋅n⋅fk​ =fk=f_k =fk​ 得证。 可以发现 DFT 和 IDFT 的柿子惊人地相似，只不过是多了个 1n\\dfrac{1}{n}n1​ 和本原单位根指数上面的负号而已。所以我们只需要解决 DFT，IDFT 就能迎刃而解。 FFT 设 fff 是一个次数为 n−1n-1n−1 且 nnn 是偶数的多项式（如果原来的 nnn 是奇数那么可以补一项系数为 000 的项），设 m=n2m=\\dfrac{n}{2}m=2n​，那么有： f(x)=∑i=0n−1fixif(x)=\\sum\\limits_{i=0}^{n-1}f_ix^i f(x)=i=0∑n−1​fi​xi 根据奇偶性分类，有： f(x)=∑i=0m−1f2ix2i+∑i=0m−1f2i+1x2i+1f(x)=\\sum\\limits_{i=0}^{m-1}f_{2i}x^{2i}+\\sum\\limits_{i=0}^{m-1}f_{2i+1}x^{2i+1} f(x)=i=0∑m−1​f2i​x2i+i=0∑m−1​f2i+1​x2i+1 =∑i=0m−1f2ix2i+x∑i=0m−1f2i+1x2i=\\sum\\limits_{i=0}^{m-1}f_{2i}x^{2i}+x\\sum\\limits_{i=0}^{m-1}f_{2i+1}x^{2i} =i=0∑m−1​f2i​x2i+xi=0∑m−1​f2i+1​x2i 定义 f0(x)=∑i=0m−1f2ixif0(x)=\\sum\\limits_{i=0}^{m-1}f_{2i}x^{i}f0(x)=i=0∑m−1​f2i​xi，f1(x)=∑i=0m−1f2i+1xif1(x)=\\sum\\limits_{i=0}^{m-1}f_{2i+1}x^{i}f1(x)=i=0∑m−1​f2i+1​xi，那么有： f(x)=f0(x2)+x⋅f1(x2)f(x)=f0(x^2)+x \\cdot f1(x^2)f(x)=f0(x2)+x⋅f1(x2) 在代入单位根之前，我们先来看两个单位根的性质： ω2n2k=ωnk\\omega_{2n}^{2k}=\\omega_{n}^k ω2n2k​=ωnk​ ω2nn+k=−ω2nk\\omega_{2n}^{n+k}=-\\omega_{2n}^k ω2nn+k​=−ω2nk​ 第一条性质是因为以 ω2n\\omega_{2n}ω2n​ 的辐角转 2k2k2k 次相当于以 ωn\\omega_{n}ωn​ 的辐角转 kkk 次。 而第二条性质是因为以 ω2n\\omega_{2n}ω2n​ 的辐角转 nnn 次就到达了 −1-1−1 的位置。 记住这两条性质，代入单位根，对于满足 0≤k&lt;m0\\le k&lt;m0≤k&lt;m 的 kkk，有： f(ωnk)=f0(ωn2k)+ωnk⋅f1(ωn2k)f(\\omega_n^k)=f0(\\omega_n^{2k})+\\omega_n^k\\cdot f1(\\omega_n^{2k}) f(ωnk​)=f0(ωn2k​)+ωnk​⋅f1(ωn2k​) =f0(ωmk)+ωnk⋅f1(ωmk)=f0(\\omega_m^k)+\\omega_n^k\\cdot f1(\\omega_m^k) =f0(ωmk​)+ωnk​⋅f1(ωmk​) f(ωnm+k)=f0(ωn2(m+k))+ωnm+k⋅f1(ωn2(m+k))f(\\omega_n^{m+k})=f0(\\omega_n^{2(m+k)})+\\omega_n^{m+k}\\cdot f1(\\omega_n^{2(m+k)}) f(ωnm+k​)=f0(ωn2(m+k)​)+ωnm+k​⋅f1(ωn2(m+k)​) =f0(ωmk)−ωnk⋅f1(ωmk)=f0(\\omega_m^k)-\\omega_n^{k}\\cdot f1(\\omega_m^k) =f0(ωmk​)−ωnk​⋅f1(ωmk​) 以上两个柿子十分相似，所以被称作蝴蝶操作。 由蝴蝶操作不难得出，只要我们算出了 f0(ωm0,ωm1,ωm2,…,ωmm−1)f0(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})f0(ωm0​,ωm1​,ωm2​,…,ωmm−1​) 和 f1(ωm0,ωm1,ωm2,…,ωmm−1)f1(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})f1(ωm0​,ωm1​,ωm2​,…,ωmm−1​)，就可以快速得到 f(ωn0,ωn1,ωn2,…,ωnn−1)f(\\omega_n^0,\\omega_n^1,\\omega_n^2,\\dots,\\omega_n^{n-1})f(ωn0​,ωn1​,ωn2​,…,ωnn−1​)。 而 f0(ωm0,ωm1,ωm2,…,ωmm−1)f0(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})f0(ωm0​,ωm1​,ωm2​,…,ωmm−1​) 和 f1(ωm0,ωm1,ωm2,…,ωmm−1)f1(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})f1(ωm0​,ωm1​,ωm2​,…,ωmm−1​) 又可以递归下去算，所以我们可以分治下去，用 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度完成 DFT！ 不过需要注意的是，nnn 必须是 222 的幂，要不然无法分治。 快速进行 IDFT 也相当好办，只要把 FFT 中用到的所有 ωn\\omega_nωn​ 换成 ωn−1\\omega_n^{-1}ωn−1​ ，最后再把所有点值乘上 1n\\dfrac{1}{n}n1​ 即可。 但是这还不够快，所以会被卡常。观察到影响效率的是按奇偶性分治，所以可以考虑令 rev⁡(x)\\operatorname{rev}(x)rev(x) 表示 xxx 的二进制反过来组成的数，令 fi′=frev⁡(i)f^\\prime_i=f_{\\operatorname{rev}(i)}fi′​=frev(i)​，那么在 f′f^\\primef′ 上的分治操作其实就是相邻两个序列的分治，这样可以大大加快 FFT 的速度，并且可以把 FFT 写成非递归的。 代码如下：（模板题） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; const long long MS=5000005; const double PI=acos(-1); struct plex { double x,y; plex(double a=0,double b=0) {x=a,y=b;} }; plex operator+(plex a,plex b) {return plex(a.x+b.x,a.y+b.y);} plex operator-(plex a,plex b) {return plex(a.x-b.x,a.y-b.y);} plex operator*(plex a,plex b) {return plex(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);} inline int getlen(int n) { int res=1; while(res&lt;n) res&lt;&lt;=1; return res; } int p_rev[MS],p_rev_lstn; inline void FFT(int n,plex a[],int tpe) { if(p_rev_lstn!=n) { p_rev_lstn=n; for(int i=0;i&lt;n;i++) p_rev[i]=(p_rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); } for(int i=0;i&lt;n;i++) if(p_rev[i]&lt;i) swap(a[p_rev[i]],a[i]); for(int mid=1;mid&lt;n;mid&lt;&lt;=1) { int len=mid&lt;&lt;1; plex Wn=plex(cos(2*PI/len),tpe*sin(2*PI/len)); for(int l=0;l&lt;n-len+1;l+=len) { plex Wk=plex(1,0); for(int k=0;k&lt;mid;k++,Wk=Wk*Wn) { plex x=a[l+k],y=Wk*a[l+mid+k]; a[l+k]=x+y,a[l+mid+k]=x-y; } } } } inline void DFT(int n,plex a[]) {FFT(n,a,1);} inline void IDFT(int n,plex a[]) { FFT(n,a,-1); for(int i=0;i&lt;n;i++) a[i].x/=n,a[i].y/=n; } int n,m; plex a[MS],b[MS]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) { scanf(&quot;%lf&quot;,&amp;a[i].x); } for(int i=0;i&lt;=m;i++) { scanf(&quot;%lf&quot;,&amp;b[i].x); } int len=getlen(n+m+1); DFT(len,a); DFT(len,b); for(int i=0;i&lt;len;i++) { a[i]=a[i]*b[i]; } IDFT(len,a); for(int i=0;i&lt;n+m+1;i++) { printf(&quot;%d &quot;,(int)(a[i].x+0.5)); } printf(&quot;\\n&quot;); return 0; } ","tags":[{"name":"多项式、生成函数","slug":"XKmkuK_oz","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/XKmkuK_oz/"},{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"快速傅里叶变换（FFT）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kuai-su-fu-li-xie-bian-huan-fftxue-xi-bi-ji/","stats":{"text":"15 min read","time":850000,"words":2767,"minutes":15},"date":"2023-03-23 16:25:24","dateFormat":"2023-03-23"},{"abstract":"","content":"这是个大工程，以后会不断补充。 最大流 最大流的建模，往往是把流量和题目要求的东西直接关联起来，是最简单直白的建模。最大流的模型有时候可以转化为二分图最大匹配。 拆点模型 P2472 [SCOI2007] 蜥蜴 网络流图中的点如果有流量限制，那么可以把一个点 uuu 拆成入点 u1u_1u1​ 和出点 u2u_2u2​，u1u_1u1​ 负责接收流量，u2u_2u2​ 负责输送流量，u1u1u1 向 u2u2u2 连一条流量为点权的边即可。 分层图模型 P2754 [CTSC1999]家园 / 星际转移问题 网络流图中的点如果会“动”，那么不妨按时间分层建图，模拟时间流逝。 还有一类题比较特殊，要求最小层数。那么先判断无解，再不断加层直到满足条件即可。 最小路径覆盖模型 P2764 最小路径覆盖问题 正难则反，首先考虑让所有点都自成路径，然后考虑尽可能通过边来“合并”这些路径。 因为每个点只能在一条路径上，所以考虑拆点。把每个点 uuu 拆成 u1u_1u1​ 和 u2u_2u2​，源点向 U1U_1U1​ 连一条流量为 111 的边，u2u_2u2​ 向汇点连一条流量为 111 的边，表示 uuu 在路径上的前驱和后继只能有 111 个节点。 然后对于每条边 (x,y)(x,y)(x,y)，从 x1x_1x1​ 向 y2y_2y2​ 连一条边，表示 yyy 可以做 xxx 的后继，xxx 可以做 yyy 前驱。 最后用 nnn 减去最大流即可。 可以发现此时的图其实是一个二分图，所以可以用二分图最大匹配代替网络流。 流量平衡模型 见 网络流求最小费用特解（网络流解线性规划）学习笔记 危桥模型 [P3163 [CQOI2014]危桥](https://www.luogu.com.cn/problem/P3163) 往返 ana_nan​ 次相当于是从 a1a_1a1​ 到 a2a_2a2​ 走了 2an2a_n2an​ 次，bbb 也一样，所以问题转化为： 有两组源汇点 s1,t1s1,t1s1,t1 和 s2,t2s2,t2s2,t2，s1→t1s1\\to t1s1→t1 最多流 a1a1a1 的流量，s2→t2s2\\to t2s2→t2 最多流 a2a2a2 的流量，请判断能否满流。 若直接源点向 s1,s1s1,s1s1,s1 分别连流量为 a1,a2a1,a2a1,a2 的边，t1,t2t1,t2t1,t2 向汇点连流量为 a1,a2a1,a2a1,a2 的边然后判是否满流，可能会出现这种情况： 即所有满流的方案中都会有一部分流量从 s1s1s1 流到 t2t2t2，一部分流量从 s2s2s2 流到 t1t1t1，此时实际上是不存在合法方案的，但是这样建图却会认为可以满流。 解决方案很简单，我们交换 s2,t2s2,t2s2,t2，即从源点向 t2t2t2 连流量为 a2a2a2 的边，从 s2s2s2 向汇点连流量为 a2a2a2 的边，其余部分连边不变，再判断一次是否满流。若上图中的不合法情况必然出现，那么新图不可能满流；否则若新图上这种情况必定出现： 那么原图必定不可能满流。因为假若这两种情况同时出现，那么就可以这样流： 所以只要这两个图都能满流就证明原问题有解。 类似的，这种建模方法应该还能推广到有 nnn 对源汇点的情况，通过固定一对源汇点，枚举剩下的源汇点的交换与否，跑 2n−12^{n-1}2n−1 次最大流，则原问题有解当且仅当每次都是满流。 最小割 从最小割角度建模也是一种比较常见的建模方式。 设点 uuu 最终在源点 SSS 所在的连通块则 bu=1b_u=1bu​=1，否则 bu=0b_u=0bu​=0。 基本模型 考虑最小割的数学定义： 边 (S,x,a)(S,x,a)(S,x,a) 对答案的贡献为 a×(1−bx)a\\times (1-b_x)a×(1−bx​)； 边 (x,T,a)(x,T,a)(x,T,a) 对答案的贡献为 a×bxa\\times b_xa×bx​； 边 (x,y,a)(x,y,a)(x,y,a) 对答案的贡献为 a×bx(1−by)a\\times b_x(1-b_y)a×bx​(1−by​)； 所以基本限制如下： 有 nnn 个 01 变量 bib_ibi​，你需要确定每个 bib_ibi​ 的取值使得代价最小。 代价分为三类： 若 bi=0b_i=0bi​=0，有代价 w1iw1_iw1i​； 若 bi=1b_i=1bi​=1，有代价 w2iw2_iw2i​； 若 bi=1b_i=1bi​=1 且 bj=0b_j=0bj​=0，有代价 w3i,jw3_{i,j}w3i,j​； 基本模型如下： 给第 iii 个元素建一个点 iii。 对于第一类限制，连边 (S,i,w1i)(S,i,w1_i)(S,i,w1i​)； 对于第二类限制，连边 (i,T,w2i)(i,T,w2_i)(i,T,w2i​)； 对于第三类限制，连边 (i,j,w3i,j)(i,j,w3_{i,j})(i,j,w3i,j​)； 混合模型 相当于把基本模型中的 SSS 换成别的点，流量不再由 SSS 直接提供。 可以看成多层基本模型。 共同收益模型 P1361 小M的作物 诸如「对于所有 u∈Au\\in Au∈A，若 ∑bu=∣A∣\\sum b_u\\not=|A|∑bu​​=∣A∣ 则有代价 www」的情况，可以新建一个点 uuu，连接边： (S,u,w)(S,u,w)(S,u,w)； (u,x,inf⁡)(u,x,\\inf)(u,x,inf)，其中 x∈Ax\\in Ax∈A； 同理，「对于所有 u∈Au\\in Au∈A，若 ∑bu=0\\sum b_u\\not=0∑bu​​=0 则有代价 www」的情况也可以类似做，新建一个点 uuu，连接边： (u,T,w)(u,T,w)(u,T,w)； (x,u,inf⁡)(x,u,\\inf)(x,u,inf)，其中 x∈Ax\\in Ax∈A； 建图是这样的： 切糕模型 P3227 [HNOI2013] 切糕 有 nnn 个整数变量 bib_ibi​，第 iii 个变量取值范围 [Li,Ri][L_i,R_i][Li​,Ri​]。 代价分为两类： bi=xb_i=xbi​=x 时有代价 Wi,xW_{i,x}Wi,x​； bi≥x,bj≥yb_i\\ge x,b_j\\ge ybi​≥x,bj​≥y 时有代价 Wi,x,j,yW_{i,x,j,y}Wi,x,j,y​； 直接看图吧： 混合模型 各种模型的流量都可以不由 SSS 直接提供。 P8215 [THUPC2022 初赛] 分组作业 | 题解 ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"网络流","slug":"19EjLeSB_D","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/19EjLeSB_D/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"网络流的常见建模","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/wang-luo-liu-de-chang-jian-jian-mo/","stats":{"text":"6 min read","time":357000,"words":1477,"minutes":6},"date":"2023-03-23 16:20:04","dateFormat":"2023-03-23"},{"abstract":"","content":"整体二分，就是把查询放到一起二分，从而降低代码复杂度的一种离线算法。所以想要使用整体二分需要保证查询的答案具有单调性和操作可以离线。 首先看一道例题： 有一个空的可重集和 mmm 个操作，每个操作有类型 tpeitpe_itpei​ 和一个参数 xix_ixi​。tpei=1tpe_i=1tpei​=1 的操作表示往可重集里添加 xix_ixi​，tpe=i2tpe=_i2tpe=i​2 的操作表示询问可重集内第 xix_ixi​ 小的数。 1≤m≤1051\\le m\\le 10^51≤m≤105 显然这道题可以用平衡树做，但是它太难写了。观察到答案具有单调性，所以可以二分答案，用一个数据结构维护当前可重集内小于 midmidmid 的数的个数即可。这样的时间复杂度是 O(mlog⁡m)O(m\\log m)O(mlogm) 的，但是仍然很难写。 考虑降低代码复杂度。我们可以先把所有操作离线下来，然后对于所有操作一起二分。“一起二分”就是将答案在 [l,r][l,r][l,r] 区间内的询问和对这些询问的答案有影响的修改操作一起处理，设 curcurcur 表示 [l,r][l,r][l,r] 内的操作序列，那么显然若 l=rl=rl=r，那么我们就已经找到答案了。 考虑 l=rl\\not=rl​=r 的情况。设 mid=⌊l+r2⌋mid=\\left\\lfloor\\dfrac{l+r}{2}\\right\\rfloormid=⌊2l+r​⌋，那么我们需要把 curcurcur 分为两个操作序列 lftlftlft 和 rigrigrig，其中 lftlftlft 的答案在 [l,mid][l,mid][l,mid] 内，rigrigrig 的答案在 [mid+1,r][mid+1,r][mid+1,r] 内，这样我们递归下去就可以求出答案了。 考虑怎么分组。对于修改操作 iii，显然若 xi≤midx_i \\le midxi​≤mid 那么这个操作会对 lftlftlft 和 rigrigrig 造成影响，但为了保证时间复杂度，我们只将它放入 lftlftlft 中；否则只会对 rigrigrig 造成影响，放入 rigrigrig 中。 而对于询问操作 iii，我们可以计算出操作序列执行到 iii 时可重集内比 midmidmid 小的数的个数 kkk。若 k≥xik\\ge x_ik≥xi​，那么说明当前 midmidmid 大了或者对了，这个询问操作需要分到 lftlftlft 里；否则说明当前 midmidmid 小了，这个询问操作需要分到 rigrigrig 里。 但是注意，k&lt;xik&lt;x_ik&lt;xi​ 即 iii 被分到 rigrigrig 时，需要将 xix_ixi​ 减去 kkk。因为我们加入修改操作时把所有对两个操作序列都有影响的操作放进了 lftlftlft 而没有加入 rigrigrig，所以我们需要额外计算上这些修改的贡献。 容易发现，计算操作序列执行到 iii 时可重集内比 midmidmid 小的数的个数 kkk 可以用一个变量 cntcntcnt 简单统计。然后递归的层数是 log⁡m\\log mlogm，每一层会遍历一次所有操作，所以时间复杂度为 O(mlog⁡m)O(m\\log m)O(mlogm)。 考虑如何求第 kkk 大值。显然可以只有分组部分有变化： 对于修改操作 iii，显然若 xi&gt;midx_i &gt; midxi​&gt;mid 那么这个操作会对 lftlftlft 和 rigrigrig 造成影响，但为了保证时间复杂度，我们只将它放入 rigrigrig 中；否则只会对 lftlftlft 造成影响，放入 lftlftlft 中。 而对于询问操作 iii，我们可以计算出操作序列执行到 iii 时可重集内比 midmidmid 大的数的个数 kkk。若 k&gt;=xik&gt;=x_ik&gt;=xi​，那么说明当前 midmidmid 小了，这个询问操作需要分到 rigrigrig 里；否则说明当前 midmidmid 大了或者对了，这个询问操作需要分到 lftlftlft 里。但是注意，k&lt;xik&lt;x_ik&lt;xi​ 即 iii 被分到 lftlftlft 时，需要将 xix_ixi​ 减去 kkk。因为我们加入修改操作时把所有对两个操作序列都有影响的操作放进了 rigrigrig 而没有加入 lftlftlft，所以我们需要额外计算上这些修改的贡献。 那么现在来看道例题吧： P3332 [ZJOI2013]K大数查询 显然还是分组过程变了。发现变动的地方只是单点修改，整段查询变成了区间修改，区间查询。所以用线段树维护 [l,r][l,r][l,r] 内可重集的并内比 midmidmid 大的数的个数 kkk 即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const long long MS=50005; struct node { int tpe,l,r,id; long long val; }; int n,m,quecnt; int ans[MS]; long long sum[MS&lt;&lt;2],lazy[MS&lt;&lt;2]; inline void updata(int u) { sum[u]=sum[u&lt;&lt;1]+sum[u&lt;&lt;1|1]; } inline void lazydown(int u,int l,int r) { if(lazy[u]==0) { return; } int mid=l+r&gt;&gt;1; lazy[u&lt;&lt;1]+=lazy[u]; lazy[u&lt;&lt;1|1]+=lazy[u]; sum[u&lt;&lt;1]+=lazy[u]*(mid-l+1); sum[u&lt;&lt;1|1]+=lazy[u]*(r-mid); lazy[u]=0; } void upd(int u,int l,int r,int L,int R,long long k) { if(r&lt;L||l&gt;R) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { lazy[u]+=k; sum[u]+=k*(r-l+1); return; } lazydown(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid) { upd(u&lt;&lt;1,l,mid,L,R,k); } if(R&gt;=mid+1) { upd(u&lt;&lt;1|1,mid+1,r,L,R,k); } updata(u); } long long que(int u,int l,int r,int L,int R) { if(r&lt;L||l&gt;R) { return 0; } if(l&gt;=L&amp;&amp;r&lt;=R) { return sum[u]; } lazydown(u,l,r); int mid=l+r&gt;&gt;1; long long res=0; if(L&lt;=mid) { res+=que(u&lt;&lt;1,l,mid,L,R); } if(R&gt;=mid+1) { res+=que(u&lt;&lt;1|1,mid+1,r,L,R); } return res; } void slove(int l,int r,vector&lt;node&gt; &amp;cur) { if(l==r) { for(node x:cur) { if(x.tpe==2) { ans[x.id]=l; } } return; } int mid=l+r&gt;&gt;1; vector&lt;node&gt; lft,rig; for(node x:cur) { if(x.tpe==1) { if(x.val&lt;=mid) { lft.push_back(x); } else { rig.push_back(x); upd(1,1,n,x.l,x.r,1); } } else { long long vl=que(1,1,n,x.l,x.r); if(vl&gt;=x.val) { rig.push_back(x); } else { x.val-=vl; lft.push_back(x); } } } for(node x:rig) { if(x.tpe==1) { upd(1,1,n,x.l,x.r,-1); } } if(lft.size()&gt;0) { slove(l,mid,lft); } if(rig.size()&gt;0) { slove(mid+1,r,rig); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); vector&lt;node&gt; a; for(int i=1;i&lt;=m;i++) { node x; scanf(&quot;%d%d%d%lld&quot;,&amp;x.tpe,&amp;x.l,&amp;x.r,&amp;x.val); if(x.tpe==2) { x.id=++quecnt; } a.push_back(x); } slove(-n,n,a); for(int i=1;i&lt;=quecnt;i++) { printf(&quot;%d\\n&quot;,ans[i]); } return 0; } 练习题目 P3527 [POI2011]MET-Meteors ","tags":[{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"整体二分学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zheng-ti-er-fen-xue-xi-bi-ji/","stats":{"text":"8 min read","time":446000,"words":1617,"minutes":8},"date":"2023-03-23 16:18:52","dateFormat":"2023-03-23"},{"abstract":"","content":"由于网络流图中除了源点和汇点外，其它节点都满足流入的流量等于流出的流量。所以我们可以通过把若干等式转换成图来求解最小费用的特解，不等式变形做一下差分变成等式也可以求。 具体的做法是，先把每个等式都变形、化简，令每一个未知数都在且仅在两个等式里出现，且系数分别为 +1+1+1 和 −1-1−1。 接下来： 建立源点、汇点，并对每一个等式建一个点 如果第 iii 个不等式右边的常量为非负整数 wiw_iwi​，那么从 iii 向汇点连流量为 wiw_iwi​，费用为 000 的边表示多余数量被吸走；如果第 iii 个不等式右边的常量为负整数 wiw_iwi​，那么从源点向 iii 连流量为 −wi-w_i−wi​，费用为 000 的边表示少掉的流量被补充 如果未知数 xix_ixi​ 在等式 jjj 里的系数为 −1-1−1，在等式 kkk 里的系数为 +1+1+1，并且这个未知数在最终计算答案的时候的系数为 cic_ici​，那么从 jjj 向 kkk 连流量为 inf⁡\\infinf，费用为 cic_ici​ 的边，表示这个未知数的值从多出来的等式流向少掉的等式，且这个未知数增大需要收取费用（计算进答案） 最后判断有无可行解即判断是否满流，而最小解即为最小费用最大流。 例题 先假设共 333 天，第 iii 天招募 pip_ipi​ 人，共有 333 类志愿者： 第一类：从第 111 天到第 333 天，费用为 c1c_1c1​，招募了 b1b_1b1​ 人 第二类：从第 222 天到第 333 天，费用为 c2c_2c2​，招募了 b2b_2b2​ 人 第三类：从第 111 天到第 333 天，费用为 c3c_3c3​，招募了 b3b_3b3​ 人 可以列出如下不等式： p1=b1+b3≥a1p_1=b_1+b_3\\ge a_1 p1​=b1​+b3​≥a1​ p2=b1+b2+b3≥a2p_2=b_1+b_2+b_3\\ge a_2 p2​=b1​+b2​+b3​≥a2​ p3=b1+b2≥a3p_3=b_1+b_2\\ge a_3 p3​=b1​+b2​≥a3​ 考虑转化成等式，设第 iii 天招募的人数超出最小人数 did_idi​ 人，显然 di≥0d_i\\ge0di​≥0，那么有： p1=b1+b3=a1+d1p_1=b_1+b_3=a_1+d_1 p1​=b1​+b3​=a1​+d1​ p2=b1+b2+b3=a2+d2p_2=b_1+b_2+b_3=a_2+d_2 p2​=b1​+b2​+b3​=a2​+d2​ p3=b1+b2=a3+d3p_3=b_1+b_2=a_3+d_3 p3​=b1​+b2​=a3​+d3​ 相邻两个等式相减（默认第 000 个和第 444 个等式为 000）: p1=b1+b3=a1+d1p_1=b_1+b_3=a_1+d_1 p1​=b1​+b3​=a1​+d1​ p2−p1=b2=a2−a1+d2−d1p_2-p_1=b_2=a_2-a_1+d_2-d_1 p2​−p1​=b2​=a2​−a1​+d2​−d1​ p3−p2=−b3=a3−a2+d3−d2p_3-p_2=-b_3=a_3-a_2+d_3-d_2 p3​−p2​=−b3​=a3​−a2​+d3​−d2​ −p3=−b1−b2=−a3−d3-p_3=-b_1-b_2=-a_3-d_3 −p3​=−b1​−b2​=−a3​−d3​ 整理，消去 ppp，得： b1+b3−a1−d1=0b_1+b_3-a_1-d_1=0 b1​+b3​−a1​−d1​=0 b2+a1−a2+d1−d2=0b_2+a_1-a_2+d_1-d_2=0 b2​+a1​−a2​+d1​−d2​=0 −b3+a2−a3+d2−d3=0-b_3+a_2-a_3+d_2-d_3=0 −b3​+a2​−a3​+d2​−d3​=0 −b1−b2+a3+d3=0-b_1-b_2+a_3+d_3=0 −b1​−b2​+a3​+d3​=0 容易发现，这样构造可以令等式满足条件，所以可以建图跑最小费用最大流求解了。 建图方式如下： 建立源点、汇点和 n+1n+1n+1 个等式点 处理掉未知数 did_idi​ 和 aia_iai​，iii 向 i+1i+1i+1 连一条流量为 inf⁡\\infinf，费用为 000 的边 处理掉 bib_ibi​，对于第 iii 类志愿者，从 sis_isi​ 向 tit_iti​ 连一条流量为 inf⁡\\infinf，费用为 cic_ici​ 的边，表示答案贡献式里的系数计算 从源点向 111 连一条流量为 inf⁡\\infinf，费用为 000 的边；从 n+1n+1n+1 向汇点连一条流量为 inf⁡\\infinf，费用为 000 的边，让整张图“流起来” 最后跑最小费用最大流求出最小费用即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int S=5000005,MS=100005; const long long inf=1000000007; int n,m,s,t; int esum,to[S],nxt[S],h[MS]; long long c[S],cost[S]; long long dis[MS]; int cur[MS]; bool vis[MS]; long long maxflow,mincost; inline void init() { esum=1; memset(h,0,sizeof(h)); s=0; t=n+2; } inline void add(int x,int y,long long w,long long v) { to[++esum]=y; c[esum]=w; cost[esum]=v; nxt[esum]=h[x]; h[x]=esum; } inline bool spfa() { memset(dis,127,sizeof(dis)); memset(vis,0,sizeof(vis)); long long inf=dis[0]; queue&lt;int&gt; q; dis[s]=0; vis[s]=true; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=false; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; long long w=cost[i]; if(c[i]&gt;0&amp;&amp;dis[u]+w&lt;dis[v]) { dis[v]=dis[u]+w; if(!vis[v]) { vis[v]=true; q.push(v); } } } } return dis[t]&lt;inf; } long long dfs(int u,long long w) { if(u==t) { return w; } vis[u]=true; long long sum=0; for(int &amp;i=cur[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dis[v]==dis[u]+cost[i]&amp;&amp;!vis[v]) { long long re=dfs(v,min(w,c[i])); mincost+=re*cost[i]; c[i]-=re; c[i^1]+=re; w-=re; sum+=re; if(w==0) { break; } } } vis[u]=false; return sum; } inline void mcmf() { mincost=0; maxflow=0; while(spfa()) { for(int i=s;i&lt;=t;i++) { cur[i]=h[i]; } maxflow+=dfs(s,1e17); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); add(s,1,inf,0); add(1,s,0,0); add(n+1,t,inf,0); add(t,n+1,0,0); for(int i=1;i&lt;=n;i++) { long long x; scanf(&quot;%lld&quot;,&amp;x); add(i,i+1,inf-x,0); add(i+1,i,0,0); } for(int i=1;i&lt;=m;i++) { int l,r; long long need; scanf(&quot;%d%d%lld&quot;,&amp;l,&amp;r,&amp;need); add(l,r+1,1e17,need); add(r+1,l,0,-need); } mcmf(); printf(&quot;%lld\\n&quot;,mincost); return 0; } ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"网络流","slug":"19EjLeSB_D","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/19EjLeSB_D/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"网络流求最小费用特解（网络流解线性规划）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/wang-luo-liu-qiu-zui-xiao-fei-yong-te-jie-wang-luo-liu-jie-xian-xing-gui-hua-xue-xi-bi-ji/","stats":{"text":"7 min read","time":401000,"words":1369,"minutes":7},"date":"2023-03-23 16:17:59","dateFormat":"2023-03-23"},{"abstract":"","content":"有些树上操作题目需要换根操作，用普通的树链剖分无法解决此类问题。这时我们就需要改造一下树剖，令它支持换根操作。 首先肯定不可能每次都重新剖分，因为那样会 TLE。那么考虑以 111 为根剖，记下当前的跟 rtrtrt，对于每个操作特殊处理。 最近公共祖先 考虑用 lca⁡(x,y)\\operatorname{lca}(x,y)lca(x,y) 表示以 111 为根时 xxx 和 yyy 的最近公共祖先，用 LCA⁡(x,y)\\operatorname{LCA}(x,y)LCA(x,y) 表示换根后 xxx 和 yyy 的最近公共祖先（这里默认 xxx 深度小于等于 yyy）。 若 lca⁡(x,y)=x\\operatorname{lca}(x,y)=xlca(x,y)=x：（图中绿色节点是 xxx，红色节点是 yyy，不同颜色的节点是不同情况下 rtrtrt 的位置） (1) 若 rtrtrt 位于黄色区域，即 lca⁡(x,rt)=x∧lca⁡(y,rt)=y\\operatorname{lca}(x,rt)=x\\land\\operatorname{lca}(y,rt)=ylca(x,rt)=x∧lca(y,rt)=y，那么 LCA⁡(x,y)=y\\operatorname{LCA}(x,y)=yLCA(x,y)=y (2) 若 rtrtrt 位于橙色区域，即 lca⁡(x,rt)=x∧lca⁡(y,rt)=y\\operatorname{lca}(x,rt)=x\\land\\operatorname{lca}(y,rt)\\not=ylca(x,rt)=x∧lca(y,rt)​=y，那么 LCA⁡(x,y)=lca⁡(y,rt)\\operatorname{LCA}(x,y)=\\operatorname{lca}(y,rt)LCA(x,y)=lca(y,rt) (3) 若 rtrtrt 位于粉色区域，即 lca⁡(x,rt)=x\\operatorname{lca}(x,rt)\\not=xlca(x,rt)​=x，那么 LCA⁡(x,y)=lca⁡(x,y)\\operatorname{LCA}(x,y)=\\operatorname{lca}(x,y)LCA(x,y)=lca(x,y) 若 lca⁡(x,y)=x\\operatorname{lca}(x,y)\\not=xlca(x,y)​=x：（图中绿色节点是 xxx，红色节点是 yyy，不同颜色的节点是不同情况下 rtrtrt 的位置） (1) 若 rtrtrt 位于灰色区域，即 lca⁡(x,rt)=x\\operatorname{lca}(x,rt)=xlca(x,rt)=x，那么 LCA⁡(x,y)=x\\operatorname{LCA}(x,y)=xLCA(x,y)=x (2) 若 rtrtrt 位于蓝色区域，即 lca⁡(x,rt)=y\\operatorname{lca}(x,rt)=ylca(x,rt)=y，那么 LCA⁡(x,y)=y\\operatorname{LCA}(x,y)=yLCA(x,y)=y (3) 若 rtrtrt 位于粉色区域，即 lca⁡(x,rt)=lca⁡(y,rt)\\operatorname{lca}(x,rt)=\\operatorname{lca}(y,rt)lca(x,rt)=lca(y,rt)，那么 LCA⁡(x,y)=lca⁡(x,y)\\operatorname{LCA}(x,y)=\\operatorname{lca}(x,y)LCA(x,y)=lca(x,y) (4) 若 rtrtrt 位于橙色区域，即 (lca⁡(x,rt)=rt∧lca⁡(y,rt)=lca⁡(x,y))∨(lca⁡(x,rt)=lca⁡(x,y)∧lca⁡(y,rt)=y)(\\operatorname{lca}(x,rt)=rt\\land\\operatorname{lca}(y,rt)=\\operatorname{lca}(x,y))\\lor(\\operatorname{lca}(x,rt)=\\operatorname{lca}(x,y)\\land\\operatorname{lca}(y,rt)=y)(lca(x,rt)=rt∧lca(y,rt)=lca(x,y))∨(lca(x,rt)=lca(x,y)∧lca(y,rt)=y)，那么 LCA⁡(x,y)=rt\\operatorname{LCA}(x,y)=rtLCA(x,y)=rt (5) 若以上条件均不满足，那么若 lca⁡(x,rt)=lca⁡(x,y)\\operatorname{lca}(x,rt)=\\operatorname{lca}(x,y)lca(x,rt)=lca(x,y)，那么 LCA⁡(x,y)=lca⁡(x,rt)\\operatorname{LCA}(x,y)=\\operatorname{lca}(x,rt)LCA(x,y)=lca(x,rt)，否则 LCA⁡(x,y)=lca⁡(y,rt)\\operatorname{LCA}(x,y)=\\operatorname{lca}(y,rt)LCA(x,y)=lca(y,rt) 代码如下： inline int getLCA(int x,int y) { if(dep[x]&gt;dep[y]) { swap(x,y); } int xr=getlca(x,rt),yr=getlca(y,rt),xy=getlca(x,y); if(xy==x) { if(xr==x&amp;&amp;yr==y) { return y; } if(xr==x) { return yr; } return x; } else { if(xr==x||yr==y) { return xr==x?x:y; } if(xr==yr) { return xy; } if((xr==rt&amp;&amp;yr==xy)||(xr==xy&amp;&amp;yr==rt)) { return rt; } return xr==xy?yr:xr; } } 链上询问/修改 显然无论根怎么换，链 (u,v)(u,v)(u,v) 上的节点都不会改变，所以直接修改即可。 子树内询问/修改 图中绿色节点是 xxx。 若 rt=xrt=xrt=x，那么查询/修改整棵子树 若 rtrtrt 位于黄色区域，即 $\\operatorname{lca}(x,rt)=x，那么查询/修改 xxx 子树除了 rtrtrt 方向儿子的子树外所有的节点 否则说明 rtrtrt 位于粉色区域，那么查询/求改 xxx 子树即可 代码如下： inline int jump(int x,int k) { for(int i=25;i&gt;=0;i--) { if(k&amp;(1&lt;&lt;i)) { x=up[x][i]; } } return x; } inline int quesubtree(int x) { if(x==rt) { return que(1,1,n,1,n); } int xr; if(dep[rt]&gt;dep[x]&amp;&amp;up[xr=jump(rt,dep[rt]-dep[x]-1)][0]==x) { if(id[xr]==1) { return que(1,1,n,R[xr]+1,n); } if(R[xr]==n) { return que(1,1,n,1,id[xr]-1); } return min(que(1,1,n,1,id[xr]-1),que(1,1,n,R[xr]+1,n)); } return que(1,1,n,id[x],R[x]); } 模板题代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long S=1000005,MS=100005; const int inf=2147483647; int n,m,val[MS]; int esum,to[S],nxt[S],h[MS]; int up[MS][30],dep[MS],siz[MS],hson[MS]; int cnt,id[MS],top[MS],a[MS],R[MS]; int minn[MS&lt;&lt;2],lazy[MS&lt;&lt;2]; int rt; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs1(int u,int fa) { up[u][0]=fa; for(int i=1;i&lt;=25;i++) { up[u][i]=up[up[u][i-1]][i-1]; } dep[u]=dep[fa]+1; siz[u]=1; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[hson[u]]) { hson[u]=v; } } } void dfs2(int u,int tpf) { id[u]=++cnt; top[u]=tpf; a[cnt]=val[u]; if(hson[u]!=0) { dfs2(hson[u],tpf); } for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==up[u][0]||v==hson[u]) { continue; } dfs2(v,v); } R[u]=cnt; } void build(int u,int l,int r) { lazy[u]=-1; if(l==r) { minn[u]=a[l]; return; } int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); minn[u]=min(minn[u&lt;&lt;1],minn[u&lt;&lt;1|1]); } void upd(int u,int l,int r,int L,int R,int k) { if(l&gt;R||r&lt;L) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { minn[u]=k; lazy[u]=k; return; } if(lazy[u]!=-1) { minn[u&lt;&lt;1]=lazy[u]; minn[u&lt;&lt;1|1]=lazy[u]; lazy[u&lt;&lt;1]=lazy[u]; lazy[u&lt;&lt;1|1]=lazy[u]; lazy[u]=-1; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) { upd(u&lt;&lt;1,l,mid,L,R,k); } if(R&gt;=mid+1) { upd(u&lt;&lt;1|1,mid+1,r,L,R,k); } minn[u]=min(minn[u&lt;&lt;1],minn[u&lt;&lt;1|1]); } int que(int u,int l,int r,int L,int R) { if(l&gt;R||r&lt;l) { return inf; } if(l&gt;=L&amp;&amp;r&lt;=R) { return minn[u]; } if(lazy[u]!=-1) { minn[u&lt;&lt;1]=lazy[u]; minn[u&lt;&lt;1|1]=lazy[u]; lazy[u&lt;&lt;1]=lazy[u]; lazy[u&lt;&lt;1|1]=lazy[u]; lazy[u]=-1; } int mid=l+r&gt;&gt;1,res=inf; if(L&lt;=mid) { res=min(res,que(u&lt;&lt;1,l,mid,L,R)); } if(R&gt;=mid+1) { res=min(res,que(u&lt;&lt;1|1,mid+1,r,L,R)); } return res; } inline int jump(int x,int k) { for(int i=25;i&gt;=0;i--) { if(k&amp;(1&lt;&lt;i)) { x=up[x][i]; } } return x; } inline int getlca(int x,int y) { if(dep[x]&lt;dep[y]) { swap(x,y); } for(int i=25;i&gt;=0;i--) { if(dep[up[x][i]]&gt;=dep[y]) { x=up[x][i]; } } if(x==y) { return x; } for(int i=25;i&gt;=0;i--) { if(up[x][i]!=up[y][i]) { x=up[x][i]; y=up[y][i]; } } return up[x][0]; } inline int getLCA(int x,int y) { if(dep[x]&gt;dep[y]) { swap(x,y); } int xr=getlca(x,rt),yr=getlca(y,rt),xy=getlca(x,y); if(xy==x) { if(xr==x&amp;&amp;yr==y) { return y; } if(xr==x) { return yr; } return x; } else { if(xr==x||yr==y) { return xr==x?x:y; } if(xr==yr) { return xy; } if((xr==rt&amp;&amp;yr==xy)||(xr==xy&amp;&amp;yr==rt)) { return rt; } return xr==xy?yr:xr; } } inline void updpath(int x,int y,int k) { while(top[x]!=top[y]) { if(dep[top[x]]&gt;dep[top[y]]) { upd(1,1,n,id[top[x]],id[x],k); x=up[top[x]][0]; } else { upd(1,1,n,id[top[y]],id[y],k); y=up[top[y]][0]; } } upd(1,1,n,min(id[x],id[y]),max(id[x],id[y]),k); } inline int quesubtree(int x) { if(x==rt) { return que(1,1,n,1,n); } int xr; if(dep[rt]&gt;dep[x]&amp;&amp;up[xr=jump(rt,dep[rt]-dep[x]-1)][0]==x) { if(id[xr]==1) { return que(1,1,n,R[xr]+1,n); } if(R[xr]==n) { return que(1,1,n,1,id[xr]-1); } return min(que(1,1,n,1,id[xr]-1),que(1,1,n,R[xr]+1,n)); } return que(1,1,n,id[x],R[x]); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;val[i]); } scanf(&quot;%d&quot;,&amp;rt); dfs1(1,0); dfs2(1,1); build(1,1,n); while(m--) { int op; scanf(&quot;%d&quot;,&amp;op); if(op==1) { scanf(&quot;%d&quot;,&amp;rt); } else if(op==2) { int x,y,k; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k); updpath(x,y,k); } else { int x; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,quesubtree(x)); } } return 0; } 练习题目 CF916E Jamie and Tree ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"换根树剖学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/huan-gen-shu-pou-xue-xi-bi-ji/","stats":{"text":"12 min read","time":690000,"words":2034,"minutes":12},"date":"2023-03-23 16:14:28","dateFormat":"2023-03-23"},{"abstract":"","content":"有些时候，我们想要计算一个集合 SSS 里元素的最小值/最大值，设最小值为 MIN⁡(S)=min⁡x∈Sx\\operatorname{MIN}(S)=\\min\\limits_{x\\in S}xMIN(S)=x∈Smin​x，最大值为 MAX⁡(S)=max⁡x∈Sx\\operatorname{MAX}(S)=\\max\\limits_{x\\in S}xMAX(S)=x∈Smax​x。 但是有时我们想要求 MIN⁡(S)\\operatorname{MIN}(S)MIN(S)，但却很难求，反而 MAX⁡(S)\\operatorname{MAX}(S)MAX(S) 很好求；或者想要求 MAX⁡(S)\\operatorname{MAX}(S)MAX(S)，但却很难求，反而 MIN⁡(S)\\operatorname{MIN}(S)MIN(S) 很好求。那么这时就可以通过 Min-Max 容斥来实现 MIN⁡(S)\\operatorname{MIN}(S)MIN(S) 和 MAX⁡(S)\\operatorname{MAX}(S)MAX(S) 的互相转化，从而求得 MIN⁡(S)\\operatorname{MIN}(S)MIN(S) 或者 MAX⁡(S)\\operatorname{MAX}(S)MAX(S)。 朴素 Min-Max 容斥 Min-Max 容斥，先给出式子： MIN⁡(S)=∑T⊆S(−1)∣T∣+1MAX⁡(T)MAX⁡(S)=∑T⊆S(−1)∣T∣+1MIN⁡(T)\\operatorname{MIN}(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}\\operatorname{MAX}(T)\\\\ \\operatorname{MAX}(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}\\operatorname{MIN}(T)\\\\ MIN(S)=T⊆S∑​(−1)∣T∣+1MAX(T)MAX(S)=T⊆S∑​(−1)∣T∣+1MIN(T) 先考虑第一个式子的证明： 首先假设 SSS 内元素互不相同（离散化），然后令 SSS 中元素升序排列后的数列为 AAA。 令 MAX⁡(T)=Ai\\operatorname{MAX}(T)=A_iMAX(T)=Ai​，有以下两种情况： i=1i=1i=1，那么显然 ∣T∣=1|T|=1∣T∣=1，此时 MAX⁡(T)=MIN⁡(S)\\operatorname{MAX}(T)=\\operatorname{MIN}(S)MAX(T)=MIN(S)，TTT 的贡献也就是 (−1)2MIN⁡(S)=MIN⁡(S)(-1)^2\\operatorname{MIN}(S)=\\operatorname{MIN}(S)(−1)2MIN(S)=MIN(S)； i&gt;1i&gt;1i&gt;1，那么集合内显然不可能存在满足 j&gt;ij&gt;ij&gt;i 的 AjA_{j}Aj​，那么只有 2i−12^{i-1}2i−1 个集合贡献为 AiA_iAi​，显然有 2i−22^{i-2}2i−2 个集合的大小是奇数，2i−22^{i-2}2i−2 个集合的大小是偶数，它们抵消了，所以此时 TTT 的贡献是 000； 第二个式子证明过程大体相同，只不过 AAA 换成了降序排列。 Min-Max 的优点在于它能实现 f(MIN⁡(S))f(\\operatorname{MIN}(S))f(MIN(S)) 和 f(MAX⁡(S))f(\\operatorname{MAX}(S))f(MAX(S)) 的不涉及到取 min⁡\\minmin 和取 max⁡\\maxmax 操作的互相转化，其中 fff 是任意一个线性函数，例如期望。 理解了它的原理后也不难推出式子： f(MIN⁡(S))=∑T⊆S(−1)∣T∣+1f(MAX⁡(T))f(MAX⁡(S))=∑T⊆S(−1)∣T∣+1f(MIN⁡(T))f(\\operatorname{MIN}(S))=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}f(\\operatorname{MAX}(T))\\\\ f(\\operatorname{MAX}(S))=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}f(\\operatorname{MIN}(T))\\\\ f(MIN(S))=T⊆S∑​(−1)∣T∣+1f(MAX(T))f(MAX(S))=T⊆S∑​(−1)∣T∣+1f(MIN(T)) Kth-Min-Max 容斥 Min-Max 容斥的另一个优点在于，它还能求出集合 SSS 的第 kkk 大/小 MAX⁡k(S)\\operatorname{MAX}_k(S)MAXk​(S) 和 MIN⁡k(S)\\operatorname{MIN}_k(S)MINk​(S)，推导如下： 考虑令 MIN⁡k(S)=∑T⊆SF(∣T∣)MAX⁡(T)\\operatorname{MIN}_k(S)=\\sum\\limits_{T\\subseteq S}F(|T|)\\operatorname{MAX}(T)MINk​(S)=T⊆S∑​F(∣T∣)MAX(T)，构造 FFF。 类似的，假设 SSS 内元素互不相同（离散化），然后令 SSS 中元素降升序排列后的数列 AAA。 我们设 MAX⁡(T)=Ap\\operatorname{MAX}(T)=A_pMAX(T)=Ap​ 那么显然只有 TTT 不包含满足 j&gt;pj&gt;pj&gt;p 的 AjA_jAj​ 才能让 MAX⁡(T)=Ap\\operatorname{MAX}(T)=A_pMAX(T)=Ap​，即有 p−1p-1p−1 个数可供选择，所以对于所有满足 MAX⁡(T)=Ap\\operatorname{MAX}(T)=A_pMAX(T)=Ap​ 的 TTT，它的系数 FFF 是： ∑i=0p−1(p−1i)F(i+1)\\sum\\limits_{i=0}^{p-1}\\dbinom{p-1}{i}F(i+1) i=0∑p−1​(ip−1​)F(i+1) 求和函数的变量 iii 表示除了 ApA_pAp​ 外多选的元素，然后 F(i+1)F(i+1)F(i+1) 表示选那么多数的贡献系数，(p−1i)\\dbinom{p-1}{i}(ip−1​) 表示可以随便选择。 然后我们想让 FFF 满足： ∑i=0p−1(p−1i)F(i+1)=[p=k]\\sum\\limits_{i=0}^{p-1}\\dbinom{p-1}{i}F(i+1)=[p=k] i=0∑p−1​(ip−1​)F(i+1)=[p=k] 即： ∑i=0p(pi)F(i+1)=[p=k−1]\\sum\\limits_{i=0}^{p}\\dbinom{p}{i}F(i+1)=[p=k-1] i=0∑p​(ip​)F(i+1)=[p=k−1] 二项式反演一下： [p=k+1]=∑i=0p(pi)F(i+1)⇒F(p+1)=∑i=0p(−1)p−i(pi)[i=k−1][p=k+1]=\\sum\\limits_{i=0}^{p}\\dbinom{p}{i}F(i+1)\\Rightarrow F(p+1)=\\sum\\limits_{i=0}^{p}(-1)^{p-i}\\dbinom{p}{i}[i=k-1] [p=k+1]=i=0∑p​(ip​)F(i+1)⇒F(p+1)=i=0∑p​(−1)p−i(ip​)[i=k−1] 即： F(p)=(−1)p−k(p−1k−1)F(p)=(-1)^{p-k}\\dbinom{p-1}{k-1} F(p)=(−1)p−k(k−1p−1​) 所以： MIN⁡k(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)MAX⁡(T)MAX⁡k(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)MIN⁡(T)\\operatorname{MIN}_k(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-k}\\dbinom{|T|-1}{k-1}\\operatorname{MAX}(T)\\\\ \\operatorname{MAX}_k(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-k}\\dbinom{|T|-1}{k-1}\\operatorname{MIN}(T) MINk​(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)MAX(T)MAXk​(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)MIN(T) 代入 k=1k=1k=1 验证： MIN⁡1(S)=∑T⊆S(−1)∣T∣−1(∣T∣−11−1)MAX⁡(T)=∑T⊆S(−1)∣T∣−1MAX⁡(T)\\begin{aligned} \\operatorname{MIN}_1(S)&amp;=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-1}\\dbinom{|T|-1}{1-1}\\operatorname{MAX}(T)\\\\ &amp;=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-1}\\operatorname{MAX}(T)\\\\ \\end{aligned} MIN1​(S)​=T⊆S∑​(−1)∣T∣−1(1−1∣T∣−1​)MAX(T)=T⊆S∑​(−1)∣T∣−1MAX(T)​ 发现得到了之前的式子，所以我们推对了。 同样的，Kth-Min-Max 容斥也可以套上任意线性函数。 应用 HDU 4624 Endless Spin 双倍经验：ABC242Ex Random Painting 要求所有球均被染色的时间，可以通过 Min-Max 容斥转化为求一个子集 SSS 中的球最早被染色的时间 TmeSTme_STmeS​。 进一步的，若 SSS 中的球被染色的概率为 ppp，那么 TmeSTme_STmeS​ 就等于 1p\\frac{1}{p}p1​。 而被染色的概率很好求，只要求出能给这些球染色的区间个数 sumsumsum，除以总的区间个数 (n2)+n\\binom{n}{2}+n(2n​)+n 即可。 那么直接设 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个球处理完毕，当前子集 SSS 选了球 iii 且不被染色的选区间的方案数为 jjj 的选子集的方案数，转移的时候把容斥系数也乘进去，最后套 Min-Max 的式子即可。 时间复杂度 O(n4)O(n^4)O(n4)。 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Min-Max 容斥学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/min-max-rong-chi-xue-xi-bi-ji/","stats":{"text":"8 min read","time":469000,"words":1563,"minutes":8},"date":"2023-03-23 16:12:27","dateFormat":"2023-03-23"},{"abstract":"","content":"二项式反演在需要容斥问题的中经常出现，也是很多知识的基础。 引入 首先设 A1,A2,…,AnA_1,A_2,\\dots,A_nA1​,A2​,…,An​ 是 nnn 个集合，那么有： ∣Ai∪A2∪⋯∪An∣=(∑1≤i≤n∣Ai∣)−(∑1≤i&lt;j≤n∣Ai∩Aj∣)+(∑1≤i&lt;j&lt;k≤n∣Ai∩Aj∩Ak∣)−⋯+(−1)n−1×∣A1∩A2∩⋯∩An∣|A_i\\cup A_2\\cup\\dots\\cup A_n|=\\left(\\sum\\limits_{1\\le i\\le n}|A_i|\\right)-\\left(\\sum\\limits_{1\\le i&lt;j\\le n}|A_i\\cap A_j|\\right)+\\left(\\sum\\limits_{1\\le i&lt;j&lt;k\\le n}|A_i\\cap A_j\\cap A_k|\\right)-\\dots+(-1)^{n-1}\\times|A_1\\cap A_2\\cap\\dots\\cap A_n| ∣Ai​∪A2​∪⋯∪An​∣=(1≤i≤n∑​∣Ai​∣)−(1≤i&lt;j≤n∑​∣Ai​∩Aj​∣)+⎝⎛​1≤i&lt;j&lt;k≤n∑​∣Ai​∩Aj​∩Ak​∣⎠⎞​−⋯+(−1)n−1×∣A1​∩A2​∩⋯∩An​∣ 这其实很好理解，就是减掉算重一次的，加上算重两次的，减掉算重三次的…… 变形一下，有：（AicA_i^cAic​ 是 AiA_iAi​ 的补集，SSS 是全集） ∣Aic∩A2c∩⋯∩Anc∣=∣S∣−(∑1≤i≤n∣Ai∣)+(∑1≤i&lt;j≤n∣Ai∩Aj∣)−(∑1≤i&lt;j&lt;k≤n∣Ai∩Aj∩Ak∣)+⋯+(−1)n×∣A1∩A2∩⋯∩An∣|A_i^c\\cap A_2^c\\cap\\dots\\cap A_n^c|=|S|-\\left(\\sum\\limits_{1\\le i\\le n}|A_i|\\right)+\\left(\\sum\\limits_{1\\le i&lt;j\\le n}|A_i\\cap A_j|\\right)-\\left(\\sum\\limits_{1\\le i&lt;j&lt;k\\le n}|A_i\\cap A_j\\cap A_k|\\right)+\\dots+(-1)^n\\times|A_1\\cap A_2\\cap\\dots\\cap A_n| ∣Aic​∩A2c​∩⋯∩Anc​∣=∣S∣−(1≤i≤n∑​∣Ai​∣)+(1≤i&lt;j≤n∑​∣Ai​∩Aj​∣)−⎝⎛​1≤i&lt;j&lt;k≤n∑​∣Ai​∩Aj​∩Ak​∣⎠⎞​+⋯+(−1)n×∣A1​∩A2​∩⋯∩An​∣ 由于补集的补集是原集，所以有： ∣Ai∩A2∩⋯∩An∣=∣S∣−(∑1≤i≤n∣Aic∣)+(∑1≤i&lt;j≤n∣Aic∩Ajc∣)−(∑1≤i&lt;j&lt;k≤n∣Aic∩Ajc∩Akc∣)+⋯+(−1)n×∣A1c∩A2c∩⋯∩Anc∣|A_i\\cap A_2\\cap\\dots\\cap A_n|=|S|-\\left(\\sum\\limits_{1\\le i\\le n}|A_i^c|\\right)+\\left(\\sum\\limits_{1\\le i&lt;j\\le n}|A_i^c\\cap A_j^c|\\right)-\\left(\\sum\\limits_{1\\le i&lt;j&lt;k\\le n}|A_i^c\\cap A_j^c\\cap A_k^c|\\right)+\\dots+(-1)^n\\times|A_1^c\\cap A_2^c\\cap\\dots\\cap A_n^c| ∣Ai​∩A2​∩⋯∩An​∣=∣S∣−(1≤i≤n∑​∣Aic​∣)+(1≤i&lt;j≤n∑​∣Aic​∩Ajc​∣)−⎝⎛​1≤i&lt;j&lt;k≤n∑​∣Aic​∩Ajc​∩Akc​∣⎠⎞​+⋯+(−1)n×∣A1c​∩A2c​∩⋯∩Anc​∣ 考虑一种特殊情况，集合的交集大小之和集合个数有关。设 f(n)f(n)f(n) 表示 nnn 个集合的补集的交集大小，g(n)g(n)g(n) 表示 nnn 个集合的交集大小，那么上面两条式子可以写成： f(n)=∑i=0n(−1)i(ni)g(i)f(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}g(i) f(n)=i=0∑n​(−1)i(in​)g(i) g(n)=∑i=0n(−1)i(ni)f(i)g(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}f(i) g(n)=i=0∑n​(−1)i(in​)f(i) 所以这两条式子是等价的关系，那么有： f(n)=∑i=0n(−1)i(ni)g(i) ⟺ g(n)=∑i=0n(−1)i(ni)f(i)f(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}g(i)\\iff g(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}f(i) f(n)=i=0∑n​(−1)i(in​)g(i)⟺g(n)=i=0∑n​(−1)i(in​)f(i) 这就是二项式反演的形式一。 更多形式 形式二 f(n)=∑i=0n(ni)g(i) ⟺ g(n)=∑i=0n(−1)n−i(ni)f(i)f(n)=\\sum\\limits_{i=0}^n\\dbinom{n}{i}g(i)\\iff g(n)=\\sum\\limits_{i=0}^n(-1)^{n-i}\\dbinom{n}{i}f(i) f(n)=i=0∑n​(in​)g(i)⟺g(n)=i=0∑n​(−1)n−i(in​)f(i) 证明： 令 h(n)=(−1)ng(n)h(n)=(-1)^n g(n)h(n)=(−1)ng(n)，那么带入形式一有 f(n)=∑i=0n(ni)h(i) ⟺ h(n)(−1)n=g(n)=∑i=0n(−1)i(ni)f(i)f(n)=\\sum\\limits_{i=0}^n\\binom{n}{i}h(i)\\iff \\frac{h(n)}{(-1)^n}=g(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}f(i)f(n)=i=0∑n​(in​)h(i)⟺(−1)nh(n)​=g(n)=i=0∑n​(−1)i(in​)f(i)，整理后即得证。 形式三 f(n)=∑i=nm(in)g(i) ⟺ g(n)=∑i=nm(−1)i−n(in)f(i)f(n)=\\sum\\limits_{i=n}^m\\binom{i}{n}g(i)\\iff g(n)=\\sum\\limits_{i=n}^m(-1)^{i-n}\\binom{i}{n}f(i) f(n)=i=n∑m​(ni​)g(i)⟺g(n)=i=n∑m​(−1)i−n(ni​)f(i) 证明： 组合意义是 f(n)f(n)f(n) 表示钦定 nnn 个选，g(n)g(n)g(n) 表示恰好选 nnn 个。因为 f(n)f(n)f(n) 同一种方案会计算多次，具体的，选 nnn 个的方案钦定选 iii 个就会重复计算 (ni)\\binom{n}{i}(in​) 次，所以 f(n)=∑i=nm(in)g(i)f(n)=\\sum\\limits_{i=n}^m\\binom{i}{n}g(i)f(n)=i=n∑m​(ni​)g(i)。而 g(n)=∑i=nm(−1)i−n(in)f(i)=∑i=nm(−1)i−n(in)∑j=im(ji)g(j)=∑j=nmg(j)∑i=nj(−1)i−n(in)(ji)=∑j=nmg(j)∑i=nj(−1)i−ni!n!(i−n)!j!i!(j−i)!=∑j=nmg(j)∑i=nj(−1)i−nj!n!(i−n)!(j−i)!=∑j=nmg(j)∑i=nj(−1)i−nj!(j−n)!n!(i−n)!(j−i)!(j−n)!=∑j=nm(jn)g(j)∑i=nj(−1)i−n(j−ni−n)=∑j=nm(jn)g(j)∑i=0j−n(−1)i(j−ni)=∑j=nm(jn)g(j)(1−1)j−n=∑j=nm(jn)g(j)[j==n]=(nn)g(n)=g(n)\\begin{aligned} g(n)&amp;=\\sum\\limits_{i=n}^m(-1)^{i-n}\\binom{i}{n}f(i)\\\\ &amp;=\\sum\\limits_{i=n}^m(-1)^{i-n}\\binom{i}{n}\\sum\\limits_{j=i}^m\\binom{j}{i}g(j)\\\\ &amp;=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\binom{i}{n}\\binom{j}{i}\\\\ &amp;=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\frac{i!}{n!(i-n)!}\\frac{j!}{i!(j-i)!}\\\\ &amp;=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\frac{j!}{n!(i-n)!(j-i)!}\\\\ &amp;=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\frac{j!(j-n)!}{n!(i-n)!(j-i)!(j-n)!}\\\\ &amp;=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\binom{j-n}{i-n}\\\\ &amp;=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)\\sum\\limits_{i=0}^{j-n}(-1)^{i}\\binom{j-n}{i}\\\\ &amp;=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)(1-1)^{j-n}\\\\ &amp;=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)[j==n]\\\\ &amp;=\\binom{n}{n}g(n)\\\\ &amp;=g(n)\\\\ \\end{aligned} g(n)​=i=n∑m​(−1)i−n(ni​)f(i)=i=n∑m​(−1)i−n(ni​)j=i∑m​(ij​)g(j)=j=n∑m​g(j)i=n∑j​(−1)i−n(ni​)(ij​)=j=n∑m​g(j)i=n∑j​(−1)i−nn!(i−n)!i!​i!(j−i)!j!​=j=n∑m​g(j)i=n∑j​(−1)i−nn!(i−n)!(j−i)!j!​=j=n∑m​g(j)i=n∑j​(−1)i−nn!(i−n)!(j−i)!(j−n)!j!(j−n)!​=j=n∑m​(nj​)g(j)i=n∑j​(−1)i−n(i−nj−n​)=j=n∑m​(nj​)g(j)i=0∑j−n​(−1)i(ij−n​)=j=n∑m​(nj​)g(j)(1−1)j−n=j=n∑m​(nj​)g(j)[j==n]=(nn​)g(n)=g(n)​ 所以得证。 例题 bzoj 2839 集合计数 设 f(i)f(i)f(i) 表示钦定交集有 iii 个的方案数，g(i)g(i)g(i) 表示交集恰好有 iii 个的方案数，那么有 f(i)=(ni)(22n−i−1)f(i)=\\binom{n}{i}(2^{2^{n-i}}-1)f(i)=(in​)(22n−i−1)，f(i)=∑j=in(ji)g(j)f(i)=\\sum\\limits_{j=i}^n\\binom{j}{i}g(j)f(i)=j=i∑n​(ij​)g(j)，反演一下得到 g(i)=∑j=in(−1)j−i(ji)f(j)g(i)=\\sum\\limits_{j=i}^n(-1)^{j-i}\\binom{j}{i}f(j)g(i)=j=i∑n​(−1)j−i(ij​)f(j)，由于只要算一次，所以直接算就行了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int S=1000005,p=1000000007; int fra[S],inv[S]; int n,k; int f[S]; inline int qpow(int x,int y,int p) { int res=1; for(;y&gt;0;y&gt;&gt;=1,x=1ll*x*x%p) res=(y&amp;1)?1ll*res*x%p:res; return res; } inline int C(int n,int m) { return 1ll*fra[n]*inv[n-m]%p*inv[m]%p; } int main() { fra[0]=1; for(int i=1;i&lt;=S-3;i++) fra[i]=1ll*fra[i-1]*i%p; inv[S-3]=qpow(fra[S-3],p-2,p); for(int i=S-3;i&gt;=1;i--) inv[i-1]=1ll*inv[i]*i%p; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;=n;i++) f[i]=1ll*C(n,i)*((long long)qpow(2,qpow(2,n-i,p-1),p)-1+p)%p; int ans=0; for(int i=k;i&lt;=n;i++) { int pre=1ll*C(i,k)*f[i]%p; if(i-k&amp;1) ans=(ans-pre+p)%p; else ans=(ans+pre)%p; } printf(&quot;%d\\n&quot;,ans); return 0; } 习题 P4859 已经没有什么好害怕的了 P5505 [JSOI2011]分特产 ","tags":[{"name":"组合计数","slug":"vqtoUvqF8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/vqtoUvqF8/"},{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"二项式反演学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/er-xiang-shi-fan-yan-xue-xi-bi-ji/","stats":{"text":"12 min read","time":670000,"words":1946,"minutes":12},"date":"2023-03-23 16:11:37","dateFormat":"2023-03-23"},{"abstract":"","content":"树上最小 k 覆盖问题是一种很典型的树上贪心问题，这里做一下小结。 树上最小 k 覆盖问题的形式一般是： 给定一棵树，边有边权，点 uuu 有满足 du∈{0,1}d_u\\in\\{0,1\\}du​∈{0,1} 的点权 dud_udu​，称所有满足 du=1d_u=1du​=1 的 uuu 为“关键点”。 你需要选中一些点，令所有的“关键点”被这些点覆盖。一个“关键点”xxx 被“覆盖”了当且仅当存在一个你选中的点 yyy，满足 xxx 和 yyy 之间的距离小于等于 kkk，你需要最小化选中的点的数量。 这个问题有诸多变形，比较常见的是配合二分答案来考。 我们可以使用树上贪心来解决这个问题。 首先设 fuf_ufu​ 表示 uuu 子树内距离 uuu 最远的未被覆盖的关键点距 uuu 的距离，显然 fu=max⁡{fx+1,x∈sonu}f_u=\\max\\{f_x+1,x\\in son_u\\}fu​=max{fx​+1,x∈sonu​}。 考虑距离 uuu 最远的未被覆盖的关键点 vvv，vvv 显然有可能被 uuu 子树里的点覆盖，也有可能被 uuu 的父亲覆盖，或者被 uuu 的兄弟子树里的点覆盖。那么我们先考虑被 uuu 的子树里的点覆盖的情况，显然画出来时这样的：（黄色节点代表 vvv，绿色节点代表一个已经被选中且覆盖黄色节点的点 www） 显然，vvv 和 www 不可能是 uuu 的同一个儿子的子孙，因为那样的话 vvv 早就已经被 www 覆盖了。所以 vvv 和 www 之间的距离就是 vvv 和 uuu 的距离加上 www 和 uuu 的距离，也就是 fuf_ufu​ 加上 www 和 uuu 的距离。那么我们就要让 www 和 uuu 的距离尽可能短，不妨设它为 gug_ugu​，那么显然 gu=min⁡{gx+1,x∈sonu}g_u=\\min\\{g_x+1,x\\in son_u\\}gu​=min{gx​+1,x∈sonu​}。 接下来分类讨论： 若 fu+gu≤kf_u+g_u\\le kfu​+gu​≤k，那么 uuu 的子树能自给自足，这时 fu=−inf⁡f_u=-\\inffu​=−inf，表示 uuu 的字树内没有关键点未被覆盖； 若 fu=kf_u=kfu​=k，说明 vvv 必须被 uuu 覆盖了，这时需要选中 uuu，同时整棵 uuu 的子树都会被覆盖，则 fu=−inf⁡f_u=-\\inffu​=−inf，gu=0g_u=0gu​=0，ans++ans++ans++； 若 du=1d_u=1du​=1 且 gu&gt;kg_u&gt;kgu​&gt;k，说明 uuu 是关键点且不能被它子树内之前选中的点覆盖，那么果断交给自己的父亲和兄弟子树，fu=max⁡(fu,0)f_u=\\max(f_u,0)fu​=max(fu​,0)。 这三种情况有可能同时成立多种，但并不互相干扰，所以需要写成三个 if 并行。 最后注意若 f1≥0f_1\\ge0f1​≥0 说明还有关键点没被覆盖，等着 111 号节点的父亲和兄弟子树覆盖它们。但是 111 号节点没有父亲和兄弟，此时直接选中 111 号节点即可，ans++ans++ans++。 例题代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long S=1000005,MS=300005; const int inf=1e8; int n,m,d[MS]; int esum,to[S],nxt[S],h[MS]; int tot,f[MS],g[MS]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u,int fa,int mid) { f[u]=-inf; g[u]=inf; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs(v,u,mid); f[u]=max(f[u],f[v]+1); g[u]=min(g[u],g[v]+1); } if(f[u]+g[u]&lt;=mid) { f[u]=-inf; } if(d[u]==1&amp;&amp;g[u]&gt;mid) { f[u]=max(f[u],0); } if(f[u]==mid) { f[u]=-inf; g[u]=0; tot++; } } inline bool check(int mid) { tot=0; dfs(1,0,mid); if(f[1]&gt;=0) { tot++; } return tot&lt;=m; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;d[i]); } for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } int l=0,r=n,ans=-1; while(l&lt;=r) { int mid=l+r&gt;&gt;1; if(check(mid)) { ans=mid; r=mid-1; } else { l=mid+1; } } printf(&quot;%d\\n&quot;,ans); return 0; } 练习题目 P3942 将军令 ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"树上最小 k 覆盖问题学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/shu-shang-zui-xiao-k-fu-gai-wen-ti-xue-xi-bi-ji/","stats":{"text":"5 min read","time":277000,"words":1017,"minutes":5},"date":"2023-03-23 16:09:02","dateFormat":"2023-03-23"},{"abstract":"","content":"动态 dp，其实是一个用线段树+矩阵乘法来实现带修快速对一段区间进行 dp 的算法。 Part 1 序列上动态 DP 主体思路 首先学过矩阵快速幂优化递推的同学肯定都知道，矩阵乘法本质上可以是 dp 的转移。 那么我们就可以在构造出状态 i−1→i-1\\toi−1→ 状态 iii 的转移矩阵后，使用线段树维护这些矩阵，实现快速进行 dp。 但是有个问题，有些 dp 需要最大值和最小值操作。这时，我们就可以重新定义一下矩阵乘法了： Ci,j=max⁡kAi,k+Bk,jC_{i,j}=\\max\\limits_{k} A_{i,k}+B_{k,j} Ci,j​=kmax​Ai,k​+Bk,j​ 或者 Ci,j=min⁡kAi,k+Bk,jC_{i,j}=\\min\\limits_{k} A_{i,k}+B_{k,j} Ci,j​=kmin​Ai,k​+Bk,j​ 稍加思考可以发现，这样定义矩阵乘法，可以方便大多数 dp 的转移： 若某一项需要加上 xxx，那么对应位置设为 xxx 若某一项不能算进答案，那么对应位置设为 −inf/inf-inf/inf−inf/inf 而且它满足结合律。 但是如果某一项需要乘上系数，dp 转移还需要最大/最小值，那么动态 dp 就无法解决了。 由于线段树的操作是 O(log⁡n)O(\\log n)O(logn) 的，所以动态 dp 的单次时间复杂度是 O(log⁡n)O(\\log n)O(logn)。 例题讲解 SP1043 GSS1 - Can you answer these queries I 可以发现，这道题和小白逛公园十分类似，但我们尝试使用动态 dp 求解。 考虑朴素的 dp，定义 fif_ifi​ 为以 iii 结尾的最大子段和，gi=max⁡j≤ifjg_i=\\max\\limits_{j\\le i} f_jgi​=j≤imax​fj​。 那么易得转移方程： {fi=max⁡(fi−1+ai,ai)gi=max⁡(gi−1,fi)\\begin{cases}f_i=\\max(f_{i-1}+a_i,a_i)\\\\g_i=\\max(g_{i-1},f_i)\\end{cases} {fi​=max(fi−1​+ai​,ai​)gi​=max(gi−1​,fi​)​ 接下来考虑转移矩阵的构造。 设当前已经求出了 fif_ifi​ 和 gig_igi​，要求 fi+1f_{i+1}fi+1​ 和 gi+1g_{i+1}gi+1​。 那么设当前矩阵为 [fi0gi]\\begin{bmatrix}f_i&amp;0&amp;g_i\\end{bmatrix}[fi​​0​gi​​]，则可以构造转移矩阵： [fi0gi]⋅[ai−infaiai0ai−inf−inf0]=[fi+10gi+1]\\begin{bmatrix}f_i&amp;0&amp;g_i\\end{bmatrix}\\cdot\\begin{bmatrix}a_i&amp;-inf&amp;a_i\\\\a_i&amp;0&amp;a_i\\\\-inf&amp;-inf&amp;0\\end{bmatrix}=\\begin{bmatrix}f_{i+1}&amp;0&amp;g_{i+1}\\end{bmatrix} [fi​​0​gi​​]⋅⎣⎡​ai​ai​−inf​−inf0−inf​ai​ai​0​⎦⎤​=[fi+1​​0​gi+1​​] 注意此时的矩阵乘法是重新定义过的：Ci,j=max⁡kAi,k+Bk,jC_{i,j}=\\max\\limits_{k} A_{i,k}+B_{k,j}Ci,j​=kmax​Ai,k​+Bk,j​。 推出转移矩阵后，我们只要造一棵线段树来维护就好了。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const long long MS=50005; struct mrt { int n,m; long long dat[15][15]; }tree[MS&lt;&lt;4]; int n,m; long long a[MS]; inline long long read() { long long s=0,w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48),ch=getchar(); return s*w; } inline mrt mrtmul(mrt x,mrt y) { if(x.n==-1&amp;&amp;x.m==-1) { return y; } if(y.n==-1&amp;&amp;y.m==-1) { return x; } mrt res; res.n=x.n; res.m=y.m; for(int i=1;i&lt;=res.n;i++) { for(int j=1;j&lt;=res.m;j++) { res.dat[i][j]=-1e17; } } for(int i=1;i&lt;=x.n;i++) { for(int j=1;j&lt;=y.m;j++) { for(int k=1;k&lt;=x.m;k++) { res.dat[i][j]=max(res.dat[i][j],x.dat[i][k]+y.dat[k][j]); } } } return res; } inline void updata(int u) { tree[u]=mrtmul(tree[u&lt;&lt;1],tree[u&lt;&lt;1|1]); } void build(int u,int l,int r) { if(l==r) { tree[u].n=3; tree[u].m=3; tree[u].dat[1][1]=a[l]; tree[u].dat[1][2]=-1e17; tree[u].dat[1][3]=a[l]; tree[u].dat[2][1]=a[l]; tree[u].dat[2][2]=0; tree[u].dat[2][3]=a[l]; tree[u].dat[3][1]=-1e17; tree[u].dat[3][2]=-1e17; tree[u].dat[3][3]=0; return; } int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); updata(u); } void que(int u,int l,int r,int L,int R,mrt&amp; res) { if(r&lt;L||l&gt;R) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { res=mrtmul(res,tree[u]); return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) { que(u&lt;&lt;1,l,mid,L,R,res); } if(R&gt;=mid+1) { que(u&lt;&lt;1|1,mid+1,r,L,R,res); } } int main() { n=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } build(1,1,n); m=read(); while(m--) { int x,y; x=read(); y=read(); if(x&gt;y) { swap(x,y); } if(x==y) { printf(&quot;%lld\\n&quot;,a[x]); continue; } mrt tmp; tmp.n=-1; tmp.m=-1; que(1,1,n,x+1,y,tmp); mrt ans; ans.n=1; ans.m=3; ans.dat[1][1]=a[x]; ans.dat[1][2]=0; ans.dat[1][3]=a[x]; ans=mrtmul(ans,tmp); printf(&quot;%lld\\n&quot;,ans.dat[1][3]); } return 0; } SP1716 GSS3 - Can you answer these queries III 可以发现这题是上题的加强版，动态 dp 的强大之处也在这题体现了。 这题多了一个单点修改的操作，那么只要对于修改的那个位置单独重新构造矩阵即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const long long MS=50005; struct mrt { int n,m; long long dat[15][15]; }tree[MS&lt;&lt;4]; int n,m; long long a[MS]; inline long long read() { long long s=0,w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48),ch=getchar(); return s*w; } inline mrt mrtmul(mrt x,mrt y) { if(x.n==-1&amp;&amp;x.m==-1) { return y; } if(y.n==-1&amp;&amp;y.m==-1) { return x; } mrt res; res.n=x.n; res.m=y.m; for(int i=1;i&lt;=res.n;i++) { for(int j=1;j&lt;=res.m;j++) { res.dat[i][j]=-1e17; } } for(int i=1;i&lt;=x.n;i++) { for(int j=1;j&lt;=y.m;j++) { for(int k=1;k&lt;=x.m;k++) { res.dat[i][j]=max(res.dat[i][j],x.dat[i][k]+y.dat[k][j]); } } } return res; } inline void updata(int u) { tree[u]=mrtmul(tree[u&lt;&lt;1],tree[u&lt;&lt;1|1]); } void build(int u,int l,int r) { if(l==r) { tree[u].n=3; tree[u].m=3; tree[u].dat[1][1]=a[l]; tree[u].dat[1][2]=-1e17; tree[u].dat[1][3]=a[l]; tree[u].dat[2][1]=a[l]; tree[u].dat[2][2]=0; tree[u].dat[2][3]=a[l]; tree[u].dat[3][1]=-1e17; tree[u].dat[3][2]=-1e17; tree[u].dat[3][3]=0; return; } int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); updata(u); } void upd(int u,int l,int r,int pos,long long val) { if(l==r) { tree[u].n=3; tree[u].m=3; tree[u].dat[1][1]=val; tree[u].dat[1][2]=-1e17; tree[u].dat[1][3]=val; tree[u].dat[2][1]=val; tree[u].dat[2][2]=0; tree[u].dat[2][3]=val; tree[u].dat[3][1]=-1e17; tree[u].dat[3][2]=-1e17; tree[u].dat[3][3]=0; return; } int mid=l+r&gt;&gt;1; if(pos&lt;=mid) { upd(u&lt;&lt;1,l,mid,pos,val); } else { upd(u&lt;&lt;1|1,mid+1,r,pos,val); } updata(u); } void que(int u,int l,int r,int L,int R,mrt&amp; res) { if(r&lt;L||l&gt;R) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { res=mrtmul(res,tree[u]); return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) { que(u&lt;&lt;1,l,mid,L,R,res); } if(R&gt;=mid+1) { que(u&lt;&lt;1|1,mid+1,r,L,R,res); } } int main() { n=read(); for(int i=1;i&lt;=n;i++) { a[i]=read(); } build(1,1,n); m=read(); while(m--) { int ty; ty=read(); if(ty==0) { int x=read(); long long y=read(); a[x]=y; upd(1,1,n,x,y); } else { int x=read(); int y=read(); if(x&gt;y) { swap(x,y); } if(x==y) { printf(&quot;%lld\\n&quot;,a[x]); continue; } mrt tmp; tmp.n=-1; tmp.m=-1; que(1,1,n,x+1,y,tmp); mrt ans; ans.n=1; ans.m=3; ans.dat[1][1]=a[x]; ans.dat[1][2]=0; ans.dat[1][3]=a[x]; ans=mrtmul(ans,tmp); printf(&quot;%lld\\n&quot;,ans.dat[1][3]); } } return 0; } CF750E New Year and Old Subsequence 我们可以设 fi,0/1/2/3/4f_{i,0/1/2/3/4}fi,0/1/2/3/4​ 表示前 iii 个字符，包含 ∅/2/20/201/2017\\varnothing/2/20/201/2017∅/2/20/201/2017 至少需要删除多少个字符，那么转移方程： {fi,0=fi−1,0+[si=2]fi,1=min⁡(fi−1,1+[si=0],fi−1,0[si=2])fi,2=min⁡(fi−1,2+[si=1],fi−1,1[si=0])fi,3=min⁡(fi−1,3+[si=7∨si=6],fi−1,2[si=1])fi,4=min⁡(fi−1,4+[si=6],fi−1,3[si=7])\\begin{cases}f_{i,0}=f_{i-1,0}+[s_i=2]\\\\f_{i,1}=\\min(f_{i-1,1}+[s_i=0],f_{i-1,0}[s_i=2])\\\\f_{i,2}=\\min(f_{i-1,2}+[s_i=1],f_{i-1,1}[s_i=0])\\\\f_{i,3}=\\min(f_{i-1,3}+[s_i=7\\vee s_i=6],f_{i-1,2}[s_i=1])\\\\f_{i,4}=\\min(f_{i-1,4}+[s_i=6],f_{i-1,3}[s_i=7])\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​fi,0​=fi−1,0​+[si​=2]fi,1​=min(fi−1,1​+[si​=0],fi−1,0​[si​=2])fi,2​=min(fi−1,2​+[si​=1],fi−1,1​[si​=0])fi,3​=min(fi−1,3​+[si​=7∨si​=6],fi−1,2​[si​=1])fi,4​=min(fi−1,4​+[si​=6],fi−1,3​[si​=7])​ 构造转移矩阵即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long MS=200000; const int inf=1e8; struct mrt { int n,m; int dat[6][6]; }tree[(MS&lt;&lt;2)+5]; int n,m; char a[MS+5]; inline void mrtmul(mrt &amp;res,mrt x,mrt y) { if(x.n==-1&amp;&amp;x.m==-1) { res=y; return; } if(y.n==-1&amp;&amp;y.m==-1) { res=x; return; } res.n=x.n; res.m=y.m; for(int i=1;i&lt;=res.n;i++) { for(int j=1;j&lt;=res.m;j++) { res.dat[i][j]=inf; } } for(int i=1;i&lt;=res.n;i++) { for(int j=1;j&lt;=res.m;j++) { for(int k=1;k&lt;=x.m;k++) { res.dat[i][j]=min(res.dat[i][j],x.dat[i][k]+y.dat[k][j]); } } } } inline void updata(int u) { mrtmul(tree[u],tree[u&lt;&lt;1],tree[u&lt;&lt;1|1]); } void build(int u,int l,int r) { if(l==r) { tree[u].n=5; tree[u].m=5; for(int i=1;i&lt;=5;i++) { for(int j=1;j&lt;=5;j++) { tree[u].dat[i][j]=inf; } } tree[u].dat[1][1]=a[l]==2; tree[u].dat[1][2]=(a[l]!=2)*inf; tree[u].dat[2][2]=a[l]==0; tree[u].dat[2][3]=(a[l]!=0)*inf; tree[u].dat[3][3]=a[l]==1; tree[u].dat[3][4]=(a[l]!=1)*inf; tree[u].dat[4][4]=a[l]==6||a[l]==7; tree[u].dat[4][5]=(a[l]!=7)*inf; tree[u].dat[5][5]=a[l]==6; return; } int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); updata(u); } void que(int u,int l,int r,int L,int R,mrt &amp;res) { if(r&lt;L||l&gt;R) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { mrtmul(res,res,tree[u]); return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) { que(u&lt;&lt;1,l,mid,L,R,res); } if(R&gt;=mid+1) { que(u&lt;&lt;1|1,mid+1,r,L,R,res); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,a+1); for(int i=1;i&lt;=n;i++) { a[i]-='0'; } build(1,1,n); while(m--) { int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(l&gt;r) { swap(l,r); } if(r-l+1&lt;4) { puts(&quot;-1&quot;); continue; } mrt tmp; tmp.n=-1; tmp.m=-1; que(1,1,n,l+1,r,tmp); mrt ans; ans.n=1; ans.m=5; ans.dat[1][1]=a[l]==2; ans.dat[1][2]=(a[l]!=2)*inf; ans.dat[1][3]=inf; ans.dat[1][4]=inf; ans.dat[1][5]=inf; mrtmul(ans,ans,tmp); printf(&quot;%d\\n&quot;,ans.dat[1][5]&gt;n?-1:ans.dat[1][5]); } return 0; } 练习题目 CF573D Bear and Cavalry CF1609E William The Oblivious Part 2 树上动态 DP 看一道例题：P4719 【模板】&quot;动态 DP&quot;&amp;动态树分治 给你一棵树，点有点权，带修，每次修改完输出最大独立集的大小。 我们设 fu,0/1f_{u,0/1}fu,0/1​ 表示点 uuu 没选/选了时 uuu 的子树的最大收益，那么显然有： {fu,0=∑jmax⁡(fj,0,fj,1)fu,1=∑jfj,0\\begin{cases}f_{u,0}=\\sum\\limits_{j}\\max(f_{j,0},f_{j,1})\\\\f_{u,1}=\\sum\\limits_{j}f_{j,0}\\end{cases} ⎩⎪⎨⎪⎧​fu,0​=j∑​max(fj,0​,fj,1​)fu,1​=j∑​fj,0​​ 其中 jjj 是 iii 的一个儿子。 但是当你尝试构造转移矩阵时，你就会发现这是一对多的转移，不好维护，所以我们可以跑一下树剖，并且引入一个 gu,0/1g_{u,0/1}gu,0/1​ 表示点 uuu 的所有轻儿子可选可不选/都不选时的最大收益，那么有转移： {gu,0=∑jmax⁡(fj,0,fj,1)gu,1=au+∑jfj,0\\begin{cases}g_{u,0}=\\sum\\limits_{j}\\max(f_{j,0},f_{j,1})\\\\g_{u,1}=a_u+\\sum\\limits_{j}f_{j,0}\\end{cases} ⎩⎪⎨⎪⎧​gu,0​=j∑​max(fj,0​,fj,1​)gu,1​=au​+j∑​fj,0​​ 其中 jjj 是 uuu 的一个轻儿子。 {fu,0=max⁡(fv,0,fv,1)+gu,0fu,1=fv,0+gu,1\\begin{cases}f_{u,0}=\\max(f_{v,0},f_{v,1})+g_{u,0}\\\\f_{u,1}=f_{v,0}+g_{u,1}\\end{cases} {fu,0​=max(fv,0​,fv,1​)+gu,0​fu,1​=fv,0​+gu,1​​ 其中 vvv 是 uuu 的重儿子。 这样可以构造转移矩阵了：（其中的矩阵乘法是重新定义的：Ci,j=max⁡kAi,k+Bk,jC_{i,j}=\\max\\limits_{k} A_{i,k}+B_{k,j}Ci,j​=kmax​Ai,k​+Bk,j​） [gu,0gu,0gu,1−inf⁡]⋅[fv,0fv,1]=[fu,0fu,1]\\begin{bmatrix}g_{u,0}&amp;g_{u,0}\\\\g_{u,1}&amp;-\\inf\\end{bmatrix}\\cdot\\begin{bmatrix}f_{v,0}\\\\f_{v,1}\\end{bmatrix}=\\begin{bmatrix}f_{u,0}\\\\f_{u,1}\\end{bmatrix} [gu,0​gu,1​​gu,0​−inf​]⋅[fv,0​fv,1​​]=[fu,0​fu,1​​] 这么构造是因为跑完树剖之后求一段区间矩阵的乘积是从深度小的往深度大的乘过去。 考虑怎么修改，假设当前要修改 uuu，那么我们可以求出 uuu 所在的重链在修改 uuu 前的答案 frt0/1frt_{0/1}frt0/1​，然后修改 uuu，接下来求出修改 uuu 后的答案 lst0/1lst_{0/1}lst0/1​。 然后，我们考虑修改 uuu 对它所属重链顶端的节点的父亲的贡献，设 uuu 所属重链顶端的节点的父亲为 ppp，ppp 的父节点为 qqq，那么显然 ppp 是 qqq 的轻儿子，那么我们令 gq,0=gq,0−max⁡(frt0,frt1)+max⁡(lst0,lst1)，gq,1=gq,1−frt0+lst0g_{q,0}=g_{q,0}-\\max(frt_0,frt_1)+\\max(lst_0,lst_1)\\text{，}g_{q,1}=g_{q,1}-frt_0+lst_0 gq,0​=gq,0​−max(frt0​,frt1​)+max(lst0​,lst1​)，gq,1​=gq,1​−frt0​+lst0​ 然后又会发现，这个是关于 qqq 和它的重链的修改。所以我们不断地跳、修改即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long S=200005,MS=100005; const int inf=50000005; struct mrt { int n,m; int dat[4][4]; }tree[MS&lt;&lt;2]; int n,m; int val[MS]; int esum,to[S],nxt[S],h[MS]; int f[MS][2],g[MS][2]; int fat[MS],siz[MS],hson[MS]; int cnt,id[MS],vl[MS],a[MS][2],top[MS],depp[MS]; mrt b[MS]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs1(int u,int fa) { f[u][1]=val[u]; fat[u]=fa; siz[u]=1; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs1(v,u); f[u][0]+=max(f[v][0],f[v][1]); f[u][1]+=f[v][0]; siz[u]+=siz[v]; if(siz[v]&gt;siz[hson[u]]) { hson[u]=v; } } } void dfs2(int u,int fa,int tpf) { g[u][1]=val[u]; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa||v==hson[u]) { continue; } g[u][0]+=max(f[v][0],f[v][1]); g[u][1]+=f[v][0]; } id[u]=++cnt; vl[cnt]=val[u]; a[cnt][0]=g[u][0]; a[cnt][1]=g[u][1]; top[u]=tpf; depp[tpf]=cnt; if(hson[u]!=0) { dfs2(hson[u],u,tpf); } for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa||v==hson[u]) { continue; } dfs2(v,u,v); } } inline void mrtmul(mrt&amp; res,mrt x,mrt y) { if(x.n==-1&amp;&amp;x.m==-1) { res=y; return; } if(y.n==-1&amp;&amp;y.m==-1) { res=x; return; } res.n=x.n; res.m=y.m; for(int i=1;i&lt;=res.n;i++) { for(int j=1;j&lt;=res.m;j++) { res.dat[i][j]=-inf; } } for(int i=1;i&lt;=res.n;i++) { for(int j=1;j&lt;=res.m;j++) { for(int k=1;k&lt;=x.m;k++) { res.dat[i][j]=max(res.dat[i][j],x.dat[i][k]+y.dat[k][j]); } } } } inline void updata(int u) { mrtmul(tree[u],tree[u&lt;&lt;1],tree[u&lt;&lt;1|1]); } void build(int u,int l,int r) { if(l==r) { tree[u].n=2; tree[u].m=2; tree[u].dat[1][1]=a[l][0]; tree[u].dat[1][2]=a[l][0]; tree[u].dat[2][1]=a[l][1]; tree[u].dat[2][2]=-inf; b[l]=tree[u]; return; } int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); updata(u); } void que(int u,int l,int r,int L,int R,mrt&amp; res) { if(r&lt;L||l&gt;R) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { mrtmul(res,res,tree[u]); return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) { que(u&lt;&lt;1,l,mid,L,R,res); } if(R&gt;=mid+1) { que(u&lt;&lt;1|1,mid+1,r,L,R,res); } } void upd(int u,int l,int r,int pos) { if(l==r) { tree[u]=b[l]; return; } int mid=l+r&gt;&gt;1; if(pos&lt;=mid) { upd(u&lt;&lt;1,l,mid,pos); } else { upd(u&lt;&lt;1|1,mid+1,r,pos); } updata(u); } inline void updnode(int u,int k) { b[id[u]].dat[2][1]+=k-vl[id[u]]; vl[id[u]]=k; while(u!=0) { mrt frt,lst; frt.n=-1; frt.m=-1; lst.n=-1; lst.m=-1; que(1,1,n,id[top[u]],depp[top[u]],frt); upd(1,1,n,id[u]); que(1,1,n,id[top[u]],depp[top[u]],lst); u=fat[top[u]]; b[id[u]].dat[1][1]+=max(lst.dat[1][1],lst.dat[2][1])-max(frt.dat[1][1],frt.dat[2][1]); b[id[u]].dat[1][2]=b[id[u]].dat[1][1]; b[id[u]].dat[2][1]+=lst.dat[1][1]-frt.dat[1][1]; } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;val[i]); } for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } dfs1(1,0); dfs2(1,0,1); build(1,1,n); while(m--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); updnode(x,y); mrt ans; ans.n=-1; ans.m=-1; que(1,1,n,id[top[1]],depp[top[1]],ans); printf(&quot;%d\\n&quot;,max(ans.dat[1][1],ans.dat[2][1])); } return 0; } 练习题目 P5024 [NOIP2018 提高组] 保卫王国 P3781 [SDOI2017]切树游戏 ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"动态 DP 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/dong-tai-dp-xue-xi-bi-ji/","stats":{"text":"25 min read","time":1461000,"words":4323,"minutes":25},"date":"2023-03-23 12:58:12","dateFormat":"2023-03-23"},{"abstract":"","content":"高斯消元是一个用来求解多元一次方程的算法，它求解 nnn 元一次方程的时间复杂度是 O(n3)O(n^3)O(n3)。 做法 我们考虑这样的一个三元一次方程组： {x1+2x2=3x2+x3=5x1+3x3=10\\begin{cases}x_1+2x_2=3\\\\x_2+x_3=5\\\\ x_1+3x_3=10\\end{cases}⎩⎪⎨⎪⎧​x1​+2x2​=3x2​+x3​=5x1​+3x3​=10​ 把每一条方程的未知数补全： {x1+2x2+0x3=30x1+x2+x3=5x1+0x2+3x3=10\\begin{cases}x_1+2x_2+0x_3=3\\\\0x_1+x_2+x_3=5\\\\ x_1+0x_2+3x_3=10\\end{cases}⎩⎪⎨⎪⎧​x1​+2x2​+0x3​=30x1​+x2​+x3​=5x1​+0x2​+3x3​=10​ 然后我们就可以不关心具体的未知数了，只用关心系数。方程组也就可以写成一个矩阵： [1203011510310]\\begin{bmatrix}1&amp;2&amp;0&amp;3\\\\0&amp;1&amp;1&amp;5\\\\1&amp;0&amp;3&amp;10\\end{bmatrix} ⎣⎡​101​210​013​3510​⎦⎤​ 其中前三列表示系数，最后一列是方程右边的常数。 考虑方程的求解。很明显可以先加减消元，让某个方程只剩下一个未知数。再代入消元，求出所有未知数。 首先我们让矩阵第三行的方程减去第一行的方程，消掉 x1x_1x1​： [120301150−237]\\begin{bmatrix}1&amp;2&amp;0&amp;3\\\\0&amp;1&amp;1&amp;5\\\\0&amp;-2&amp;3&amp;7\\end{bmatrix} ⎣⎡​100​21−2​013​357​⎦⎤​ 然后让矩阵第三行的方程减去 −2-2−2 倍的第二行的方程，消掉 x2x_2x2​： [1203011500517]\\begin{bmatrix}1&amp;2&amp;0&amp;3\\\\0&amp;1&amp;1&amp;5\\\\0&amp;0&amp;5&amp;17\\end{bmatrix} ⎣⎡​100​210​015​3517​⎦⎤​ 接下来我们就可以求出 x3x_3x3​ 的值了，然后再一步一步往回代，就可以解出所有未知数了。 模板题代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; const long long MS=105; const double zeo=0.0001; int n; double a[MS][MS],res[MS]; inline bool slove() { // 加减消元过程 for(int i=1;i&lt;=n;i++) // 枚举每一个方程，用第 i 个方程消去未知数 x[i] { if(fabs(a[i][i])&lt;=zeo) // 如果当前这个方程不含未知数 x[i]（系数为 0），那么去找一个含有它的方程交换一下 { bool f=false; // 是否能找到 for(int j=i+1;j&lt;=n;j++) { if(fabs(a[j][i])&gt;zeo) // 找到了 { for(int k=1;k&lt;=n+1;k++) // 交换 { swap(a[i][k],a[j][k]); } f=true; break; } } if(!f) // 条件不足，无法解出方程 { return false; } } for(int j=i+1;j&lt;=n;j++) // 消去后面的方程中的未知数 x[i] { double bs=a[j][i]/a[i][i]; // 第 j 个方程需要减去第 i 个方程的 bs 倍 for(int k=1;k&lt;=n+1;k++) // 减去 { a[j][k]-=a[i][k]*bs; } } } // 代入消元过程 for(int i=n;i&gt;=1;i--) { for(int j=i+1;j&lt;=n;j++) // x[i+1...n] 已经计算完成，直接代入 { a[i][n+1]-=a[i][j]*res[j]; } res[i]=a[i][n+1]/a[i][i]; // 消完元后只剩下 x[i]，可以直接求出 } return true; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n+1;j++) { scanf(&quot;%lf&quot;,&amp;a[i][j]); } } if(!slove()) { puts(&quot;No Solution&quot;); return 0; } for(int i=1;i&lt;=n;i++) { printf(&quot;%.2lf\\n&quot;,res[i]); } return 0; } 练习题目 P4035 [JSOI2008]球形空间产生器 P2455 [SDOI2006]线性方程组 P3232 [HNOI2013]游走 CF24D Broken robot P5643 [PKUWC2018]随机游走 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"高斯消元学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/gao-si-xiao-yuan-xue-xi-bi-ji/","stats":{"text":"4 min read","time":238000,"words":824,"minutes":4},"date":"2023-03-23 12:56:43","dateFormat":"2023-03-23"},{"abstract":"","content":"差分约束系统，其实是一个类似网络流的，求一类不等式方程组的解的算法。 基本形式 差分约束系统主要用求这样的不等式方程组的一个解： {xa1−xb1≤y1xa2−xb2≤y2xa3−xb3≤y3⋯⋯xam−xbm≤ym\\begin{cases}x_{a_1}-x_{b_1}\\le y_1\\\\x_{a_2}-x_{b_2}\\le y_2\\\\x_{a_3}-x_{b_3}\\le y_3\\\\\\qquad\\cdots\\cdots\\\\x_{a_m}-x_{b_m}\\le y_m\\\\\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​xa1​​−xb1​​≤y1​xa2​​−xb2​​≤y2​xa3​​−xb3​​≤y3​⋯⋯xam​​−xbm​​≤ym​​ 其中 1≤ai,bi≤n1\\le a_i,b_i\\le n1≤ai​,bi​≤n。 我们先考虑其中的一条不等式 xa1−xb1≤y1x_{a_1}-x_{b_1}\\le y_1xa1​​−xb1​​≤y1​，很明显可以转化为 xa1≤xb1+y1x_{a_1}\\le x_{b_1}+y_1xa1​​≤xb1​​+y1​。 观察这个等式，很容易联想到最短路中，点 uuu 和点 vvv 中间如果有一条长度为 www 的边，那么这两个点之间的最短路长度一定小于等于 www。所以，我们可以把这 mmm 个方程转换为 mmm 条边，建出一个有向图来。 建完图后，我们考虑加一个大源点 000，向每一个未知数连一条长度为 000 的边。这样，以 000 作为源点跑出来的最短路，就是整个方程组的解了。 不过注意到，如果有负环，那么最短路是跑不出来的，这意味着方程组无解。 模板题代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const long long S=10000005,MS=100005; int n,m; int esum,to[S],nxt[S],c[S],h[MS]; int dis[MS],vis[MS]; bool inq[MS]; inline void add(int x,int y,int w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } inline bool slove() { dis[0]=0; for(int i=1;i&lt;=n;i++) { dis[i]=1e9; } memset(vis,0,sizeof(vis)); memset(inq,0,sizeof(inq)); queue&lt;int&gt; q; q.push(0); inq[0]=true; while(!q.empty()) { int u=q.front(); q.pop(); inq[u]=false; vis[u]++; if(vis[u]&gt;n) { return false; } for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(dis[u]+w&lt;dis[v]) { dis[v]=dis[u]+w; if(!inq[v]) { inq[v]=true; q.push(v); } } } } return true; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y,w; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w); add(y,x,w); } for(int i=1;i&lt;=n;i++) { add(0,i,0); } bool can=slove(); if(!can) { puts(&quot;NO&quot;); } else { for(int i=1;i&lt;=n;i++) { printf(&quot;%d &quot;,dis[i]); } printf(&quot;\\n&quot;); } return 0; } 一些变形 遇到 xai≥xbi+yix_{a_i}\\ge x_{b_i}+y_ixai​​≥xbi​​+yi​，可以反过来连边，变成 xbi≤xai−yix_{b_i}\\le x_{a_i}-y_ixbi​​≤xai​​−yi​，或者同时乘以 −1-1−1，将符号反过来 遇到 xai−xbi=yix_{a_i}-x_{b_i}=y_ixai​​−xbi​​=yi​，可以转化为两个不等式：xai≤xbi+yix_{a_i}\\le x_{b_i}+y_ixai​​≤xbi​​+yi​ 和 xai≥xbi+yix_{a_i}\\ge x_{b_i}+y_ixai​​≥xbi​​+yi​ 遇到 [si,ti][s_i,t_i][si​,ti​] 的和为 viv_ivi​ 这类问题时，可以用前缀和转换为 sumti−sumsi−1=visum_{t_i}-sum_{s_i-1}=v_isumti​​−sumsi​−1​=vi​ 练习题目 自己选着做吧…… ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"差分约束系统学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/chai-fen-yue-shu-xi-tong-xue-xi-bi-ji/","stats":{"text":"4 min read","time":217000,"words":726,"minutes":4},"date":"2023-03-23 12:56:01","dateFormat":"2023-03-23"},{"abstract":"","content":"这东西也叫 baka's trick。 众所周知，添加元素方便但删除元素不方便的情况下可以用回滚莫队来代替莫队，那尺取可以用什么代替呢？ 回滚尺取！ 具体做法 设要处理的数组长度为 nnn，且从 111 开始编号，位置 iii 的状态为 aia_iai​。 首先引入一个指针 midmidmid，令它初始为 111。 然后令左指针 lll 指向 midmidmid。设当前状态为 LLL，在 l≥1l\\ge 1l≥1 且 L∪alL\\cup a_lL∪al​ 合法的情况下不断让 L=L∪alL=L\\cup a_lL=L∪al​ 且左移 lll。并记录下这一过程下的 LLL，记 lll 为 xxx 时的 LLL 为 tmpxtmp_xtmpx​。 接下来令右指针 rrr 指向 mid+1mid+1mid+1，设当前状态为 RRR： 令 R=R∪arR=R\\cup a_rR=R∪ar​ 在 tmpl∪Rtmp_l\\cup Rtmpl​∪R 不合法的情况下不断右移 lll 指针，直到 l&gt;midl&gt;midl&gt;mid 或者 tmpl∪Rtmp_l\\cup Rtmpl​∪R 合法 若此时 l≤midl\\le midl≤mid，那么更新答案；否则令 mid=rmid=rmid=r，跳出循环 令 r=r+1r=r+1r=r+1，若 l&gt;nl&gt;nl&gt;n，那么跳出循环；否则，返回步骤 111 跳出循环后注意 lll 大于 nnn 的话就说明计算完了，可以结束整个尺取。 伪代码如下： // merge(val,val2)：返回状态 val 和状态 val2 合并后的状态 // cant(val)：若状态 val 合法，返回 true，否则返回 false int ans=0; for(int mid=1;mid&lt;n;) { int l,r; // 左移 l，记录下一路上 [l,mid] 的状态 int L=0; for(l=mid;l&gt;=1;l--) { L=merge(L,a[l]); tmp[l]=L; if(cant(L)) { break; } } l++; // 右移 r int R=0; for(r=mid+1;r&lt;=n;r++) { R=merge(R,a[r]); while(l&lt;=mid&amp;&amp;cant(merge(tmp[l],R))) // 不断右移 l 直到状态合法或者 l 大于 mid { l++; } if(l&lt;=mid) { ans=max(ans,r-l+1); // 更新答案 } else { mid=r; // 开始新一轮尺取 break; } } if(r&gt;n) // 计算完了，尺取结束 { break; } } 经典例题 CF1548B Integers Have Friends 考虑 x,yx,yx,y 对 mmm 取余的结果相同这个东西的本质。 设 xmod m=ymod m=kx\\mod m=y\\mod m=kxmodm=ymodm=k，那么 ∣(x−k)−(y−k)∣|(x-k)-(y-k)|∣(x−k)−(y−k)∣ 一定可以被 mmm 整除，即 ∣x−y∣|x-y|∣x−y∣ 可以被 mmm 整除。 考虑推广到三个数，设它们为 x,y,zx,y,zx,y,z。显然只有当 gcd⁡(∣x−y∣,∣y−z∣)&gt;1\\gcd(|x-y|,|y-z|)&gt; 1gcd(∣x−y∣,∣y−z∣)&gt;1 时才能够找到合法的 mmm。 所以这个问题便转化为求一个最长的区间 [l,r][l,r][l,r]，使得 gcd⁡(∣al−al+1∣,∣al+1−al+2∣,⋯ ,∣am−1−am∣)&gt;1\\gcd(|a_l-a_{l+1}|,|a_{l+1}-a_{l+2}|,\\cdots,|a_{m-1}-a_m|)&gt;1gcd(∣al​−al+1​∣,∣al+1​−al+2​∣,⋯,∣am−1​−am​∣)&gt;1。 很明显，普通的尺取无法处理这个问题，因为添加元素很简单，但是删除元素很难。所以我们需要使用回滚尺取。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; long long a[200005],tmp[200005]; inline long long gcd(long long a,long long b) { if(a==0||b==0) { return a+b; } long long t=a%b; while(t!=0) { a=b; b=t; t=a%b; } return b; } inline long long ckjabs(long long x) { return x&lt;0?-x:x; } int main() { int _; scanf(&quot;%d&quot;,&amp;_); while(_--) { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;,&amp;a[i]); } int ans=1; for(int mid=1;mid&lt;n;) { int l,r; long long L=0; for(l=mid;l&gt;=1;l--) { L=gcd(L,ckjabs(a[mid]-a[l])); tmp[l]=L; if(L==1) { break; } } l++; long long R=0; for(r=mid+1;r&lt;=n;r++) { R=gcd(R,ckjabs(a[r]-a[mid])); while(l&lt;=mid&amp;&amp;gcd(R,tmp[l])==1) { l++; } if(l&lt;=mid) { ans=max(ans,r-l+1); } else { mid=r; break; } } if(r&gt;n) { break; } } printf(&quot;%d\\n&quot;,ans); } return 0; } ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"回滚尺取（不删除尺取）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/hui-gun-chi-qu-bu-shan-chu-chi-qu-xue-xi-bi-ji/","stats":{"text":"5 min read","time":279000,"words":947,"minutes":5},"date":"2023-03-23 12:53:04","dateFormat":"2023-03-23"},{"abstract":"","content":"基环树，又称环套树。顾名思义，就是有环的树，所以它是个图。 概念及定义 基环树，是一个有 nnn 个节点和 nnn 条边组成的无向连通图。由于比树多了条边，所以它会出现环。 很明显基环树只有一个环，因为如果有多个环的话，那么整张图不会联通。 而基环树森林则是由许多连通块构成的无向图，满足每个连通块都是基环树。 一般来讲，只要看到 nnn 个点 nnn 条边、每个点都有且仅有一个仇人/上级/xxx 这种条件，这个图就一定是基环树森林。 基环树的例子： 处理方法 常见的题型就是在基环树上 dp。 有两种方法，第一种是把环拎出来，对于环下面挂着的树进行 dp，然后信息合并到环上处理： 还有一种是断掉环的一条边，然后分类讨论进行 dp，最后合并答案。 比较常见的是第二种。 经典题目 CF711D Directed Roads 链接 由于有 nnn 个点 nnn 条边，iii 只会连向 aia_iai​，所以是个基环树。 但是又没说联通，所以是基环树森林。 可以先找出所有的环，那么不被环包含的边可以随便定方向。 设当前找到的环的长度为 lenlenlen，那么想要形成环只会有两种定方向的方式，所以不形成环的方案数是 2len−22^{len}-22len−2。 答案即为 2n−∑len∑2len−22^{n-\\sum len}\\sum 2^{len}-22n−∑len∑2len−2。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long S=500005,MS=200005,mod=1000000007; int n; int esum,to[S],nxt[S],h[MS]; int dep[MS],vis[MS]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u,int fa,int &amp;len) { dep[u]=dep[fa]+1; vis[u]=1; for(int i=h[u],cnt=0;i;i=nxt[i]) { int v=to[i]; if(v==fa) { if(cnt==1) { len=2; } cnt++; continue; } if(vis[v]==1) { len=dep[u]-dep[v]+1; continue; } dfs(v,u,len); } vis[u]=2; } inline long long qpow(long long a,long long b) { long long res=1,tmp=a; while(b&gt;0) { if(b&amp;1) { res=res*tmp%mod; } tmp=tmp*tmp%mod; b&gt;&gt;=1; } return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); add(i,x); add(x,i); } long long ans=1,sum=n; for(int i=1;i&lt;=n;i++) { if(vis[i]==0) { int len; dfs(i,0,len); sum-=len; ans=ans*(qpow(2,len)-2)%mod; } } printf(&quot;%lld\\n&quot;,qpow(2,sum)*ans%mod); return 0; } P1453 城市环路 链接 很容易发现是个基环树，那么可以使用第二种方法，断掉一条边之后做没有上司的舞会。 但是有一些细节。首先断掉的边还是存在的，设这条边连接的两点为 x,yx,yx,y，那么最后要么 xxx 不选 yyy 选，要么都不选，要么 xxx 选 yyy 不选。前两种情况很好做，但是最后一种情况就有点难了。需要将 yyy 的人流量设为 −inf-inf−inf 再 dp。 最后需要注意一种很烦人的环： 这种情况下断掉 u,vu,vu,v 之间的边后它们会不连通，所以断边后需要分别以 uuu 和 vvv 为根做 dp，然后计算贡献。 这题数据太水了所以上图的情况如果不特判也能过。 P2607 [ZJOI2008]骑士 链接 其实是城市环路的加强版，注意一下是个基环树森林即可。 P4381 [IOI2008] Island 链接 首先读题，可以发现这是个基环树森林。然后看一下坐船的条件： 你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 S 走到 D (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。 再结合一下样例解释，你就会惊喜的发现，坐船其实就是从基环树森林里的一棵基环树走到另一棵基环树上，然后一棵基环树走了之后就不能回来了。 所以问题转化为所有基环树的最长链之和。 首先考虑单棵基环树的最长链。把环拎出来后，最长链的组成方法有： 一棵吊着的树的直径 一棵吊着的树的高度+环上的一段边+另一棵不同的吊着的树的高度 所以我们可以使用第一种方法，计算出每棵吊着的树的直径和高度，然后考虑合并。 第一种直径的组成方式很明显可以处理，而第二种就有点麻烦了。我们记编号为 iii 的节点的子树的深度为 wiw_iwi​，然后断环为链，很明显环变成了这样的东西： 然后做滑动的窗口即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const long long S=2000005,MS=1000005; struct node { int id; long long w,val; }cir[MS]; int n; int esum,to[S],nxt[S],h[MS]; long long c[S]; int vis[MS]; long long dp[MS][2],maxdep[MS],trd; long long sum[MS],que[MS]; int tot; inline void add(int x,int y,long long w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } bool dfs(int u,int fa) { bool res=false; vis[u]=1; for(int i=h[u],cnt=0;i;i=nxt[i]) { int v=to[i]; if(v==fa) { if(cnt==1) { cir[++tot]=(node){u,0,c[i]}; vis[fa]=4; res=true; } cnt++; continue; } if(vis[v]==1) { cir[++tot]=(node){u,0,c[i]}; vis[v]=4; res=true; continue; } if(vis[v]!=0) { continue; } if(dfs(v,u)) { if(vis[u]!=2) { cir[++tot]=(node){u,0,c[i]}; if(vis[u]==4) { vis[fa]=2; } } else { vis[fa]=2; } res=true; } } vis[u]=2; return res; } void dfs2(int u,int fa,int rt) { dp[u][0]=dp[u][1]=0; maxdep[u]=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; long long w=c[i]; if(v==fa||v==rt) { continue; } dfs2(v,u,rt); maxdep[u]=max(maxdep[u],w+maxdep[v]); long long val=w+dp[v][0]; if(val&gt;=dp[u][0]) { dp[u][1]=dp[u][0]; dp[u][0]=val; } else if(val&gt;=dp[u][1]) { dp[u][1]=val; } } trd=max(trd,dp[u][1]+dp[u][0]); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x; long long L; scanf(&quot;%d%lld&quot;,&amp;x,&amp;L); add(i,x,L); add(x,i,L); } long long ans=0; for(int i=1;i&lt;=n;i++) { if(vis[i]==0) { tot=0; dfs(i,0); long long curans=0; int m=tot; for(int j=1;j&lt;=m/2;j++) { swap(cir[j],cir[m-j+1]); } for(int j=1;j&lt;=m;j++) { int u=cir[j].id; trd=0; dfs2(u,cir[j==1?m:j-1].id,cir[j==m?1:j+1].id); curans=max(curans,trd); cir[j].w=maxdep[u]; } for(int j=1;j&lt;=m;j++) { cir[++tot]=cir[j]; } int newsiz=m*2-1; for(int j=1;j&lt;=newsiz;j++) { sum[j]=sum[j-1]+cir[j].val; } int hed=1,til=0; for(int j=1;j&lt;=newsiz;j++) { while(hed&lt;=til&amp;&amp;que[hed]&lt;=j-m) { hed++; } if(hed&lt;=til) { curans=max(curans,(cir[que[hed]].w+sum[j-1]-sum[que[hed]-1])+cir[j].w); } while(hed&lt;=til&amp;&amp;(cir[que[til]].w+sum[j-1]-sum[que[til]-1])&lt;=cir[j].w) { til--; } que[++til]=j; } ans+=curans; } } printf(&quot;%lld\\n&quot;,ans); return 0; } 细节 最重要的细节就是 这种环的处理和基环树森林的处理。 练习题目 P5022 [NOIP2018 提高组] 旅行 P3533 [POI2012]RAN-Rendezvous P7981 [JRKSJ R3] system P1399 [NOI2013] 快餐店 CF835F Roads in the Kingdom P2081 [NOI2012] 迷失游乐园 ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"基环树学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ji-huan-shu-xue-xi-bi-ji/","stats":{"text":"9 min read","time":508000,"words":1816,"minutes":9},"date":"2023-03-23 12:45:01","dateFormat":"2023-03-23"},{"abstract":"<blockquote>\n<p>给定一个长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> 的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 次询问，每次询问给定 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L,R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>，求</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mi>R</mi></munderover><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mi>l</mi></mrow><mi>R</mi></munderover><mi mathvariant=\"normal\">mex</mi><mo>⁡</mo><mo>(</mo><mo>{</mo><msub><mi>a</mi><mi>l</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>r</mi></msub><mo>}</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum\\limits_{l=L}^{R}\\sum\\limits_{r=l}^{R} \\operatorname{mex}(\\{a_l,a_{l+1},a_{l+2},\\dots,a_r\\})\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3.1304490000000005em;vertical-align:-1.302113em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8283360000000002em;\"><span style=\"top:-1.8478869999999998em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\">L</span></span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.300005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.302113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8283360000000002em;\"><span style=\"top:-1.8478869999999998em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.300005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.302113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">x</span></span><span class=\"mopen\">(</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>其中 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">mex</mi><mo>⁡</mo><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{mex}(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">x</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> 表示 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中最小的未出现的非负整数。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,q\\le 10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</blockquote>\n","content":" 给定一个长度为 nnn 的序列 aaa，有 qqq 次询问，每次询问给定 L,RL,RL,R，求 ∑l=LR∑r=lRmex⁡({al,al+1,al+2,…,ar})\\sum\\limits_{l=L}^{R}\\sum\\limits_{r=l}^{R} \\operatorname{mex}(\\{a_l,a_{l+1},a_{l+2},\\dots,a_r\\}) l=L∑R​r=l∑R​mex({al​,al+1​,al+2​,…,ar​}) 其中 mex⁡(S)\\operatorname{mex}(S)mex(S) 表示 SSS 中最小的未出现的非负整数。 1≤n,q≤1061\\le n,q\\le 10^61≤n,q≤106。 考虑只有一次询问的时候怎么做，首先 l=1l=1l=1 时每个 [l,r][l,r][l,r] 的 mex⁡\\operatorname{mex}mex 是可以 O(n)O(n)O(n) 预处理的，那么接下来考虑把 lll 往右移，即删掉 ala_lal​ 后每个 [l,r][l,r][l,r] 的 mex⁡\\operatorname{mex}mex。 不如设当前 [l,i][l,i][l,i] 的 mex⁡\\operatorname{mex}mex 为 meime_imei​，那么删除 ala_lal​ 相当于让 me[l+1,nxtl−1]me_{[l+1,nxt_{l}-1]}me[l+1,nxtl​−1]​ 对 ala_lal​ 取 min⁡\\minmin，其中 nxtlnxt_{l}nxtl​ 为 ala_lal​ 下一次出现的位置。 不难发现可以用线段树维护 mememe，由于 mememe 有单调性，所以区间取 min⁡\\minmin 可以通过线段树二分找到 &gt;al&gt;a_l&gt;al​ 的后缀来转换成区间赋值。那么只有一个询问就可以在 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间内解决。 考虑有多个询问的情况，显然一次询问 [L,R][L,R][L,R] 可以拆成 l∈[1,R],r∈[L,R]l\\in[1,R],r\\in[L,R]l∈[1,R],r∈[L,R] 的答案减掉 l∈[1,L−1],r∈[L,R]l\\in[1,L-1],r\\in[L,R]l∈[1,L−1],r∈[L,R] 的答案，那么问题就变成要求 l∈[1,x],r∈[L,R]l\\in[1,x],r\\in[L,R]l∈[1,x],r∈[L,R] 的答案。 考虑把询问离线下来，按照 xxx 升序排序，然后把 lll 从 111 往右移动。这样问题就变成了要求 [L,R][L,R][L,R] 的 mememe 的历史和（每次修改后的值累加的结果，可以看作是在时间维上做前缀和）。 维护历史和有很多种写法，比较通用的是给每个位置维护一个一次函数 k×tme+bk\\times tme+bk×tme+b，其中 tmetmetme 表示当前时间，kkk 存的是上一次修改之后的 meime_imei​。在时间 iii 修改一个位置的 mememe 为 xxx 的时候，设 b′b&#x27;b′ 为新的 bbb，k′k&#x27;k′ 为新的 kkk，那么有： b′=i×(k−x)+bk′=xb&#x27;=i\\times (k-x)+b\\\\ k&#x27;=x b′=i×(k−x)+bk′=x 注意到这个东西只有在区间内每个位置的 kkk 都相等时才可以用区间加快速维护，但是不难发现一个区间改完之后区间内的每个位置的 kkk 就会变成一样的，所以每次修改暴力找到所有区间内 kkk 相等的区间是对的，这样做每一次修改的时间复杂度均摊为 O(log⁡n)O(\\log n)O(logn)，那么总时间复杂度就是 O((n+q)log⁡n)O((n+q)\\log n)O((n+q)logn)。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; const int S=1000005; struct ask { int l,r,bse,id; }; struct node { long long ks,bs; long long mnk,mxk,tk,tb; }; int IDX; int n,q,a[S]; node tr[S&lt;&lt;2]; vector&lt;ask&gt; vec[S]; bool vis[S]; int b[S],lst[S],nxt[S]; long long ans[S]; inline void upd(int u) { tr[u].ks=tr[u&lt;&lt;1].ks+tr[u&lt;&lt;1|1].ks; tr[u].bs=tr[u&lt;&lt;1].bs+tr[u&lt;&lt;1|1].bs; tr[u].mnk=min(tr[u&lt;&lt;1].mnk,tr[u&lt;&lt;1|1].mnk); tr[u].mxk=max(tr[u&lt;&lt;1].mxk,tr[u&lt;&lt;1|1].mxk); } void build(int u,int l,int r) { if(l==r) return tr[u].ks=tr[u].mnk=tr[u].mxk=b[l],void(); int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r); upd(u); } inline void addtag(int u,int l,int r,long long k,long long b) { int siz=r-l+1; tr[u].ks+=k*siz,tr[u].bs+=b*siz; tr[u].mnk+=k,tr[u].mxk+=k; tr[u].tk+=k,tr[u].tb+=b; } inline void dwntag(int u,int l,int r) { if(tr[u].tk==0&amp;&amp;tr[u].tb==0) return; int mid=l+r&gt;&gt;1; addtag(u&lt;&lt;1,l,mid,tr[u].tk,tr[u].tb); addtag(u&lt;&lt;1|1,mid+1,r,tr[u].tk,tr[u].tb); tr[u].tk=tr[u].tb=0; } int quepos(int u,int l,int r,int L,int R,long long k) { if(l&gt;R||r&lt;L||tr[u].mxk&lt;=k) return -1; if(l==r) return l; dwntag(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid&amp;&amp;tr[u&lt;&lt;1].mxk&gt;k) return quepos(u&lt;&lt;1,l,mid,L,R,k); return quepos(u&lt;&lt;1|1,mid+1,r,L,R,k); } void upda(int u,int l,int r,int L,int R,int tme,long long k) { if(l&gt;R||r&lt;L) return; if(l&gt;=L&amp;&amp;r&lt;=R&amp;&amp;tr[u].mxk==tr[u].mnk) { int len=r-l+1; addtag(u,l,r,k-tr[u].mxk,tme*(tr[u].mxk-k)); return; } dwntag(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid) upda(u&lt;&lt;1,l,mid,L,R,tme,k); if(R&gt;=mid+1) upda(u&lt;&lt;1|1,mid+1,r,L,R,tme,k); upd(u); } long long quer(int u,int l,int r,int L,int R,int x) { if(l&gt;R||r&lt;L) return 0; if(l&gt;=L&amp;&amp;r&lt;=R) return 1ll*tr[u].ks*x+tr[u].bs; dwntag(u,l,r); int mid=l+r&gt;&gt;1; long long res=0; if(L&lt;=mid) res+=quer(u&lt;&lt;1,l,mid,L,R,x); if(R&gt;=mid+1) res+=quer(u&lt;&lt;1|1,mid+1,r,L,R,x); return res; } int main() { scanf(&quot;%d&quot;,&amp;IDX); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),a[i]=min(a[i],n+1); scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=q;i++) { int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); vec[r].push_back((ask){l,r,1,i}); if(l&gt;1) vec[l-1].push_back((ask){l,r,-1,i}); } for(int i=1,p=0;i&lt;=n;i++) { vis[a[i]]=true; while(vis[p]) p++; b[i]=p; } build(1,1,n); for(int i=0;i&lt;=n+1;i++) lst[i]=n+1; for(int i=n;i&gt;=1;i--) { nxt[i]=lst[a[i]]; lst[a[i]]=i; } for(int i=1;i&lt;=n;i++) { for(ask u:vec[i]) { ans[u.id]+=u.bse*quer(1,1,n,u.l,u.r,i); } int lb=i+1,rb=nxt[i]-1; if(lb&lt;=rb) { int pos=quepos(1,1,n,lb,rb,a[i]); if(pos!=-1) upda(1,1,n,pos,rb,i,a[i]); } upda(1,1,n,i,i,i,0); } for(int i=1;i&lt;=q;i++) printf(&quot;%lld\\n&quot;,ans[i]); return 0; } ","tags":[{"name":"做题记录","slug":"9Q1f-EwaH","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/9Q1f-EwaH/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"}],"title":"【2022NOI模拟赛01】漏网之鱼 做题记录","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/2022noi-mo-ni-sai-01-lou-wang-zhi-yu-zuo-ti-ji-lu/","stats":{"text":"9 min read","time":510000,"words":1580,"minutes":9},"date":"2023-03-21 19:05:00","dateFormat":"2023-03-21"},{"abstract":"","content":"这篇学习笔记大部分内容参考自任之洲的论文《积性函数求和的几种方法》。 0 前置知识 数论分块 1 一些定义 数论函数的定义 定义域为正整数域，陪域为负数域的函数被称为数论函数。 积性函数的定义 设 fff 为一个数论函数，若对于每一对互质的 a,ba,ba,b 均满足 f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b)，则 fff 为积性函数。 特别的，设 ggg 为一个数论函数，若对于每一对 a,ba,ba,b 均班满足 g(ab)=g(a)g(b)g(ab)=g(a)g(b)g(ab)=g(a)g(b)，则 ggg 为完全积性函数。 1.1 常见的积性函数 除数函数 σk(n)\\sigma_k(n)σk​(n)：nnn 的所有因数的 kkk 次方和 欧拉函数 φ(n)\\varphi(n)φ(n)：不超过 nnn 且与 nnn 互质的正整数个数 莫比乌斯函数： μ(n)={1 n=1(−1)k n 为 k 个不同的质数之积0其它情况\\mu(n)=\\begin{cases}1&amp;\\,n=1\\\\(-1)^k&amp;\\,n \\text{ 为 } k \\text{ 个不同的质数之积}\\\\ 0&amp;\\text{其它情况}\\end{cases} μ(n)=⎩⎪⎨⎪⎧​1(−1)k0​n=1n 为 k 个不同的质数之积其它情况​ 1.2 常见的完全积性函数 单位函数： ϵ(n)={1n=10n&gt;1\\epsilon(n)=\\begin{cases}1&amp;n=1\\\\0&amp;n&gt;1\\end{cases} ϵ(n)={10​n=1n&gt;1​ 2 莫比乌斯反演 2.1 狄利克雷卷积 定义两个数论函数 f(n),g(n)f(n),g(n)f(n),g(n) 的狄利克雷卷积为：（记作 (f∗g)(n)(f*g)(n)(f∗g)(n)） (f∗g)(n)=∑d∣nf(d)g(nd)(f*g)(n)=\\sum\\limits_{d|n}f(d)g(\\dfrac{n}{d}) (f∗g)(n)=d∣n∑​f(d)g(dn​) 狄利克雷卷积满足以下运算定律： 交换律：f∗g=g∗ff*g=g*ff∗g=g∗f 结合律: (f∗g)∗h=f∗(g∗h)(f*g)*h=f*(g*h)(f∗g)∗h=f∗(g∗h) 分配律：f∗(g+h)=f∗g+f∗hf*(g+h)=f*g+f*hf∗(g+h)=f∗g+f∗h 单位元：f∗ϵ=ff*\\epsilon=ff∗ϵ=f 若 f,gf,gf,g 均为积性函数，则 f∗gf*gf∗g 也为积性函数 2.2 莫比乌斯反演 定理 2.1. μ∗1=ϵ\\mu *1=\\epsilonμ∗1=ϵ，即：（其中函数 111 为返回值恒为 111 的常数函数） ∑d∣nμ(d)=ϵ(n)\\sum\\limits_{d|n}\\mu(d)=\\epsilon(n) d∣n∑​μ(d)=ϵ(n) 证明 设 nnn 有 kkk 个不同的质因子，则 ∑d∣nμ(d)=∑i=0k(−1)iC⁡ki=∑i=0kC⁡ki(−1)i1k−i\\sum\\limits_{d|n}\\mu(d)=\\sum\\limits_{i=0}^k (-1)^i\\operatorname{C}_k^i=\\sum\\limits_{i=0}^k \\operatorname{C}_k^i(-1)^i1^{k-i} d∣n∑​μ(d)=i=0∑k​(−1)iCki​=i=0∑k​Cki​(−1)i1k−i 根据二项式定理，可得：（这里规定 00=10^0=100=1） ∑i=0kC⁡ki(−1)i1k−i=(1−1)k=0k=ϵ(n)\\sum\\limits_{i=0}^k \\operatorname{C}_k^i(-1)^i1^{k-i}=(1-1)^k=0^k=\\epsilon(n) i=0∑k​Cki​(−1)i1k−i=(1−1)k=0k=ϵ(n) 所以莫比乌斯函数相当于是狄利克雷卷积下 111 的逆元。 定理 2.2. 设 f,gf,gf,g 是两个数论函数，且满足 f(n)=∑d∣ng(d)f(n)=\\sum\\limits_{d|n} g(d) f(n)=d∣n∑​g(d) 则它们也满足 g(n)=∑d∣nμ(d)f(nd)g(n)=\\sum\\limits_{d|n} \\mu(d)f(\\dfrac{n}{d}) g(n)=d∣n∑​μ(d)f(dn​) 反之亦然，即 f=g∗1⇔g=μ∗ff=g*1\\Leftrightarrow g=\\mu*f f=g∗1⇔g=μ∗f 证明 f=g∗1f=g*1 f=g∗1 两边同时卷上 μ\\muμ，得： f∗μ=g∗1∗μf*\\mu=g*1*\\mu f∗μ=g∗1∗μ 根据定理 2.1 得： f∗μ=gf*\\mu=g f∗μ=g 两侧都卷上 111，得： f=g∗1f=g*1 f=g∗1 3 一些应用 P2257 YY的GCD 求 ∑i=1n∑j=1m[gcd⁡(i,j)∈Prime]\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[\\gcd(i,j)\\in Prime] i=1∑n​j=1∑m​[gcd(i,j)∈Prime] 首先枚举质数 ppp，则原式可化为： ∑i=1n∑j=1m[gcd⁡(i,j)=p]\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[\\gcd(i,j)=p] i=1∑n​j=1∑m​[gcd(i,j)=p] 即 ∑i=1⌊np⌋∑j=1⌊mp⌋[gcd⁡(i,j)=1]\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}[\\gcd(i,j)=1] i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​[gcd(i,j)=1] 也就是 ∑i=1⌊np⌋∑j=1⌊mp⌋ϵ(gcd⁡(i,j)=1)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}\\epsilon(\\gcd(i,j)=1) i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​ϵ(gcd(i,j)=1) 通过定理 2.1 展开得 ∑i=1⌊np⌋∑j=1⌊mp⌋∑d∣gcd⁡(i,j)μ(d)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}\\sum\\limits_{d|\\gcd(i,j)}\\mu(d) i=1∑⌊pn​⌋​j=1∑⌊pm​⌋​d∣gcd(i,j)∑​μ(d) 变换求和顺序，得 ∑d=1μ(d)∑i=1⌊np⌋[d∣i]∑j=1⌊mp⌋[d∣j]\\sum\\limits_{d=1}\\mu(d)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}[d|i]\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}[d|j] d=1∑​μ(d)i=1∑⌊pn​⌋​[d∣i]j=1∑⌊pm​⌋​[d∣j] ∵1∼⌊np⌋ 中有 ⌊⌊np⌋d⌋个 d 的倍数\\because1\\sim \\lfloor\\dfrac{n}{p}\\rfloor\\text{ 中有 }\\left\\lfloor \\dfrac{\\lfloor\\dfrac{n}{p}\\rfloor}{d} \\right\\rfloor\\text{个 }d\\text{ 的倍数}∵1∼⌊pn​⌋ 中有 ⎣⎢⎢⎢⎢​d⌊pn​⌋​⎦⎥⎥⎥⎥​个 d 的倍数 ∴\\therefore∴ 得 ∑d=1μ(d)⌊⌊np⌋d⌋⌊⌊mp⌋d⌋\\sum\\limits_{d=1}\\mu(d)\\left\\lfloor \\dfrac{\\lfloor\\dfrac{n}{p}\\rfloor}{d} \\right\\rfloor\\left\\lfloor \\dfrac{\\lfloor\\dfrac{m}{p}\\rfloor}{d} \\right\\rfloor d=1∑​μ(d)⎣⎢⎢⎢⎢​d⌊pn​⌋​⎦⎥⎥⎥⎥​⎣⎢⎢⎢⎢​d⌊pm​⌋​⎦⎥⎥⎥⎥​ 即 ∑d=1min⁡(⌊np⌋,⌊mp⌋)μ(d)⌊npd⌋⌊mpd⌋\\sum\\limits_{d=1}^{\\min(\\lfloor\\frac{n}{p}\\rfloor,\\lfloor\\frac{m}{p}\\rfloor)}\\mu(d)\\lfloor\\dfrac{n}{pd}\\rfloor\\lfloor\\dfrac{m}{pd}\\rfloor d=1∑min(⌊pn​⌋,⌊pm​⌋)​μ(d)⌊pdn​⌋⌊pdm​⌋ 显然可以使用数论分块求解。 但是这样还不够优，考虑继续化简： 设 T=pdT=pdT=pd，则原式变为 ∑d=1min⁡(⌊np⌋,⌊mp⌋)μ(d)⌊nT⌋⌊mT⌋\\sum\\limits_{d=1}^{\\min(\\lfloor\\frac{n}{p}\\rfloor,\\lfloor\\frac{m}{p}\\rfloor)}\\mu(d)\\lfloor\\dfrac{n}{T}\\rfloor\\lfloor\\dfrac{m}{T}\\rfloor d=1∑min(⌊pn​⌋,⌊pm​⌋)​μ(d)⌊Tn​⌋⌊Tm​⌋ 也就是 ∑T=1min⁡(n,m)⌊nT⌋⌊mT⌋∑p∈Prime,p∣Tμ(Tp)\\sum\\limits_{T=1}^{\\min(n,m)}\\lfloor\\dfrac{n}{T}\\rfloor\\lfloor\\dfrac{m}{T}\\rfloor\\sum\\limits_{p\\in Prime,p|T}\\mu(\\dfrac{T}{p}) T=1∑min(n,m)​⌊Tn​⌋⌊Tm​⌋p∈Prime,p∣T∑​μ(pT​) 容易发现，最后那个求和可以预处理，最后套一下整除分块即可。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long S=1e7+1; int n,m; bool nop[S+5]; int tot,prime[S+5]; int mu[S+5]; long long sum[S+5]; inline int read() { int s=0,w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48),ch=getchar(); return s*w; } inline void writen(long long x) { if(x&gt;9) writen(x/10); putchar(x%10|48); } inline void init() { nop[1]=true; mu[1]=1; for(register int i=2;i&lt;=S;++i) { if(!nop[i]) { prime[++tot]=i; mu[i]=-1; } for(register int j=1;j&lt;=tot;++j) { if(i*prime[j]&gt;S) { break; } nop[i*prime[j]]=true; if(i%prime[j]==0) { mu[i*prime[j]]=0; break; } mu[i*prime[j]]=-mu[i]; } } for(int i=1;i&lt;=tot;++i) { for(int j=1;j*prime[i]&lt;=S;++j) { sum[j*prime[i]]+=mu[j]; } } for(int i=1;i&lt;=S;++i) { sum[i]+=sum[i-1]; } } int main() { init(); int _=read(); while(_--) { n=read(); m=read(); if(n&gt;m) { swap(n,m); } long long ans=0; for(int l=1;l&lt;=n;) { int r=min(n/(n/l),m/(m/l)); ans+=(sum[r]-sum[l-1])*(n/l)*(m/l); l=r+1; } writen(ans); printf(&quot;\\n&quot;); } return 0; } P2522 [HAOI2011]Problem b 求 ∑i=ab∑j=cd[gcd⁡(i,j)=k]\\sum\\limits_{i=a}^b\\sum\\limits_{j=c}^d[\\gcd(i,j)=k] i=a∑b​j=c∑d​[gcd(i,j)=k] 根据容斥原理，这个柿子可以分成四块，每一块的形式都是 ∑i=1n∑j=1m[gcd⁡(i,j)=k]\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[\\gcd(i,j)=k] i=1∑n​j=1∑m​[gcd(i,j)=k] 即 ∑d=1min⁡(⌊nk⌋,⌊mk⌋)μ(d)⌊nkd⌋⌊mkd⌋\\sum\\limits_{d=1}^{\\min(\\lfloor\\frac{n}{k}\\rfloor,\\lfloor\\frac{m}{k}\\rfloor)}\\mu(d)\\lfloor\\dfrac{n}{kd}\\rfloor\\lfloor\\dfrac{m}{kd}\\rfloor d=1∑min(⌊kn​⌋,⌊km​⌋)​μ(d)⌊kdn​⌋⌊kdm​⌋ 可以使用数论分块求解。 4 练习题目 P1829 [国家集训队]Crash的数字表格 / JZPTAB P3455 [POI2007]ZAP-Queries P3327 [SDOI2015]约数个数和 P6810 「MCOI-02」Convex Hull 凸包 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"莫比乌斯反演学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/mo-bi-wu-si-fan-yan-xue-xi-bi-ji/","stats":{"text":"11 min read","time":634000,"words":1969,"minutes":11},"date":"2023-03-21 15:49:52","dateFormat":"2023-03-21"},{"abstract":"","content":"树链剖分，就是用来增加代码长度的…… 反正我模板题写了 4 kb/ll 树链剖分，简称树剖，是用来把一棵树划分成很多条互不相交的链，再用类似线段树的数据结构来维护信息的。通常，“树剖”指的是树链剖分中的重链剖分。 模板题 首先看一些定义： 重儿子：对于每一个非叶节点，它所有儿子中子树最大的节点 轻儿子：不是重儿子的其他儿子 重边：一个非叶节点连向它的重儿子的边 轻边：一个非叶节点连向它的轻儿子的边 重链：以一个轻儿子开始，由若干条重边连接而成的链（单独一个轻儿子也能作为一条重链） 很容易发现，每条重链都不会相交，这样我们就可以使用类似线段树这样的数据结构来维护这些重链了。 然后我们很显然可以在 O(n)O(n)O(n) 的时间复杂度内求出节点 uuu 的父节点 fatufat_ufatu​、子树大小 sizusiz_usizu​ 和重儿子 hsonuhson_uhsonu​。 代码如下： void dfs1(int u,int fa) { fat[u]=fa; siz[u]=1; dep[u]=dep[fa]+1; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[hson[u]]) { hson[u]=v; } } } 接下来，我们考虑将整棵树映射到一个序列上，再使用线段树去维护它。很显然，可以使用 dfs 序，然后只要先递归重儿子，就可以保证同一条重链的区间是连续的了。 具体的做法是，再跑一遍 dfs，在 O(n)O(n)O(n) 的时间复杂度内求出新的序列 aaa、节点 uuu 在新序列中的编号 iduid_uidu​、节点 uuu 所属链的开头的节点 toputop_utopu​ 和节点 uuu 子树在新序列中的右端点 RuR_uRu​。 代码如下： void dfs2(int u,int tpf,int fa) // tpf 是 u 所属的重链的开头节点 { id[u]=++cnt; a[cnt]=val[u]; top[u]=tpf; if(hson[u]==0) // 如果没有重儿子说明是叶子 { R[u]=cnt; return; } dfs2(hson[u],tpf,u); // 先递归重儿子，因为它和 u 属于同一条重链 for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa||v==hson[u]) { continue; } dfs2(v,v,u); // 对于轻儿子，直接新开一条重链 } R[u]=cnt; } 现在我们已经成功地把树“剖开”了，接下来的工作就是使用线段树来维护新的序列。 首先看两个对于 xxx 的子树的操作。很显然，xxx 的子树对应的区间是 [idx,Rx][id_x,R_x][idx​,Rx​]，那么子树加和子树和查询就相当于在这个区间上操作。 代码如下： inline void addsubtree(int u,long long k) { upd(1,1,n,id[u],R[u],k); } inline long long quesubtree(int u) { return que(1,1,n,id[u],R[u]); } 而对于两个节点 x,yx,yx,y 的最短路径的操作，可以让它们不断往上跳重链，直到两点在同一重链里。 具体的做法是，不断令所在重链开始节点的深度较大的那个节点往上跳一整条链，并计算这条链的贡献。 画出来是这样的： 代码如下： inline void addpath(int x,int y,long long k) { while(top[x]!=top[y]) { if(dep[top[x]]&gt;dep[top[y]]) { upd(1,1,n,id[top[x]],id[x],k); // 贡献 x=fat[top[x]]; // 往上跳 } else { upd(1,1,n,id[top[y]],id[y],k); // 贡献 y=fat[top[y]]; // 往上跳 } } upd(1,1,n,min(id[x],id[y]),max(id[x],id[y]),k); // 最后的一小段 } inline long long quepath(int x,int y) // 同理 { long long res=0; while(top[x]!=top[y]) { if(dep[top[x]]&gt;dep[top[y]]) { res=(res+que(1,1,n,id[top[x]],id[x]))%p; x=fat[top[x]]; } else { res=(res+que(1,1,n,id[top[y]],id[y]))%p; y=fat[top[y]]; } } res=(res+que(1,1,n,min(id[x],id[y]),max(id[x],id[y])))%p; return res; } 复杂度证明： 首先子树操作的复杂度显然是 O(log⁡n)O(\\log n)O(logn)。 然后对于最短路径操作，由于 uuu 的轻儿子的子树大小最多是 ⌊sizu2⌋\\lfloor\\dfrac{siz_u}{2}\\rfloor⌊2sizu​​⌋，所以最多只会跳 log⁡n\\log nlogn 次重边，那么时间复杂度就是 O(log⁡2n)O(\\log^2n)O(log2n)。 综上，树剖的时间复杂度为 O(log⁡2n)O(\\log^2n)O(log2n)。 模板题代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long S=200005,MS=100005; int n,m,r; long long p,val[MS]; int esum,to[S],nxt[S],h[MS]; int fat[MS],siz[MS],hson[MS],dep[MS]; int cnt,id[MS],top[MS],R[MS]; long long a[MS]; long long sum[MS&lt;&lt;2],lazy[MS&lt;&lt;2]; inline void add(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs1(int u,int fa) { fat[u]=fa; siz[u]=1; dep[u]=dep[fa]+1; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[hson[u]]) { hson[u]=v; } } } void dfs2(int u,int tpf,int fa) // tpf 是 u 所属的重链的开头节点 { id[u]=++cnt; a[cnt]=val[u]; top[u]=tpf; if(hson[u]==0) // 如果没有重儿子说明是叶子 { R[u]=cnt; return; } dfs2(hson[u],tpf,u); // 先递归重儿子，因为它和 u 属于同一条重链 for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa||v==hson[u]) { continue; } dfs2(v,v,u); // 对于轻儿子，直接新开一条重链 } R[u]=cnt; } inline void updata(int u) { sum[u]=(sum[u&lt;&lt;1]+sum[u&lt;&lt;1|1])%p; } inline void lazydown(int u,int l,int r) { if(lazy[u]==0) { return; } int mid=l+r&gt;&gt;1; sum[u&lt;&lt;1]=(sum[u&lt;&lt;1]+lazy[u]*(mid-l+1))%p; sum[u&lt;&lt;1|1]=(sum[u&lt;&lt;1|1]+lazy[u]*(r-mid))%p; lazy[u&lt;&lt;1]=(lazy[u&lt;&lt;1]+lazy[u])%p; lazy[u&lt;&lt;1|1]=(lazy[u&lt;&lt;1|1]+lazy[u])%p; lazy[u]=0; } void build(int u,int l,int r) { if(l==r) { sum[u]=a[l]; return; } int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); updata(u); } void upd(int u,int l,int r,int L,int R,long long k) { if(r&lt;L||l&gt;R) { return; } if(l&gt;=L&amp;&amp;r&lt;=R) { sum[u]=(sum[u]+k*(r-l+1))%p; lazy[u]=(lazy[u]+k)%p; return; } lazydown(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid) { upd(u&lt;&lt;1,l,mid,L,R,k); } if(r&gt;=mid+1) { upd(u&lt;&lt;1|1,mid+1,r,L,R,k); } updata(u); } long long que(int u,int l,int r,int L,int R) { if(r&lt;L||l&gt;R) { return 0; } if(l&gt;=L&amp;&amp;r&lt;=R) { return sum[u]; } lazydown(u,l,r); int mid=l+r&gt;&gt;1; long long res=0; if(L&lt;=mid) { res=(res+que(u&lt;&lt;1,l,mid,L,R))%p; } if(R&gt;=mid+1) { res=(res+que(u&lt;&lt;1|1,mid+1,r,L,R))%p; } return res; } inline void addpath(int x,int y,long long k) { while(top[x]!=top[y]) { if(dep[top[x]]&gt;dep[top[y]]) { upd(1,1,n,id[top[x]],id[x],k); // 贡献 x=fat[top[x]]; // 往上跳 } else { upd(1,1,n,id[top[y]],id[y],k); // 贡献 y=fat[top[y]]; // 往上跳 } } upd(1,1,n,min(id[x],id[y]),max(id[x],id[y]),k); // 最后的一小段 } inline long long quepath(int x,int y) // 同理 { long long res=0; while(top[x]!=top[y]) { if(dep[top[x]]&gt;dep[top[y]]) { res=(res+que(1,1,n,id[top[x]],id[x]))%p; x=fat[top[x]]; } else { res=(res+que(1,1,n,id[top[y]],id[y]))%p; y=fat[top[y]]; } } res=(res+que(1,1,n,min(id[x],id[y]),max(id[x],id[y])))%p; return res; } inline void addsubtree(int u,long long k) { upd(1,1,n,id[u],R[u],k); } inline long long quesubtree(int u) { return que(1,1,n,id[u],R[u]); } int main() { scanf(&quot;%d%d%d%lld&quot;,&amp;n,&amp;m,&amp;r,&amp;p); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;,&amp;val[i]); val[i]%=p; } for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } dfs1(r,0); dfs2(r,r,0); build(1,1,n); while(m--) { int ty; scanf(&quot;%d&quot;,&amp;ty); if(ty==1) { int x,y; long long z; scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;z); addpath(x,y,z); } else if(ty==2) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%lld\\n&quot;,quepath(x,y)); } else if(ty==3) { int x; long long z; scanf(&quot;%d%lld&quot;,&amp;x,&amp;z); addsubtree(x,z); } else { int x; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%lld\\n&quot;,quesubtree(x)); } } return 0; } 练习题目 P2146 [NOI2015] 软件包管理器 P2486 [SDOI2011]染色 P2590 [ZJOI2008]树的统计 P3178 [HAOI2015]树上操作 ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"树链剖分学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/shu-lian-pou-fen-xue-xi-bi-ji/","stats":{"text":"11 min read","time":630000,"words":2069,"minutes":11},"date":"2023-03-21 15:47:24","dateFormat":"2023-03-21"},{"abstract":"","content":"整除分块主要是用来求这么一个柿子的： ∑i=1n⌊ni⌋\\sum\\limits_{i=1}^n \\lfloor \\dfrac{n}{i}\\rfloor i=1∑n​⌊in​⌋ 这个东西在 nnn 很小的情况下是可以暴力做的，但是如果 nnn 太大就不行了。 首先我们先打表找一下规律，输出一下 n=30n=30n=30 时 ⌊ni⌋\\lfloor\\dfrac{n}{i}\\rfloor⌊in​⌋ 的值： 30 15 10 7 6 5 4 3 3 3 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 很容易发现，整个序列是单调不增的，而且会出现一些很长的值相同的连续段。 那么我们可以考虑每个连续段里的点的贡献一起计算，假设我们现在已经知道一个块的左端点为 lll，那么我们只需要求出这个块的右端点 rrr 就行了。 我们推一下柿子： ∵⌊nr⌋=⌊nl⌋\\because \\lfloor\\dfrac{n}{r}\\rfloor=\\lfloor\\dfrac{n}{l}\\rfloor ∵⌊rn​⌋=⌊ln​⌋ ∴⌊nl⌋≤nr&lt;⌈nl⌉\\therefore \\lfloor\\dfrac{n}{l}\\rfloor\\le\\dfrac{n}{r}&lt;\\lceil\\dfrac{n}{l}\\rceil ∴⌊ln​⌋≤rn​&lt;⌈ln​⌉ 省略上界： nr≥⌊nl⌋\\dfrac{n}{r}\\ge\\lfloor\\dfrac{n}{l}\\rfloor rn​≥⌊ln​⌋ 两边同时取倒数，得：（不等式要变号） rn≤1⌊nl⌋\\dfrac{r}{n}\\le\\dfrac{1}{\\lfloor\\dfrac{n}{l}\\rfloor} nr​≤⌊ln​⌋1​ 两边同时乘上 nnn，得： r≤n⌊nl⌋r\\le\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor} r≤⌊ln​⌋n​ ∵r是整数，且r最大\\because r \\color{Black}\\colorbox{White}{是整数，且} r \\color{Black}\\colorbox{White}{最大} ∵r是整数，且​r最大​ ∴r=⌊n⌊nl⌋⌋\\therefore r=\\left\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}\\right\\rfloor ∴r=⎣⎢⎢⎢​⌊ln​⌋n​⎦⎥⎥⎥​ 所以可以得出，如果一个块的左端点是 lll，那么右端点就是 ⌊n⌊nl⌋⌋\\left\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}\\right\\rfloor⎣⎢⎢⎢​⌊ln​⌋n​⎦⎥⎥⎥​。 我们考虑推广一下它，易得出如果要求 ∑i=1n⌊ki⌋\\sum\\limits_{i=1}^n \\lfloor \\dfrac{k}{i}\\rfloor i=1∑n​⌊ik​⌋ 的话，左端点为 lll 的块的右端点是 min⁡(n,⌊k⌊kl⌋⌋)\\min(n,\\left\\lfloor\\dfrac{k}{\\lfloor\\dfrac{k}{l}\\rfloor}\\right\\rfloor)min(n,⎣⎢⎢⎢⎢​⌊lk​⌋k​⎦⎥⎥⎥⎥​)。 那么这样做的时间复杂度是多少的呢？很明显是 O(k)O(\\sqrt k)O(k​) 的，因为 ⌊ki⌋\\lfloor\\dfrac{k}{i}\\rfloor⌊ik​⌋ 只有 k\\sqrt kk​ 种取值，所以也就只有 k\\sqrt kk​ 个块。 现在我们来看一道例题：(P2261 [CQOI2007]余数求和) 求 G⁡(n,k)=∑i=1nkmod i\\operatorname{G}(n,k)=\\sum\\limits_{i=1}^n k\\mod iG(n,k)=i=1∑n​kmodi 推一下柿子： ∑i=1nkmod i\\sum\\limits_{i=1}^n k\\mod i i=1∑n​kmodi =∑i=1nk−i⌊ki⌋=\\sum\\limits_{i=1}^n k-i\\lfloor\\dfrac{k}{i}\\rfloor =i=1∑n​k−i⌊ik​⌋ =nk−∑i=1ni⌊ki⌋=nk-\\sum\\limits_{i=1}^n i\\lfloor\\dfrac{k}{i}\\rfloor =nk−i=1∑n​i⌊ik​⌋ 现在问题变为要求 ∑i=1ni⌊ki⌋\\sum\\limits_{i=1}^n i\\lfloor\\dfrac{k}{i}\\rfloori=1∑n​i⌊ik​⌋ 的值了。我们可以运用刚刚的结论，求出每一个块的左右端点后，用 kl\\dfrac{k}{l}lk​ 乘上 ∑i=lri\\sum\\limits_{i=l}^r ii=l∑r​i。∑i=lri\\sum\\limits_{i=l}^r ii=l∑r​i 很显然可以 O(1)O(1)O(1) 求出来。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; long long n,k; inline long long getsum(long long l,long long r) { return (l+r)*(r-l+1)/2; } int main() { scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); long long ans=0; for(long long l=1;l&lt;=n&amp;&amp;k/l&gt;0;) // 如果 k/l=0，那么会 RE，仔细想想，这个块肯定是对答案没贡献的，所以直接跳出循环 { long long r=min(k/(k/l),n); // 记得取 min ans+=getsum(l,r)*(k/l); l=r+1; } printf(&quot;%lld\\n&quot;,k*n-ans); return 0; } 再看一道进阶版的题： P2260 [清华集训2012]模积和 首先我们令 nnn 为 n,mn,mn,m 中较小的一个，mmm 为另一个。 推一下柿子，不难得出：（推柿子还是自己推推比较好，给个思路：总体减去 i=ji=ji=j 的，实在不行可以看 这里） 原式=F⁡(n)F⁡(m)−n2m+nG⁡(n,m)+mG⁡(n,n)−∑i=1ni2⌊ni⌋⌊mi⌋\\color{Black}\\colorbox{White}{原式}=\\operatorname{F}(n)\\operatorname{F}(m)-n^2m+n\\operatorname{G}(n,m)+m\\operatorname{G}(n,n)-\\sum\\limits_{i=1}^n i^2\\lfloor\\dfrac{n}{i}\\rfloor\\lfloor\\dfrac{m}{i}\\rfloor 原式​=F(n)F(m)−n2m+nG(n,m)+mG(n,n)−i=1∑n​i2⌊in​⌋⌊im​⌋ 其中： G⁡(n,k)=∑i=1ni⌊ki⌋\\operatorname{G}(n,k)=\\sum\\limits_{i=1}^n i\\lfloor\\dfrac{k}{i}\\rfloor G(n,k)=i=1∑n​i⌊ik​⌋ F⁡(n)=∑i=1nn−i⌊ni⌋=n2−G⁡(n,n)\\operatorname{F}(n)=\\sum\\limits_{i=1}^n n-i\\lfloor\\dfrac{n}{i}\\rfloor=n^2-\\operatorname{G}(n,n) F(n)=i=1∑n​n−i⌊in​⌋=n2−G(n,n) 现在考虑求解 ∑i=1ni2⌊ni⌋⌊mi⌋\\sum\\limits_{i=1}^n i^2\\lfloor\\dfrac{n}{i}\\rfloor\\lfloor\\dfrac{m}{i}\\rfloori=1∑n​i2⌊in​⌋⌊im​⌋，容易发现，⌊ni⌋⌊mi⌋\\lfloor\\dfrac{n}{i}\\rfloor\\lfloor\\dfrac{m}{i}\\rfloor⌊in​⌋⌊im​⌋ 是单调不增的，所以可以使用数论分块，左端点为 lll 的块右端点就是 min⁡(⌊n⌊nl⌋⌋,⌊m⌊ml⌋⌋)\\min(\\left\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}\\right\\rfloor,\\left\\lfloor\\dfrac{m}{\\lfloor\\dfrac{m}{l}\\rfloor}\\right\\rfloor)min(⎣⎢⎢⎢​⌊ln​⌋n​⎦⎥⎥⎥​,⎣⎢⎢⎢​⌊lm​⌋m​⎦⎥⎥⎥​)，i2i^2i2 的和则可以使用公式来求解。 代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const long long mod=19940417,inv2=9970209,inv6=3323403; long long n,m; inline long long G(long long n,long long k) { long long res=0; for(long long l=1;l&lt;=n&amp;&amp;k/l&gt;0;) { long long r=min(k/(k/l),n); res+=(l+r)*(r-l+1)%mod*inv2%mod*(k/l)%mod; res%=mod; l=r+1; } return res; } inline long long F(long long n) { return (((n*n%mod-G(n,n))%mod)+mod)%mod; } inline long long sum(long long x) // 小学奥数的知识：1^2+2^2+3^2+...+x^2 { return x*(x+1)%mod*(x+x+1)%mod*inv6%mod; } int main() { scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); if(n&gt;m) { long long t=n; n=m; m=t; } long long ans=F(n)*F(m)%mod-n*n%mod*m%mod+n*G(n,m)%mod+m*G(n,n)%mod; // 疯狂取模，少一个可能就会 WA ans=(ans%mod+mod)%mod; for(long long l=1;l&lt;=n;) { long long r=min(n/(n/l),m/(m/l)); ans-=((sum(r)-sum(l-1))%mod+mod)%mod*(n/l)%mod*(m/l)%mod; ans=(ans%mod+mod)%mod; l=r+1; } printf(&quot;%lld\\n&quot;,ans); return 0; } 练习题目 UVA11526 H(n) P3935 Calculating ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"整除分块学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zheng-chu-fen-kuai-xue-xi-bi-ji/","stats":{"text":"8 min read","time":464000,"words":1494,"minutes":8},"date":"2023-03-21 15:35:04","dateFormat":"2023-03-21"},{"abstract":"","content":"CDQ 分治，据说是由陈丹琦最先引入国内 OI 圈的。它与 dp 类似，是一种思想，而不是一种具体的算法。 CDQ 分治一般用来解决点对的问题，例如P3810 【模板】三维偏序（陌上花开）这道题： 给定 n 个元素，每个元素有权值 a_i,b_i,c_i。 规定 f(i) 为满足 a_j&lt;=a_i,b_j&lt;=b_i,c_j&lt;=c_i 且 j!=i 的 j 的个数。 求所有 0&lt;=x&lt;n 的 ans(x) 表示有多少个满足 f(i)=x 的 i。 CDQ 分治的步骤大体如下： 二分一个 midmidmid 递归处理所有 i,j≤midi,j\\le midi,j≤mid 的点对和所有 i,j≥mid+1i,j\\ge mid+1i,j≥mid+1 的点对 设法处理所有 i≤mid,j≥mid+1i\\le mid,j\\ge mid+1i≤mid,j≥mid+1 的点对 没错，归并排序求逆序对也是类似的思路，所以可以说归并排序求逆序对也是一种 CDQ 分治（ 回到例题，首先考虑一个弱智版问题： 每个元素只有一个属性 a_i 很明显排一次序就行了。 再来看一个难一点的 每个元素有两个属性 a_i 和 b_i 可以先按 aia_iai​ 排序，然后再用树状数组计算贡献。 sort(a+1,a+n+1,cmpa); // 按 a_i 排序 for(int i=1;i&lt;=n;i++) { // 下文 add 函数和 que 函数分别是树状数组的单点修改和前缀和查询 a[i].ans=que(a[i].b); // 查询 add(a[i].b,1); // 插入树状数组 } 回到例题，首先对 aia_iai​ 排序，这样我们就消去了一个关键字。由于有重复的元素，所以我们可以做一下去重（其实不去重也没什么关系）。 接下来，我们可以使用 CDQ 分治来再去一个关键字。 具体的做法是，递归分治完两边后，需要计算 x∈[l,mid]x\\in[l,mid]x∈[l,mid] 对 y∈[mid+1,r]y\\in[mid+1,r]y∈[mid+1,r] 的贡献，那么由于 ax≤yxa_x\\le y_xax​≤yx​，所以可以先对两个区间的 bib_ibi​ 排序，然后用树状数组统计答案。 排序部分可以用归并排序，省去一些时间。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; struct node { int a,b,c,cnt,ans; }a[100005],tmp[100005]; int n,k; int c[200005],ans[100005]; inline bool cmpa(node x,node y) { if(x.a==y.a) { if(x.b==y.b) { return x.c&lt;y.c; } return x.b&lt;y.b; } return x.a&lt;y.a; } inline bool cmpb(node x,node y) { if(x.b==y.b) { return x.c&lt;y.c; } return x.b&lt;y.b; } inline void add(int pos,int val) { for(int i=pos;i&lt;=k;i+=i&amp;-i) { c[i]+=val; } } inline int que(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) { res+=c[i]; } return res; } void slove(int l,int r) { // “分” if(l==r) { return; } int mid=l+r&gt;&gt;1; slove(l,mid); slove(mid+1,r); // “治” int j=l,tot=0; for(int i=mid+1;i&lt;=r;i++) // 归并排序，计算贡献 { while(j&lt;=mid&amp;&amp;a[j].b&lt;=a[i].b) { add(a[j].c,a[j].cnt); tmp[++tot]=a[j++]; } a[i].ans+=que(a[i].c); tmp[++tot]=a[i]; } while(j&lt;=mid) { add(a[j].c,a[j].cnt); tmp[++tot]=a[j++]; } for(int i=l;i&lt;=mid;i++) // 清空树状数组，这样写比 memset 快一点（ { add(a[i].c,-a[i].cnt); } for(int i=l;i&lt;=r;i++) { a[i]=tmp[i-l+1]; } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d&quot;,&amp;a[i].a,&amp;a[i].b,&amp;a[i].c); } sort(a+1,a+n+1,cmpa); int tot=0; for(int i=1,sum=0;i&lt;=n;i++) // 去重 { sum++; if(a[i].a!=a[i+1].a||a[i].b!=a[i+1].b||a[i].c!=a[i+1].c) { a[++tot]=a[i]; a[tot].cnt=sum; sum=0; } } slove(1,tot); for(int i=1;i&lt;=tot;i++) { ans[a[i].ans+a[i].cnt-1]+=a[i].cnt; // 计算答案，&lt;= a_i 的有 a_i.ans 个，再算上 = a_i 的，最后减去重复计算的 a_i } for(int i=0;i&lt;n;i++) { printf(&quot;%d\\n&quot;,ans[i]); } return 0; } 做完这道题，可以发现 CDQ 分治处理偏序问题的本质是消关键字（ 所以四维偏序可以使用 CDQ 分治套 CDQ 分治来做（（（ 练习题目 P3157 [CQOI2011]动态逆序对 UVA11990 ``Dynamic'' Inversion ","tags":[{"name":"分治","slug":"xOdsxnJdt","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/xOdsxnJdt/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"CDQ 分治学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/cdq-fen-zhi-xue-xi-bi-ji/","stats":{"text":"6 min read","time":306000,"words":1058,"minutes":6},"date":"2023-03-21 15:32:45","dateFormat":"2023-03-21"},{"abstract":"","content":"Part 1 什么是网络流 1.概念 网络可以理解为一堆水管，而流则可以理解为水流。水流可以从源头源源不断地流进管道系统，然后从排水口流出管道系统。 但因为水管是有大小的，如果单位时间流过的水比这跟水管的容量还大，那么这跟水管就会被撑爆。所以，单位时间内每根水管能流的水量是有限的，我们把第 iii 根水管的容量记为 cic_ici​，表示第 iii 根水管在单位时间内最多能流 cic_ici​ 那么多的水。 而且由于水往低处流，所以水管是有方向的。 管道系统肯定不止一根水管，而多根水管连起来就需要一些节点。我们可以把节点理解为水流中继站，因为水流中继站肯定不会把水给吞了，所以流入某个中继站的水流总量和流出这个中继站的水流总量是相等的。 把这个水管系统画出来大概就是这样的:（S 表示源头，T 表示排水口，箭头表示水管，箭头旁边的数字表示水管的容量） 在上图中，我们发现其实源头和排水口也可以当成中继站来用。 这种图是不是很眼熟？没错！这是一个带权有向图，水管在图里是边，水管的容量是边权，中继站是节点，源头和排水口也是节点。 2.术语 因为像 水管容量、排水口出水量、水管系统 这类名字众 Oier 不喜欢，所以大家给它们取了一些听起来很高级学术化的名字。 大家把 水管 叫做边，水管容量 叫做边的容量，排水口出水量 叫做流量，水管系统 叫做网络，源头 叫做源点，排水口 叫做汇点，中继站 叫做节点。 也就是 #define 边 水管 #define 边的容量 水管容量 #define 流量 排水口出水量 #define 网络 水管系统 #define 源点 源头 #define 汇点 排水口 #define 节点 中继站 Part 2 网络最大流问题 1.定义 顾名思义，“网络最大流” 即一个网络在单位时间内最多能流多少流量。而网络最大流问题即给你一个网络和源点、汇点编号，要你求这个网络的最大流。 模板题 举个例子，对于下图中的网络，它的最大流便为 9。 2.求解 如何用算法求解网络最大流呢？ 考虑最暴力朴素的做法，很显然可以爆搜，但时间复杂度会爆炸的。 现在有请我们的嘉宾——猴子，来帮忙求解网络最大流。 反向边的引入 我们给猴子一个这样的网络（边上的数表示这条还有多少容量） 猴子很开心，因为它一眼就看见了一条可以让流 1 流量的路 现在这个网络的最大流从原来的 0 更新成了 1。 猴子尝试继续找路，可它发现找不到路了，于是猴子跑路了。 Oier 们又来搞事情了，大家觉得 路 不好听，所以把猴子找的这种路叫做增广路。 那么猴子求出来的是最大流吗？不，很明显可以让上面的两条边通过 1 的流量，再让下面的两条边通过 1 的流量，整个网络的最大流其实是 2 而不是 1。 猴子被友好的工作人员请回来了，现在它开始反思，为什么它会错呢？114514 秒过去了，猴子终于知道自己错误的原因了，那就是它不会反悔。如果能不经过中间那条边它求的最大流就会变成 2 了。 猴子跑去吃香蕉了，我们又要自己思考做法了。 吸取了猴子惨痛的失败经验后，我们发现，电脑其实也像一只猴子，它并不会反悔。那如何教会电脑反悔呢？建反向边就行啦！ 不过要注意，反向边的容量一开始是 0。 例如我们之前给猴子的网络，建完反向边之后就变成这样了 反向边如何使用呢？很简单，当一条边流过 kkk 的流量时，反向边便增加 kkk 的容量；当一条边的反向边流过 kkk 的流量时，它的正向边便增加 kkk 的容量。这样相当于给了电脑一个反悔的机会，如果这条边流过去了 kkk 的流量，那么它的反向边流 kkk 的流量就相当于把流走的流量还给流量流出去的节点。 增加反向边后，猴子就会发现它能轻松地求出网络最大流了。 首先，猴子还是找到了之前那一条增广路。不过这次它把反向边的容量增加了 现在猴子发现它还能找增广路 这下它总算求出了正确答案，猴子开心地跑了。 我们发现，猴子在找第二条增广路的时候走了中间那条边的反向边。这其实表示猴子反悔了，它让红色那条增广路不走中间那条边，改成走右下那一条，而当前的增广路 “接管” 了之前红色增广路走的边。 EK 算法 有了反向边，电脑也可以轻松地求网络最大流了。 建完图后，我们可以用 bfs 来找增广路。根据网络最大流的定义，bfs 应该从源点开始，到汇点结束。所以如果 bfs 时访问到了汇点，那么电脑就找到了一条增广路。 找到增广路之后还得把增广路上的正向边的剩余容量减少，把反向边的剩余容量增加。所以我们需要一个数组 pre，preipre_iprei​ 表示在当前找到的增广路中，iii 是从哪一条边过来的。 特别的，反向边的存储有个特殊方式，那就是 iii 的反向边编号为 iii xorxorxor 111，写成代码就是 x^1。这么规定是因为电脑很笨，它在更新剩余容量的时候不知道哪一条是正向边，哪一条是反向边，所以我们需要 xorxorxor 这种对称（雾）的操作。 例如: 2 号边的反向边就是 2^1=3，而 3 号边的反向边就是 3^1=2。 问题又来了，1^1=0，因为我们不喜欢 0 这个数字，所以边的编号应该从 2 开始，也就是一开始 esum=1（esum 表示当前边的条数）。 由于一个网络可能不止一条增广路，所以我们需要跑很多次 bfs，一直跑到找不到增广路为止。 这种利用很多次 bfs 来求网络最大流的算法被称为 EK 算法 。 代码 // P3376 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; typedef long long ll; int n,m,s,t; int esum,to[10005],head[205],nxt[10005]; ll ans,c[10005],f[10005]; int las[205]; bool vis[205]; inline void init() { esum=1; memset(head,0,sizeof(head)); } inline void add(int x,int y,ll w) { c[++esum]=w; to[esum]=y; nxt[esum]=head[x]; head[x]=esum; } inline bool bfs() { queue&lt;int&gt; q; q.push(s); memset(vis,0,sizeof(vis)); vis[s]=true; f[s]=1e17; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=head[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;!vis[v]) { las[v]=i; f[v]=min(f[u],c[i]); vis[v]=true; q.push(v); if(v==t) { return true; } } } } return false; } inline ll upd() { ll nflow=0; nflow+=f[t]; int u=t; while(u!=s) { int i=las[u]; c[i]-=f[t]; c[i^1]+=f[t]; u=to[i^1]; } return nflow; } inline ll ek() { ll maxflow=0; while(bfs()) { maxflow+=upd(); } return maxflow; } int main() { scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); init(); for(int i=1;i&lt;=m;i++) { int x,y; ll w; scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;w); add(x,y,w); add(y,x,0); } printf(&quot;%lld\\n&quot;,ek()); return 0; } dinic 算法 在 EK 算法中，我们需要跑很多次 bfs 才能得到答案。但 bfs 在最坏情况下是要访问所有节点的，这导致 EK 算法的时间复杂度并不够优秀。所以，人们发明了 dinic 算法。 dinic 算法是一种十分巧妙的算法，它利用了层次图来减少 bfs执行的次数。 相关法律规定：网络流题不能卡 dinic。 层次图 层次图，顾名思义，就是把图分层。可以这么理解：一张图本来是平的，现在有个人把它放在了山坡上，它就斜过来了。由于水往低处流，所以把一个网络分层之后，水流（流）就只能从高处（深度小）的节点流向低处（深度大）的节点，而分层的过程其实就是一次 bfs。 分层的流程大概如下：首先把源点的深度设置成 1，然后访问和源点相连的其它点，把它们的深度设置成 2，依此类推。 算法流程 首先我们需要把网络分层，然后对于分完层的网络，我们再跑很多遍 dfs。但是在 dfs里我们只允许当前节点的流向深度正好比当前节点深度大 1 的节点流去。这样保证了 dinic 算法的正确性，其实也可以理解为用 dfs 来跑 EK 算法中的 bfs。但是用 dfs 有个好处，那就是 bfs 需要遍历完整个图才能找到一条增广路，而 dfs 遍历整个图有可能会找到多条增广路。 如果 dfs 到达不了汇点了（找不到增广路了），那么就需要重新分层，再跑一次 bfs。如果 bfs 到达不了汇点，那么就说明增广路找完了，求出了网络最大流。 写成伪代码大概是这样的： dfs 部分： dfs(int u,int w) // u 表示当前节点的编号，w 表示流向当前点的流量 { 遍历所有从 u 出发的边 i { int v=i 到达的节点; if(v 的深度 == u 的深度 +1) { int re=dfs(v,min(w,i 的容量)); if(增广成功) { 更新正向边和反向边的容量; return re; } } } return 增广失败; } 求解部分： while(bfs 可以到达 汇点) { while(增广路增广的流量 = dfs(s,inf) != 增广失败) { 网络最大流+=增广路增广的流量; } } 此外，dinic 算法还有几个优化，分别是多路增广优化、当前弧优化和断层优化： 多路增广优化：令一次 dfs 能够找到多条增广路； 当前弧优化：类似欧拉路，令 dfs 多路增广时不增广增广过的边； 断层优化：把已经“榨干”的节点“删掉”； 加了三个优化的代码 const int S=505,NS=1005,MS=500005; const int inf=1e8; int esum=1,to[MS],c[MS],nxt[MS],h[NS]; int s,t; int dep[NS],cur[NS]; inline void added(int x,int y,int w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } inline void add(int x,int y,int w) { added(x,y,w),added(y,x,0); } inline bool bfs() { for(int i=s;i&lt;=t;i++) dep[i]=0,cur[i]=h[i]; queue&lt;int&gt; q; dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); if(u==t) return true; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(w&gt;0&amp;&amp;dep[v]==0) { dep[v]=dep[u]+1; q.push(v); } } } return false; } int dfs(int u,int w) { if(u==t) return w; int sum=0; for(int &amp;i=cur[u];i;i=nxt[i]) { if(c[i]==0) continue; int v=to[i]; if(dep[v]!=dep[u]+1) continue; int r=dfs(v,min(c[i],w)); c[i]-=r; c[i^1]+=r; w-=r; sum+=r; if(w==0) break; } if(sum==0) dep[u]=0; return sum; } inline int dinic() { int res=0; while(bfs()) res+=dfs(s,inf); return res; } Part 3 最小费用最大流问题 最小费用最大流，就相当于水管开始收钱了，每条边都有一个单位代价 wiw_iwi​，即这条边通过 111 流量需要 wiw_iwi​ 的代价，最小费用最大流要求的就是流量尽可能大时最小代价是多少。 这样的问题也可以使用 dinic 算法解决，只不过建边时反向边代价为 −wi-w_i−wi​，而且 bfs 需要换成 spfa。 值得注意的一点是，由于代价可能为 000，所以深搜的时候需要加上 vis 标记。 模板题代码 // P3381 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; typedef long long ll; int n,m,s,t; int esum,to[100005],nxt[100005],h[5005]; ll c[100005],cost[100005]; ll dep[5005]; ll maxflow,mincost; bool vis[5005]; inline void init() { esum=1; memset(h,0,sizeof(h)); } inline void add(int x,int y,ll w,ll v) { to[++esum]=y; c[esum]=w; cost[esum]=v; nxt[esum]=h[x]; h[x]=esum; } inline bool spfa() { memset(dep,127,sizeof(dep)); memset(vis,0,sizeof(vis)); ll inf=dep[0]; queue&lt;int&gt; q; q.push(s); dep[s]=0; vis[s]=true; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=false; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[u]+cost[i]&lt;dep[v]) { dep[v]=dep[u]+cost[i]; if(!vis[v]) { vis[v]=true; q.push(v); } } } } return dep[t]&lt;inf; } ll dfs(int u,ll w) { if(u==t) { maxflow+=w; return w; } vis[u]=true; ll sum=0; for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(!vis[v]&amp;&amp;c[i]&gt;0&amp;&amp;dep[v]==dep[u]+cost[i]) { ll re=dfs(v,min(c[i],w)); mincost+=cost[i]*re; c[i]-=re; c[i^1]+=re; w-=re; sum+=re; if(w==0) { break; } } } vis[u]=false; if(sum==0) { dep[u]=-1e17; } return sum; } inline void dinic() { while(spfa()) { dfs(s,1e18); } } int main() { scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); init(); for(int i=1;i&lt;=m;i++) { int x,y; ll w,v; scanf(&quot;%d%d%lld%lld&quot;,&amp;x,&amp;y,&amp;w,&amp;v); add(x,y,w,v); add(y,x,0,-v); } dinic(); printf(&quot;%lld %lld\\n&quot;,maxflow,mincost); return 0; } Part 4 网络流求图的最小割 一个有向图中 x,yx,yx,y 两点之间的割，即为一组割断后 xxx 无法到达 yyy 的边，而最小割，就是边权和最小的一个割。 这里有一个重要的结论： 最大流 === 最小割 这个结论的证明如下： ∵\\because∵ 最大流求完后源点 SSS 不能到达汇点 TTT ∴\\therefore∴ 最小割所包含的边的流量（边权）都用完了（被割掉了） ∵\\because∵ 最小割所包含的边限制了流量 ∴\\therefore∴ 最大流 === 最小割 Part 5 有上下界网络流 5.1 有上下界循环可行流 nnn 个点，mmm 条有向边，每条边有一个流量下界 lil_ili​ 和流量上界 rir_iri​，求该图的一个循环可行流，即你需要构造 mmm 个变量 fif_ifi​ 满足： 流量合法：∀i,li≤fi≤ri\\forall i,l_i\\le f_i\\le r_i∀i,li​≤fi​≤ri​； 流量平衡：对于每个点 iii，设 IiI_iIi​ 为 iii 的入边集合，UiU_iUi​ 为 iii 的出边集合，那么有：∑j∈Iifj=∑j∈Uifj\\sum\\limits_{j\\in I_i} f_j=\\sum\\limits_{j\\in U_i}f_jj∈Ii​∑​fj​=j∈Ui​∑​fj​； 考虑每条边先钦定流过 lil_ili​ 的流量，转化为每条边只有流量上界 ri−lir_i-l_iri​−li​，那么流量有可能不平衡。 考虑用点与源点 SSS 或汇点 TTT 的连边刻画每个点的额外流量。记 bi=∑j∈Iilj−∑j∈Uiljb_i=\\sum\\limits_{j\\in I_i} l_j-\\sum\\limits_{j\\in U_i}l_jbi​=j∈Ii​∑​lj​−j∈Ui​∑​lj​，即每个点进入的流量减出去的流量，那么： 若 bi&lt;0b_i&lt;0bi​&lt;0，连接边 (i,T,−bi)(i,T,-b_i)(i,T,−bi​)； 若 bi&gt;0b_i&gt;0bi​&gt;0，连接边 (S,i,bi)(S,i,b_i)(S,i,bi​)； 原先的边 iii 直接连 (xi,yi,ri−li)(x_i,y_i,r_i-l_i)(xi​,yi​,ri​−li​)。 跑最大流，若所有 (i,T,−bi)(i,T,-b_i)(i,T,−bi​) 和 (S,i,bi)(S,i,b_i)(S,i,bi​) 均满流，则有解，否则无解。设跑完后第 iii 条边的流量为 cic_ici​，则第 iii 条边的流量为 li+cil_i+c_ili​+ci​。 时间复杂度和最大流同阶。 代码 // LOJ #115 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int S=205,MS=30005; const int inf=1e8; struct node { int x,y,wl,wr; }ed[MS]; int n,m; int smf[S]; int esum=1,to[MS],c[MS],id[MS],nxt[MS],h[S]; int s,t; int dep[S],cur[S]; inline void added(int x,int y,int w,int idx) { to[++esum]=y; c[esum]=w; id[esum]=idx; nxt[esum]=h[x]; h[x]=esum; } inline void add(int x,int y,int w,int idx) { added(x,y,w,0),added(y,x,0,idx); } inline bool bfs() { for(int i=s;i&lt;=t;i++) dep[i]=0,cur[i]=h[i]; queue&lt;int&gt; q; dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); if(u==t) return true; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(w&gt;0&amp;&amp;dep[v]==0) { dep[v]=dep[u]+1; q.push(v); } } } return false; } int dfs(int u,int w) { if(u==t) return w; int sum=0; for(int &amp;i=cur[u];i;i=nxt[i]) { if(c[i]==0) continue; int v=to[i]; if(dep[v]!=dep[u]+1) continue; int r=dfs(v,min(c[i],w)); c[i]-=r; c[i^1]+=r; w-=r; sum+=r; if(w==0) break; } if(sum==0) dep[u]=0; return sum; } inline int dinic() { int res=0; while(bfs()) res+=dfs(s,inf); return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;ed[i].x,&amp;ed[i].y,&amp;ed[i].wl,&amp;ed[i].wr); s=0,t=n+1; for(int i=1;i&lt;=m;i++) { smf[ed[i].x]-=ed[i].wl; smf[ed[i].y]+=ed[i].wl; } for(int i=1;i&lt;=n;i++) { if(smf[i]&lt;0) add(i,t,-smf[i],0); if(smf[i]&gt;0) add(s,i,smf[i],0); } for(int i=1;i&lt;=m;i++) add(ed[i].x,ed[i].y,ed[i].wr-ed[i].wl,i); dinic(); bool f=true; for(int i=h[s];i;i=nxt[i]) f&amp;=c[i]==0; for(int i=h[t];i;i=nxt[i]) f&amp;=c[i^1]==0; if(!f) return puts(&quot;NO&quot;),0; else puts(&quot;YES&quot;); for(int i=2;i&lt;=esum;i++) { if(id[i]==0) continue; ed[id[i]].wl+=c[i]; } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ed[i].wl); return 0; } 5.2 有上下界有源汇最大流 考虑将其转化为循环流来消去下界，设源点为 sss，汇点为 ttt，则不难发现相当于从 sss 出发的流量等于到达 ttt 的流量，连边 (t,s,[0,∞])(t,s,[0,\\infin])(t,s,[0,∞])。 跑出循环流记 resresres 为 (t,s,[0,∞])(t,s,[0,\\infin])(t,s,[0,∞]) 的流量后把 (t,s,[0,∞])(t,s,[0,\\infin])(t,s,[0,∞]) 去掉，设第 iii 条边在循环流中流过了 cic_ici​ 流量，则连接边 (xi,yi)(x_i,y_i)(xi​,yi​) 时： 正向边流量为 ri−cir_i-c_iri​−ci​； 反向边流量为 ci−lic_i-l_ici​−li​； 则答案即为 resresres 加上当前图从 sss 到 ttt 的最大流。 代码 // LOJ #116 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int S=505,MS=100005; const int inf=1e8; struct node { int x,y,wl,wr; }ed[MS]; int n,m,nst,ned; int smf[S]; int esum=1,to[MS],c[MS],idx[MS],nxt[MS],h[S]; int s,t; int dep[S],cur[S]; inline void clear() { esum=1; for(int i=s;i&lt;=t;i++) h[i]=0; } inline void added(int x,int y,int w,int id) { to[++esum]=y; c[esum]=w; idx[esum]=id; nxt[esum]=h[x]; h[x]=esum; } inline void add(int x,int y,int w,int id) { added(x,y,w,0),added(y,x,0,id); } inline bool bfs() { for(int i=s;i&lt;=t;i++) dep[i]=0,cur[i]=h[i]; queue&lt;int&gt; q; dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); if(u==t) return true; for(int i=h[u];i;i=nxt[i]) { int v=to[i],w=c[i]; if(w&gt;0&amp;&amp;dep[v]==0) { dep[v]=dep[u]+1; q.push(v); } } } return false; } int dfs(int u,int w) { if(u==t) return w; int sum=0; for(int &amp;i=cur[u];i;i=nxt[i]) { if(c[i]==0) continue; int v=to[i]; if(dep[v]!=dep[u]+1) continue; int r=dfs(v,min(c[i],w)); c[i]-=r; c[i^1]+=r; w-=r; sum+=r; if(w==0) break; } if(sum==0) dep[u]=0; return sum; } inline int dinic() { int res=0; while(bfs()) res+=dfs(s,inf); return res; } int main() { scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;nst,&amp;ned); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;ed[i].x,&amp;ed[i].y,&amp;ed[i].wl,&amp;ed[i].wr); for(int i=1;i&lt;=m;i++) smf[ed[i].x]-=ed[i].wl,smf[ed[i].y]+=ed[i].wl; s=0,t=n+1; for(int i=1;i&lt;=n;i++) { if(smf[i]&lt;0) add(i,t,-smf[i],0); if(smf[i]&gt;0) add(s,i,smf[i],0); } ed[++m]=(node){ned,nst,0,inf}; for(int i=1;i&lt;=m;i++) add(ed[i].x,ed[i].y,ed[i].wr-ed[i].wl,i); dinic(); bool f=true; for(int i=h[s];i;i=nxt[i]) f&amp;=c[i]==0; for(int i=h[t];i;i=nxt[i]) f&amp;=c[i^1]==0; if(!f) return puts(&quot;please go home to sleep&quot;),0; int ans=0; for(int i=2;i&lt;=esum;i++) { if(idx[i]==0) continue; if(idx[i]==m) ans+=c[i]; else { ed[idx[i]].wr-=ed[idx[i]].wl; ed[idx[i]].wl=c[i]; } } m--; clear(); add(s,nst,inf,0),add(ned,t,inf,0); for(int i=1;i&lt;=m;i++) { added(ed[i].x,ed[i].y,ed[i].wr-ed[i].wl,0); added(ed[i].y,ed[i].x,ed[i].wl,0); // printf(&quot;%d %d %d\\n&quot;,ed[i].x,ed[i].y,ed[i].wr-ed[i].wl); // printf(&quot;%d %d %d\\n&quot;,ed[i].y,ed[i].x,ed[i].wl); } ans+=dinic(); printf(&quot;%d\\n&quot;,ans); return 0; } 5.3 有上下界有源汇最小流 最大流是尽可能从 sss 流到 ttt，那么最小流就是尽可能从 ttt 退回 sss。 跑出 ttt 到 sss 的最大流 rfrfrf，答案即为 res−rfres-rfres−rf。 Part 6 常见模型&amp;技巧 网络流的常见建模 ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"网络流","slug":"19EjLeSB_D","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/19EjLeSB_D/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"网络流学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/wang-luo-liu-xue-xi-bi-ji/","stats":{"text":"25 min read","time":1465000,"words":5315,"minutes":25},"date":"2023-03-21 15:27:18","dateFormat":"2023-03-21"},{"abstract":"","content":"后缀数组又名 SA，它是一种十分实用的字符串处理工具，在很多地方能替代后缀自动机。 后缀数组的作用是在 O(nlog⁡n)O(n\\log n)O(nlogn) 时间复杂度内求出一个字符串 SSS 的所有后缀的排名。 为了下文表述方便，我们先规定几个记号： 记 bib_ibi​ 为字符串 SSS 从 iii 开始的后缀，str[l,r]str[l,r]str[l,r] 表示 strstrstr 的第 lll 到第 rrr 这段区间里的字符组成的字符串，saisa_isai​ 为排名为 iii 的后缀的起始位置，rkirk_irki​ 为 bib_ibi​ 的排名。很明显，sasasa 和 rkrkrk 互为逆操作。 我们可以先考虑一个弱智问题： 对所有后缀的第一个字符排序。 很明显，这个东西可以用桶排序来解决，但是注意会有并列的情况。 对于并列的情况，为了方便以后的处理，我们令 rkrkrk 相同但 sasasa 不相同。 代码如下： struct node { int x,pos; }tmp[1000005],tmp2[1000005]; int n; char s[1000005]; int sa[1000005],rk[1000005]; int tot[1000005]; inline void fastsort(int w) // w 为值域 { for(int i=0;i&lt;=w;i++) tot[i]=0; // 桶排序，tot[i] 表示权值 &lt;= i 的元素个数 for(int i=1;i&lt;=n;i++) tot[tmp[i].x]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; // 获得排序后的数组，并复制到 tmp // 对于下面这个 for 的解释： // 由于 x 可能相同，所以权值为 tmp[i].x 的点可能有多个 // 那么它们的排名区间是 [ tot[tmp[i].x-1]+1 , tot[tmp[i].x] ] // 由于排序最好是稳定的（即相同元素不改变相对位置），所以我们要从后往前跑循环，即从后往前插入到排名区间里 for(int i=n;i&gt;=1;i--) tmp2[tot[tmp[i].x]--]=tmp[i]; for(int i=1;i&lt;=n;i++) tmp[i]=tmp2[i]; // 复制 } inline void sasort() // 弱智问题的解法 { for(int i=1;i&lt;=n;i++) tmp[i]=(node){(int)s[i],i}; // 注意要记录位置 fastsort(256); for(int i=1;i&lt;=n;i++) sa[i]=tmp[i].pos; // 不考虑并列的话排名为 i 的后缀就是 b[tmp[i].pos] for(int i=1;i&lt;=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x); // 注意只有元素不一样排名才增加 } 解决完这个弱智问题后，我们来看一个进阶版的问题： 对所有后缀的前两个字符排序，即对所有关键字 &lt;Si,Si+1&gt;&lt;S_i,S_{i+1}&gt;&lt;Si​,Si+1​&gt; 排序。 这个问题使用桶排序有点难解决，但还是可做的。 首先对第二关键字排序，求出 tpitp_itpi​ 表示在第二关键字中排名为 iii 的元素的位置，并列则按位置排序。 然后求出第一关键字 ≤x\\le x≤x 的元素个数 totxtot_xtotx​。 通过弱智问题代码注释中的结论，我们知道第一关键字为 xxx 的排名区间为： [totx−1+1,totx][tot_{x-1}+1,tot_x] [totx−1​+1,totx​] 又因为第二关键字中排名为 iii 的元素的位置为 tpitp_itpi​，所以我们可以从后往前遍历 tptptp 数组，把 tpitp_itpi​ 从后往前依次加进元素 iii 对应的排名区间内，这样不但保证排序正确，还能保证这个排序是稳定的。 代码如下： struct node { int x,y,pos; }tmp[1000005],tmp2[1000005]; int n; char s[1000005]; int sa[1000005],rk[1000005]; int tp[1000005],tot[1000005]; inline void fastsort(int w) { for(int i=0;i&lt;=w;i++) tot[i]=0; // 对第二关键字排序，求出 tp[i] 表示第二关键字中排名第 i 的关键字的位置（相当于第二关键字的 sa） for(int i=1;i&lt;=n;i++) tot[tmp[i].y]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; for(int i=n;i&gt;=1;i--) tp[tot[tmp[i].y]--]=i; for(int i=0;i&lt;=w;i++) tot[i]=0; // 对第一关键字排序 for(int i=1;i&lt;=n;i++) tot[tmp[i].x]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; // 结合起来 for(int i=n;i&gt;=1;i--) tmp2[tot[tmp[tp[i]].x]--]=tmp[tp[i]]; for(int i=1;i&lt;=n;i++) tmp[i]=tmp2[i]; } inline void sasort() // 进阶问题的解法 { for(int i=1;i&lt;=n-1;i++) tmp[i]=(node){(int)s[i],(int)s[i+1],i}; // 只有 n-1 个元素有两个关键字 tmp[n]=(node){(int)s[n],0,i}; // 没有第二关键字，那么令它为 0 fastsort(256); for(int i=1;i&lt;=n;i++) sa[i]=tmp[i].pos; for(int i=1;i&lt;=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y); } 我们再来考虑一个问题： 对所有后缀的前四个字符排序，即对所有关键字 &lt;Si,Si+1,Si+2,Si+3&gt;&lt;S_i,S_{i+1},S_{i+2},S_{i+3}&gt;&lt;Si​,Si+1​,Si+2​,Si+3​&gt; 排序。 对于这个问题，我们并不需要重新写一个排序，因为那样太麻烦了。我们只需要先对 &lt;Si,Si+1&gt;&lt;S_i,S_{i+1}&gt;&lt;Si​,Si+1​&gt; 排序，再对 &lt;rki,rki+2&gt;&lt;rk_i,rk_{i+2}&gt;&lt;rki​,rki+2​&gt; 排序即可。因为和 bi[3,4]b_i[3,4]bi​[3,4] 最相似的长度为 222 的前缀是 bi+2[1,2]b_{i+2}[1,2]bi+2​[1,2]，我们就可以把 bi[1,2]b_i[1,2]bi​[1,2] 和 bi+2[3,4]b_{i+2}[3,4]bi+2​[3,4] 拼接起来排序。 所以，我们可以使用倍增来排序所有后缀！ 模板题代码如下： // P3809 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; struct node { int x,y,pos; }tmp[1000005],tmp2[1000005]; int n; char s[1000005]; int sa[1000005],rk[1000005]; int tp[1000005],tot[1000005]; inline void fastsort(int w) { for(int i=0;i&lt;=w;i++) tot[i]=0; // 对第二关键字排序，求出 tp[i] 表示第二关键字中排名第 i 的关键字的位置（相当于第二关键字的 sa） for(int i=1;i&lt;=n;i++) tot[tmp[i].y]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; for(int i=n;i&gt;=1;i--) tp[tot[tmp[i].y]--]=i; for(int i=0;i&lt;=w;i++) tot[i]=0; // 对第一关键字排序 for(int i=1;i&lt;=n;i++) tot[tmp[i].x]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; // 结合起来 for(int i=n;i&gt;=1;i--) tmp2[tot[tmp[tp[i]].x]--]=tmp[tp[i]]; for(int i=1;i&lt;=n;i++) tmp[i]=tmp2[i]; } inline void sasort() { // 对第一个字符排序 for(int i=1;i&lt;=n;i++) tmp[i]=(node){(int)s[i],0,i}; fastsort(256); for(int i=1;i&lt;=n;i++) sa[i]=tmp[i].pos; for(int i=1;i&lt;=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y); // 倍增 for(int p=1;p&lt;=n;p&lt;&lt;=1) { for(int i=1;i&lt;=n-p;i++) tmp[i]=(node){rk[i],rk[i+p],i}; // b[i] 已经根据前 p 个字符排过序了 // 所以和 b[i] 的第 p+1 ~ p+p 个字符最相似的是 b[rk[i+p]] 的前 p 个字符 for(int i=n-p+1;i&lt;=n;i++) tmp[i]=(node){rk[i],0,i}; // 没有第二关键字，那么设为 0 fastsort(rk[sa[n]]); // 排序，注意值域是 rk[sa[n]] 即最大的 rk 值 for(int i=1;i&lt;=n;i++) sa[i]=tmp[i].pos; for(int i=1;i&lt;=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y); if(rk[sa[n]]&gt;=n) break; } } int main() { scanf(&quot;%s&quot;,s+1); n=strlen(s+1); sasort(); for(int i=1;i&lt;=n;i++) { printf(&quot;%d &quot;,sa[i]); } printf(&quot;\\n&quot;); return 0; } 接下来我们考虑一个很经典的问题：（P2408 不同子串个数） 求出某个字符串的不同子串个数。 我们记 bsaib_{sa_i}bsai​​ 和 bsai−1b_{sa_i-1}bsai​−1​ 的最长公共前缀长度为 heightiheight_iheighti​，bib_{i}bi​ 和 bsarki−1b_{sa_{rk_{i-1}}}bsarki−1​​​ 的最长公共前缀长度为 hih_ihi​。很明显 hi=heightrkih_i=height_{rk_i}hi​=heightrki​​。 那么很显然可以用暴力，不断让 hih_ihi​ 增加直到 hih_ihi​ 大于两个后缀长度中最小的那个或者两个后缀的第 hi+1h_i+1hi​+1 个字符不同。 但是有个很巧妙的柿子： hi≥hi−1−1h_i\\ge h_{i-1}-1 hi​≥hi−1​−1 证明如下:（转载自这里） 最后 bib_ibi​ 对答案的贡献即为 (n−i+1)−hi(n-i+1)-h_i(n−i+1)−hi​。 题目代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; struct node { int x,y,pos; }tmp[100005],tmp2[100005]; int n; char s[100005]; int tot[100005],tp[100005]; int sa[100005],rk[100005]; int h[100005]; inline void fastsort(int w) { for(int i=0;i&lt;=w;i++) tot[i]=0; for(int i=1;i&lt;=n;i++) tot[tmp[i].y]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; for(int i=n;i&gt;=1;i--) tp[tot[tmp[i].y]--]=i; for(int i=0;i&lt;=w;i++) tot[i]=0; for(int i=1;i&lt;=n;i++) tot[tmp[i].x]++; for(int i=1;i&lt;=w;i++) tot[i]+=tot[i-1]; for(int i=n;i&gt;=1;i--) tmp2[tot[tmp[tp[i]].x]--]=tmp[tp[i]]; for(int i=1;i&lt;=n;i++) tmp[i]=tmp2[i]; } inline void sasort() { for(int i=1;i&lt;=n;i++) tmp[i]=(node){(int)s[i],0,i}; fastsort(256); for(int i=1;i&lt;=n;i++) sa[i]=tmp[i].pos; for(int i=1;i&lt;=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y); for(int p=1;p&lt;=n;p&lt;&lt;=1) { for(int i=1;i&lt;=n-p;i++) tmp[i]=(node){rk[i],rk[i+p],i}; for(int i=n-p+1;i&lt;=n;i++) tmp[i]=(node){rk[i],0,i}; fastsort(n); for(int i=1;i&lt;=n;i++) sa[i]=tmp[i].pos; for(int i=1;i&lt;=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y); if(rk[sa[n]]&gt;=n) break; } } inline void geth() { for(int i=1;i&lt;=n;i++) { int k=max(h[i-1]-1,0); int pos=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;pos+k&lt;=n&amp;&amp;s[i+k]==s[pos+k]) { k++; } h[i]=k; } } int main() { scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); sasort(); geth(); long long ans=0; for(int i=1;i&lt;=n;i++) { ans+=(n-i+1)-h[i]; } printf(&quot;%lld\\n&quot;,ans); return 0; } 练习题目 P3763 [TJOI2017]DNA P2463 [SDOI2008] Sandy 的卡片 P2852 [USACO06DEC]Milk Patterns G P3181 [HAOI2016]找相同字符 ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"后缀数组学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/hou-zhui-shu-zu-xue-xi-bi-ji/","stats":{"text":"13 min read","time":762000,"words":2533,"minutes":13},"date":"2023-03-21 15:26:26","dateFormat":"2023-03-21"},{"abstract":"","content":"算法介绍 Manacher 是一个求解字符串的回文子串的算法。 考虑这样的一道例题： 给定字符串 SSS，询问所有子串中的最长回文子串长度。例如 ebaabaf 最长的回文子串是 baab。 1≤∣S∣≤1.1×1071\\le|S|\\le 1.1\\times 10^71≤∣S∣≤1.1×107。 很明显能使用中心点和往一端拓展的长度来确定一个回文子串，但由于回文串分为奇回文串和偶回文串，而奇回文串的中心是字符，偶回文串的中心确是字符的间隔处，所以可以在两个字符中间加入 #，来使得所有回文子串都变为奇回文串。 例如字符串 dbaabab 就变成了 #d#b#a#a#b#a#b#； 原串中的回文子串 aba 对应转化串中的 #a#b#a#； 原串中的回文子串 baab 对应转化串中的 #b#a#a#b#。 这样一来，奇/偶回文子串的中心都在字符上。只不过，奇回文子串的中心在转化串里是原串的字符；而偶回文子串的中心在转化串里是 # 间隔符。 但是这样一来，同一个回文子串我们就会计算两遍，因为 a#b#a 和 #a#b#a# 都对应原串中的 aba。所以如果一个字符作为中心在转化串中最多能扩展 LLL 位，那么在原串中它最多只能拓展 ⌊L2⌋\\lfloor \\dfrac{L}{2}\\rfloor⌊2L​⌋ 位。 预处理完转换串后，我们就可以开始求解答案了。设 extiext_iexti​ 表示从第 iii 位开始拓展，最多可以拓展的位数。即满足 Si−exti≠Si+extiS_{i-ext_i}\\ne S_{i+ext_i}Si−exti​​​=Si+exti​​ 的最小的值。（注意是在转换串上） 首先考虑暴力求解。可以枚举每一个 iii，然后往两边暴力拓展，直到遇到不同的字符。 但我们考虑以下这种情况： 求以 xyzdabaaabaefeaba[a]abadxyz 中被框起来的字符 a 为回文中 心的最长回文子串。 假如我们知道 xyz [dabaaabaefeabaaabad] xyz 和 xyz d[abaaaba]efeabaaabad xyz 被框起来的部分都是回文子串，那么我们就可以得出需要求解的回文子串至少包含下面被框起来的部分： xyz dabaaabaefe[abaaaba]d xyz 这条特质是由回文串的对称性引出的，也就是说被大回文串包含的小回文串可以以大回文串中心“对过去”。 所以转移过程中，我们需要记录下对于当前的 iii，以 pospospos 为中心的回文子串中，右端点最靠右的那个 pospospos，即找到 pos+extpospos+ext_{pos}pos+extpos​ 最大的 pospospos。（1≤pos≤i−11\\le pos\\le i-11≤pos≤i−1） 如果 pos+extpos&gt;ipos+ext_{pos}&gt; ipos+extpos​&gt;i，那么 iii 在 pospospos 为中心的最长回文子串内，直接让 exti=min⁡(extpos+pos−i,extpos∗2−i)ext_i=\\min(ext_{pos}+pos-i,ext_{pos*2-i})exti​=min(extpos​+pos−i,extpos∗2−i​) 然后暴力拓展即可。 否则直接暴力拓展 最后更新一下 pospospos 即可。 然后还有一个很重要的细节，为了防止算法跑出去，所以要在转化串开头和结尾分别加上 @ 和 &amp; 两个哨兵。 模板代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int n; char s[30000005]; int ext[30000005]; int main() { scanf(&quot;%s&quot;,s+1); n=strlen(s+1); // 预处理转化串 for(int i=n;i&gt;=1;i--) { s[i*2]=s[i]; } n=n*2+1; for(int i=1;i&lt;=n;i+=2) { s[i]='#'; } // 加入哨兵 s[0]='@'; s[n+1]='&amp;'; int ans=0; for(int i=1,pos=0;i&lt;=n;i++) { if(pos+ext[pos]&gt;i) ext[i]=min(pos+ext[pos]-i,ext[pos*2-i]); // 运用特质拓展 while(s[i+ext[i]]==s[i-ext[i]]) ext[i]++; // 暴力拓展 if(i+ext[i]&gt;pos+ext[pos]) pos=i; // 更新 pos ans=max(ans,ext[i]-1); } printf(&quot;%d\\n&quot;,ans); return 0; } 时空复杂度分析 空间复杂度 显然是 O(n)O(n)O(n) 的，但是注意要开两倍空间。 时间复杂度 考虑 r=pos+extposr=pos+ext_{pos}r=pos+extpos​ 在算法过程中的变化，分为两种情况： 当前的 iii 运用特质拓展了： 此时要么 iii 不会再暴力拓展，要么是这种情况： 这样每暴力拓展一次 rrr 就一定会往右移一位。 当前的 iii 未运用性质拓展，那么每暴力拓展一次 rrr 就一定会往右移一位。 最后我们得到了一个结论：每次暴力拓展都会令 rrr 右移一位，那么暴力拓展的次数上限是 nnn，算法时间复杂度自然为 O(n)O(n)O(n)。 注意到每次暴力拓展都有可能是找到了一个新的回文子串，所以一个字符串 SSS 的本质不同回文子串个数最多是 nnn。 一些性质 一个字符串 SSS 的本质不同回文子串个数最多是 nnn； 最长回文子串为 max⁡{exti−1}\\max\\{ext_i-1\\}max{exti​−1}； 回文子串个数即为 ∑⌊exti2⌋\\sum\\lfloor \\dfrac{ext_i}{2}\\rfloor∑⌊2exti​​⌋； 练习题目 P1659 [国家集训队]拉拉队排练 P4555 [国家集训队]最长双回文串 P6216 回文匹配 P5446 [THUPC2018]绿绿和串串 P3501 [POI2010]ANT-Antisymmetry P4287 [SHOI2011]双倍回文 ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Manacher 算法学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/manacher-suan-fa-xue-xi-bi-ji/","stats":{"text":"6 min read","time":326000,"words":1330,"minutes":6},"date":"2023-03-21 15:24:31","dateFormat":"2023-03-21"},{"abstract":"","content":"EXCRT 其实和 CRT 半毛钱关系都没有…… 我们在 CRT 中需要用到求逆元的操作： inv⁡(Mbi,bi)\\operatorname{inv}(\\dfrac{M}{b_i},b_i) inv(bi​M​,bi​) 但是如果 bib_ibi​ 不满足两两互质，我们就无法求出逆元，这样 CRT 就用不了了。 为了解决这个问题，求出 bib_ibi​ 不一定两两互质时同余方程组 {x≡a1(modb1)x≡a2(modb2)x≡a3(modb3)……x≡an(modbn)\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\\\x\\equiv a_3\\pmod{b_3}\\\\\\qquad\\dots\\dots\\\\x\\equiv a_n\\pmod{b_n}\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x≡a1​(modb1​)x≡a2​(modb2​)x≡a3​(modb3​)……x≡an​(modbn​)​ 的解，EXCRT 就诞生了。 首先考虑两个方程的情况： {x≡a1(modb1)x≡a2(modb2)\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\end{cases} {x≡a1​(modb1​)x≡a2​(modb2​)​ 可以转化为这样： {x=a1+k1⋅b1x=a2+k2⋅b2\\begin{cases}x=a_1+k_1\\cdot b_1\\\\x=a_2+k_2\\cdot b_2\\end{cases} {x=a1​+k1​⋅b1​x=a2​+k2​⋅b2​​ 即： a1+k1⋅b1=a2+k2⋅b2a_1+k_1\\cdot b_1=a_2+k_2\\cdot b_2 a1​+k1​⋅b1​=a2​+k2​⋅b2​ 移项： k1⋅b1−k2⋅b2=a2−a1k_1\\cdot b_1-k_2\\cdot b_2=a_2-a_1 k1​⋅b1​−k2​⋅b2​=a2​−a1​ 这个柿子很明显能使用 exgcd 求解。 很明显，若 a2−a1mod gcd⁡(b1,b2)≠0a_2-a_1\\mod{\\gcd(b_1,b_2)} \\ne 0a2​−a1​modgcd(b1​,b2​)​=0 那么无解。 设 y1,y2y_1,y_2y1​,y2​ 满足 y1⋅b1+y2⋅b2=gcd⁡(b1,b2)y_1\\cdot b_1+y_2\\cdot b_2=\\gcd(b_1,b_2)y1​⋅b1​+y2​⋅b2​=gcd(b1​,b2​)，则 k1=y1⋅a2−a1gcd⁡(b1,b2),k2=−y2⋅a2−a1gcd⁡(b1,b2)k_1=y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)},k_2=-y_2\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}k1​=y1⋅gcd(b1​,b2​)a2​−a1​​,k2​=−y2​⋅gcd(b1​,b2​)a2​−a1​​。 所以我们可以求出这个方程组的一个解为 x=a1+y1⋅a2−a1gcd⁡(b1,b2)⋅b1x=a_1+y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}\\cdot b_1x=a1​+y1⋅gcd(b1​,b2​)a2​−a1​​⋅b1​。 很明显最小正整数解就是 xmin=xmod lcm⁡(b1,b2)x_{min}=x\\mod{\\operatorname{lcm}(b_1,b_2)}xmin​=xmodlcm(b1​,b2​)，但由于 xxx 有可能是负数，所以取模时需要特殊处理。 接下来 EXCRT 的核心思想来了： 我们可以把 x=a1+y1⋅a2−a1gcd⁡(b1,b2)⋅b1mod lcm⁡(b1,b2)x=a_1+y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}\\cdot b_1\\mod{\\operatorname{lcm}(b_1,b_2)}x=a1​+y1⋅gcd(b1​,b2​)a2​−a1​​⋅b1​modlcm(b1​,b2​) 改写成同余方程，即： x≡a1+y1⋅a2−a1gcd⁡(b1,b2)⋅b1mod lcm⁡(b1,b2)(modlcm⁡(b1,b2))x\\equiv a_1+y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}\\cdot b_1\\mod{\\operatorname{lcm}(b_1,b_2)}\\pmod{\\operatorname{lcm}(b_1,b_2)}x≡a1​+y1⋅gcd(b1​,b2​)a2​−a1​​⋅b1​modlcm(b1​,b2​)(modlcm(b1​,b2​)) 这时，我们就成功把两个同余方程合并为了一个！ 所以只要一直合并下去，就能得到最终的解了。 模板题代码：（需要高精所以开了 __int128） #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; __int128 a[100005],b[100005]; inline __int128 read() { __int128 s=0; int w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48),ch=getchar(); return s; } void writen(__int128 x) { if(x&lt;0) putchar('-'),writen(-x); x&gt;9?writen(x/10),putchar(x%10|48):putchar(x|48); } inline __int128 lcm(__int128 a,__int128 b) { __int128 tmpa=a,tmpb=b; __int128 t=a%b; while(t!=0) { a=b; b=t; t=a%b; } return tmpa*tmpb/b; } __int128 exgcd(__int128 a,__int128 b,__int128 &amp;x,__int128 &amp;y) { if(a&lt;b) { return exgcd(b,a,y,x); } if(b==0) { x=1; y=0; return a; } __int128 tmpx,tmpy; __int128 res=exgcd(b,a%b,tmpx,tmpy); x=tmpy; y=tmpx-a/b*tmpy; return res; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { b[i]=read(); a[i]=read(); } a[1]=(a[1]%b[1]+b[1])%b[1]; for(int i=2;i&lt;=n;i++) { __int128 rig=a[i]-a[i-1]; __int128 y1,y2; __int128 g=exgcd(b[i-1],b[i],y1,y2); if(rig%g!=0) { puts(&quot;Impossible!&quot;); break; } y1*=rig/g; a[i]=a[i-1]+b[i-1]*y1; b[i]=lcm(b[i-1],b[i]); a[i]=(a[i]%b[i]+b[i])%b[i]; } writen(a[n]); putchar('\\n'); return 0; } ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"扩展中国剩余定理(EXCRT)学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kuo-zhan-zhong-guo-sheng-yu-ding-li-excrtxue-xi-bi-ji/","stats":{"text":"6 min read","time":301000,"words":921,"minutes":6},"date":"2023-03-21 15:21:14","dateFormat":"2023-03-21"},{"abstract":"","content":"中国剩余定理(CRT)是用来求这样的一个不定方程组的解的： {x≡a1(modb1)x≡a2(modb2)x≡a3(modb3)……x≡an(modbn)\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\\\x\\equiv a_3\\pmod{b_3}\\\\\\qquad\\dots\\dots\\\\x\\equiv a_n\\pmod{b_n}\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x≡a1​(modb1​)x≡a2​(modb2​)x≡a3​(modb3​)……x≡an​(modbn​)​ 其中 bib_ibi​ 两两互质。 我们可以先考虑一个简单点的问题： {x≡2(mod3)x≡3(mod5)x≡2(mod7)\\begin{cases}x\\equiv 2\\pmod{3}\\\\x\\equiv 3\\pmod{5}\\\\x\\equiv 2\\pmod{7}\\end{cases} ⎩⎪⎨⎪⎧​x≡2(mod3)x≡3(mod5)x≡2(mod7)​ 我们可以： 令 y1y_1y1​ 除以 333 余 222，除以 555 余 000，除以 777 余 000 令 y2y_2y2​ 除以 333 余 000，除以 555 余 333，除以 777 余 000 令 y3y_3y3​ 除以 333 余 000，除以 555 余 000，除以 777 余 222 那么这个方程组的一个解就是 x=y1+y2+y3x=y_1+y_2+y_3x=y1​+y2​+y3​。 继续对 y1y_1y1​ 分解（其实对 y2y_2y2​ 和 y3y_3y3​ 也同理），令 zzz 除以 333 余 111，除以 555 余 000，除以 777 余 000，那么显然有 y1=z∗2y_1=z*2y1​=z∗2。 令 M=∏i=1nbi=105M=\\prod\\limits_{i=1}^nb_i=105M=i=1∏n​bi​=105，那么 zzz 肯定能被 Mb1=1053=35\\dfrac{M}{b_1}=\\dfrac{105}{3}=35b1​M​=3105​=35 整除，不妨令 z=35kz=35kz=35k。那么 35k≡1(modb1)35k\\equiv 1\\pmod{b_1}35k≡1(modb1​) 即 35k≡1(mod3)35k\\equiv 1\\pmod{3}35k≡1(mod3)。很明显，kkk 就是 353535 在模 333 意义下的逆元。 所以 y1=a1⋅Mb1⋅inv⁡(Mb1,b1)y_1=a_1\\cdot\\dfrac{M}{b_1}\\cdot\\operatorname{inv}(\\dfrac{M}{b_1},b_1)y1​=a1​⋅b1​M​⋅inv(b1​M​,b1​) 即 y1=2∗35∗2=140y_1=2*35*2=140y1​=2∗35∗2=140。 归纳一下，yi=ai⋅Mbi⋅inv⁡(Mbi,bi)y_i=a_i\\cdot\\dfrac{M}{b_i}\\cdot\\operatorname{inv}(\\dfrac{M}{b_i},b_i)yi​=ai​⋅bi​M​⋅inv(bi​M​,bi​)，那么 x=∑i=1nai⋅Mbi⋅inv⁡(Mbi,bi)x=\\sum\\limits_{i=1}^n a_i\\cdot\\dfrac{M}{b_i}\\cdot\\operatorname{inv}(\\dfrac{M}{b_i},b_i)x=i=1∑n​ai​⋅bi​M​⋅inv(bi​M​,bi​)。 但由于这时候求出的 xxx 只是任意解，最小解 xminx_{min}xmin​ 即为 xmod lcm⁡(b1,b2,b3,…,bn)x\\mod{\\operatorname{lcm}(b_1,b_2,b_3,\\dots,b_n)}xmodlcm(b1​,b2​,b3​,…,bn​)。 所以方程组 {x≡a1(modb1)x≡a2(modb2)x≡a3(modb3)……x≡an(modbn)\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\\\x\\equiv a_3\\pmod{b_3}\\\\\\qquad\\dots\\dots\\\\x\\equiv a_n\\pmod{b_n}\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x≡a1​(modb1​)x≡a2​(modb2​)x≡a3​(modb3​)……x≡an​(modbn​)​ 的最小解为： xmin=∑i=1nai⋅Mbi⋅inv⁡(Mbi,bi)mod lcm⁡(b1,b2,b3,…,bn)x_{min}=\\sum\\limits_{i=1}^n a_i\\cdot\\dfrac{M}{b_i}\\cdot\\operatorname{inv}(\\dfrac{M}{b_i},b_i)\\mod{\\operatorname{lcm}(b_1,b_2,b_3,\\dots,b_n)} xmin​=i=1∑n​ai​⋅bi​M​⋅inv(bi​M​,bi​)modlcm(b1​,b2​,b3​,…,bn​) 其中 M=∏i=1nbiM=\\prod\\limits_{i=1}^nb_iM=i=1∏n​bi​。 可以发现 Mbi\\dfrac{M}{b_i}bi​M​ 其实能用前缀和维护。 模板题代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; long long a[15],b[15]; long long sum[2][15]; long long exgcd(long long a,long long b,long long &amp;x,long long &amp;y) { if(a&lt;b) { return exgcd(b,a,y,x); } if(b==0) { x=1; y=0; return a; } long long tmpx,tmpy; long long res=exgcd(b,a%b,tmpx,tmpy); x=tmpy; y=tmpx-a/b*tmpy; return res; } inline long long inv(long long a,long long p) // 扩欧求逆元 { long long x,y; if(exgcd(a,p,x,y)!=1) { return -1; } return (x%p+p)%p; } inline long long lcm(long long a,long long b) { long long tmpa=a,tmpb=b; long long t=a%b; while(t!=0) { a=b; b=t; t=a%b; } return tmpa*tmpb/b; } int main() { scanf(&quot;%d&quot;,&amp;n); long long llcm=1; for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld%lld&quot;,&amp;b[i],&amp;a[i]); llcm=lcm(llcm,b[i]); } // 前缀和维护 M/b_i sum[0][0]=sum[1][n+1]=1; for(int i=1;i&lt;=n;i++) { sum[0][i]=sum[0][i-1]*b[i]; } for(int i=n;i&gt;=1;i--) { sum[1][i]=sum[1][i+1]*b[i]; } long long ans=0; for(int i=1;i&lt;=n;i++) { ans+=a[i]*sum[0][i-1]*sum[1][i+1]*inv(sum[0][i-1]*sum[1][i+1],b[i]); } printf(&quot;%lld\\n&quot;,ans%llcm); // 求最小解 return 0; } ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"中国剩余定理(CRT)学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zhong-guo-sheng-yu-ding-li-crtxue-xi-bi-ji/","stats":{"text":"6 min read","time":312000,"words":934,"minutes":6},"date":"2023-03-21 15:19:53","dateFormat":"2023-03-21"},{"abstract":"","content":"前置芝士 exgcd 就是用来求解 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) 这个方程的最小整数解的（a,b∈N∗a,b \\in \\mathbb{N^*}a,b∈N∗）。 拿到这个柿子，第一步当然是推导、化简啦。 推导过程 首先为了方便推导，令 a≥ba\\ge ba≥b； 很明显，若 b=0b=0b=0，则 gcd⁡(a,b)=a,x=1,y=0\\gcd(a,b)=a,x=1,y=0gcd(a,b)=a,x=1,y=0； 对于 b≠0b\\ne 0b​=0 的情况： 设 x=x′,y=y′x=x^\\prime,y=y^\\primex=x′,y=y′ 为 bx+(a%b)y=gcd⁡(b,a%b)bx+(a\\%b)y=\\gcd(b,a\\%b)bx+(a%b)y=gcd(b,a%b) 的最小整数解； ∵gcd⁡(a,b)=gcd⁡(b,a%b)\\because \\gcd(a,b)=\\gcd(b,a\\%b) ∵gcd(a,b)=gcd(b,a%b) ∴ax+by=bx′+(a%b)y′\\therefore ax+by=bx^\\prime+(a\\%b)y^\\prime ∴ax+by=bx′+(a%b)y′ ∵a≥b\\because a\\ge b ∵a≥b ∴a%b=a−b⌊ab⌋\\therefore a\\%b=a-b\\lfloor\\dfrac{a}{b}\\rfloor ∴a%b=a−b⌊ba​⌋ ∴ax+by=bx′+(a−b⌊ab⌋)y′\\therefore ax+by=bx^\\prime+(a-b\\lfloor\\dfrac{a}{b}\\rfloor)y^\\prime ∴ax+by=bx′+(a−b⌊ba​⌋)y′ =bx′+ay′−b⌊ab⌋y′\\qquad \\qquad \\,\\,\\,= bx^\\prime+ay^\\prime-b\\lfloor\\dfrac{a}{b}\\rfloor y^\\prime =bx′+ay′−b⌊ba​⌋y′ =ay′+b(x′−⌊ab⌋y′)\\qquad \\qquad \\,\\,\\,= ay^\\prime+b(x^\\prime-\\lfloor\\dfrac{a}{b}\\rfloor y^\\prime) =ay′+b(x′−⌊ba​⌋y′) 而我们想要令 x,yx,yx,y 最小，所以 x=y′,y=x′−⌊ab⌋y′x=y^\\prime,y=x^\\prime-\\lfloor\\dfrac{a}{b}\\rfloor y^\\primex=y′,y=x′−⌊ba​⌋y′。 模板代码 int exgcd(int a,int b,int &amp;x,int &amp;y) // x 和 y 是引用，因为我懒得写结构体…… { if(a&lt;b) // 如果 a &lt; b 那么交换 a 和 b 来求 { return exgcd(b,a,y,x); } if(b==0) // 如果 b 为 0，那么 gcd(a,b) = a，x = 1，y = 0 { x=1; y=0; return a; } // 其它情况 int tmpx,tmpy; int res=exgcd(b,a%b,tmpx,tmpy); x=tmpy; y=tmpx-a/b*tmpy; return res; } 应用（求乘法逆元） exgcdexgcdexgcd 可以干很多事情，甚至还有 exexgcdexexgcdexexgcd……（扩展扩展欧几里得函数） 所以理解好它很重要 awa exgcdexgcdexgcd 的一个比较常见的用途是求乘法逆元。 设 aaa 在 mod b\\mod{b}modb 意义下的逆元是 a∗a^*a∗，那么 a⋅a∗≡1mod ba\\cdot a^* \\equiv 1\\mod{b} a⋅a∗≡1modb 即 b∣(a⋅a∗−1)b\\mid (a\\cdot a^*-1) b∣(a⋅a∗−1) 设 a⋅a∗−1b\\dfrac{a\\cdot a^*-1}{b}ba⋅a∗−1​ 为 yyy，那么 a∗⋅a−1=bya^*\\cdot a -1=by a∗⋅a−1=by 即 a∗⋅a−by=1a^*\\cdot a-by=1 a∗⋅a−by=1 这个方程就是 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) 的形式，所以我们可以得知**xxx 的逆元存在的必要条件是 xxx 和模数 ppp 互质**。 所以我们只需要使用 exgcdexgcdexgcd 就可以求出逆元了。 求逆元代码如下：(P5431 【模板】乘法逆元 2) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int n; long long p,k; long long a[5000005],sum[2][5000005]; inline long long read() { long long s=0,w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48),ch=getchar(); return s*w; } long long exgcd(long long a,long long b,long long &amp;x,long long &amp;y) // x 和 y 是引用，因为我懒得写结构体…… { if(a&lt;b) // 如果 a &lt; b 那么交换 a 和 b 来求 { return exgcd(b,a,y,x); } if(b==0) // 如果 b 为 0，那么 gcd(a,b) = a，x = 1，y = 0 { x=1; y=0; return a; } // 其它情况 long long tmpx,tmpy; long long res=exgcd(b,a%b,tmpx,tmpy); x=tmpy; y=tmpx-a/b*tmpy; return res; } inline long long inv(long long val) // exgcd 求乘法逆元 { long long x,y; if(exgcd(val,p,x,y)!=1) { return -1; } return (x%p+p)%p; } int main() { scanf(&quot;%d%lld%lld&quot;,&amp;n,&amp;p,&amp;k); for(int i=1;i&lt;=n;i++) { a[i]=read(); } sum[0][0]=1; sum[1][n+1]=1; for(int i=1;i&lt;=n;i++) { sum[0][i]=sum[0][i-1]*a[i]%p; } for(int i=n;i&gt;=1;i--) { sum[1][i]=sum[1][i+1]*a[i]%p; } long long summ=0,base=1; for(int i=1;i&lt;=n;i++) { base=base*k%p; summ+=base*sum[0][i-1]%p*sum[1][i+1]%p; summ%=p; } printf(&quot;%lld\\n&quot;,summ*inv(sum[0][n])%p); return 0; } 练习题目 P2613 【模板】有理数取余 P1516 青蛙的约会 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"扩展欧几里得算法学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kuo-zhan-ou-ji-li-de-suan-fa-xue-xi-bi-ji/","stats":{"text":"6 min read","time":336000,"words":1038,"minutes":6},"date":"2023-03-21 15:17:58","dateFormat":"2023-03-21"},{"abstract":"","content":"DDDDDDDD 问题 DDDDDDDD 问题形式化描述如下： 给一个正整数 NNN 和 一个正个位数 DDD，求至少多少个 DDD 组成的 DD…DD‾\\overline{DD\\dots DD}DD…DD 可以被 NNN 整除。 1≤N≤2×1091\\le N\\le 2\\times 10^91≤N≤2×109。 显然 DD…DD‾\\overline{DD\\dots DD}DD…DD 可以表示为 D×(10k−1)9\\frac{D\\times(10^k-1)}{9}9D×(10k−1)​，推一波式子： N∣D×(10k−1)99N∣D×(10k−1)设 d=gcd⁡(D,9N):9Nd∣10k−110k≡1(mod9Nd)N\\mid\\frac{D\\times(10^k-1)}{9}\\\\ 9N\\mid D\\times (10^k-1)\\\\ 设\\,d=\\gcd(D,9N):\\\\ \\frac{9N}{d}\\mid10^k-1\\\\ 10^k\\equiv1\\pmod{\\frac{9N}{d}} N∣9D×(10k−1)​9N∣D×(10k−1)设d=gcd(D,9N):d9N​∣10k−110k≡1(modd9N​) 此时，若 101010 和 9Nd\\frac{9N}{d}d9N​ 不互质那么无解。 考虑如何求出 kkk 的最小值，即答案，根据欧拉定理，有： 10φ(9Nd)≡1(mod9Nd)10^{\\varphi(\\frac{9N}{d})}\\equiv 1\\pmod{\\frac{9N}{d}} 10φ(d9N​)≡1(modd9N​) 此时最小的 kkk 一定是 φ(9Nd)\\varphi(\\frac{9N}{d})φ(d9N​) 的因子. 证明 设 φ(9Nd)=M\\varphi(\\frac{9N}{d})=Mφ(d9N​)=M，假如最小的 k=xk=xk=x 且 x∤Mx\\nmid Mx∤M，那么设 M=qx+rM=qx+rM=qx+r； 因为 10x≡1(mod9Nd)10^x\\equiv 1\\pmod{\\frac{9N}{d}}10x≡1(modd9N​)，所以 10qx≡1(mod9Nd)10^{qx}\\equiv 1\\pmod{\\frac{9N}{d}}10qx≡1(modd9N​)； 由于 10M≡1(mod9Nd)10^M\\equiv 1\\pmod{\\frac{9N}{d}}10M≡1(modd9N​) 所以 10qx+r≡1(mod9Nd)10^{qx+r}\\equiv1\\pmod{\\frac{9N}{d}}10qx+r≡1(modd9N​)，10r≡1(mod9Nd)10^r\\equiv 1\\pmod{\\frac{9N}{d}}10r≡1(modd9N​)； 由于 0≤r&lt;x0\\le r&lt;x0≤r&lt;x，所以 rrr 比 xxx 更小，矛盾。 那么枚举 φ(9Nd)\\varphi(\\frac{9N}{d})φ(d9N​) 的因子，快速幂判断即可。 指数级搜索（exponetial search） 这是一种用于处理 check⁡(l,mid)\\operatorname{check}(l,mid)check(l,mid) 时间复杂度为 O(mid−l+1)O(mid-l+1)O(mid−l+1) 即时间复杂度和序列长度相关的搜索算法。 一般用于需要在序列上不断二分划分出一段段互不相交的合法区间的题目中。 发现二分的问题在于从 iii 出发找以 iii 开头的合法区间的右端点 rrr 的时候时间复杂度为 O((n−i)log⁡(n−i))O((n-i)\\log(n-i))O((n−i)log(n−i))，总时间复杂度最坏为 O(n2log⁡n)O(n^2\\log n)O(n2logn)，无法接受。 不难发现问题在于二分的区间太大了，不妨先从小到大枚举 jjj，找到第一个满足 check⁡(i,i+2j−1)=true\\operatorname{check}(i,i+2^j-1)=truecheck(i,i+2j−1)=true 的 jjj，然后在 [i,i+2j−1][i,i+2^j-1][i,i+2j−1] 里二分，这样二分的时间复杂度就是 O((r−i+1)log⁡(r−i+1))O((r-i+1)\\log(r-i+1))O((r−i+1)log(r−i+1)) 也就是只和当前区间的长度有关，均摊时间复杂度即为 O(nlog⁡n)O(n\\log n)O(nlogn)。 参考代码 for(int i=1;i&lt;=n;i++) { int rb=-1; for(int j=0;j&lt;=20;j++) { int pre=min(i+(1&lt;&lt;j)-1,n); if(chk(i,pre)) { rb=pre; break; } } if(rb==-1) break; int lb=i,nxt=0; while(lb&lt;=rb) { int mid=lb+rb&gt;&gt;1; if(chk(i,mid)) nxt=mid,rb=mid-1; else lb=mid+1; } ans[++anscnt]=nxt; i=nxt; } gcd⁡(ax−1,ay−1)=agcd⁡(x,y)−1\\gcd(a^x-1,a^y-1)=a^{\\gcd(x,y)}-1gcd(ax−1,ay−1)=agcd(x,y)−1 证明： x≥ygcd⁡(ax−1,ay−1)=gcd⁡(ax−1−ax−y×(ay−1),ay−1)=gcd⁡(ax−y−1,ay−1)...=agcd⁡(x,y)−1x\\ge y\\\\\\begin{aligned}&amp;\\gcd(a^x-1,a^y-1)\\\\&amp;=\\gcd(a^x-1-a^{x-y}\\times(a^y-1),a^y-1)\\\\&amp;=\\gcd(a^{x-y}-1,a^y-1)\\\\&amp;...\\\\&amp;=a^{\\gcd(x,y)}-1\\end{aligned} x≥y​gcd(ax−1,ay−1)=gcd(ax−1−ax−y×(ay−1),ay−1)=gcd(ax−y−1,ay−1)...=agcd(x,y)−1​ 最大团的经典随机算法 随机一个加点顺序，按照这个顺序加点。若加进去后还是团则加进去，否则不加。这个东西实际上很难卡。 把 &lt;x&lt;x&lt;x 的看作 000，≥x\\ge x≥x 的看作 111 这个技巧通常搭配二分 xxx 来使用，或者直接考虑 010101 序列然后通过这个套路证明某些东西。 例题 1：Magic Breeding 题解 考虑每次询问二分答案 ansansans，对于每个初始数列 1≤i≤k1\\le i\\le k1≤i≤k，设 bi=[ai,y≥ans]b_i=[a_{i,y}\\ge ans]bi​=[ai,y​≥ans]，那么每次修改操作就相当于让 bcnt=bx&amp;byb_{cnt}=b_{x}\\&amp;b_ybcnt​=bx​&amp;by​ 或者 bx∣byb_x|b_ybx​∣by​，其中 &amp;\\&amp;&amp; 和 ∣|∣ 是按位与和按位或操作。最后若 bx=1b_{x}=1bx​=1 则 ansansans 合法，往上二分，否则往下二分。 观察到 kkk 很小，bib_ibi​ 只有两种取值，所以可以把 b[1,k]b_{[1,k]}b[1,k]​ 压缩成一个二进制数，用 bitset 存下 b[1,k]b_{[1,k]}b[1,k]​ 每种情况的 bxb_xbx​ 的取值，修改的时候简单按位操作，二分的时候直接查询即可。 时间复杂度 O(qmax⁡(2k64,klog⁡V))O(q\\max(\\frac{2^k}{64},k\\log V))O(qmax(642k​,klogV))。 例题 2：A Serious Referee 题解 显然，对于所有的 1≤i≤n1\\le i\\le n1≤i≤n，设 bi,j=[aj≥ai]b_{i,j}=[a_j\\ge a_i]bi,j​=[aj​≥ai​]。若每个 bib_ibi​ 都能被排序，那么显然 aaa 能被排序。因为每个 bib_ibi​ 都能被排序代表排序后不会有任何逆序对。 那么用搜索+剪枝即可。 出现次数大于一半，每次随机化可以缩小一半错误率 例题：CF364D Ghd 题解 至少一半的数的因数，这启发我们想到随机化。 具体的，每次随机一个 iii，那么 aia_iai​ 出现在是答案的倍数的集合中的概率是 12\\frac{1}{2}21​，枚举 aia_iai​ 的每一个因子作为答案判断是否可行，如可行则贡献给全局答案。 单次时间复杂度 O(106)O(10^6)O(106)，随机 101010 次可将错误率缩减到 11024\\frac{1}{1024}10241​，如果不是特别脸黑就可以通过本题。 练习：CF1305F Kuroni and the Punishment 曼哈顿距离和切比雪夫距离互转 曼哈顿距离：∣x1−x2∣+∣y1−y2∣|x1-x2|+|y1-y2|∣x1−x2∣+∣y1−y2∣ 切比雪夫距离：max⁡(∣x1−x2∣,∣y1−y2∣)\\max(|x1-x2|,|y1-y2|)max(∣x1−x2∣,∣y1−y2∣) 把所有点 (x,y)(x,y)(x,y) 变成 (x+y,x−y)(x+y,x-y)(x+y,x−y) 后两点之间的切比雪夫距离就等于原来的曼哈顿距离，把所有点 (x,y)(x,y)(x,y) 变成 (x+y2,x−y2)(\\frac{x+y}{2},\\frac{x-y}{2})(2x+y​,2x−y​) 后两点的曼哈顿距离就等于原来的切比雪夫距离。 bzoj3170 松鼠聚会 AT_code_festival_2017_quala_d P3439 P2906 P5098 P4648 P7561 网格空间连通块容斥 在二维网格图中数中间没有洞的四向连通块个数可以这样容斥： 可以通过做四次扫描线来解决。 八连通也是类似的： 并且这还可以拓展到高维空间，相当于是高维面积乘上 −1砍掉一面的维度的个数-1^{\\text{砍掉一面的维度的个数}}−1砍掉一面的维度的个数 的容斥系数然后加起来。 ∑d∣nO(d)=O(n34)\\sum\\limits_{d|n}O(\\sqrt d)=O(n^{\\frac{3}{4}})d∣n∑​O(d​)=O(n43​) 不会证，感性理解一下就是 ∑d=1nd+nd\\sum\\limits_{d=1}^{\\sqrt n}\\sqrt d+\\sqrt{\\frac{n}{d}}d=1∑n​​d​+dn​​ 是 O(n34)O(n^{\\frac{3}{4}})O(n43​) 级别的。 以后可以大胆写整除分块套整除分块。 Jerry Wen 定理 解的一些必要/充分条件的并，很有可能就是解的充要条件。 一些博弈论、图论、构造题可以尝试找必要/充分条件刻画解的充要条件。 按 rrr 分块 某些题目中 ∣i−j∣≤r|i-j|\\le r∣i−j∣≤r 的无序点对 (i,j)(i,j)(i,j) 才有贡献，此时可以按 rrr 分块（[1,r][1,r][1,r]、[r+1,2r][r+1,2r][r+1,2r] 等等为一块）。这样做的好处： 令 i&gt;ji&gt;ji&gt;j，考虑固定 iii 后有贡献的点对 (i,j)(i,j)(i,j) 的集合 SSS； 贡献可以分为块内贡献和块间（iii 所在块和上一块）贡献； 块内贡献：正着扫，SSS 中只会加入新元素； 块间贡献：倒着扫，SSS 中同样只会加入新元素； 注意要先处理块间贡献。 例题：【2023成都集训模拟赛04】op 同余最短路 当模 ppp 同余的所有状态等价，要求 did_idi​ 表示模 ppp 为 iii 的状态中最小的那个时，一般建出 ppp 个点代表状态等价类，把状态间的转移映射成这些点间的边，跑最短路求 did_idi​。 典型应用： 给一些数，求至少要拼几次才能拼出模 ppp 为 iii 的数； 给一些数，求这些数完全背包后能表示的数的个数； 给一些数，求这些数完全背包后不能表示的最小/最大数； 例题： ARC084D Small Multiple 【2023NOIP模拟赛09】补幺梨 贡献为函数时考虑拆开再算新增贡献 例题： 【2023NOI模拟赛36】A AGC065A Shuffle and mod K 各种组合意义 排列 考虑建立一个 n×nn\\times nn×n 的网格，只有 (i,pi)(i,p_i)(i,pi​) 有标记； CF1909F2 考虑连有向边 (i,pi)(i,p_i)(i,pi​)，形成若干个置换环； ","tags":[{"name":"小技巧","slug":"J5sSduNPX","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/J5sSduNPX/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"各种小技巧","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ge-chong-xiao-ji-qiao/","stats":{"text":"11 min read","time":640000,"words":2346,"minutes":11},"date":"2023-03-21 15:15:51","dateFormat":"2023-03-21"},{"abstract":"","content":" T1 好水，埃氏筛模板，切了/cy T2 smg 啊……打了个状压 dp 骗了 50 pts（后来发现数组开小了痛失 30 pts /ll） T3 乱搞了一个卡时 dfs /ll T4 瞎弄了一个 bfs，好在除了最后一个大样例其它都过了 期望得分：100+50+[0,12]+[0,32]=[150,194] luogu：100+20+12+28=160 小秃驴：100+40+16+32=188 真实成绩：100+20+12+24=156 2021-12-3 1= 分数线 155，压线 1= /fad ","tags":[{"name":"NOIP","slug":"rs_nI3vFV","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/rs_nI3vFV/"},{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"},{"name":2021,"slug":"W1pmcP3ls8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/W1pmcP3ls8/"}],"title":"NOIP 2021 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/noip-2021-you-ji/","stats":{"text":"1 min read","time":31000,"words":118,"minutes":1},"date":"2023-03-21 15:14:35","dateFormat":"2023-03-21"},{"abstract":"","content":"AC 自动机是一种字符串匹配算法，而不是自动让你 AC 的作弊工具……（说实话我也不知道为什么它叫 AC 自动机） 它主要是解决这一类问题：给定 nnn 个模式串 tit_iti​ 和一个文本串 sss，让 sss 和这 nnn 个 ttt 做匹配。 例如这道模板题，就是要求文本串里有多少个模式串出现了。 考虑对于这种有多个模式串的匹配问题。我们可以先对于所有模式串建一棵 trie 树，然后在 trie 上跑匹配。 注意到在任意时刻，如果我们匹配到了节点 uuu，那么我们可以跳到所有表示的字符串是 uuu 所表示的字符串的后缀的节点 vvv。 而为了不重不漏，我们肯定要跳到表示字符串长度最长的那一个点，因为从那个点继续跳就可以访问完所有表示的字符串是 uuu 所表示的字符串的节点了。 可以用一个数组来存这个东西，令 failufail_ufailu​ 存表示的字符串是 uuu 的一个后缀且最长的节点 vvv。 先考虑 failfailfail 数组的求解，由于 failufail_ufailu​ 的深度肯定小于 uuu 的深度，所以我们可以使用 bfs 来求解。很明显，fail1=1fail_1=1fail1​=1，对于所有节点 111 的儿子 vvv，failv=1fail_v=1failv​=1。对于一个节点 uuu 的儿子 vvv，设 (u,v)(u,v)(u,v) 的边权为 iii，那么 failv=sonfailu,ifail_v=son_{fail_u,i}failv​=sonfailu​,i​。 在求解 failfailfail 数组时，我们要顺便把 uuu 的所有边权为 iii 且不存在的儿子 vvv 赋值为 sonfailu,ison_{fail_u,i}sonfailu​,i​。这是为了令匹配的时候如果没有儿子可以不用暴力跳 failfailfail，可以 O(1)O(1)O(1) 重新开始匹配。 求 failfailfail 数组的代码如下： inline void init() // 求解 fail 数组 { queue&lt;int&gt; q; // bfs 用的队列 fail[1]=1; // fail[1] = 1 for(int i=0;i&lt;26;i++) { int v=son[1][i]; if(v!=0) // 有这个儿子，fail 设置为 1 + 入队 { fail[v]=1; q.push(v); } else // 没有这个儿子，造一个！ { son[1][i]=1; } } while(!q.empty()) { int u=q.front(); q.pop(); int fiu=fail[u]; // 父亲的 fail for(int i=0;i&lt;26;i++) { int v=son[u][i]; if(v!=0) // 有这个儿子，设置 fail + 入队 { fail[v]=son[fiu][i]; q.push(v); } else // 没有这个儿子，造一个！ { son[u][i]=son[fiu][i]; } } } } 有了 failfailfail 数组，匹配也很简单了： inline int slove() // 匹配 { int u=1,res=0; int len=strlen(str+1); // str 是一个全局变量，调用 slove() 时存的是文本串 for(int i=1;i&lt;=len;i++) { int id=str[i]-'a'; u=son[u][id]; // 在 trie 树（trie 图？）上继续走一步 int tmp=u; // 计算当前能匹配到的所有字符串对答案的贡献 while(tmp!=1&amp;&amp;sum[tmp]!=-1) // 跳到根节点或者跳到过就不用跳 { res+=sum[tmp]; // 计算贡献 sum[tmp]=-1; // 标记跳到过了 tmp=fail[tmp]; // 继续跳 fail } } return res; } 这道题就做完啦，给出完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; int n; char str[1000005]; int cnt,son[1000005][26]; int fail[1000005],sum[1000005]; inline void ins() { int u=1; int len=strlen(str+1); for(int i=1;i&lt;=len;i++) { int id=str[i]-'a'; if(son[u][id]==0) { son[u][id]=++cnt; } u=son[u][id]; } sum[u]++; } inline void init() // 求解 fail 数组 { queue&lt;int&gt; q; // bfs 用的队列 fail[1]=1; // fail[1] = 1 for(int i=0;i&lt;26;i++) { int v=son[1][i]; if(v!=0) // 有这个儿子，fail 设置为 1 + 入队 { fail[v]=1; q.push(v); } else // 没有这个儿子，造一个！ { son[1][i]=1; } } while(!q.empty()) { int u=q.front(); q.pop(); int fiu=fail[u]; // 父亲的 fail for(int i=0;i&lt;26;i++) { int v=son[u][i]; if(v!=0) // 有这个儿子，设置 fail + 入队 { fail[v]=son[fiu][i]; q.push(v); } else // 没有这个儿子，造一个！ { son[u][i]=son[fiu][i]; } } } } inline int slove() // 匹配 { int u=1,res=0; int len=strlen(str+1); // str 是一个全局变量，调用 slove() 时存的是文本串 for(int i=1;i&lt;=len;i++) { int id=str[i]-'a'; u=son[u][id]; // 在 trie 树（trie 图？）上继续走一步 int tmp=u; // 计算当前能匹配到的所有字符串对答案的贡献 while(tmp!=1&amp;&amp;sum[tmp]!=-1) // 跳到根节点或者跳到过就不用跳 { res+=sum[tmp]; // 计算贡献 sum[tmp]=-1; // 标记跳到过了 tmp=fail[tmp]; // 继续跳 fail } } return res; } int main() { scanf(&quot;%d&quot;,&amp;n); cnt=1; for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,str+1); ins(); } init(); scanf(&quot;%s&quot;,str+1); printf(&quot;%d\\n&quot;,slove()); return 0; } 练习题目： P3796 【模板】AC自动机（加强版） P5357 【模板】AC自动机（二次加强版） P5231 [JSOI2012]玄武密码 P3966 [TJOI2013]单词 P2322 [HNOI2006]最短母串问题 P3121 [USACO15FEB]Censoring G P2444 [POI2000]病毒 ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"AC 自动机学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ac-zi-dong-ji-xue-xi-bi-ji/","stats":{"text":"6 min read","time":327000,"words":1204,"minutes":6},"date":"2023-03-21 15:10:07","dateFormat":"2023-03-21"},{"abstract":"","content":"这篇学习笔记写的没有这篇题解好/kk 扫描线是一种线段树的巧妙运用，通常用来解决一些图形的面积/周长问题。 先从最经典的问题入手： 求 n 个矩形的面积并。 —— P5490 【模板】扫描线 首先画个图，最烦人的肯定是下面这种情况： 两个矩形有相交的部分，最朴素的想法当然是减掉它。但是我们求的是 nnn 个矩形的面积并，所以不可行。 我们可以转换一下思维，把图中所有与 YYY 轴平行的线段都标红、延长（称其为扫描线），可以得到这样的一个图： 很容易发现，这四条扫描线把矩形割开了，而相邻的两条线之间的部分一定是规则的矩形。 于是我们可以考虑使用某种数据结构维护两条扫描线之间的矩形投影到 XXX 轴之后的总长度。很显然这东西能用线段树维护，让线段树的 sumusum_usumu​ 存储节点 uuu 所代表的区间中被矩形覆盖的长度，alluall_uallu​ 储存节点 uuu 所代表的区间共被多少个矩形完全覆盖，sum1sum_1sum1​ 就是总长度了。 但还有一个问题，那就是坐标有可能非常大，所以我们需要对 xxx 坐标进行离散化，然后让节点 uuu 维护 [poslu,posru+1][pos_{l_u},pos_{r_u+1}][poslu​​,posru​+1​] 的信息。 模板题代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; struct node { long long y,lx,rx; bool in; }a[2000005]; int n; int tot; long long pos[2000005]; int all[8000005]; long long sum[8000005]; inline bool cmp(node x,node y) { return x.y&lt;y.y; } inline void upd(int u,int l,int r) { if(all[u]!=0) { sum[u]=pos[r+1]-pos[l]; } else { sum[u]=sum[u&lt;&lt;1]+sum[u&lt;&lt;1|1]; } } void add(int u,int l,int r,long long L,long long R,int val) { if(pos[l]&gt;=L&amp;&amp;pos[r+1]&lt;=R) { all[u]+=val; upd(u,l,r); return; } int mid=l+r&gt;&gt;1; if(L&lt;pos[mid+1]) { add(u&lt;&lt;1,l,mid,L,R,val); } if(R&gt;pos[mid+1]) { add(u&lt;&lt;1|1,mid+1,r,L,R,val); } upd(u,l,r); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { long long x1,y1,x2,y2; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); long long lx=min(x1,x2),rx=max(x1,x2),ly=min(y1,y2),ry=max(y1,y2); pos[++tot]=lx; a[tot]=(node){ry,lx,rx,true}; pos[++tot]=rx; a[tot]=(node){ly,lx,rx,false}; } sort(a+1,a+n*2+1,cmp); sort(pos+1,pos+tot+1); tot=unique(pos+1,pos+tot+1)-(pos+1); long long ans=0; for(int i=1;i&lt;n*2;i++) { add(1,1,tot-1,a[i].lx,a[i].rx,a[i].in?1:-1); ans+=sum[1]*(a[i+1].y-a[i].y); } printf(&quot;%lld\\n&quot;,ans); return 0; } 不过给P1856 [IOI1998] [USACO5.5] 矩形周长Picture的更简单的解法。其实可以先按 xxx 轴扫描一下这些矩形，再按 yyy 轴扫描一下这些矩形，最后将扫描得到的周长相加就可以了，完全不用题解区里那么难。 完整代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; struct nodey { long long y,lx,rx; bool inl; }liny[200005]; struct nodex { long long x,ly,ry; bool inl; }linx[200005]; int n; int tot[2]; long long pos[2][200005]; long long sum[2][800005]; int all[2][800005]; inline long long ckjabs(long long x) { return x&lt;0?-x:x; } inline bool cmpy(nodey x,nodey y) { return x.y&lt;y.y; } inline bool cmpx(nodex x,nodex y) { return x.x&lt;y.x; } inline void upd(int id,int u,int l,int r) { if(all[id][u]!=0) { sum[id][u]=pos[id][r+1]-pos[id][l]; } else { sum[id][u]=sum[id][u&lt;&lt;1]+sum[id][u&lt;&lt;1|1]; } } void add(int id,int u,int l,int r,long long L,long long R,int val) { if(pos[id][l]&gt;=L&amp;&amp;pos[id][r+1]&lt;=R) { all[id][u]+=val; upd(id,u,l,r); return; } int mid=l+r&gt;&gt;1; if(L&lt;pos[id][mid+1]) { add(id,u&lt;&lt;1,l,mid,L,R,val); } if(R&gt;pos[id][mid+1]) { add(id,u&lt;&lt;1|1,mid+1,r,L,R,val); } upd(id,u,l,r); } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { long long x1,y1,x2,y2; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); long long lx=min(x1,x2),rx=max(x1,x2); long long ly=min(y1,y2),ry=max(y1,y2); pos[0][++tot[0]]=lx; pos[0][++tot[0]]=rx; pos[1][++tot[1]]=ly; pos[1][++tot[1]]=ry; liny[i]=(nodey){ly,lx,rx,true}; liny[n+i]=(nodey){ry,lx,rx,false}; linx[i]=(nodex){lx,ly,ry,true}; linx[n+i]=(nodex){rx,ly,ry,false}; } sort(liny+1,liny+n*2+1,cmpy); sort(linx+1,linx+n*2+1,cmpx); sort(pos[0]+1,pos[0]+tot[0]+1); sort(pos[1]+1,pos[1]+tot[1]+1); tot[0]=unique(pos[0]+1,pos[0]+tot[0]+1)-(pos[0]+1); tot[1]=unique(pos[1]+1,pos[1]+tot[1]+1)-(pos[1]+1); long long ans=0; long long lst=0; for(int i=1;i&lt;n*2;i++) { add(0,1,1,tot[0]-1,liny[i].lx,liny[i].rx,liny[i].inl?1:-1); ans+=ckjabs(sum[0][1]-lst); lst=sum[0][1]; } ans+=lst; lst=0; for(int i=1;i&lt;n*2;i++) { add(1,1,1,tot[1]-1,linx[i].ly,linx[i].ry,linx[i].inl?1:-1); ans+=ckjabs(sum[1][1]-lst); lst=sum[1][1]; } ans+=lst; printf(&quot;%lld\\n&quot;,ans); return 0; } ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"扫描线学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/sao-miao-xian-xue-xi-bi-ji/","stats":{"text":"7 min read","time":400000,"words":1268,"minutes":7},"date":"2023-03-21 14:40:15","dateFormat":"2023-03-21"},{"abstract":"","content":"顾名思义，fhq-Treap 就是由 fhq 大佬改进的一种 Treap。它的核心思想是不使用旋转操作，而是使用分裂和合并操作来同时维护二叉搜索树的特性和二叉堆的特性。 首先是分裂操作，顾名思义，就是把一棵 fhq-Treap 分裂成两颗 fhq-Treap。分裂有两种方式，一种是按照权值分裂，还有一种是按照大小分裂。而前者更常用，后者则通常是用来维护区间的。 按照权值分裂的代码如下： void split(int u,int val,int &amp;x,int &amp;y) // 按权值分裂以 u 为根的树（x 子树上的所有权值都 &lt; val，y 子树上的所有权值都 &gt;= val） { if(u==0) // 如果没得分裂了 { x=y=0; // 赋值为 0 return; } if(tree[u].val&lt;val) // 如果 u 的权值比 val 小，那么 u 属于 x 的子树 { x=u; // 赋值 split(tree[u].r,val,tree[u].r,y); // 递归分裂当前 u 的右儿子（u 的左儿子都比 val 小，都属于 x 的子树） } else // 否则 u 属于 y 的子树 { y=u; // 赋值 split(tree[u].l,val,x,tree[u].l); // 递归分裂当前 u 的左儿子（u 的右儿子都 &gt;= val，都属于 y 的子树） } upd(u); // 不要忘记更新节点信息 } 按大小分裂的代码如下： void split(int u,int val,int &amp;x,int &amp;y) { if(u==0) { x=y=0; return; } if(tree[tree[u].lson].sum&lt;val) { x=u; split(tree[u].rson,val-tree[tree[u].lson].sum-1,tree[u].rson,y); } else { y=u; split(tree[u].lson,val,x,tree[u].lson); } upd(u); } 然后是合并操作，即把两棵树合并成一棵树。合并的时候注意要同时满足二叉搜索树的特性和二叉堆的的特性。 int merge(int x,int y) // 合并 x 的子树和 y 的子树，返回合并之后的根（x 的子树的权值必须保证都小于 y 的子树的权值） { if(x==0||y==0) return x+y; // 有一棵子树为空，那么返回另一棵子树的根 if(tree[x].w&gt;tree[y].w) // 我们要保证 w 满足大根堆的特性，所以如果 x 的 w 大于 y 的 w，那么就要把 y 接到 x 下面， // 又因为 x 的子树的权值都小于 y 的子树的权值，所以 y 要接到 x 的右儿子，即让 x 的右儿子和 y 合并 { tree[x].r=merge(tree[x].r,y); upd(x); // 记得更新节点信息 return x; } else // 同理 { tree[y].l=merge(x,tree[y].l); upd(y); // 记得更新节点信息 return y; } } 解决了这两个最核心也最难的操作后，剩下的操作就简单了。 插入操作就相当于把整棵树扒开，然后再把要插入的节点放进去，最后再缝合起来。这种十分暴力的行为很好写，而且还不容易出错，代码如下： inline void ins(int val) // 插入 { int x,y; split(rt,val,x,y); // 扒开整棵树 int u=++cnt; // 新建一个节点 tree[u].val=val; tree[u].sum=1; tree[u].w=rand(); rt=merge(x,merge(u,y)); // 放进去，缝合起来 } 删除操作则相当于扒开整棵树，找到要删除的子树的根，合并它的左右儿子，再把整棵树缝合起来。同样很暴力，代码如下： inline void del(int val) // 删除 { int x,y,z; split(rt,val,x,y); // 先把整棵树分为权值都小于 val 的子树 x 和权值都大于等于 val 的子树 y split(y,val+1,y,z); // 再把 y 的子树里权值大于 val 的子树分割出来，此时 y 子树内的权值都等于 val if(y!=0) y=merge(tree[y].l,tree[y].r); // 如果存在权值为 val 的节点，即 y!=0，则合并 y 的左右儿子 rt=merge(x,merge(y,z)); // 缝合整棵树 } 查询 val 的排名则相当于把扒开整棵树，然后记录下权值小于 val 的子树的大小 + 1，再缝合整棵树，最后返回之前记录下的答案。代码如下： inline int getrk(int val) // 求 val 的排名 { int x,y; split(rt,val,x,y); // 扒开整棵树 int res=tree[x].sum+1; // 记录下权值都小于 val 的子树的大小 + 1（答案） rt=merge(x,y); // 缝合整棵树 return res; // 返回答案 } 查询排名为 val 的数是唯一一个没有那么暴力的操作，它是直接在 fhq-Treap 那布满伤痕的身体上进行遍历来求答案的： inline int getbyrk(int val) // 获取排名为 val 的数 { int u=rt; // 从根开始遍历 while(1) { if(tree[tree[u].l].sum+1==val) break; // 如果左子树大小 + 1 == val，那么答案就是当前节点的值 else if(tree[tree[u].l].sum+1&gt;val) u=tree[u].l; // 如果左子树大小 + 1 &gt; val，那么答案在当前节点的左子树 else // 否则答案在当前右子树 { val-=tree[tree[u].l].sum+1; // 记得把 val 减去左子树大小 + 1 u=tree[u].r; } } return tree[u].val; // 返回答案 } 求前驱后继也相当于把整棵树扒开，然后再处理，最后缝合上： inline int getfrt(int val) // 求前驱 { int x,y; split(rt,val,x,y); // 把整棵树扒开，前驱肯定在 x 的子树内 int u=x; while(1) // 由于前驱是 x 子树内最大的那个值，所以要一直往右儿子去 { if(tree[u].r!=0) u=tree[u].r; else break; } rt=merge(x,y); // 缝合好 return tree[u].val; // 返回答案 } inline int getnxt(int val) // 求后继 { int x,y; split(rt,val+1,x,y); // 把整棵树扒开，后继肯定在 y 的子树内 int u=y; while(1) // 由于后继是 y 子树内最小的那个值，所以要一直往左儿子去 { if(tree[u].l!=0) u=tree[u].l; else break; } rt=merge(x,y); // 缝合好 return tree[u].val; // 返回答案 } 最终模板题代码如下： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using namespace std; struct node { int val,w; int sum; int l,r; }tree[100005]; int q; int cnt,rt; inline void upd(int u) { tree[u].sum=tree[tree[u].l].sum+tree[tree[u].r].sum+1; } void split(int u,int val,int &amp;x,int &amp;y) // 按权值分裂以 u 为根的树（x 子树上的所有权值都 &lt; val，y 子树上的所有权值都 &gt;= val） { if(u==0) // 如果没得分裂了 { x=y=0; // 赋值为 0 return; } if(tree[u].val&lt;val) // 如果 u 的权值比 val 小，那么 u 属于 x 的子树 { x=u; // 赋值 split(tree[u].r,val,tree[u].r,y); // 递归分裂当前 u 的右儿子（u 的左儿子都比 val 小，都属于 x 的子树） } else // 否则 u 属于 y 的子树 { y=u; // 赋值 split(tree[u].l,val,x,tree[u].l); // 递归分裂当前 u 的左儿子（u 的右儿子都 &gt;= val，都属于 y 的子树） } upd(u); // 不要忘记更新节点信息 } int merge(int x,int y) // 合并 x 的子树和 y 的子树，返回合并之后的根（x 的子树的权值必须保证都小于 y 的子树的权值） { if(x==0||y==0) return x+y; // 有一棵子树为空，那么返回另一棵子树的根 if(tree[x].w&gt;tree[y].w) // 我们要保证 w 满足大根堆的特性，所以如果 x 的 w 大于 y 的 w，那么就要把 y 接到 x 下面， // 又因为 x 的子树的权值都小于 y 的子树的权值，所以 y 要接到 x 的右儿子，即让 x 的右儿子和 y 合并 { tree[x].r=merge(tree[x].r,y); upd(x); // 记得更新节点信息 return x; } else // 同理 { tree[y].l=merge(x,tree[y].l); upd(y); // 记得更新节点信息 return y; } } inline void ins(int val) // 插入 { int x,y; split(rt,val,x,y); // 扒开整棵树 int u=++cnt; // 新建一个节点 tree[u].val=val; tree[u].sum=1; tree[u].w=rand(); rt=merge(x,merge(u,y)); // 放进去，缝合起来 } inline void del(int val) // 删除 { int x,y,z; split(rt,val,x,y); // 先把整棵树分为权值都小于 val 的子树 x 和权值都大于等于 val 的子树 y split(y,val+1,y,z); // 再把 y 的子树里权值大于 val 的子树分割出来，此时 y 子树内的权值都等于 val if(y!=0) y=merge(tree[y].l,tree[y].r); // 如果存在权值为 val 的节点，即 y!=0，则合并 y 的左右儿子 rt=merge(x,merge(y,z)); // 缝合整棵树 } inline int getrk(int val) // 求 val 的排名 { int x,y; split(rt,val,x,y); // 扒开整棵树 int res=tree[x].sum+1; // 记录下权值都小于 val 的子树的大小 + 1（答案） rt=merge(x,y); // 缝合整棵树 return res; // 返回答案 } inline int getbyrk(int val) // 获取排名为 val 的数 { int u=rt; // 从根开始遍历 while(1) { if(tree[tree[u].l].sum+1==val) break; // 如果左子树大小 + 1 == val，那么答案就是当前节点的值 else if(tree[tree[u].l].sum+1&gt;val) u=tree[u].l; // 如果左子树大小 + 1 &gt; val，那么答案在当前节点的左子树 else // 否则答案在当前右子树 { val-=tree[tree[u].l].sum+1; // 记得把 val 减去左子树大小 + 1 u=tree[u].r; } } return tree[u].val; // 返回答案 } inline int getfrt(int val) // 求前驱 { int x,y; split(rt,val,x,y); // 把整棵树扒开，前驱肯定在 x 的子树内 int u=x; while(1) // 由于前驱是 x 子树内最大的那个值，所以要一直往右儿子去 { if(tree[u].r!=0) u=tree[u].r; else break; } rt=merge(x,y); // 缝合好 return tree[u].val; // 返回答案 } inline int getnxt(int val) // 求后继 { int x,y; split(rt,val+1,x,y); // 把整棵树扒开，后继肯定在 y 的子树内 int u=y; while(1) // 由于后继是 y 子树内最小的那个值，所以要一直往左儿子去 { if(tree[u].l!=0) u=tree[u].l; else break; } rt=merge(x,y); // 缝合好 return tree[u].val; // 返回答案 } int main() { srand(time(NULL)); scanf(&quot;%d&quot;,&amp;q); while(q--) { int opt,x; scanf(&quot;%d%d&quot;,&amp;opt,&amp;x); if(opt==1) ins(x); if(opt==2) del(x); if(opt==3) printf(&quot;%d\\n&quot;,getrk(x)); if(opt==4) printf(&quot;%d\\n&quot;,getbyrk(x)); if(opt==5) printf(&quot;%d\\n&quot;,getfrt(x)); if(opt==6) printf(&quot;%d\\n&quot;,getnxt(x)); } return 0; } ","tags":[{"name":"平衡树","slug":"MusX6NdWf","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/MusX6NdWf/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"fhq-Treap 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/fhq-treap-xue-xi-bi-ji/","stats":{"text":"12 min read","time":680000,"words":2553,"minutes":12},"date":"2023-03-21 13:57:59","dateFormat":"2023-03-21"},{"abstract":"","content":"Treap 是平衡树的一种，也是一棵笛卡尔树。它是一种随机数据结构，相当于 wiw_iwi​ 是随机数的笛卡尔树。 模板题 首先对于一个节点，我们不仅需要保存二叉搜索树的几个值，还要保存 wiw_iwi​。节点结构体定义如下： struct node { int val,w; // 数值，权值 w int cnt,sum; // 数值个数，子树大小 int l,r; // 左右儿子 }tree[100005]; 朴素的笛卡尔树并没有插入和删除的操作，而作为平衡树，Treap 必须支持这两种操作。但是插入和删除的过程中还要维护堆的特性，需要进行旋转操作，即二叉堆中的把某个儿子提上来。 由于旋转时还需要维护二叉搜索树的特性，所以旋转稍微有点复杂： 这样旋转不但可以做到把某个儿子提上来，还可以维护二叉搜索树的特性。 左旋右旋代码如下： inline void upd(int u) { tree[u].sum=tree[tree[u].l].sum+tree[tree[u].r].sum+tree[u].cnt; } inline void lrot(int &amp;u) // 左旋 { int t=tree[u].r; // 先存下 Y 的编号 tree[u].r=tree[t].l; // 右儿子变成 B tree[t].l=u; // Y 的左儿子变成 X tree[t].sum=tree[u].sum; // Y 变成了之前 X 的子树的根 upd(u); // 更新 X 的子树大小 u=t; // 完成旋转 } inline void rrot(int &amp;u) // 右旋，和左旋原理一样 { int t=tree[u].l; tree[u].l=tree[t].r; tree[t].r=u; tree[t].sum=tree[u].sum; upd(u); u=t; } 有了左旋右旋，插入和删除就不难实现了。 插入： void ins(int &amp;u,int val) // 插入 { if(u==0) // 如果递归到了空节点，那么在这里插入 { u=++cnt; tree[u].val=val; tree[u].cnt=1; tree[u].sum=1; tree[u].w=rand(); // 随机化权值 w return; } tree[u].sum++; // 子树大小 ++ if(val==tree[u].val) tree[u].cnt++; // 如果找到了值为 val 的节点，那么该节点的数值个数 ++ else if(val&lt;tree[u].val) { ins(tree[u].l,val); // 往左子树插入 if(tree[tree[u].l].w&lt;tree[u].w) rrot(u); // 维护二叉堆的性质 } else { ins(tree[u].r,val); // 往右子树插入 if(tree[tree[u].r].w&lt;tree[u].w) lrot(u); // 维护二叉堆的性质 } } 删除：（返回值为成不成功，即有没有找到值为 val 的节点） bool del(int &amp;u,int val) // 删除 { if(u==0) return false; // 递归到了空节点，删除失败 if(val==tree[u].val) // 找到了 { if(tree[u].cnt&gt;1) // 删除之后节点还存在 { tree[u].sum--; tree[u].cnt--; return true; // 删除成功 } else { if(tree[u].l==0||tree[u].r==0) // 只有一个儿子或者没有儿子，那么直接用儿子替换当前节点 { u=tree[u].l+tree[u].r; return true; // 删除成功 } else // 有两个儿子，那么我们可以把当前节点通过左旋右旋往下移动，直到可以直接删除 { if(tree[tree[u].l].w&lt;tree[tree[u].r].w) // 需要提左儿子上来 { rrot(u); // 右旋 return del(u,val); // 递归，注意递归的节点必须是 u } else // 需要提右儿子上来 { lrot(u); return del(u,val); // 递归，注意递归的节点必须是 u } } } } else if(val&lt;tree[u].val) { bool f=del(tree[u].l,val); // 往左子树递归 if(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- return f; } else { bool f=del(tree[u].r,val); // 往右子树递归 if(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- return f; } } 解决了插入删除两个比较困难的操作后，剩下的操作就非常好实现了。 求排名： int getrk(int u,int val) { if(u==0) return 1; if(tree[u].val==val) return tree[tree[u].l].sum+1; else if(val&lt;tree[u].val) return getrk(tree[u].l,val); else return tree[tree[u].l].sum+tree[u].cnt+getrk(tree[u].r,val); } 求排名为 val 的数： int getbyrk(int u,int val) { if(u==0) return 0; if(val&lt;=tree[tree[u].l].sum) return getbyrk(tree[u].l,val); else if(val&lt;=tree[tree[u].l].sum+tree[u].cnt) return tree[u].val; else return getbyrk(tree[u].r,val-tree[tree[u].l].sum-tree[u].cnt); } 求前驱后继： int getfrt(int u,int val) { if(u==0) return -inf; if(val&lt;=tree[u].val) return getfrt(tree[u].l,val); else return max(tree[u].val,getfrt(tree[u].r,val)); } int getnxt(int u,int val) { if(u==0) return inf; if(val&gt;=tree[u].val) return getnxt(tree[u].r,val); else return min(tree[u].val,getnxt(tree[u].l,val)); } 完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using namespace std; #define inf (((long long)1&lt;&lt;31)-1) struct node { int val,w; // 数值，权值 w int cnt,sum; // 数值个数，子树大小 int l,r; // 左右儿子 }tree[100005]; int q,cnt,rt; inline void upd(int u) { tree[u].sum=tree[tree[u].l].sum+tree[tree[u].r].sum+tree[u].cnt; } inline void lrot(int &amp;u) // 左旋 { int t=tree[u].r; // 先存下 Y 的编号 tree[u].r=tree[t].l; // 右儿子变成 B tree[t].l=u; // Y 的左儿子变成 X tree[t].sum=tree[u].sum; // Y 变成了之前 X 的子树的根 upd(u); // 更新 X 的子树大小 u=t; // 完成旋转 } inline void rrot(int &amp;u) // 右旋，和左旋原理一样 { int t=tree[u].l; tree[u].l=tree[t].r; tree[t].r=u; tree[t].sum=tree[u].sum; upd(u); u=t; } void ins(int &amp;u,int val) // 插入 { if(u==0) // 如果递归到了空节点，那么在这里插入 { u=++cnt; tree[u].val=val; tree[u].cnt=1; tree[u].sum=1; tree[u].w=rand(); // 随机化权值 w return; } tree[u].sum++; // 子树大小 ++ if(val==tree[u].val) tree[u].cnt++; // 如果找到了值为 val 的节点，那么该节点的数值个数 ++ else if(val&lt;tree[u].val) { ins(tree[u].l,val); // 往左子树插入 if(tree[tree[u].l].w&lt;tree[u].w) rrot(u); // 维护二叉堆的性质 } else { ins(tree[u].r,val); // 往右子树插入 if(tree[tree[u].r].w&lt;tree[u].w) lrot(u); // 维护二叉堆的性质 } } bool del(int &amp;u,int val) // 删除 { if(u==0) return false; // 递归到了空节点，删除失败 if(val==tree[u].val) // 找到了 { if(tree[u].cnt&gt;1) // 删除之后节点还存在 { tree[u].sum--; tree[u].cnt--; return true; // 删除成功 } else { if(tree[u].l==0||tree[u].r==0) // 只有一个儿子或者没有儿子，那么直接用儿子替换当前节点 { u=tree[u].l+tree[u].r; return true; // 删除成功 } else // 有两个儿子，那么我们可以把当前节点通过左旋右旋往下移动，直到可以直接删除 { if(tree[tree[u].l].w&lt;tree[tree[u].r].w) // 需要提左儿子上来 { rrot(u); // 右旋 return del(u,val); // 递归，注意递归的节点必须是 u } else // 需要提右儿子上来 { lrot(u); return del(u,val); // 递归，注意递归的节点必须是 u } } } } else if(val&lt;tree[u].val) { bool f=del(tree[u].l,val); // 往左子树递归 if(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- return f; } else { bool f=del(tree[u].r,val); // 往右子树递归 if(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- return f; } } int getrk(int u,int val) { if(u==0) return 1; if(tree[u].val==val) return tree[tree[u].l].sum+1; else if(val&lt;tree[u].val) return getrk(tree[u].l,val); else return tree[tree[u].l].sum+tree[u].cnt+getrk(tree[u].r,val); } int getbyrk(int u,int val) { if(u==0) return 0; if(val&lt;=tree[tree[u].l].sum) return getbyrk(tree[u].l,val); else if(val&lt;=tree[tree[u].l].sum+tree[u].cnt) return tree[u].val; else return getbyrk(tree[u].r,val-tree[tree[u].l].sum-tree[u].cnt); } int getfrt(int u,int val) { if(u==0) return -inf; if(val&lt;=tree[u].val) return getfrt(tree[u].l,val); else return max(tree[u].val,getfrt(tree[u].r,val)); } int getnxt(int u,int val) { if(u==0) return inf; if(val&gt;=tree[u].val) return getnxt(tree[u].r,val); else return min(tree[u].val,getnxt(tree[u].l,val)); } int main() { srand(time(NULL)); scanf(&quot;%d&quot;,&amp;q); while(q--) { int opt,x; scanf(&quot;%d%d&quot;,&amp;opt,&amp;x); if(opt==1) ins(rt,x); if(opt==2) del(rt,x); if(opt==3) printf(&quot;%d\\n&quot;,getrk(rt,x)); if(opt==4) printf(&quot;%d\\n&quot;,getbyrk(rt,x)); if(opt==5) printf(&quot;%d\\n&quot;,getfrt(rt,x)); if(opt==6) printf(&quot;%d\\n&quot;,getnxt(rt,x)); } return 0; } ","tags":[{"name":"平衡树","slug":"MusX6NdWf","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/MusX6NdWf/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Treap 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/treap-xue-xi-bi-ji/","stats":{"text":"10 min read","time":588000,"words":2001,"minutes":10},"date":"2023-03-21 13:55:57","dateFormat":"2023-03-21"},{"abstract":"","content":"笛卡尔树是一种特殊的二叉树，它的每个节点有两个权值 kik_iki​ 和 wiw_iwi​。对于权值 kik_iki​，满足二叉搜索树的特性，即父节点的 kik_iki​ 严格大于它左儿子的 kik_iki​，它右儿子的 kik_iki​ 又严格大于它的 kik_iki​。而对于权值 wiw_iwi​，满足小根堆的特性，即父节点的 wiw_iwi​ 小于等于它儿子的 wiw_iwi​。 例如下图就是一棵 wiw_iwi​ 为圆圈里的数的笛卡尔树。 考虑笛卡尔树的构建。首先对 kik_iki​ 排过序，那么新加进来的节点肯定在右链上（右链即从根节点一直往右儿子去所形成的链）。此时可以使用单调栈来维护右链，进行 O(n)O(n)O(n) 的建树。 建树过程类似下图（圆圈里的数为 wiw_iwi​）： 建树代码： sta[++top]=1; for(int i=2;i&lt;=n;i++) { while(w[sta[top]]&gt;w[i]&amp;&amp;top&gt;0) { top--; } if(top==0) { son[i][0]=sta[top+1]; } else { son[i][0]=son[sta[top]][1]; son[sta[top]][1]=i; } sta[++top]=i; } 练习题目： P5854 【模板】笛卡尔树 P1377 [TJOI2011]树的序 SP3734 PERIODNI - Periodni P6453 [COCI2008-2009#4] F P7988 [USACO21DEC] HILO G ","tags":[{"name":"平衡树","slug":"MusX6NdWf","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/MusX6NdWf/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"笛卡尔树学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/di-qia-er-shu-xue-xi-bi-ji/","stats":{"text":"2 min read","time":72000,"words":292,"minutes":2},"date":"2023-03-21 10:03:53","dateFormat":"2023-03-21"},{"abstract":"","content":"欧拉函数，一般写作 φ\\varphiφ 或者 ϕ\\phiϕ。φ(x)\\varphi(x)φ(x) 表示的是 [1,x][1,x][1,x] 区间内有多少个数与 xxx 互质（最大公因数为 1）。 性质 1：当 ppp 为质数时 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1。 性质 2：设 pip_ipi​ 表示 xxx 的第 iii 个质因子，nnn 表示 xxx 的质因子个数，则 φ(x)=x∏i=1npi−1pi\\varphi(x)=x\\prod\\limits_{i=1}^n\\frac{p_i-1}{p_i}φ(x)=xi=1∏n​pi​pi​−1​。 只有不是 xxx 的质因子的倍数的数才和 xxx 互质； 第一个质因子的倍数共有 x×1pix\\times \\frac{1}{p_i}x×pi​1​ 个，那么和第一个质因子互质的数就有 x×pi−1pix\\times \\frac{p_i-1}{p_i}x×pi​pi​−1​ 个； 这 x×pi−1pix\\times \\frac{p_i-1}{p_i}x×pi​pi​−1​ 个数里，和第二个质因子互质的个数又有 x×pi−1pix\\times \\frac{p_i-1}{p_i}x×pi​pi​−1​ 个； 一直乘下去，便得到 φ(x)=x∏i=1npi−1pi\\varphi(x)=x\\prod\\limits_{i=1}^n\\frac{p_i-1}{p_i}φ(x)=xi=1∏n​pi​pi​−1​。 性质 3：φ(xy)=φ(x)φ(y)×gcd⁡(x,y)φ(gcd⁡(x,y))\\varphi(xy)=\\varphi(x)\\varphi(y)\\times\\frac{\\gcd(x,y)}{\\varphi(\\gcd(x,y))}φ(xy)=φ(x)φ(y)×φ(gcd(x,y))gcd(x,y)​ 考虑 φ(x)=x∏i=1npi−1pi\\varphi(x)=x\\prod\\limits_{i=1}^n\\frac{p_i-1}{p_i}φ(x)=xi=1∏n​pi​pi​−1​，观察到 φ(x)φ(y)=xy∏i=1mpi−1pi\\varphi(x)\\varphi(y)=xy\\prod\\limits_{i=1}^m\\frac{p_i-1}{p_i}φ(x)φ(y)=xyi=1∏m​pi​pi​−1​ 多乘了 gcd⁡(x,y)\\gcd(x,y)gcd(x,y) 的质因子的 pi−1pi\\frac{p_i-1}{p_i}pi​pi​−1​，所以要除掉 φ(gcd⁡(x,y))gcd⁡(x,y)\\frac{\\varphi(\\gcd(x,y))}{\\gcd(x,y)}gcd(x,y)φ(gcd(x,y))​。 性质 4：若 ppp 是 xxx 的一个质因子，φ(xp)=φ(x)⋅p\\varphi(xp)=\\varphi(x)\\cdot pφ(xp)=φ(x)⋅p。 若 gcd(x,y)=1gcd(x,y) = 1gcd(x,y)=1，gcd(x,y+x)=1gcd(x,y+x) = 1gcd(x,y+x)=1。 性质 5：∑d∣nφ(d)=n\\sum\\limits_{d|n}\\varphi(d)=nd∣n∑​φ(d)=n 设 nnn 个分数 1n2n3n...nn\\dfrac{1}{n}\\dfrac{2}{n}\\dfrac{3}{n}...\\dfrac{n}{n}n1​n2​n3​...nn​，全部化到最简后，分母显然全部是 nnn 的因子，而分母 ddd 有 φ(d)\\varphi(d)φ(d) 个，又因为分母总共有 nnn 个，所以得证。 以上性质的具体证明可以看这篇文章。 有了这些特质，我们便可以结合欧拉筛来实现 O(n)O(n)O(n) 求 x∈[1,n]x\\in[1,n]x∈[1,n] 的 φ(x)\\varphi(x)φ(x) 了。 代码如下： int fhi[100005]; bool nop[100005]; int tot,prime[100005]; int n; void init() { nop[0]=true; // 0 不是质数 nop[1]=true; // 1 不是质数 fhi[1]=1; // 1 和 1 互质（ for(int i=2;i&lt;=n;i++) { if(!nop[i]) { prime[++tot]=i; fhi[i]=i-1; // 是一个质数，fhi(i) 满足性质 1 } for(int j=1;j&lt;=tot;j++) { if(i*prime[j]&gt;n) { break; } nop[i*prime[j]]=true; if(i%prime[j]==0) { fhi[i*prime[j]]=fhi[i]*prime[j]; // prime[j] 是 i 的一个质因子，满足性质 4 break; } fhi[i*prime[j]]=fhi[i]*fhi[prime[j]]; // i 和 prime[j] 互质，满足性质 3 } } } 练习题目 P2158 [SDOI2008] 仪仗队 P2398 GCD SUM P1390 公约数的和 P2568 GCD LOJ 6179 Pyh 的求和 ","tags":[{"name":"数学","slug":"Dkn2lgn3B","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Dkn2lgn3B/"},{"name":"数论","slug":"3Mw3ZQABXP","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/3Mw3ZQABXP/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"欧拉函数学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/ou-la-han-shu-xue-xi-bi-ji/","stats":{"text":"5 min read","time":243000,"words":789,"minutes":5},"date":"2023-03-21 10:02:56","dateFormat":"2023-03-21"},{"abstract":"","content":"Trie，即字典树，也就是一颗功能上很像字典的树。 Trie 经常用于维护一些关于字符串的东西，例如给定一些字符串，询问给定的字符串里有没有 sss。又例如给定一些字符串，询问给定的字符串里有多少个前缀为 sss。 Trie 的主要思路是以空间换时间，每一条边上都有一个字符类型的权值，根节点到节点 xxx 的路径上所有字符拼接起来便是 xxx 所代表的的字符串。 注意 Trie 的节点里还要保存它所表示的字符串是不是给出的字符串。 经典例题 P2580 于是他错误的点名开始了 完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n,m; char s[105]; int sons[500005][26]; // 大小是 50*10000 int cnt; bool vis[500005],endd[500005]; void ins(int u,string str) { if(str.empty()) // 搞完了，标记一下这个点代表的字符串是给定的 { endd[u]=true; return; } if(sons[u][str[0]-'a']==0) { sons[u][str[0]-'a']=++cnt; // 没有这个儿子，新开一个点 } ins(sons[u][str[0]-'a'],str.substr(1)); // 递归下去 } int que(int u,string str) { if(str.empty()) // 搞完了 { if(endd[u]) // 是给定的字符串 { if(vis[u]) // 访问过 { return 2; } vis[u]=true; return 1; } return 0; } if(sons[u][str[0]-'a']==0) // 没有节点可以代表 str { return 0; } return que(sons[u][str[0]-'a'],str.substr(1)); // 递归下去 } int main() { scanf(&quot;%d&quot;,&amp;n); cnt=1; for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s); ins(1,s); } scanf(&quot;%d&quot;,&amp;m); while(m--) { scanf(&quot;%s&quot;,s); int res=que(1,s); puts(res==1?&quot;OK&quot;:(res==2?&quot;REPEAT&quot;:&quot;WRONG&quot;)); } return 0; } LOJ2742 销售基因链（JOI Open 2016 T2 「RNA 鎖の販売 / Selling RNA Strands」） JOI 原题 首先对所有字符串和其翻转串建出 Trie 树，这样问题就变成了求同时在两棵树的两个子树中的字符串的个数。 考虑 dfs 序，把子树映射为区间之后就变成了二维数点问题，可以直接离线下来做。 代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int S=5000005; struct node { int x,y; }a[S],que[S]; struct node2 { int x,y,id,tpe; }; int n,q; char str[S]; int cnt1=1,son1[S][4]; int cnt2=1,son2[S][4]; vector&lt;int&gt; idx1[S],idx2[S]; int tt1,dfn1[S]; int tt2,dfn2[S]; int lx[S],rx[S],ly[S],ry[S]; int m; node2 pts[S]; int c[S],res[S]; inline int id(char x) { return x=='A'?0:(x=='U'?1:(x=='G'?2:3)); } void ins1(int idd) { int u=1,n=strlen(str+1); for(int i=1;i&lt;=n;i++) { int x=id(str[i]); if(son1[u][x]==0) son1[u][x]=++cnt1; u=son1[u][x]; } idx1[u].push_back(idd); } void ins2(int idd) { int u=1,n=strlen(str+1); for(int i=1;i&lt;=n;i++) { int x=id(str[i]); if(son2[u][x]==0) son2[u][x]=++cnt2; u=son2[u][x]; } idx2[u].push_back(idd); } void dfs1(int u) { lx[u]=dfn1[u]=++tt1; for(int i:idx1[u]) a[i].x=tt1; for(int i=0;i&lt;4;i++) if(son1[u][i]!=0) dfs1(son1[u][i]); rx[u]=tt1; } void dfs2(int u) { ly[u]=dfn2[u]=++tt2; for(int i:idx2[u]) a[i].y=tt2; for(int i=0;i&lt;4;i++) if(son2[u][i]!=0) dfs2(son2[u][i]); ry[u]=tt2; } int got1() { int u=1,n=strlen(str+1); for(int i=1;i&lt;=n;i++) { int x=id(str[i]); u=son1[u][x]; } return u; } int got2() { int u=1,n=strlen(str+1); for(int i=1;i&lt;=n;i++) { int x=id(str[i]); u=son2[u][x]; } return u; } void addd(int pos,int val) { for(int i=pos;i&lt;=S-3;i+=i&amp;-i) c[i]+=val; } int quee(int pos) { int res=0; for(int i=pos;i&gt;=1;i-=i&amp;-i) res+=c[i]; return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,str+1); ins1(i); int len=strlen(str+1); for(int j=1;j&lt;=len/2;j++) swap(str[j],str[len-j+1]); ins2(i); } dfs1(1),dfs2(1); for(int i=1;i&lt;=q;i++) { scanf(&quot;%s&quot;,str+1); que[i].x=got1(); scanf(&quot;%s&quot;,str+1); int len=strlen(str+1); for(int j=1;j&lt;=len/2;j++) swap(str[j],str[len-j+1]); que[i].y=got2(); } for(int i=1;i&lt;=q;i++) { // printf(&quot;[%d %d] [%d %d]\\n&quot;,lx[que[i].x],rx[que[i].x],ly[que[i].y],ry[que[i].y]); if(que[i].x==0||que[i].y==0) continue; pts[++m]=(node2){rx[que[i].x],ry[que[i].y],i,1}; pts[++m]=(node2){lx[que[i].x]-1,ry[que[i].y],i,-1}; pts[++m]=(node2){rx[que[i].x],ly[que[i].y]-1,i,-1}; pts[++m]=(node2){lx[que[i].x]-1,ly[que[i].y]-1,i,1}; } sort(a+1,a+n+1,[&amp;](node x,node y){return x.x&lt;y.x;}); sort(pts+1,pts+m+1,[&amp;](node2 x,node2 y){return x.x&lt;y.x;}); // for(int i=1;i&lt;=n;i++) printf(&quot;%d %d\\n&quot;,a[i].x,a[i].y); for(int i=1,j=1;i&lt;=m;i++) { while(j&lt;=n&amp;&amp;a[j].x&lt;=pts[i].x) addd(a[j++].y,1); int pre=quee(pts[i].y); res[pts[i].id]+=pre*pts[i].tpe; } for(int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,res[i]); return 0; } ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"Trie 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/trie-xue-xi-bi-ji/","stats":{"text":"7 min read","time":395000,"words":1211,"minutes":7},"date":"2023-03-21 10:01:46","dateFormat":"2023-03-21"},{"abstract":"","content":"最小割树，顾名思义，就是用来快速求出两点之间最小割的一种树。 经典例题 P4897 【模板】最小割树（Gomory-Hu Tree） 不难发现，求出两点之间的最小割为 valvalval 后，整个图会被分成互不连通的两部分，不妨使用集合 AAA 和集合 BBB 表示。不难发现，对于所有 x∈A,y∈Bx\\in A,y\\in Bx∈A,y∈B，都有 mincut⁡(x,y)≤val\\operatorname{mincut}(x,y)\\le valmincut(x,y)≤val（∀x∈A,y∈B,∃mincut⁡(x,y)≤val\\forall x\\in A,y\\in B,\\exists \\operatorname{mincut}(x,y)\\le val∀x∈A,y∈B,∃mincut(x,y)≤val）。 根据这条性质，我们便可以画一个这样的图： 接下来，我们可以再细分下去： 然后继续细分： 这样，我们就造出了一棵树。不难发现，树上 x,yx,yx,y 两点之间的路径上的最小边权和便是 mincut⁡(x,y)\\operatorname{mincut}(x,y)mincut(x,y)，用倍增即可实现 O(log⁡n)O(\\log n)O(logn) 最小割查询。 完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; #define S 100005 #define MS 1005 int n,m,q,s,t; int ineu[S],inev[S],inew[S]; int esum,to[S],c[S],nxt[S],h[MS]; int dep[MS],cur[MS]; int esum2,to2[S],c2[S],nxt2[S],h2[MS]; int nd[MS],tot1,tmp1[MS],tot2,tmp2[MS]; int depp[MS],up[MS][30],minn[MS][30]; inline void init() { esum=1; memset(h,0,sizeof(h)); } inline void add(int x,int y,int w) { to[++esum]=y; c[esum]=w; nxt[esum]=h[x]; h[x]=esum; } inline void add2(int x,int y,int w) { to2[++esum2]=y; c2[esum2]=w; nxt2[esum2]=h2[x]; h2[x]=esum2; } inline bool bfs() { memset(dep,0,sizeof(dep)); queue&lt;int&gt; q; q.push(s); dep[s]=1; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[v]==0) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]&gt;0; } int dfs(int u,int w) { if(u==t) { return w; } int sum=0; for(int &amp;i=cur[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0&amp;&amp;dep[v]==dep[u]+1) { int re=dfs(v,min(w,c[i])); c[i]-=re; c[i^1]+=re; w-=re; sum+=re; if(w==0) { break; } } } return sum; } inline int dinic() { int ans=0; while(bfs()) { for(int i=1;i&lt;=n;i++) { cur[i]=h[i]; } ans+=dfs(s,1e8); } return ans; } inline int slove(int x,int y) { init(); s=x; t=y; for(int i=1;i&lt;=m;i++) { add(ineu[i],inev[i],inew[i]); add(inev[i],ineu[i],0); add(inev[i],ineu[i],inew[i]); add(ineu[i],inev[i],0); } return dinic(); } void built(int l,int r) { if(l==r) { return; } int nans=slove(nd[l],nd[r]); add2(nd[l],nd[r],nans); add2(nd[r],nd[l],nans); tot1=0; tot2=0; for(int i=l;i&lt;=r;i++) { if(dep[nd[i]]&gt;0) { tmp1[++tot1]=nd[i]; } else { tmp2[++tot2]=nd[i]; } } for(int i=1;i&lt;=tot1;i++) { nd[l+i-1]=tmp1[i]; } for(int i=1;i&lt;=tot2;i++) { nd[l+tot1-1+i]=tmp2[i]; } int l1=l,r1=l+tot1-1; int l2=l+tot1,r2=r; built(l1,r1); built(l2,r2); } void initque(int u,int fa,int val) { depp[u]=depp[fa]+1; up[u][0]=fa; minn[u][0]=val; for(int i=1;i&lt;=25;i++) { up[u][i]=up[up[u][i-1]][i-1]; if(up[u][i]!=0) { minn[u][i]=min(minn[u][i-1],minn[up[u][i-1]][i-1]); } } for(int i=h2[u];i;i=nxt2[i]) { int v=to2[i]; if(v==fa) { continue; } initque(v,u,c2[i]); } } inline int quemin(int x,int y) { if(depp[x]&lt;depp[y]) { int t=x; x=y; y=t; } int res=1e8; for(int i=25;i&gt;=0;i--) { if(depp[up[x][i]]&gt;=depp[y]) { res=min(res,minn[x][i]); x=up[x][i]; } } if(x==y) { return res; } for(int i=25;i&gt;=0;i--) { if(up[x][i]!=up[y][i]) { res=min(res,min(minn[x][i],minn[y][i])); x=up[x][i]; y=up[y][i]; } } res=min(res,min(minn[x][0],minn[y][0])); return res; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;ineu[i],&amp;inev[i],&amp;inew[i]); } for(int i=1;i&lt;=n;i++) { nd[i]=i; } built(1,n); initque(1,0,0); scanf(&quot;%d&quot;,&amp;q); while(q--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,quemin(x,y)); } return 0; } 练习题目 P4123 [CQOI2016]不同的最小割 P3329 [ZJOI2011]最小割 UVA11594 All Pairs Maximum Flow P4214 [CERC2015]Juice Junctions CF343E Pumping Stations ","tags":[{"name":"图论","slug":"GE8D1uUdm","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/GE8D1uUdm/"},{"name":"网络流","slug":"19EjLeSB_D","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/19EjLeSB_D/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"最小割树（GHT）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zui-xiao-ge-shu-ghtxue-xi-bi-ji/","stats":{"text":"6 min read","time":340000,"words":995,"minutes":6},"date":"2023-03-21 09:58:59","dateFormat":"2023-03-21"},{"abstract":"","content":"顾名思义，主席树就是主席想出来的一种数据结构。 经典例题 P3919 【模板】可持久化线段树 1（可持久化数组） 主席树，大名“可持久化线段树”。线段树大家都知道，“可持久化”即为可以访问某一版本下的树。 很容易想到，可以开 mmm 棵线段树来实现可持久化线段树，可是这样的空间复杂度太高了，达到了 O(4nm)O(4nm)O(4nm)。 但是容易发现，每一次单点更新操作，最多只会有 O(logn)O(logn)O(logn) 个节点被更改。所以对于每次单点更新操作，可以只新建出 O(logn)O(logn)O(logn) 个节点，以节省空间。 例如这是一颗线段树：（第一个数代表版本号，第二、三个数代表区间） 假设我们需要修改位置 3 那么就需要新增一些节点： 假设我们又需要修改位置 5 那么又需要新增一些节点： 所以主席树这玩意根本不是树嘛…… 怎么样，这种沿用旧节点的思想是不是很奇妙 awa。 可持久化线段树的难点主要在修改，查询基本和线段树是一样的，只不过多了版本号，需要记下每个版本对应的根节点。 给出模板题代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #define S 1000005 using namespace std; struct node { int l,r,num; }tree[S*20]; int n,m,cnt,a[S],r[S]; void built(int &amp;now,int l,int r) { if(l==r) { tree[++cnt].num=a[l]; now=cnt; return; } int mid=l+r&gt;&gt;1; now=++cnt; built(tree[now].l,l,mid); built(tree[now].r,mid+1,r); } void upd(int &amp;now,int las,int l,int r,int wh,int val) { tree[++cnt]=tree[las]; now=cnt; if(l==r) { tree[now].num=val; return; } int mid=l+r&gt;&gt;1; if(wh&lt;=mid) { upd(tree[now].l,tree[las].l,l,mid,wh,val); } else { upd(tree[now].r,tree[las].r,mid+1,r,wh,val); } } int que(int now,int l,int r,int wh) { if(l==r) { return tree[now].num; } int mid=l+r&gt;&gt;1; if(wh&lt;=mid) { return que(tree[now].l,l,mid,wh); } else { return que(tree[now].r,mid+1,r,wh); } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } built(r[0],1,n); for(int i=1;i&lt;=m;i++) { int v,type,pos; scanf(&quot;%d%d%d&quot;,&amp;v,&amp;type,&amp;pos); if(type==1) { int val; scanf(&quot;%d&quot;,&amp;val); upd(r[i],r[v],1,n,pos,val); } else { printf(&quot;%d\\n&quot;,que(r[v],1,n,pos)); r[i]=r[v]; } } return 0; } 练习题目 P3834 【模板】可持久化线段树 2 P3402 可持久化并查集 P3168 [CQOI2015]任务查询系统 P3567 [POI2014]KUR-Couriers P3293 [SCOI2016]美味 P4587 [FJOI2016]神秘数 P2617 Dynamic Rankings P1383 高级打字机 P6166 [IOI2012]scrivener P4602 [CTSC2018]混合果汁 P4137 Rmq Problem / mex P2633 Count on a tree P3567 [POI2014]KUR-Couriers ","tags":[{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"线段树","slug":"Mhc6P6aymU","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/Mhc6P6aymU/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"主席树（可持久化线段树）学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/zhu-xi-shu-ke-chi-jiu-hua-xian-duan-shu-xue-xi-bi-ji/","stats":{"text":"4 min read","time":198000,"words":701,"minutes":4},"date":"2023-03-21 09:54:13","dateFormat":"2023-03-21"},{"abstract":"","content":"初赛 早上的 tg 四毛子算法是给人做的嘛，还有 base64 也很恶心…… 下午的 pj 怎么还有 base64…… 早上去的时候和两位奆佬一起拼车真快乐 估分： tg: 63 pj: 85 实际： tg: 62 pj: 85 相差不算太大，都过了 awa 复赛 早上的 PJ T1 好水，8 min 左右切了 T2 想了快 15 min 发现可以用离散化+值域树状数组做，当时也是 nt 没看到 1 操作有次数限制，打了大概 30 min 切掉了 T3 有点恶心，各种细节卡了快 50 min /kk T4 发现可以用链表，20 min 打好然后测了下极端数据发现没 TLE 就放心了 后面有快一个小时都在摸鱼+睡觉 /fad 下午的 TG T1 是平衡树，但是不会打 /kk，只拿了 40 pts 暴力分 T2 写了个样例都过不去的 dp /ll T3 完全不会，骗了点部分分就爬了 /ll T4 直接输出样例的 /ll 感觉 tg 无了/kk/kk/kk 估分： pj: 100+100+100+100=400 tg: 40+0+28+0=68 实际 pj: 100+100+100+100=400 tg: 100+0+36+0=136 好耶，是蓝勾勾！ ","tags":[{"name":"游记","slug":"n5pznK7k4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/n5pznK7k4/"},{"name":2021,"slug":"W1pmcP3ls8","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/W1pmcP3ls8/"},{"name":"CSP","slug":"hWQ-FoFtNl","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/hWQ-FoFtNl/"}],"title":"CSP 2021 游记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/csp-2021-you-ji/","stats":{"text":"2 min read","time":71000,"words":295,"minutes":2},"date":"2023-03-21 09:52:42","dateFormat":"2023-03-21"},{"abstract":"","content":" 练习题单：dead_X 的莫队题单 众所周知，莫队是一种优雅的暴力……（两根小手指瞎跳） Part.1 基础莫队 详解 莫队主要是用来求一段区间的某种特征值的，例如一段区间内有多少种不同的元素。 经典例题 对于一段长度为 n 的数列，有 m 个询问，每次求一段区间 [l,r] 中有多少种不同的元素。 第一行输入 n,m； 接下来输入 n 个数 a[i]； 接下来 m 行，每行两个数 l[i],r[i]。 你需要输出 m 行，为每次询问的答案。 1 &lt;= n &lt;= 10000 1 &lt;= m &lt;= 100000 1 &lt;= a[i] &lt;= 100000 考虑最朴素的做法，每次暴力枚举来求答案。可这样的做法是 O(nm)O(nm)O(nm) 的，显然会 T 飞/fad。 考虑优化，由于可以从以前询问的答案通过移动左右端点来推出当前询问的答案，所以可以这么做： int n,m,a[10005]; int sum,cnt[100005]; ...... inline void add(int x) { cnt[a[x]]++; if(cnt[a[x]]==1) { sum++; } } inline void del(int x) { cnt[a[x]]--; if(cnt[a[x]]==0) { sum--; } } int main() { ...... int lpos=1,rpos=0; for(int i=1;i&lt;=m;i++) { int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); while(lpos&gt;l) add(--lpos); while(rpos&lt;r) add(++rpos); while(lpos&lt;l) del(lpos++); while(rpos&gt;r) del(pos--); printf(&quot;%d\\n&quot;,sum); } return 0; } 但是，这么做有个缺点，如果遇到这样的询问： 1 1 10000 10000 1 1 10000 10000 那这样做就无法起到优化效果了。 但是由于询问是离线的（不必处理完第 i−1i-1i−1 次询问才能处理第 iii 次），所以我们可以按一定方法来给询问排序，排序方法便是莫队算法的核心思想。 考虑如何排序，我们可以先把整个序列分成很多长度为 n\\sqrt nn​ 的小块，因为这样做可以分摊时间复杂度，令它大致为 O(nn)O(n\\sqrt n)O(nn​)。在排序比较函数内判断一下两次询问的左端点的块编号，如果相同那么按右端点升序排序；否则按左端点升序排序。 这样排序的代码是这样的： struct node { int l,r,id; }que[100005]; int n,m,blo; ...... inline bool cmp(node x,node y) { int xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1; if(xlid==ylid) { return x.r&lt;y.r; } return x.l&lt;y.l; } ...... int main() { ...... for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;que[i].l,&amp;que[i].r); que[i].id=i; } blo=sqrt(n); sort(que+1,que+m+1,cmp); ...... return 0; } 但是这样的排序还是能优化的。我们可以让块编号为奇数的块左端点升序排序，块编号为偶数的块左端点降序排序。这样其实相当于让右端点移动得更少，假设左端点块编号为 iii 的所有询问已经处理完了，现在开始处理左端点块编号为 i+1i+1i+1 的块。如果按照之前的排序方法，右端点会从最大值跳到最小值。但是这样排序可以令右端点从最大值跳到最大值或从最小值跳到最小值，可以理解成下一块“接应”上一块 awa。 这样排序的代码是这样的：（大家叫它“奇偶优化排序”） struct node { int l,r,id; }que[100005]; int n,m,blo; ...... inline bool cmp(node x,node y) { int xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1; if(xlid==ylid) { return (xlid&amp;1)?x.r&lt;y.r:x.r&gt;y.r; } return x.l&lt;y.l; } ...... int main() { ...... for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;que[i].l,&amp;que[i].r); que[i].id=i; } blo=sqrt(n); sort(que+1,que+m+1,cmp); ...... return 0; } 至此，这道例题的莫队解法便呼之欲出了。完整代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; struct node { int l,r,id; }que[100005]; int n,m,blo,a[10005]; int sum,cnt[100005]; int ans[100005]; inline bool cmp(node x,node y) { int xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1; if(xlid==ylid) { return (xlid&amp;1)?x.r&lt;y.r:x.r&gt;y.r; } return x.l&lt;y.l; } inline void add(int x) { cnt[a[x]]++; if(cnt[a[x]]==1) { sum++; } } inline void del(int x) { cnt[a[x]]--; if(cnt[a[x]]==0) { sum--; } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;que[i].l,&amp;que[i].r); que[i].id=i; } blo=sqrt(n); sort(que+1,que+m+1,cmp); int lpos=1,rpos=0; for(int i=1;i&lt;=m;i++) { int l=que[i].l,r=que[i].r,id=que[i].id; while(lpos&gt;l) add(--lpos); while(rpos&lt;r) add(++rpos); while(lpos&lt;l) del(lpos++); while(rpos&gt;r) del(pos--); ans[id]=sum; } for(int i=1;i&lt;=m;i++) { printf(&quot;%d\\n&quot;,ans[i]); } return 0; } 练习题目 P3901 数列找不同 P1494 [国家集训队]小Z的袜子 CF86D Powerful array P2709 小B的询问 P5355 [Ynoi2017] 由乃的玉米田 双倍经验 P5072 [Ynoi 2015] 盼君莫忘 Part.2 带修莫队 基础的莫队是不支持修改操作的，不过想要支持也不是不可以，只需要加上一条时间轴即可。 例题：P1903 [国家集训队]数颜色 / 维护队列 这题除了有修改操作外和普通莫队的例题差不多，所以可以直接把上一题的代码拿过来用。不过需要给询问结构体多加一个变量来存当前询问是第几次修改之后的，移动区间也要在时间轴上移动，而排序时也要根据时间轴排序。 最后值得注意的一点是，带修莫队的块长是 n2/3n^{2/3}n2/3，具体讲解可以看这一篇博客。 完整代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #define S1 200005 #define S2 1000005 using namespace std; struct node { int l,r,gsum,id; }que[S1]; struct change { int wh,lst,nxt; }cge[S1]; int n,m,a[S1]; int suma,sumc; int lpos=1,rpos,preans,cgecnt,cnt[S2]; int blo; int ans[S1]; inline bool cmp(node x,node y) { int xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1; int xrid=(x.r-1)/blo+1,yrid=(y.r-1)/blo+1; if(xlid==ylid) { if(xrid==yrid) { return x.gsum&lt;y.gsum; } return x.r&lt;y.r; } return x.l&lt;y.l; } inline void add(int x) { cnt[a[x]]++; if(cnt[a[x]]==1) { preans++; } } inline void del(int x) { cnt[a[x]]--; if(cnt[a[x]]==0) { preans--; } } inline void upd(int type) { if(type==-1) { int pt=cge[cgecnt].wh; if(pt&gt;=lpos&amp;&amp;pt&lt;=rpos) { del(pt); } a[pt]=cge[cgecnt].lst; if(pt&gt;=lpos&amp;&amp;pt&lt;=rpos) { add(pt); } } cgecnt+=type; if(type==1) { int pt=cge[cgecnt].wh; if(pt&gt;=lpos&amp;&amp;pt&lt;=rpos) { del(pt); } a[pt]=cge[cgecnt].nxt; if(pt&gt;=lpos&amp;&amp;pt&lt;=rpos) { add(pt); } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=1;i&lt;=m;i++) { char opt; scanf(&quot; %c&quot;,&amp;opt); if(opt=='Q') { int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); suma++; que[suma]=(node){l,r,sumc,suma}; } else { int p,x; scanf(&quot;%d%d&quot;,&amp;p,&amp;x); cge[++sumc]=(change){p,a[p],x}; a[p]=x; } } for(int i=sumc;i&gt;=1;i--) { a[cge[i].wh]=cge[i].lst; } blo=pow(n,0.66666); sort(que+1,que+suma+1,cmp); for(int i=1;i&lt;=suma;i++) { int l=que[i].l,r=que[i].r,gsum=que[i].gsum,id=que[i].id; while(lpos&lt;l) del(lpos++); while(rpos&gt;r) del(rpos--); while(lpos&gt;l) add(--lpos); while(rpos&lt;r) add(++rpos); while(gsum&gt;cgecnt) upd(1); while(gsum&lt;cgecnt) upd(-1); ans[id]=preans; } for(int i=1;i&lt;=suma;i++) { printf(&quot;%d\\n&quot;,ans[i]); } return 0; } 练习题目 CF940F Machine Learning Part.3 回滚莫队 顾名思义，回滚莫队就是滚来滚去的莫队。 回滚莫队主要用来处理一些方便扩区间但不方便缩区间的情况，例如下面这道题： 经典例题 AT1219 歴史の研究 如果我们还用普通莫队的思路来解这道题，add 函数还很好写，可是到了 del 函数，我们就发现很难写了。因为维护重要度最大，需要维护重要度次大；维护重要度次大，需要维护重要度第大……这就是方便扩区间但不方便缩区间的情况。 出现这种情况，我们可以排序时先按左端点块编号升序排序，对于块编号一样的情况，按右端点升序排序。这样就能保证左端点块编号相同的询问右端点只需要扩展而不需要收缩了。另外，对于左端点和右端点在同一块内的情况，直接暴力处理即可。 考虑处理连续的一段左端点块编号相同的询问。可以先把莫队区间右端点移到当前左端点所属块的右端点，左端点为右端点加一，每次扩区间的时候右端点就可以保持只往右扩了。由于左端点不一定只往左扩，所以我们需要先把右端点扩完，记录下当前的答案 lstans，再把左端点扩到适当的位置，求出当前的答案。 接下来就需要进行“回滚”操作了，具体就是先把左端点移回 R[l]+1，但不改变答案，这时，答案可以直接赋值为之前保存的 lstans，因为区间一样，答案自然也一样了。 回滚莫队的精髓就体现在“回滚”操作上了。 完整代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define S 100005 using namespace std; struct ask { int l,r,id; }q[S]; struct node { int x,id; }temp[S]; int n,m,a[S],bullet[S]; long long pre,lst,ans[S],cnt[S],cntt[S]; int blo,who[S],L[S],R[S]; inline int read() { int s=0,w=1,ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=='-'?w=-1,ch=getchar():ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48),ch=getchar(); return s*w; } inline bool cmp(node &amp;x,node &amp;y) { return x.x&lt;y.x; } inline bool cmp1(node &amp;x,node &amp;y) { return x.id&lt;y.id; } inline bool cmp2(ask &amp;x,ask &amp;y) { return (who[x.l]==who[y.l])?(x.r&lt;y.r):(who[x.l]&lt;who[y.l]); } inline void add(int x) { pre=max(pre,++cnt[a[x]]*bullet[a[x]]); } inline void del(int x) { --cnt[a[x]]; } int main() { n=read(); m=read(); blo=sqrt(n); for(int i=1;i&lt;=n;i++) { temp[i].x=read(); temp[i].id=i; who[i]=(i-1)/blo+1; L[who[i]]=(who[i]-1)*blo+1; R[who[i]]=min(who[i]*blo,n); } for(int i=1;i&lt;=m;i++) { q[i].l=read(); q[i].r=read(); q[i].id=i; } sort(temp+1,temp+n+1,cmp); int tail=0; for(int i=1;i&lt;=n;i++) { if(temp[i].x!=bullet[tail]) { bullet[++tail]=temp[i].x; } temp[i].x=tail; } sort(temp+1,temp+n+1,cmp1); for(int i=1;i&lt;=n;i++) { a[i]=temp[i].x; } sort(q+1,q+m+1,cmp2); int lpos=1,rpos=0; for(int i=1;i&lt;=m;i++) { int l=q[i].l,r=q[i].r,id=q[i].id; lpos=R[who[l]]; if(who[l]&gt;who[q[i-1].l]) { memset(cnt,0,sizeof(cnt)); pre=0; lst=0; rpos=lpos-1; } if(who[l]==who[r]) { long long maxx=0; for(int j=l;j&lt;=r;j++) { maxx=max(maxx,++cntt[a[j]]*bullet[a[j]]); } ans[id]=maxx; for(int j=l;j&lt;=r;j++) { cntt[a[j]]=0; } continue; } while(rpos&lt;r) add(++rpos); lst=pre; while(lpos&gt;l) add(--lpos); ans[id]=pre; while(lpos&lt;R[who[l]]) del(lpos++); pre=lst; } for(int i=1;i&lt;=m;i++) { printf(&quot;%lld\\n&quot;,ans[i]); } return 0; } 同理，方便缩区间但不方便扩区间的情况回滚莫队也可以做。 经典例题 P8078 [WC2022] 秃子酋长 这道题显然莫队要维护一个有序的序列，支持插入、删除和求前驱后继。 容易发现，如果没有插入操作的话，前驱后继只要仿照双向链表删除的方法来维护就行了。所以考虑不插入的回滚莫队。 仿照不删除的回滚莫队： 首先把莫队区间设置为 [1,n][1,n][1,n]。 排序时先按左端点块编号升序排序，对于块编号一样的情况，按右端点降序排序。这样就能保证左端点块编号相同的询问右端点只需要收缩而不需要扩展了。需要注意的是，对于左端点和右端点在同一块内的情况，不需要暴力处理。 考虑处理连续的一段左端点块编号相同的询问。可以先把莫队区间右端点移到 nnn，左端点为当前块的左端点，每次缩区间的时候右端点就可以保持只往左缩了。由于左端点不一定只往右边缩，所以我们需要先把右端点缩完，再把左端点缩到适当的位置，求出当前的答案。 和不删除的回滚莫队不一样的是，缩左端点和右端点时要把一路上更改的前驱后继用栈记录下来，这样执行“回滚”操作时就能成功恢复了，处理下一个块时右端点也能顺利恢复到 nnn。 求出当前答案后就需要进行“回滚”操作了，具体就是按照栈中的值来更新答案并且扩展左端点。 注意要特判没有前驱或者后继的节点，然后就是要开 long long。 完整代码如下： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; const long long MS=500005; struct pr { int x,y; }b[MS]; struct tr { int x,y,z; }sta[MS]; struct node { int l,r,id; }que[MS]; int n,m,blo; int L[MS],a[MS]; int fir[MS],nxt[MS]; long long preans,ans[MS]; int top; inline bool cmp(node x,node y) { int xid=(x.l-1)/blo+1,yid=(y.l-1)/blo+1; return xid!=yid?x.l&lt;y.l:x.r&gt;y.r; } inline bool cmp2(pr x,pr y) { return x.x&lt;y.x; } inline void del(int x) { int lb=fir[x],rb=nxt[x]; sta[++top]=(tr){lb,x,rb}; nxt[lb]=rb; if(rb==x) { nxt[lb]=lb; } fir[rb]=lb; if(lb==x) { fir[rb]=rb; } preans-=abs(x-lb)+abs(x-rb); if(lb!=x&amp;&amp;rb!=x) { preans+=abs(lb-rb); } } inline void bak() { int lb=sta[top].x,x=sta[top].y,rb=sta[top].z; top--; fir[x]=lb; if(lb!=x) { nxt[lb]=x; } nxt[x]=rb; if(rb!=x) { fir[rb]=x; } if(lb!=x&amp;&amp;rb!=x) { preans-=abs(lb-rb); } preans+=abs(x-lb)+abs(x-rb); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); blo=sqrt(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); b[i].x=a[i]; b[i].y=i; L[i]=(i-1)/blo!=(i-2)/blo||i==1?i:L[i-1]; } for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;que[i].l,&amp;que[i].r); que[i].id=i; } sort(que+1,que+m+1,cmp); int lpos=1,rpos=n; sort(b+1,b+n+1,cmp2); fir[b[1].y]=b[1].y; nxt[b[n].y]=b[n].y; for(int i=2;i&lt;=n-1;i++) { fir[b[i].y]=b[i-1].y; nxt[b[i-1].y]=b[i].y; nxt[b[i].y]=b[i+1].y; fir[b[i+1].y]=b[i].y; preans+=abs(b[i].y-b[i-1].y); } preans+=abs(b[n].y-b[n-1].y); for(int i=1;i&lt;=m;i++) { int l=que[i].l,r=que[i].r,id=que[i].id; int LL=L[l],lstL=L[que[i-1].l]; if(LL!=lstL) { while(top&gt;0) bak(); lpos=max(1,lstL); rpos=n; while(lpos&lt;LL) del(lpos++); top=0; } while(rpos&gt;r) del(rpos--); while(lpos&lt;l) del(lpos++); ans[id]=preans; while(lpos&gt;LL) bak(),lpos--; } for(int i=1;i&lt;=m;i++) { printf(&quot;%lld\\n&quot;,ans[i]); } return 0; } 练习题目 P5906 【模板】回滚莫队&amp;不删除莫队 Part.4 树上莫队 树上莫队，顾名思义，就是莫队上树了。 树上莫队主要是用来求树上两点之间最短路径的某种特征值的，例如两点的最短路径上有多少种不同的元素。 经典例题 SP10707 COT2 - Count on a tree II 首先我们考虑如何把一棵树“拍扁”。dfs 序固然可以，但它无法维护树上父子关系。这时就需要介绍一种新的把树“拍扁”的方式了——欧拉序。 欧拉序和 dfs 序基本上是一样的，但是一个点在刚访问和访问结束的时候都会加进序列里，也就是说对于一个 nnn 个节点的树，它的欧拉序长度为 2n2n2n，每个点都会在欧拉序中出现两次。 为了下文表述方便，我们记 iniin_iini​ 表示点 iii 在欧拉序中第一次出现的位置，outiout_iouti​ 表示点 iii 在欧拉序中最后一次出现的位置。显然，iii 的子树的欧拉序就是 [ini,outi][in_i,out_i][ini​,outi​] 这段区间所对应的欧拉序。 这样，我们就实现了“拍扁”一颗树 awa。 但这还没完，考虑如何处理询问。首先记 xxx 为一组询问中 ininin 较小的那个点，yyy 为一组询问中 ininin 较大的那个点。那么如果询问的两个点在同一棵子树内，即 lca(x,y)=xlca(x,y)=xlca(x,y)=x，那么需要处理的区间即为 [inx,iny][in_x,in_y][inx​,iny​]。但是由于树可能会有分叉，所以区间中出现两次的点不能算贡献。 考虑 lca(x,y)≠xlca(x,y)\\ne xlca(x,y)​=x 的情况。对于这种情况，我们需要处理的区间便变为了 [outx,iny][out_x,in_y][outx​,iny​]。同样的，区间中出现两次的点不能算贡献。但由于没有把 lca(x,y)lca(x,y)lca(x,y) 算进去，所以还需要算上 lca(x,y)lca(x,y)lca(x,y) 的贡献。 这是树上莫队最难懂的地方，我也是看了好多文章才理解的 /kk。 梳理一下思路： 先 dfs 一次预处理出欧拉序和倍增数组 处理每一次询问，处理出询问对应的区间 正常莫队处理 例题完整代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; #define S 200005 #define MS 100005 struct node { int l,r,lca,id; }que[MS]; int n,m; int col[MS],b[MS]; int esum,to[S],nxt[S],h[MS]; int dep[MS],up[MS][30]; int cnt,a[MS],in[MS],out[MS]; int blo; bool vis[MS]; int tot[MS],preans; int ans[MS]; inline bool cmp(node x,node y) { int xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1; if(xlid==ylid) { return (xlid&amp;1)?x.r&lt;y.r:x.r&gt;y.r; } return x.l&lt;y.l; } inline void added(int x,int y) { to[++esum]=y; nxt[esum]=h[x]; h[x]=esum; } void dfs(int u,int fa) { a[++cnt]=u; in[u]=cnt; dep[u]=dep[fa]+1; up[u][0]=fa; for(int i=1;i&lt;=25;i++) { up[u][i]=up[up[u][i-1]][i-1]; } for(int i=h[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) { continue; } dfs(v,u); } a[++cnt]=u; out[u]=cnt; } inline int getlca(int x,int y) { if(dep[x]&lt;dep[y]) { int t=x; x=y; y=t; } for(int i=25;i&gt;=0;i--) { if(dep[up[x][i]]&gt;=dep[y]) { x=up[x][i]; } } if(x==y) { return x; } for(int i=25;i&gt;=0;i--) { if(up[x][i]!=up[y][i]) { x=up[x][i]; y=up[y][i]; } } return up[x][0]; } inline void add(int x) { if(!vis[x]) { vis[x]=true; tot[col[x]]++; if(tot[col[x]]==1) { preans++; } } else { vis[x]=false; tot[col[x]]--; if(tot[col[x]]==0) { preans--; } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;col[i]); b[i]=col[i]; } sort(b+1,b+n+1); for(int i=1;i&lt;=n;i++) { col[i]=lower_bound(b+1,b+n+1,col[i])-b; } for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); added(x,y); added(y,x); } dfs(1,0); blo=sqrt(n*2); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(in[x]&gt;in[y]) { int t=x; x=y; y=t; } int lca=getlca(x,y); if(lca==x) { que[i]=(node){in[x],in[y],0,i}; } else { que[i]=(node){out[x],in[y],lca,i}; } } sort(que+1,que+m+1,cmp); int lpos=1,rpos=0; for(int i=1;i&lt;=m;i++) { int l=que[i].l,r=que[i].r,lca=que[i].lca,id=que[i].id; while(lpos&gt;l) add(a[--lpos]); while(rpos&lt;r) add(a[++rpos]); while(lpos&lt;l) add(a[lpos++]); while(rpos&gt;r) add(a[rpos--]); if(lca!=0) { add(lca); } ans[id]=preans; if(lca!=0) { add(lca); } } for(int i=1;i&lt;=m;i++) { printf(&quot;%d\\n&quot;,ans[i]); } return 0; } 练习题目 P4074 [WC2013] 糖果公园 小技巧 莫队常配合其它数据结构，如莫队套树状数组、莫队套 bitset 等等 强制在线的题莫队无法解决 莫队一定要先扩区间再缩区间 ","tags":[{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"},{"name":"分块","slug":"lp69yMfSzp","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/lp69yMfSzp/"}],"title":"莫队学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/mo-dui-xue-xi-bi-ji/","stats":{"text":"25 min read","time":1461000,"words":5000,"minutes":25},"date":"2023-03-21 09:45:07","dateFormat":"2023-03-21"},{"abstract":"","content":"算法讲解 分块是一种很暴力的数据结构，它的思想主要是通过将序列分成长度为 n\\sqrt nn​ 的许多块来分别处理来保证时间复杂度为 nnn\\sqrt nnn​。 分块的实现十分简单，下面就以最基础的区间加法为例。 例题 首先我们需要初始化出每一块的左端点、右端点还有原数组中每一个位置所对应的块编号。为了方便，我们用 LiL_iLi​ 和 RiR_iRi​ 表示第 iii 块的左端点和右端点；sumisum_isumi​ 表示第 iii 块的和；lasyilasy_ilasyi​ 表示第 iii 块应该整体加上多少；whoiwho_iwhoi​ 表示原数组中第 iii 个位置对应的块编号。那么预处理代码如下： int n,m; long long a[100005]; int blo,L[100005],R[100005],who[100005]; // 块数/块长、每一块的左右端点、原序列每一个位置对应的块编号 long long sum[100005]; // 每一块的和 long long lazy[100005]; // 每一块整体应该加上多少 inline void init() { blo=sqrt(n); for(int i=1;i&lt;=blo;i++) // 预处理出每一块的左右端点 { L[i]=R[i-1]+1; R[i]=L[i]+blo-1; } R[blo]=n; // 最后一块的右端点特殊处理 for(int i=1;i&lt;=n;i++) { who[i]=(i-1)/blo+1; // 预处理出原数组每个位置对应的块编号 sum[who[i]]+=a[i]; // 预处理出每一块的和 } } 接下来，我们需要考虑怎么处理区间加操作。假设当前需要把 [l,r][l,r][l,r] 加上 kkk，那么对于 [l,r][l,r][l,r] 中整块的部分，可以将它们的 lazyilazy_ilazyi​ 直接加上 kkk；对于两边不满一块的部分，可以把它们的 aia_iai​ 分别加上 kkk，因为不满一块的长度不会超过 n\\sqrt nn​，所以时间复杂度是正确的。 区间加的代码如下： inline void add(int l,int r,long long k) { if(who[l]==who[r]) // 同一块内 { for(int i=l;i&lt;=r;i++) { a[i]+=k; } return; } // 不满一块的部分暴力处理 for(int i=l;i&lt;=R[who[l]];i++) { a[i]+=k; } for(int i=L[who[r]];i&lt;=r;i++) { a[i]+=k; } // 中间的整块直接加上 for(int i=who[l]+1;i&lt;=who[r]-1;i++) { lazy[i]+=k; } } 最后，询问的处理也呼之欲出了。只需要仿照区间加来操作就行了，不过注意要加上 lazylazylazy 值。 询问的代码如下： inline long long que(int l,int r) { if(who[l]==who[r]) // 同一块内 { long long res=0; for(int i=l;i&lt;=r;i++) { res+=a[i]+lazy[who[l]]; // 不要漏了 lazy } return res; } long long res=0; // 不满一块的部分暴力处理 for(int i=l;i&lt;=R[who[l]];i++) { res+=a[i]+lazy[who[l]]; // 不要漏了 lazy } for(int i=L[who[r]];i&lt;=r;i++) { res+=a[i]+lazy[who[r]]; // 不要漏了 lazy } // 中间的整块直接加上 for(int i=who[l]+1;i&lt;=who[r]-1;i++) { res+=sum[i]+lazy[i]; // 不要漏了 lazy } } 完整代码如下，是不是比线段树短很多，但是会 TLE，因为 O(mn)O(m \\sqrt n)O(mn​) 的时间复杂度不够优秀。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; int n,m; long long a[100005]; int blo,L[100005],R[100005],who[100005]; // 块数/块长、每一块的左右端点、原序列每一个位置对应的块编号 long long sum[100005]; // 每一块的和 long long lazy[100005]; // 每一块整体应该加上多少 inline void init() { blo=sqrt(n); for(int i=1;i&lt;=blo;i++) // 预处理出每一块的左右端点 { L[i]=R[i-1]+1; R[i]=L[i]+blo-1; } R[blo]=n; // 最后一块的右端点特殊处理 for(int i=1;i&lt;=n;i++) { who[i]=(i-1)/blo+1; // 预处理出原数组每个位置对应的块编号 sum[who[i]]+=a[i]; // 预处理出每一块的和 } } inline void add(int l,int r,long long k) { if(who[l]==who[r]) // 同一块内 { for(int i=l;i&lt;=r;i++) { a[i]+=k; } return; } // 不满一块的部分暴力处理 for(int i=l;i&lt;=R[who[l]];i++) { a[i]+=k; } for(int i=L[who[r]];i&lt;=r;i++) { a[i]+=k; } // 中间的整块直接加上 for(int i=who[l]+1;i&lt;=who[r]-1;i++) { lazy[i]+=k; } } inline long long que(int l,int r) { if(who[l]==who[r]) // 同一块内 { long long res=0; for(int i=l;i&lt;=r;i++) { res+=a[i]+lazy[who[l]]; // 不要漏了 lazy } return res; } long long res=0; // 不满一块的部分暴力处理 for(int i=l;i&lt;=R[who[l]];i++) { res+=a[i]+lazy[who[l]]; // 不要漏了 lazy } for(int i=L[who[r]];i&lt;=r;i++) { res+=a[i]+lazy[who[r]]; // 不要漏了 lazy } // 中间的整块直接加上 for(int i=who[l]+1;i&lt;=who[r]-1;i++) { res+=sum[i]+lazy[i]; // 不要漏了 lazy } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;,&amp;a[i]); } while(m--) { int type,l,r; scanf(&quot;%d%d%d&quot;,&amp;type,&amp;l,&amp;r); if(type==1) { long long k; scanf(&quot;%lld&quot;,&amp;k); add(l,r,k); } else { printf(&quot;%lld\\n&quot;,que(l,r)); } } return 0; } 练习题目 由乃打扑克 链接 这题比较简单，主体思路就是二分套二分再加上排序什么的乱搞一通。 建议先做完P2801 教主的魔法再来做这题。（双倍经验） 初始化 链接 这题有点难，要对长度为 xxx 的每次询问弄前缀和和后缀和，不过不怎么卡常，代码也是相当地短。 ","tags":[{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"},{"name":"分块","slug":"lp69yMfSzp","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/lp69yMfSzp/"}],"title":"数列分块学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/shu-lie-fen-kuai-xue-xi-bi-ji/","stats":{"text":"7 min read","time":374000,"words":1356,"minutes":7},"date":"2023-03-21 09:34:47","dateFormat":"2023-03-21"},{"abstract":"","content":"KMP 是一种用来处理字符串匹配问题的算法。 很明显，可以这样暴力解决字符串匹配问题：（nnn 为 SSS 的长度，mmm 为 TTT 的长度） for(int i=1;i&lt;=n-m+1;i++) { bool f=true; for(int j=1;j&lt;=m;j++) { if(S[i+j-1]!=T[j]) { f=false; break; } } if(f) { printf(&quot;%d\\n&quot;,i); } } 但是这样的算法时间复杂度是 O(nm)O(nm)O(nm) 的，肯定会 TLE。 考虑改进这个算法，很容易发现，下面这两个字符串匹配时： S:ACACBEAC T:ACACE 模式串匹配到 E 时我们发现失配了，但是这时我们可以不仅仅把 TTT 移动一位，而是可以直接移动两位： S:ACACBEEAC T:^^ACACE 因为 TTT 的前四位已经匹配了，而在这前四位中，前两位构成的前缀和后两位构成的后缀相同，所以我们可以移动两位。 设 frtjfrt_jfrtj​ 表示 TTT 的前 jjj 个字符构成的字符串，定义一个串 SSS 的 border TTT 为满足 T=ST\\not=ST​=S 且既是 SSS 的前缀也是 SSS 的后缀的串。那么当 TTT 的前 jjj 位已匹配，第 j+1j+1j+1 位失配时，就可以将 jjj 设置成 frtjfrt_jfrtj​ 的最长的 border 的长度。 那么我们可以用 kmpikmp_ikmpi​ 表示 frtifrt_ifrti​ 的最长 border 的长度，那么匹配的过程就可以变成这样： int j=0; for(int i=1;i&lt;=n;i++) { while(j!=0&amp;&amp;T[j+1]!=S[i]) // 如果失配，那么不停移动模式串 { j=kmp[j]; } if(T[j+1]==S[i]) // 能匹配就匹配 { j++; } if(j==m) // 匹配成功！ { printf(&quot;%d\\n&quot;,i-m+1); } } 而 kmpkmpkmp 数组的求解就可以看作是 TTT 和自己匹配： kmp[1]=0; // kmp[1] 肯定为 0 int j=0; for(int i=2;i&lt;=m;i++) // T 和自己匹配 { while(j!=0&amp;&amp;T[j+1]!=T[i]) // 失配则不断移动模式串 { j=kmp[j]; } if(T[j+1]==T[i]) // 匹配 { j++; } kmp[i]=j; // 当前匹配的长度就是 kmp[i] } 完整代码： // P3375 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int n,m; char S[1000005],T[1000005]; int kmp[1000005]; int main() { scanf(&quot;%s%s&quot;,S+1,T+1); n=strlen(S+1); m=strlen(T+1); kmp[1]=0; // kmp[1] 肯定为 0 int j=0; for(int i=2;i&lt;=m;i++) // T 和自己匹配 { while(j!=0&amp;&amp;T[j+1]!=T[i]) // 失配则不断移动模式串 { j=kmp[j]; } if(T[j+1]==T[i]) // 匹配 { j++; } kmp[i]=j; // 当前匹配的长度就是 kmp[i] } j=0; for(int i=1;i&lt;=n;i++) { while(j!=0&amp;&amp;T[j+1]!=S[i]) // 如果失配，那么不停移动模式串 { j=kmp[j]; } if(T[j+1]==S[i]) // 能匹配就匹配 { j++; } if(j==m) // 匹配成功！ { printf(&quot;%d\\n&quot;,i-m+1); } } for(int i=1;i&lt;=m;i++) { printf(&quot;%d &quot;,kmp[i]); } printf(&quot;\\n&quot;); return 0; } 这样做的时间复杂度是 O(n+m)O(n+m)O(n+m) 的，是不是比暴力优很多。 时间复杂度证明： 首先预处理 kmpkmpkmp 数组是 O(m)O(m)O(m) 的，因为 jjj 总共只会移动 mmm 次，然后每次跳 kmpkmpkmp 至少会让 jjj 减少 111，所以最多回跳 mmm 次。 匹配的时间复杂度是 O(n)O(n)O(n) 的，具体原理同上。 一些扩展 frtifrt_ifrti​ 的 border 一定是 frtkmpi,frtkmpkmpi,frtkmpkmpkmpi,…frt_{kmp_i},frt_{kmp_{kmp_i}},frt_{kmp_{kmp_{kmp_i}}},\\dotsfrtkmpi​​,frtkmpkmpi​​​,frtkmpkmpkmpi​​​​,…，所以可以建一棵根节点为 000 的树，其中 uuu 的父亲是 kmpukmp_ukmpu​，uuu 的所有祖先 rtrtrt 的 frtrtfrt_{rt}frtrt​ 都是 frtufrt_ufrtu​ 的 border。 想要求 frtifrt_ifrti​ 长度小于等于 i−xi-xi−x 或者 ⌊ix⌋\\lfloor\\frac{i}{x}\\rfloor⌊xi​⌋ 的最长的 border 也可以用类似求 kmpkmpkmp 数组的方法来求： num[1]=0; for(int i=2,j=0;i&lt;=n;i++) { while(j!=0&amp;&amp;a[j+1]!=a[i]) j=kmp[j]; if(a[j+1]==a[i]) j++; while(j*2&gt;i) j=kmp[j]; num[i]=j; } 这段代码就是求 numinum_inumi​ 表示 frtifrt_ifrti​ 长度小于等于 ⌊i2⌋\\lfloor\\frac{i}{2}\\rfloor⌊2i​⌋ 的最长的 border 的长度。 这样做的时间复杂度是 O(n)O(n)O(n) 的，证明类似求 kmpkmpkmp 数组的时间复杂度的证明。 字符串 SSS 的最小重复子串（最短的字符串 BBB 满足 S=BBBBB…BBS=BBBBB\\dots BBS=BBBBB…BB）也能用 kmpkmpkmp 数组求，若 kmp∣S∣≥⌈∣S∣2⌉kmp_{|S|}\\ge\\lceil\\frac{|S|}{2}\\rceilkmp∣S∣​≥⌈2∣S∣​⌉ 则最小重复子串的长度即为 ∣S∣−kmp∣S∣|S|-kmp_{|S|}∣S∣−kmp∣S∣​，否则 SSS 的最小重复子串就是它本身。 证明很简单。 ","tags":[{"name":"字符串","slug":"wtMqnxQGh","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/wtMqnxQGh/"},{"name":"数据结构","slug":"8ldJi7oB4","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/8ldJi7oB4/"},{"name":"学习笔记","slug":"-m_OOuWfj","used":true,"link":"https://lovely-ckj.github.io/ckjblog/tag/-m_OOuWfj/"}],"title":"KMP 学习笔记","feature":"","link":"https://lovely-ckj.github.io/ckjblog/post/kmp-xue-xi-bi-ji/","stats":{"text":"6 min read","time":311000,"words":1128,"minutes":6},"date":"2023-03-19 14:21:59","dateFormat":"2023-03-19"}]}
